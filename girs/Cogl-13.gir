<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GL" version="1.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Graphene" version="1.0"/>
  <include name="cairo" version="1.0"/>
  <package name="mutter-cogl-13"/>
  <c:include name="cogl/cogl.h"/>
  <namespace name="Cogl"
             version="13"
             shared-library="libmutter-cogl-13.so.0"
             c:identifier-prefixes="Cogl"
             c:symbol-prefixes="cogl">
    <alias name="Angle" c:type="CoglAngle">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="91">Integer representation of an angle such that 1024 corresponds to
full circle (i.e., 2 * pi).</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="97"/>
      <type name="gint32" c:type="int32_t"/>
    </alias>
    <alias name="Handle" c:type="CoglHandle">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="77">Type used for storing references to cogl objects, the CoglHandle is
a fully opaque type without any public data members.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="83"/>
      <type name="gpointer" c:type="void*"/>
    </alias>
    <alias name="PipelineKey" c:type="CoglPipelineKey">
      <source-position filename="cogl/cogl/cogl-context.h" line="319"/>
      <type name="utf8" c:type="const char* const"/>
    </alias>
    <alias name="UserDataDestroyCallback" c:type="CoglUserDataDestroyCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-object.h"
           line="127">When associating private data with a #CoglObject a callback can be
given which will be called either if the object is destroyed or if
cogl_object_set_user_data() is called with NULL user_data for the
same key.</doc>
      <source-position filename="cogl/cogl/cogl-object.h" line="137"/>
      <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
    </alias>
    <constant name="AFIRST_BIT" value="64" c:type="COGL_AFIRST_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="65"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="A_BIT" value="16" c:type="COGL_A_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="63"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="AttributeType" c:type="CoglAttributeType">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="239">Data types for the components of a vertex attribute.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="258"/>
      <member name="byte" value="5120" c:identifier="COGL_ATTRIBUTE_TYPE_BYTE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="241">Data is the same size of a byte</doc>
      </member>
      <member name="unsigned_byte"
              value="5121"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="242">Data is the same size of an
  unsigned byte</doc>
      </member>
      <member name="short"
              value="5122"
              c:identifier="COGL_ATTRIBUTE_TYPE_SHORT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="244">Data is the same size of a short integer</doc>
      </member>
      <member name="unsigned_short"
              value="5123"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="245">Data is the same size of
  an unsigned short integer</doc>
      </member>
      <member name="float"
              value="5126"
              c:identifier="COGL_ATTRIBUTE_TYPE_FLOAT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="247">Data is the same size of a float</doc>
      </member>
    </enumeration>
    <constant name="BGR_BIT" value="32" c:type="COGL_BGR_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="64"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="BUFFER"
                    c:identifier="COGL_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/deprecated/cogl-type-casts.h"
                       line="47"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Bitmap"
           c:symbol-prefix="bitmap"
           c:type="CoglBitmap"
           parent="Object"
           glib:type-name="CoglBitmap"
           glib:get-type="cogl_bitmap_get_gtype"
           glib:fundamental="1">
      <constructor name="new_for_data"
                   c:identifier="cogl_bitmap_new_for_data"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="141">Creates a bitmap using some existing data. The data is not copied
so the application must keep the buffer alive for the lifetime of
the #CoglBitmap. This can be used for example with
cogl_framebuffer_read_pixels_into_bitmap() to read data directly
into an application buffer with the specified rowstride.</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="160"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="157">A new #CoglBitmap.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="143">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="144">The width of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="145">The height of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="146">The format of the pixel data.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="147">The rowstride of the bitmap (the number of bytes from
  the start of one row of the bitmap to the next).</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="149">A pointer to the data. The bitmap will take ownership of this data.</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_buffer"
                   c:identifier="cogl_bitmap_new_from_buffer"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="85">Wraps some image data that has been uploaded into a #CoglBuffer as
a #CoglBitmap. The data is not copied in this process.</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="102"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="99">a #CoglBitmap encapsulating the given @buffer.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="87">A #CoglBuffer containing image data</doc>
            <type c:type="CoglBuffer*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="88">The #CoglPixelFormat defining the format of the image data
         in the given @buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="90">The width of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="91">The height of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="92">The rowstride in bytes of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="93">The offset into the given @buffer to the first pixel that
         should be considered part of the #CoglBitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_bitmap_new_from_file"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="70">Loads an image file from disk. This function can be safely called from
within a thread.</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="82"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="78">a #CoglBitmap to the new loaded
              image data, or %NULL if loading the image failed.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="72">the file to load.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_bitmap_new_with_size"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="109">Creates a new #CoglBitmap with the given width, height and format.
The initial contents of the bitmap are undefined.

The data for the bitmap will be stored in a newly created
#CoglPixelBuffer. You can get a pointer to the pixel buffer using
cogl_bitmap_get_buffer(). The #CoglBuffer API can then be
used to fill the bitmap with data.

&lt;note&gt;Cogl will try its best to provide a hardware array you can
map, write into and effectively do a zero copy upload when creating
a texture from it with cogl_texture_new_from_bitmap(). For various
reasons, such arrays are likely to have a stride larger than width
* bytes_per_pixel. The user must take the stride into account when
writing into it. The stride can be retrieved with
cogl_bitmap_get_rowstride().&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="136"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="132">a #CoglPixelBuffer representing the
              newly created array or %NULL on failure</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="111">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="112">width of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="113">height of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="114">the format of the pixels the array will store</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="error_quark" c:identifier="cogl_bitmap_error_quark">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="273"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <function name="get_size_from_file"
                c:identifier="cogl_bitmap_get_size_from_file">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="217">Parses an image file enough to extract the width and height
of the bitmap.</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="229"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="226">%TRUE if the image was successfully parsed</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="219">the file to check</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="220">return location for the bitmap width, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="221">return location for the bitmap height, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_buffer"
              c:identifier="cogl_bitmap_get_buffer"
              introspectable="0">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="215"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="209">the #CoglPixelBuffer that this
  buffer uses for storage. Note that if the bitmap was created with
  cogl_bitmap_new_from_file() then it will not actually be using a
  pixel buffer and this function will return %NULL.</doc>
          <type c:type="CoglPixelBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="207">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="cogl_bitmap_get_format">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="174"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="171">the #CoglPixelFormat that the data for the bitmap is in.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="169">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_bitmap_get_height">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="192"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="189">the height of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="187">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rowstride" c:identifier="cogl_bitmap_get_rowstride">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="203"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="198">the rowstride of the bitmap. This is the number of
  bytes between the address of start of one row to the address of the
  next row in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="196">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_bitmap_get_width">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="183"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="180">the width of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="178">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="BitmapError" c:type="CoglBitmapError">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-bitmap.h"
           line="252">Error codes that can be thrown when performing bitmap
operations. Note that gdk_pixbuf_new_from_file() can also throw
errors directly from the underlying image loading library. For
example, if GdkPixbuf is used then errors #GdkPixbufError&lt;!-- --&gt;s
will be used directly.</doc>
      <source-position filename="cogl/cogl/cogl-bitmap.h" line="270"/>
      <member name="failed" value="0" c:identifier="COGL_BITMAP_ERROR_FAILED">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="254">Generic failure code, something went
  wrong.</doc>
      </member>
      <member name="unknown_type"
              value="1"
              c:identifier="COGL_BITMAP_ERROR_UNKNOWN_TYPE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="256">Unknown image type.</doc>
      </member>
      <member name="corrupt_image"
              value="2"
              c:identifier="COGL_BITMAP_ERROR_CORRUPT_IMAGE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="257">An image file was broken somehow.</doc>
      </member>
    </enumeration>
    <enumeration name="BlendStringError" c:type="CoglBlendStringError">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="182">Error enumeration for the blend strings parser</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="198"/>
      <member name="parse_error"
              value="0"
              c:identifier="COGL_BLEND_STRING_ERROR_PARSE_ERROR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="184">Generic parse error</doc>
      </member>
      <member name="argument_parse_error"
              value="1"
              c:identifier="COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="185">Argument parse error</doc>
      </member>
      <member name="invalid_error"
              value="2"
              c:identifier="COGL_BLEND_STRING_ERROR_INVALID_ERROR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="186">Internal parser error</doc>
      </member>
      <member name="gpu_unsupported_error"
              value="3"
              c:identifier="COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="187">Blend string not
  supported by the GPU</doc>
      </member>
    </enumeration>
    <bitfield name="BufferBit" c:type="CoglBufferBit">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="429">Types of auxiliary buffers</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="442"/>
      <member name="color" value="1" c:identifier="COGL_BUFFER_BIT_COLOR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="431">Selects the primary color buffer</doc>
      </member>
      <member name="depth" value="2" c:identifier="COGL_BUFFER_BIT_DEPTH">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="432">Selects the depth buffer</doc>
      </member>
      <member name="stencil" value="4" c:identifier="COGL_BUFFER_BIT_STENCIL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="433">Selects the stencil buffer</doc>
      </member>
    </bitfield>
    <bitfield name="BufferTarget" c:type="CoglBufferTarget">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="119">Target flags for FBOs.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="130"/>
      <member name="window_buffer" value="2" c:identifier="COGL_WINDOW_BUFFER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="121">FIXME</doc>
      </member>
      <member name="offscreen_buffer"
              value="4"
              c:identifier="COGL_OFFSCREEN_BUFFER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="122">FIXME</doc>
      </member>
    </bitfield>
    <function-macro name="CONTEXT"
                    c:identifier="COGL_CONTEXT"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-context.h" line="96"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Color"
            c:type="CoglColor"
            glib:type-name="CoglColor"
            glib:get-type="cogl_color_get_gtype"
            c:symbol-prefix="color">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="132">A structure for holding a color definition. The contents of
the CoglColor structure are private and should never by accessed
directly.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="151"/>
      <field name="private_member_red" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_green" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_blue" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_alpha" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <constructor name="new" c:identifier="cogl_color_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="60">Creates a new (empty) color</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="69"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="65">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocated resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="cogl_color_copy">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="71">Creates a copy of @color</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="81"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="77">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocate resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="73">the color to copy</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_color_free">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="83">Frees the resources allocated by cogl_color_new() and cogl_color_copy()</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="90"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="85">the color to free</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha" c:identifier="cogl_color_get_alpha">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="269">Retrieves the alpha channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="279"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="276">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="271">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_byte" c:identifier="cogl_color_get_alpha_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="173">Retrieves the alpha channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="183"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="180">the alpha channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="175">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_float" c:identifier="cogl_color_get_alpha_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="221">Retrieves the alpha channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="231"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="228">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="223">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue" c:identifier="cogl_color_get_blue">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="257">Retrieves the blue channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="267"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="264">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="259">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_byte" c:identifier="cogl_color_get_blue_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="161">Retrieves the blue channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="171"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="168">the blue channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="163">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_float" c:identifier="cogl_color_get_blue_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="209">Retrieves the blue channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="219"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="216">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="211">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green" c:identifier="cogl_color_get_green">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="245">Retrieves the green channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="255"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="252">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="247">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_byte" c:identifier="cogl_color_get_green_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="149">Retrieves the green channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="159"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="156">the green channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="151">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_float" c:identifier="cogl_color_get_green_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="197">Retrieves the green channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="207"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="204">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="199">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red" c:identifier="cogl_color_get_red">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="233">Retrieves the red channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="243"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="240">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="235">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_byte" c:identifier="cogl_color_get_red_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="137">Retrieves the red channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="147"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="144">the red channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="139">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_float" c:identifier="cogl_color_get_red_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="185">Retrieves the red channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="195"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="192">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="187">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_from_4f" c:identifier="cogl_color_init_from_4f">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="109">Sets the values of the passed channels into a #CoglColor</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="120"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="111">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="112">value of the red channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="113">value of the green channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="114">value of the blue channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="115">value of the alpha channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4fv" c:identifier="cogl_color_init_from_4fv">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="126">Sets the values of the passed channels into a #CoglColor</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="128">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="color_array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="129">a pointer to an array of 4 float color components</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4ub" c:identifier="cogl_color_init_from_4ub">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="92">Sets the values of the passed channels into a #CoglColor.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="103"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="94">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="95">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="96">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="97">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="98">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="premultiply" c:identifier="cogl_color_premultiply">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="413">Converts a non-premultiplied color to a pre-multiplied color. For
example, semi-transparent red is (1.0, 0, 0, 0.5) when non-premultiplied
and (0.5, 0, 0, 0.5) when premultiplied.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="422"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="415">the color to premultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_alpha" c:identifier="cogl_color_set_alpha">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="402">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="410"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="404">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="405">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_byte" c:identifier="cogl_color_set_alpha_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="314">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="322"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="316">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="317">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_float" c:identifier="cogl_color_set_alpha_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="358">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="366"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="360">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="361">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue" c:identifier="cogl_color_set_blue">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="391">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="399"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="393">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="394">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_byte" c:identifier="cogl_color_set_blue_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="303">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="311"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="305">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="306">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_float" c:identifier="cogl_color_set_blue_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="347">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="355"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="349">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="350">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green" c:identifier="cogl_color_set_green">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="380">Sets the green channel of @color to @green.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="388"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="382">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="383">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_byte" c:identifier="cogl_color_set_green_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="292">Sets the green channel of @color to @green.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="300"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="294">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="295">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_float" c:identifier="cogl_color_set_green_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="336">Sets the green channel of @color to @green.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="344"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="338">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="339">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red" c:identifier="cogl_color_set_red">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="369">Sets the red channel of @color to @red.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="377"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="371">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="372">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_byte" c:identifier="cogl_color_set_red_byte">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="281">Sets the red channel of @color to @red.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="289"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="283">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="284">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_float" c:identifier="cogl_color_set_red_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="325">Sets the red channel of @color to @red.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="333"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="327">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="328">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hsl" c:identifier="cogl_color_to_hsl">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="450">Converts @color to the HLS format.

The @hue value is in the 0 .. 360 range. The @luminance and
@saturation values are in the 0 .. 1 range.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="463"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="452">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
          <parameter name="hue"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="453">return location for the hue value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="saturation"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="454">return location for the saturation value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="luminance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="455">return location for the luminance value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpremultiply" c:identifier="cogl_color_unpremultiply">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="424">Converts a pre-multiplied color to a non-premultiplied color. For
example, semi-transparent red is (0.5, 0, 0, 0.5) when premultiplied
and (1.0, 0, 0, 0.5) when non-premultiplied.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="433"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="426">the color to unpremultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_color_equal">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="435">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="448"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="445">%TRUE if the two colors are the same.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="437">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="438">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_from_hsl" c:identifier="cogl_color_init_from_hsl">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="468">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="479"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="470">return location for a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="471">hue value, in the 0 .. 360 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="saturation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="472">saturation value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="luminance" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="473">luminance value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="Context"
           c:symbol-prefix="context"
           c:type="CoglContext"
           parent="Object"
           glib:type-name="CoglContext"
           glib:get-type="cogl_context_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_context_new"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="106">Creates a new #CoglContext which acts as an application sandbox
for any state objects that are allocated.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="117"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="114">A newly allocated #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <parameter name="display"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="108">A #CoglDisplay pointer</doc>
            <type c:type="CoglDisplay*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="free_timestamp_query"
              c:identifier="cogl_context_free_timestamp_query">
        <source-position filename="cogl/cogl/cogl-context.h" line="352"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="TimestampQuery" c:type="CoglTimestampQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_display"
              c:identifier="cogl_context_get_display"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="120">Retrieves the #CoglDisplay that is internally associated with the
given @context. This will return the same #CoglDisplay that was
passed to cogl_context_new() or if %NULL was passed to
cogl_context_new() then this function returns a pointer to the
display that was automatically setup internally.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="134"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="130">The #CoglDisplay associated with the
              given @context.</doc>
          <type c:type="CoglDisplay*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="122">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gpu_time_ns"
              c:identifier="cogl_context_get_gpu_time_ns">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="359">This function should only be called if the COGL_FEATURE_ID_TIMESTAMP_QUERY
feature is advertised.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="369"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="366">Current GPU time in nanoseconds</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="361">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_named_pipeline"
              c:identifier="cogl_context_get_named_pipeline">
        <source-position filename="cogl/cogl/cogl-context.h" line="348"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="343">The #CoglPipeline associated with the
              given @context and @key, or %NULL if no such #CoglPipeline
              was found.</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="340">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="341">a #CoglPipelineKey pointer</doc>
            <type name="PipelineKey" c:type="CoglPipelineKey*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_renderer"
              c:identifier="cogl_context_get_renderer"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="136">Retrieves the #CoglRenderer that is internally associated with the
given @context. This will return the same #CoglRenderer that was
passed to cogl_display_new() or if %NULL was passed to
cogl_display_new() or cogl_context_new() then this function returns
a pointer to the renderer that was automatically connected
internally.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="151"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="147">The #CoglRenderer associated with the
              given @context.</doc>
          <type c:type="CoglRenderer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="138">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_hardware_accelerated"
              c:identifier="cogl_context_is_hardware_accelerated">
        <source-position filename="cogl/cogl/cogl-context.h" line="317"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="313">%TRUE if the @context is hardware accelerated, or %FALSE if
not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="311">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_named_pipeline"
              c:identifier="cogl_context_set_named_pipeline">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="321">Associate a #CoglPipeline with a @context and @key. This will not take a new
reference to the @pipeline, but will unref all associated pipelines when
the @context gets destroyed. Similarly, if a pipeline gets overwritten,
it will get unreffed as well.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="334"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="323">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="324">a #CoglPipelineKey pointer</doc>
            <type name="PipelineKey" c:type="CoglPipelineKey*"/>
          </parameter>
          <parameter name="pipeline"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="325">a #CoglPipeline to associate with the @context and
           @key</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
        </parameters>
      </method>
      <method name="timestamp_query_get_time_ns"
              c:identifier="cogl_context_timestamp_query_get_time_ns">
        <source-position filename="cogl/cogl/cogl-context.h" line="356"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="TimestampQuery" c:type="CoglTimestampQuery*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <constant name="DEPTH_BIT" value="256" c:type="COGL_DEPTH_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="67"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <callback name="DebugObjectForeachTypeCallback"
              c:type="CoglDebugObjectForeachTypeCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-object.h"
           line="153">A callback function to use for cogl_debug_object_foreach_type().</doc>
      <source-position filename="cogl/cogl/cogl-object.h" line="160"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-object.h"
               line="155">A pointer to a struct containing information about the type.</doc>
          <type name="DebugObjectTypeInfo"
                c:type="const CoglDebugObjectTypeInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DebugObjectTypeInfo" c:type="CoglDebugObjectTypeInfo">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-object.h"
           line="139">This struct is used to pass information to the callback when
cogl_debug_object_foreach_type() is called.</doc>
      <source-position filename="cogl/cogl/cogl-object.h" line="151"/>
      <field name="name" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-object.h"
             line="141">A human readable name for the type.</doc>
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="instance_count" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-object.h"
             line="142">The number of objects of this type that are
  currently in use</doc>
        <type name="gulong" c:type="unsigned long"/>
      </field>
    </record>
    <enumeration name="DepthTestFunction" c:type="CoglDepthTestFunction">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="318">When using depth testing one of these functions is used to compare
the depth of an incoming fragment against the depth value currently
stored in the depth buffer. The function is changed using
cogl_depth_state_set_test_function().

The test is only done when depth testing is explicitly enabled. (See
cogl_depth_state_set_test_enabled())</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="353"/>
      <member name="never"
              value="512"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NEVER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="320">Never passes.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LESS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="321">Passes if the fragment's depth
value is less than the value currently in the depth buffer.</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_EQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="323">Passes if the fragment's depth
value is equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="325">Passes if the fragment's depth
value is less or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GREATER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="327">Passes if the fragment's depth
value is greater than the value currently in the depth buffer.</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="329">Passes if the fragment's depth
value is not equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="331">Passes if the fragment's depth
value greater than or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_ALWAYS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="333">Always passes.</doc>
      </member>
    </enumeration>
    <record name="DmaBufHandle"
            c:type="CoglDmaBufHandle"
            disguised="1"
            opaque="1"
            introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="102">An opaque type that tracks the lifetime of a DMA buffer fd. Release
with cogl_dma_buf_handle_free().</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="108"/>
    </record>
    <bitfield name="EglImageFlags" c:type="CoglEglImageFlags">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="66"/>
      <member name="none" value="0" c:identifier="COGL_EGL_IMAGE_FLAG_NONE">
      </member>
      <member name="no_get_data"
              value="1"
              c:identifier="COGL_EGL_IMAGE_FLAG_NO_GET_DATA">
      </member>
    </bitfield>
    <function-macro name="FRAME_INFO"
                    c:identifier="COGL_FRAME_INFO"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-frame-info.h" line="54"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="FeatureCallback" c:type="CoglFeatureCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="242">A callback used with cogl_foreach_feature() for enumerating all
context level features supported by Cogl.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="250"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="244">A single feature currently supported by Cogl</doc>
          <type name="FeatureID" c:type="CoglFeatureID"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="245">A private pointer passed to cogl_foreach_feature().</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="FeatureID" c:type="CoglFeatureID">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="168">All the capabilities that can vary between different GPUs supported
by Cogl. Applications that depend on any of these features should explicitly
check for them using cogl_has_feature() or cogl_has_features().</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="204"/>
      <member name="ogl_feature_id_unsigned_int_indices"
              value="0"
              c:identifier="COGL_FEATURE_ID_UNSIGNED_INT_INDICES">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="173">Set if
    %COGL_INDICES_TYPE_UNSIGNED_INT is supported in
    cogl_indices_new().</doc>
      </member>
      <member name="ogl_feature_id_map_buffer_for_read"
              value="1"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_READ">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="176">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including read support.</doc>
      </member>
      <member name="ogl_feature_id_map_buffer_for_write"
              value="2"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_WRITE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="178">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including write support.</doc>
      </member>
      <member name="ogl_feature_id_fence"
              value="3"
              c:identifier="COGL_FEATURE_ID_FENCE">
      </member>
      <member name="ogl_feature_id_texture_rg"
              value="4"
              c:identifier="COGL_FEATURE_ID_TEXTURE_RG">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="170">Support for
   %COGL_TEXTURE_COMPONENTS_RG as the internal components of a
   texture.</doc>
      </member>
      <member name="ogl_feature_id_buffer_age"
              value="5"
              c:identifier="COGL_FEATURE_ID_BUFFER_AGE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="180">Available if the age of #CoglOnscreen back
   buffers are tracked and so cogl_onscreen_get_buffer_age() can be
   expected to return age values other than 0.</doc>
      </member>
      <member name="ogl_feature_id_texture_egl_image_external"
              value="6"
              c:identifier="COGL_FEATURE_ID_TEXTURE_EGL_IMAGE_EXTERNAL">
      </member>
      <member name="ogl_feature_id_blit_framebuffer"
              value="7"
              c:identifier="COGL_FEATURE_ID_BLIT_FRAMEBUFFER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="183">Whether blitting using
   cogl_blit_framebuffer() is supported.</doc>
      </member>
      <member name="ogl_feature_id_timestamp_query"
              value="8"
              c:identifier="COGL_FEATURE_ID_TIMESTAMP_QUERY">
      </member>
    </enumeration>
    <enumeration name="FilterReturn" c:type="CoglFilterReturn">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="362">Return values for the #CoglXlibFilterFunc and #CoglWin32FilterFunc functions.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="373"/>
      <member name="continue" value="0" c:identifier="COGL_FILTER_CONTINUE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="364">The event was not handled, continues the
                       processing</doc>
      </member>
      <member name="remove" value="1" c:identifier="COGL_FILTER_REMOVE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="366">Remove the event, stops the processing</doc>
      </member>
    </enumeration>
    <callback name="FrameCallback" c:type="CoglFrameCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="368">Is a callback that can be registered via
cogl_onscreen_add_frame_callback() to be called when a frame
progresses in some notable way.

Please see the documentation for #CoglFrameEvent and
cogl_onscreen_add_frame_callback() for more details about what
events can be notified.</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="385"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="370">The onscreen that the frame is associated with</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="371">A #CoglFrameEvent notifying how the frame has progressed</doc>
          <type name="FrameEvent" c:type="CoglFrameEvent"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="372">The meta information, such as timing information, about
       the frame that has progressed.</doc>
          <type name="FrameInfo" c:type="CoglFrameInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="374">The user pointer passed to
            cogl_onscreen_add_frame_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="FrameClosure"
            c:type="CoglFrameClosure"
            opaque="1"
            glib:type-name="CoglFrameClosure"
            glib:get-type="cogl_frame_closure_get_gtype"
            c:symbol-prefix="frame_closure">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="390">An opaque type that tracks a #CoglFrameCallback and associated user
data. A #CoglFrameClosure pointer will be returned from
cogl_onscreen_add_frame_callback() and it allows you to remove a
callback later using cogl_onscreen_remove_frame_callback().</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="398"/>
    </record>
    <enumeration name="FrameEvent" c:type="CoglFrameEvent">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="334">Identifiers that are passed to #CoglFrameCallback functions
(registered using cogl_onscreen_add_frame_callback()) that
mark the progression of a frame in some way which usually
means that new information will have been accumulated in the
frame's corresponding #CoglFrameInfo object.

The last event that will be sent for a frame will be a
@COGL_FRAME_EVENT_COMPLETE event and so these are a good
opportunity to collect statistics about a frame since the
#CoglFrameInfo should hold the most data at this point.

&lt;note&gt;A frame may not be completed before the next frame can start
so applications should avoid needing to collect all statistics for
a particular frame before they can start a new frame.&lt;/note&gt;</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="366"/>
      <member name="sync" value="1" c:identifier="COGL_FRAME_EVENT_SYNC">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="336">Notifies that the system compositor has
                        acknowledged a frame and is ready for a
                        new frame to be created.</doc>
      </member>
      <member name="complete"
              value="2"
              c:identifier="COGL_FRAME_EVENT_COMPLETE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="339">Notifies that a frame has ended. This
                            is a good time for applications to
                            collect statistics about the frame
                            since the #CoglFrameInfo should hold
                            the most data at this point. No other
                            events should be expected after a
                            @COGL_FRAME_EVENT_COMPLETE event.</doc>
      </member>
    </enumeration>
    <class name="FrameInfo"
           c:symbol-prefix="frame_info"
           c:type="CoglFrameInfo"
           parent="Object"
           glib:type-name="CoglFrameInfo"
           glib:get-type="cogl_frame_info_get_gtype"
           glib:fundamental="1">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-frame-info.h"
           line="48">Frame information.</doc>
      <method name="get_frame_counter"
              c:identifier="cogl_frame_info_get_frame_counter">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="76">Gets the frame counter for the #CoglOnscreen that corresponds
to this frame.</doc>
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="86"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="83">The frame counter value</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-frame-info.h"
                 line="78">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_global_frame_counter"
              c:identifier="cogl_frame_info_get_global_frame_counter"
              introspectable="0">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="128"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_symbolic"
              c:identifier="cogl_frame_info_get_is_symbolic">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="131"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_presentation_time_us"
              c:identifier="cogl_frame_info_get_presentation_time_us">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="88">Gets the presentation time for the frame. This is the time at which
the frame became visible to the user.

The presentation time measured in microseconds, is based on
CLOCK_MONOTONIC.

&lt;note&gt;Some buggy Mesa drivers up to 9.0.1 may
incorrectly report non-monotonic timestamps.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="104"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="101">the presentation time for the frame</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-frame-info.h"
                 line="90">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refresh_rate"
              c:identifier="cogl_frame_info_get_refresh_rate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="106">Gets the refresh rate in Hertz for the output that the frame was on
at the time the frame was presented.

&lt;note&gt;Some platforms can't associate a #CoglOutput with a
#CoglFrameInfo object but are able to report a refresh rate via
this api. Therefore if you need this information then this api is
more reliable than using cogl_frame_info_get_output() followed by
cogl_output_get_refresh_rate().&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="122"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="119">the refresh rate in Hertz</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-frame-info.h"
                 line="108">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rendering_duration_ns"
              c:identifier="cogl_frame_info_get_rendering_duration_ns">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="146"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sequence" c:identifier="cogl_frame_info_get_sequence">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="143"/>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_time_before_buffer_swap_us"
              c:identifier="cogl_frame_info_get_time_before_buffer_swap_us">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="149"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_hw_clock" c:identifier="cogl_frame_info_is_hw_clock">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_vsync" c:identifier="cogl_frame_info_is_vsync">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="140"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_zero_copy" c:identifier="cogl_frame_info_is_zero_copy">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="137"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <class name="Framebuffer"
           c:symbol-prefix="framebuffer"
           c:type="CoglFramebuffer"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CoglFramebuffer"
           glib:get-type="cogl_framebuffer_get_type"
           glib:type-struct="FramebufferClass">
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="102"/>
      <function name="error_quark" c:identifier="cogl_framebuffer_error_quark">
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1269"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <virtual-method name="allocate" invoker="allocate" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="104">Explicitly allocates a configured #CoglFramebuffer allowing developers to
check and handle any errors that might arise from an unsupported
configuration so that fallback configurations may be tried.

&lt;note&gt;Many applications don't support any fallback options at least when
they are initially developed and in that case the don't need to use this API
since Cogl will automatically allocate a framebuffer when it first gets
used.  The disadvantage of relying on automatic allocation is that the
program will abort with an error message if there is an error during
automatic allocation.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="120">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="106">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_y_flipped">
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="101"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="allocate"
              c:identifier="cogl_framebuffer_allocate"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="104">Explicitly allocates a configured #CoglFramebuffer allowing developers to
check and handle any errors that might arise from an unsupported
configuration so that fallback configurations may be tried.

&lt;note&gt;Many applications don't support any fallback options at least when
they are initially developed and in that case the don't need to use this API
since Cogl will automatically allocate a framebuffer when it first gets
used.  The disadvantage of relying on automatic allocation is that the
program will abort with an error message if there is an error during
automatic allocation.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="123"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="120">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="106">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="cogl_framebuffer_clear">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="865">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="878"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="867">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="868">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="870">The color to clear the color buffer too if specified in
        @buffers.</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear4f" c:identifier="cogl_framebuffer_clear4f">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="882">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="901"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="884">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="885">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="887">The red component of color to clear the color buffer too if
      specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="889">The green component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="891">The blue component of color to clear the color buffer too if
       specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="893">The alpha component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_timestamp_query"
              c:identifier="cogl_framebuffer_create_timestamp_query"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1370">Creates a query for the GPU timestamp that will complete upon completion of
all previously submitted GL commands related to this framebuffer. E.g. when
the rendering is finished on this framebuffer.

This function should only be called if the COGL_FEATURE_ID_TIMESTAMP_QUERY
feature is advertised.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1381"/>
        <return-value>
          <type name="TimestampQuery" c:type="CoglTimestampQuery*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="discard_buffers"
              c:identifier="cogl_framebuffer_discard_buffers">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1145">Declares that the specified @buffers no longer need to be referenced
by any further rendering commands. This can be an important
optimization to avoid subsequent frames of rendering depending on
the results of a previous frame.

For example; some tile-based rendering GPUs are able to avoid allocating and
accessing system memory for the depth and stencil buffer so long as these
buffers are not required as input for subsequent frames and that can save a
significant amount of memory bandwidth used to save and restore their
contents to system memory between frames.

It is currently considered an error to try and explicitly discard the color
buffer by passing %COGL_BUFFER_BIT_COLOR. This is because the color buffer is
already implicitly discard when you finish rendering to a #CoglOnscreen
framebuffer, and it's not meaningful to try and discard the color buffer of
a #CoglOffscreen framebuffer since they are single-buffered.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1171"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1147">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1148">A #CoglBufferBit mask of which ancillary buffers you want
          to discard.</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_multitextured_rectangle"
              c:identifier="cogl_framebuffer_draw_multitextured_rectangle">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="989">Draws a textured rectangle to @framebuffer with the given @pipeline
state with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2). As a pipeline may
contain multiple texture layers this interface lets you supply
texture coordinates for each layer of the pipeline.

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture for the first layer such as
#CoglTexture2DSliced textures which may internally be comprised of
multiple low-level textures.  This is unlike low-level drawing apis
such as cogl_primitive_draw() which only support low level texture
types that are directly supported by GPUs such as #CoglTexture2D.

&lt;note&gt;This api can not currently handle multiple high-level meta
texture layers. The first layer may be a high level meta texture
such as #CoglTexture2DSliced but all other layers much be low
level textures such as #CoglTexture2D.

The top left texture coordinate for layer 0 of any pipeline will be
(tex_coords[0], tex_coords[1]) and the bottom right coordinate will
be (tex_coords[2], tex_coords[3]). The coordinates for layer 1
would be (tex_coords[4], tex_coords[5]) (tex_coords[6],
tex_coords[7]) and so on...

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.

The first pair of coordinates are for the first layer (with the
smallest layer index) and if you supply less texture coordinates
than there are layers in the current source material then default
texture coordinates (0.0, 0.0, 1.0, 1.0) are generated.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1046"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="991">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="992">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="993">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="994">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="995">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="996">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tex_coords" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="997">An array containing groups of
  4 float values: [s_1, t_1, s_2, t_2] that are interpreted as two texture
  coordinates; one for the top left texel, and one for the bottom right
  texel. Each value should be between 0.0 and 1.0, where the coordinate
  (0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the
  bottom right.</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="tex_coords_len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1003">The length of the @tex_coords array. (For one layer
  and one group of texture coordinates, this would be 4)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangle"
              c:identifier="cogl_framebuffer_draw_rectangle">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="908">Draws a rectangle to @framebuffer with the given @pipeline state
and with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2).

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

&lt;note&gt;If you want to describe a rectangle with a texture mapped on
it then you can use
cogl_framebuffer_draw_textured_rectangle().&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="930"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="910">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="911">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="912">X coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="913">Y coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="914">X coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="915">Y coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangles"
              c:identifier="cogl_framebuffer_draw_rectangles">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1055">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_rectangle() does.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The positions for
the second rectangle are (coordinates[4], coordinates[5]) and
(coordinates[6], coordinates[7]) and so on...

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1087"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1057">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1058">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1059">an array of coordinates
  containing groups of 4 float values: [x_1, y_1, x_2, y_2] that are
  interpreted as two position coordinates; one for the top left of
  the rectangle (x1, y1), and one for the bottom right of the
  rectangle (x2, y2).</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1064">number of rectangles defined in @coordinates.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangle"
              c:identifier="cogl_framebuffer_draw_textured_rectangle">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="937">Draws a textured rectangle to @framebuffer using the given
@pipeline state with the top left corner positioned at (@x_1, @y_1)
and the bottom right corner positioned at (@x_2, @y_2). The top
left corner will have texture coordinates of (@s_1, @t_1) and the
bottom right corner will have texture coordinates of (@s_2, @t_2).

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

&lt;note&gt;The given texture coordinates will only be used for the first
texture layer of the pipeline and if your pipeline has more than
one layer then all other layers will have default texture
coordinates of @s_1=0.0 @t_1=0.0 @s_2=1.0 @t_2=1.0 &lt;/note&gt;

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in @s_1=0, @t_1=0, @s_2=1, @t_2=1.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="978"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="939">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="940">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="941">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="942">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="943">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="944">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="945">S texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="946">T texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="947">S texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="948">T texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangles"
              c:identifier="cogl_framebuffer_draw_textured_rectangles">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1092">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_textured_rectangle() does.

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The top left
texture coordinate is (coordinates[4], coordinates[5]) and the
bottom right texture coordinate is (coordinates[6],
coordinates[7]). The coordinates for subsequent rectangles
are defined similarly by the subsequent coordinates.

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1138"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1094">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1095">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1096">an array containing
  groups of 8 float values: [x_1, y_1, x_2, y_2, s_1, t_1, s_2, t_2]
  that have the same meaning as the arguments for
  cogl_framebuffer_draw_textured_rectangle().</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1100">number of rectangles to @coordinates to draw</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish" c:identifier="cogl_framebuffer_finish">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1174">This blocks the CPU until all pending rendering associated with the
specified framebuffer has completed. It's very rare that developers should
ever need this level of synchronization with the GPU and should never be
used unless you clearly understand why you need to explicitly force
synchronization.

One example might be for benchmarking purposes to be sure timing
measurements reflect the time that the GPU is busy for not just the time it
takes to queue rendering commands.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1189"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1176">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="cogl_framebuffer_flush">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1358">Flushes @framebuffer to ensure the current batch of commands is
submitted to the GPU.

Unlike cogl_framebuffer_finish(), this does not block the CPU.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1368"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1360">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="frustum" c:identifier="cogl_framebuffer_frustum">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="397">Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="416"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="399">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="400">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="402">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="404">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="406">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="408">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="409">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_bits"
              c:identifier="cogl_framebuffer_get_alpha_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="581">Retrieves the number of alpha bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="591"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="587">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="583">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_bits"
              c:identifier="cogl_framebuffer_get_blue_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="569">Retrieves the number of blue bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="579"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="575">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="571">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="cogl_framebuffer_get_context">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="851">Can be used to query the #CoglContext a given @framebuffer was
instantiated within. This is the #CoglContext that was passed to
cogl_onscreen_new() for example.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="863"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="859">The #CoglContext that the given
              @framebuffer was instantiated within.</doc>
          <type name="Context" c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="853">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_bits"
              c:identifier="cogl_framebuffer_get_depth_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="593">Retrieves the number of depth bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="602"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="599">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="595">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_write_enabled"
              c:identifier="cogl_framebuffer_get_depth_write_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="658">Queries whether depth buffer writing is enabled for @framebuffer. This
can be controlled via cogl_framebuffer_set_depth_write_enabled().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="668"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="665">%TRUE if depth writing is enabled or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="660">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dither_enabled"
              c:identifier="cogl_framebuffer_get_dither_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="618">Returns whether dithering has been requested for the given @framebuffer.
See cogl_framebuffer_set_dither_enabled() for more details about dithering.

&lt;note&gt;This may return %TRUE even when the underlying @framebuffer
display pipeline does not support dithering. This value only represents
the user's request for dithering.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="632"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="629">%TRUE if dithering has been requested or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="620">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_bits"
              c:identifier="cogl_framebuffer_get_green_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="557">Retrieves the number of green bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="567"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="563">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="559">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="cogl_framebuffer_get_height"
              glib:get-property="height">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="137">Queries the current height of the given @framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="146"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="143">The height of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="139">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_stereo"
              c:identifier="cogl_framebuffer_get_is_stereo">
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="616"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modelview_matrix"
              c:identifier="cogl_framebuffer_get_modelview_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="351">Stores the current model-view matrix in @matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="359"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="353">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="354">return location for the model-view matrix</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_projection_matrix"
              c:identifier="cogl_framebuffer_get_projection_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="450">Stores the current projection matrix in @matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="458"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="452">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="453">return location for the projection matrix</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_red_bits" c:identifier="cogl_framebuffer_get_red_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="545">Retrieves the number of red bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="555"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="551">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="547">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_samples_per_pixel"
              c:identifier="cogl_framebuffer_get_samples_per_pixel">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="759">Gets the number of points that are sampled per-pixel when
rasterizing geometry. Usually by default this will return 0 which
means that single-sample not multisample rendering has been chosen.
When using a GPU supporting multisample rendering it's possible to
increase the number of samples per pixel using
cogl_framebuffer_set_samples_per_pixel().

Calling cogl_framebuffer_get_samples_per_pixel() before the
framebuffer has been allocated will simply return the value set
using cogl_framebuffer_set_samples_per_pixel(). After the
framebuffer has been allocated the value will reflect the actual
number of samples that will be made by the GPU.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="781"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="776">The number of point samples made per pixel when
         rasterizing geometry or 0 if single-sample rendering
         has been chosen.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="761">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stereo_mode"
              c:identifier="cogl_framebuffer_get_stereo_mode">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="686">Gets the current #CoglStereoMode, which defines which stereo buffers
should be drawn to. See cogl_framebuffer_set_stereo_mode().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="696"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="693">A #CoglStereoMode</doc>
          <type name="StereoMode" c:type="CoglStereoMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="688">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport4fv"
              c:identifier="cogl_framebuffer_get_viewport4fv">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="230">Queries the x, y, width and height components of the current viewport as set
using cogl_framebuffer_set_viewport() or the default values which are 0, 0,
framebuffer_width and framebuffer_height.  The values are written into the
given @viewport array.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="244"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="232">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="viewport"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="233">A pointer to an
           array of 4 floats to receive the (x, y, width, height)
           components of the current viewport.</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_viewport_height"
              c:identifier="cogl_framebuffer_get_viewport_height">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="218">Queries the height of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the height of the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="228"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="225">The height of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="220">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_width"
              c:identifier="cogl_framebuffer_get_viewport_width">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="206">Queries the width of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the width of the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="216"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="213">The width of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="208">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_x"
              c:identifier="cogl_framebuffer_get_viewport_x">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="182">Queries the x coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="192"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="189">The x coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="184">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_y"
              c:identifier="cogl_framebuffer_get_viewport_y">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="194">Queries the y coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="204"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="201">The y coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="196">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="cogl_framebuffer_get_width"
              glib:get-property="width">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="126">Queries the current width of the given @framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="132">The width of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="128">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="identity_matrix"
              c:identifier="cogl_framebuffer_identity_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="266">Resets the current model-view matrix to the identity matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="273"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="268">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="orthographic" c:identifier="cogl_framebuffer_orthographic">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="424">Replaces the current projection matrix with an orthographic projection
matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="442"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="426">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="427">The x coordinate for the first vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="428">The y coordinate for the first horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="429">The x coordinate for the second vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="430">The y coordinate for the second horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="431">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="434">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="cogl_framebuffer_perspective">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="373">Replaces the current projection matrix with a perspective matrix
based on the provided values.

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there won't be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="391"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="375">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="376">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="377">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="378">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="380">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_clip" c:identifier="cogl_framebuffer_pop_clip">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="534">Reverts the clipping region to the state before the last call to
cogl_framebuffer_push_rectangle_clip(), or
cogl_framebuffer_push_primitive_clip().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="543"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="536">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_matrix" c:identifier="cogl_framebuffer_pop_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="257">Restores the model-view matrix on the top of the matrix stack.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="264"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="259">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_matrix" c:identifier="cogl_framebuffer_push_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="247">Copies the current model-view matrix onto the matrix stack. The matrix
can later be restored with cogl_framebuffer_pop_matrix().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="255"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="249">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_primitive_clip"
              c:identifier="cogl_framebuffer_push_primitive_clip"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="496">Sets a new clipping area using a 2D shaped described with a
#CoglPrimitive. The shape must not contain self overlapping
geometry and must lie on a single 2D plane. A bounding box of the
2D shape in local coordinates (the same coordinates used to
describe the shape) must be given. It is acceptable for the bounds
to be larger than the true bounds but behaviour is undefined if the
bounds are smaller than the true bounds.

The primitive is transformed by the current model-view matrix and
the silhouette is intersected with the previous clipping area.  To
restore the previous clipping area, call
cogl_framebuffer_pop_clip().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="523"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="498">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="499">A #CoglPrimitive describing a flat 2D shape</doc>
            <type c:type="CoglPrimitive*"/>
          </parameter>
          <parameter name="bounds_x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="500">x coordinate for the top-left corner of the primitives
            bounds</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="502">y coordinate for the top-left corner of the primitives
            bounds</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="504">x coordinate for the bottom-right corner of the
            primitives bounds.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="506">y coordinate for the bottom-right corner of the
            primitives bounds.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_rectangle_clip"
              c:identifier="cogl_framebuffer_push_rectangle_clip">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="472">Specifies a modelview transformed rectangular clipping area for all
subsequent drawing operations. Any drawing commands that extend
outside the rectangle will be clipped so that only the portion
inside the rectangle will be displayed. The rectangle dimensions
are transformed by the current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_framebuffer_pop_clip().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="490"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="474">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="475">x coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="476">y coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="477">x coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="478">y coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_region_clip"
              c:identifier="cogl_framebuffer_push_region_clip">
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="531"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <type name="cairo.Region" c:type="cairo_region_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels" c:identifier="cogl_framebuffer_read_pixels">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1222">This is a convenience wrapper around
cogl_framebuffer_read_pixels_into_bitmap() which allocates a
temporary #CoglBitmap to read pixel data directly into the given
buffer. The rowstride of the buffer is assumed to be the width of
the region times the bytes per pixel of the format. The source for
the data is always taken from the color buffer. If you want to use
any other rowstride or source, please use the
cogl_framebuffer_read_pixels_into_bitmap() function directly.

The implementation of the function looks like this:

|[
bitmap = cogl_bitmap_new_for_data (context,
                                   width, height,
                                   format,
                                   /&lt;!-- --&gt;* rowstride *&lt;!-- --&gt;/
                                   bpp * width,
                                   pixels);
cogl_framebuffer_read_pixels_into_bitmap (framebuffer,
                                          x, y,
                                          COGL_READ_PIXELS_COLOR_BUFFER,
                                          bitmap);
cogl_object_unref (bitmap);
]|</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1260"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1257">%TRUE if the read succeeded or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1224">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1225">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1226">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1227">The width of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1228">The height of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1229">The pixel format to store the data in</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="pixels" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1230">The address of the buffer to store the data in</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels_into_bitmap"
              c:identifier="cogl_framebuffer_read_pixels_into_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1191">This reads a rectangle of pixels from the given framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and a rectangle of pixels with the same size as the bitmap is
read right and downwards from that point.

Currently Cogl assumes that the framebuffer is in a premultiplied
format so if the format of @bitmap is non-premultiplied it will
convert it. To read the pixel values without any conversion you
should either specify a format that doesn't use an alpha channel or
use one of the formats ending in PRE.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1216"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1211">%TRUE if the read succeeded or %FALSE otherwise. The
 function is only likely to fail if the bitmap points to a pixel
 buffer and it could not be mapped.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1193">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1194">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1195">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1196">Identifies which auxiliary buffer you want to read
         (only COGL_READ_PIXELS_COLOR_BUFFER supported currently)</doc>
            <type name="ReadPixelsFlags" c:type="CoglReadPixelsFlags"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1198">The bitmap to store the results in.</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resolve_samples"
              c:identifier="cogl_framebuffer_resolve_samples">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="784">When point sample rendering (also known as multisample rendering)
has been enabled via cogl_framebuffer_set_samples_per_pixel()
then you can optionally call this function (or
cogl_framebuffer_resolve_samples_region()) to explicitly resolve
the point samples into values for the final color buffer.

Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.

Since Cogl will automatically ensure samples are resolved if the
target color buffer is used as a source this API only needs to be
used if explicit control is desired - perhaps because you want to
ensure that the resolve is completed in advance to avoid later
having to wait for the resolve to complete.

If you are performing incremental updates to a framebuffer you
should consider using cogl_framebuffer_resolve_samples_region()
instead to avoid resolving redundant pixels.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="811"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="786">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="resolve_samples_region"
              c:identifier="cogl_framebuffer_resolve_samples_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="813">When point sample rendering (also known as multisample rendering)
has been enabled via cogl_framebuffer_set_samples_per_pixel()
then you can optionally call this function (or
cogl_framebuffer_resolve_samples()) to explicitly resolve the point
samples into values for the final color buffer.

Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.

Use of this API is recommended if incremental, small updates to
a framebuffer are being made because by default Cogl will
implicitly resolve all the point samples of the framebuffer which
can result in redundant work if only a small number of samples have
changed.

Because some GPUs implicitly resolve point samples this function
only guarantees that at-least the region specified will be resolved
and if you have rendered to a larger region then it's possible that
other samples may be implicitly resolved.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="845"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="815">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="816">top-left x coordinate of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="817">top-left y coordinate of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="818">width of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="819">height of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_framebuffer_rotate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="307">Multiplies the current model-view matrix by one that rotates the
model around the axis-vector specified by @x, @y and @z. The
rotation follows the right-hand thumb rule so for example rotating
by 10 degrees about the axis-vector (0, 0, 1) causes a small
counter-clockwise rotation.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="322"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="309">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="310">Angle in degrees to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="311">X-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="312">Y-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="313">Z-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler" c:identifier="cogl_framebuffer_rotate_euler">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="328">Multiplies the current model-view matrix by one that rotates
according to the rotation described by @euler.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="337"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="330">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="331">A #graphene_euler_t</doc>
            <type name="Graphene.Euler" c:type="const graphene_euler_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_framebuffer_scale">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="275">Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="286"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="277">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="278">Amount to scale along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="279">Amount to scale along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="280">Amount to scale along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_write_enabled"
              c:identifier="cogl_framebuffer_set_depth_write_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="670">Enables or disables depth buffer writing when rendering to @framebuffer.
If depth writing is enabled for both the framebuffer and the rendering
pipeline, and the framebuffer has an associated depth buffer, depth
information will be written to this buffer during rendering.

Depth buffer writing is enabled by default.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="683"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="672">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="depth_write_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="673">%TRUE to enable depth writing or %FALSE to disable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dither_enabled"
              c:identifier="cogl_framebuffer_set_dither_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="634">Enables or disabled dithering if supported by the hardware.

Dithering is a hardware dependent technique to increase the visible
color resolution beyond what the underlying hardware supports by playing
tricks with the colors placed into the framebuffer to give the illusion
of other colors. (For example this can be compared to half-toning used
by some news papers to show varying levels of grey even though their may
only be black and white are available).

If the current display pipeline for @framebuffer does not support dithering
then this has no affect.

Dithering is enabled by default.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="655"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="636">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="dither_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="637">%TRUE to enable dithering or %FALSE to disable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modelview_matrix"
              c:identifier="cogl_framebuffer_set_modelview_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="362">Sets @matrix as the new model-view matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="370"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="364">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="365">the new model-view matrix</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_projection_matrix"
              c:identifier="cogl_framebuffer_set_projection_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="461">Sets @matrix as the new projection matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="469"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="463">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="464">the new projection matrix</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_samples_per_pixel"
              c:identifier="cogl_framebuffer_set_samples_per_pixel">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="716">Requires that when rendering to @framebuffer then @n point samples
should be made per pixel which will all contribute to the final
resolved color for that pixel. The idea is that the hardware aims
to get quality similar to what you would get if you rendered
everything twice as big (for 4 samples per pixel) and then scaled
that image back down with filtering. It can effectively remove the
jagged edges of polygons and should be more efficient than if you
were to manually render at a higher resolution and downscale
because the hardware is often able to take some shortcuts. For
example the GPU may only calculate a single texture sample for all
points of a single pixel, and for tile based architectures all the
extra sample data (such as depth and stencil samples) may be
handled on-chip and so avoid increased demand on system memory
bandwidth.

By default this value is usually set to 0 and that is referred to
as "single-sample" rendering. A value of 1 or greater is referred
to as "multisample" rendering.

&lt;note&gt;There are some semantic differences between single-sample
rendering and multisampling with just 1 point sample such as it
being redundant to use the cogl_framebuffer_resolve_samples() and
cogl_framebuffer_resolve_samples_region() apis with single-sample
rendering.&lt;/note&gt;

&lt;note&gt;It's recommended that
cogl_framebuffer_resolve_samples_region() be explicitly used at the
end of rendering to a point sample buffer to minimize the number of
samples that get resolved. By default Cogl will implicitly resolve
all framebuffer samples but if only a small region of a
framebuffer has changed this can lead to redundant work being
done.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="756"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="718">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="samples_per_pixel" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="719">The minimum number of samples per pixel</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stereo_mode"
              c:identifier="cogl_framebuffer_set_stereo_mode">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="698">Sets which stereo buffers should be drawn to. The default
is %COGL_STEREO_BOTH, which means that both the left and
right buffers will be affected by drawing. For this to have
an effect, the display system must support stereo drawables,
and the framebuffer must have been created with stereo
enabled. (See cogl_onscreen_template_set_stereo_enabled(),
cogl_framebuffer_get_is_stereo().)</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="713"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="700">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="stereo_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="701">A #CoglStereoMode specifying which stereo buffers
              should be drawn tow.</doc>
            <type name="StereoMode" c:type="CoglStereoMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_viewport" c:identifier="cogl_framebuffer_set_viewport">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="148">Defines a scale and offset for everything rendered relative to the
top-left of the destination framebuffer.

By default the viewport has an origin of (0,0) and width and height
that match the framebuffer's size. Assuming a default projection and
modelview matrix then you could translate the contents of a window
down and right by leaving the viewport size unchanged by moving the
offset to (10,10). The viewport coordinates are measured in pixels.
If you left the x and y origin as (0,0) you could scale the windows
contents down by specify and width and height that's half the real
size of the framebuffer.

&lt;note&gt;Although the function takes floating point arguments, existing
drivers only allow the use of integer values. In the future floating
point values will be exposed via a checkable feature.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="176"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="150">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="151">The top-left x coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="153">The top-left y coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="155">The width of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="156">The height of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="cogl_framebuffer_transform">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="340">Multiplies the current model-view matrix by the given matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="348"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="342">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="343">the matrix to multiply with the current model-view</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_framebuffer_translate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="291">Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="302"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="293">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="294">Distance to translate along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="295">Distance to translate along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="296">Distance to translate along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <property name="context"
                introspectable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="driver-config"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="height"
                writable="1"
                construct="1"
                transfer-ownership="none"
                getter="get_height"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="width"
                writable="1"
                construct="1"
                transfer-ownership="none"
                getter="get_width"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="destroy" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="FramebufferClass"
            c:type="CoglFramebufferClass"
            glib:is-gtype-struct-for="Framebuffer">
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="102"/>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="allocate">
        <callback name="allocate" throws="1">
          <source-position filename="cogl/cogl/cogl-framebuffer.h" line="99"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="120">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="framebuffer" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-framebuffer.h"
                   line="106">A #CoglFramebuffer</doc>
              <type name="Framebuffer" c:type="CoglFramebuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_y_flipped">
        <callback name="is_y_flipped">
          <source-position filename="cogl/cogl/cogl-framebuffer.h" line="101"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="framebuffer" transfer-ownership="none">
              <type name="Framebuffer" c:type="CoglFramebuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="FramebufferDriverConfig"
            c:type="CoglFramebufferDriverConfig"
            disguised="1"
            opaque="1">
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="87"/>
    </record>
    <enumeration name="FramebufferError" c:type="CoglFramebufferError">
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1281"/>
      <member name="framebuffer_error_allocate"
              value="0"
              c:identifier="COGL_FRAMEBUFFER_ERROR_ALLOCATE">
      </member>
    </enumeration>
    <enumeration name="GraphicsResetStatus" c:type="CoglGraphicsResetStatus">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="267">All the error values that might be returned by
cogl_get_graphics_reset_status(). Each value's meaning corresponds
to the similarly named value defined in the ARB_robustness and
NV_robustness_video_memory_purge extensions.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="287"/>
      <member name="no_error"
              value="0"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_NO_ERROR">
      </member>
      <member name="guilty_context_reset"
              value="1"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_GUILTY_CONTEXT_RESET">
      </member>
      <member name="innocent_context_reset"
              value="2"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_INNOCENT_CONTEXT_RESET">
      </member>
      <member name="unknown_context_reset"
              value="3"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_UNKNOWN_CONTEXT_RESET">
      </member>
      <member name="purged_context_reset"
              value="4"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_PURGED_CONTEXT_RESET">
      </member>
    </enumeration>
    <enumeration name="IndicesType" c:type="CoglIndicesType">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="260">You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.

Note that %COGL_INDICES_TYPE_UNSIGNED_INT is only supported if the
%COGL_FEATURE_ID_UNSIGNED_INT_INDICES feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="281"/>
      <member name="byte"
              value="0"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="262">Your indices are unsigned bytes</doc>
      </member>
      <member name="short"
              value="1"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="263">Your indices are unsigned shorts</doc>
      </member>
      <member name="int"
              value="2"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_INT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="264">Your indices are unsigned ints</doc>
      </member>
    </enumeration>
    <function-macro name="META_TEXTURE"
                    c:identifier="COGL_META_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl/cogl/deprecated/cogl-type-casts.h"
                       line="49"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OBJECT"
                    c:identifier="COGL_OBJECT"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-object.h" line="41"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="CoglObject"
           abstract="1"
           glib:type-name="CoglObject"
           glib:get-type="cogl_object_get_gtype"
           glib:fundamental="1"
           glib:ref-func="cogl_object_ref"
           glib:unref-func="cogl_object_unref"
           glib:set-value-func="cogl_object_value_set_object"
           glib:get-value-func="cogl_object_value_get_object">
      <function name="ref" c:identifier="cogl_object_ref" introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-object.h"
             line="57">Increases the reference count of @object by 1</doc>
        <source-position filename="cogl/cogl/cogl-object.h" line="66"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-object.h"
               line="63">the @object, with its reference count increased</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="59">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_object_unref"
                introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-object.h"
             line="68">Drecreases the reference count of @object by 1; if the reference
count reaches 0, the resources allocated by @object will be freed</doc>
        <source-position filename="cogl/cogl/cogl-object.h" line="76"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="70">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_user_data"
              c:identifier="cogl_object_get_user_data"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-object.h"
             line="184">Finds the user data previously associated with @object using
the given @key. If no user data has been associated with @object
for the given @key this function returns NULL.</doc>
        <source-position filename="cogl/cogl/cogl-object.h" line="199"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-object.h"
               line="194">The user data previously associated
  with @object using the given @key; or %NULL if no associated
  data is found.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="186">The object with associated private data to query</doc>
            <type name="Object" c:type="CoglObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="187">The address of a #CoglUserDataKey which provides a unique value
      with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cogl_object_set_user_data"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-object.h"
             line="163">Associates some private @user_data with a given #CoglObject. To
later remove the association call cogl_object_set_user_data() with
the same @key but NULL for the @user_data.</doc>
        <source-position filename="cogl/cogl/cogl-object.h" line="179"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="165">The object to associate private data with</doc>
            <type name="Object" c:type="CoglObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="166">The address of a #CoglUserDataKey which provides a unique value
  with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="168">The data to associate with the given object,
  or %NULL to remove a previous association.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-object.h"
                 line="170">A #CoglUserDataDestroyCallback to call if the object is
  destroyed or if the association is removed by later setting
  %NULL data for the same key.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="Offscreen"
           c:symbol-prefix="offscreen"
           c:type="CoglOffscreen"
           parent="Framebuffer"
           glib:type-name="CoglOffscreen"
           glib:get-type="cogl_offscreen_get_type"
           glib:type-struct="OffscreenClass">
      <source-position filename="cogl/cogl/cogl-offscreen.h" line="56"/>
      <constructor name="new_with_texture"
                   c:identifier="cogl_offscreen_new_with_texture">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-offscreen.h"
             line="60">This creates an offscreen framebuffer object using the given
@texture as the primary color buffer. It doesn't just initialize
the contents of the offscreen buffer with the @texture; they are
tightly bound so that drawing to the offscreen buffer effectively
updates the contents of the given texture. You don't need to
destroy the offscreen buffer before you can use the @texture again.

&lt;note&gt;This api only works with low-level #CoglTexture types such as
#CoglTexture2D and not with meta-texture types such as
#CoglTexture2DSliced.&lt;/note&gt;

The storage for the framebuffer is actually allocated lazily
so this function will never return %NULL to indicate a runtime
error. This means it is still possible to configure the framebuffer
before it is really allocated.

Simple applications without full error handling can simply rely on
Cogl to lazily allocate the storage of framebuffers but you should
be aware that if Cogl encounters an error (such as running out of
GPU memory) then your application will simply abort with an error
message. If you need to be able to catch such exceptions at runtime
then you can explicitly allocate your framebuffer when you have
finished configuring it by calling cogl_framebuffer_allocate() and
passing in a #GError argument to catch any exceptions.</doc>
        <source-position filename="cogl/cogl/cogl-offscreen.h" line="93"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-offscreen.h"
               line="89">a newly instantiated #CoglOffscreen
  framebuffer.</doc>
          <type name="Offscreen" c:type="CoglOffscreen*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-offscreen.h"
                 line="62">A #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_texture"
              c:identifier="cogl_offscreen_get_texture"
              introspectable="0">
        <source-position filename="cogl/cogl/cogl-offscreen.h" line="99"/>
        <return-value>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="offscreen" transfer-ownership="none">
            <type name="Offscreen" c:type="CoglOffscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="OffscreenClass"
            c:type="CoglOffscreenClass"
            glib:is-gtype-struct-for="Offscreen">
      <source-position filename="cogl/cogl/cogl-offscreen.h" line="56"/>
      <field name="parent_class">
        <type name="FramebufferClass" c:type="CoglFramebufferClass"/>
      </field>
    </record>
    <class name="Onscreen"
           c:symbol-prefix="onscreen"
           c:type="CoglOnscreen"
           parent="Framebuffer"
           glib:type-name="CoglOnscreen"
           glib:get-type="cogl_onscreen_get_type"
           glib:type-struct="OnscreenClass">
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="87"/>
      <virtual-method name="bind">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="62"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="direct_scanout"
                      invoker="direct_scanout"
                      introspectable="0"
                      throws="1">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="80"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_buffer_age" invoker="get_buffer_age">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="172">Gets the current age of the buffer contents.

This function allows applications to query the age of the current
back buffer contents for a #CoglOnscreen as the number of frames
elapsed since the contents were most recently defined.

These age values exposes enough information to applications about
how Cogl internally manages back buffers to allow applications to
re-use the contents of old frames and minimize how much must be
redrawn for the next frame.

The back buffer contents can either be reported as invalid (has an
age of 0) or it may be reported to be the same contents as from n
frames prior to the current frame.

The queried value remains valid until the next buffer swap.

&lt;note&gt;One caveat is that under X11 the buffer age does not reflect
changes to buffer contents caused by the window systems. X11
applications must track Expose events to determine what buffer
regions need to additionally be repaired each frame.&lt;/note&gt;

The recommended way to take advantage of this buffer age api is to
build up a circular buffer of length 3 for tracking damage regions
over the last 3 frames and when starting a new frame look at the
age of the buffer and combine the damage regions for the current
frame with the damage regions of previous @age frames so you know
everything that must be redrawn to update the old contents for the
new frame.

&lt;note&gt;If the system doesn't not support being able to track the age
of back buffers then this function will always return 0 which
implies that the contents are undefined.&lt;/note&gt;

&lt;note&gt;The %COGL_FEATURE_ID_BUFFER_AGE feature can optionally be
explicitly checked to determine if Cogl is currently tracking the
age of #CoglOnscreen back buffer contents. If this feature is
missing then this function will always return 0.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="86"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="215">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="174">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="queue_damage_region" invoker="queue_damage_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="221">Implementation for https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_partial_update.txt
This immediately queues state to OpenGL that will be used for the
next swap.
This needs to be called every frame.

The expected values are independent of any viewport transforms applied to
the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="76"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="223">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="224">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="226">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="swap_buffers_with_damage"
                      invoker="swap_buffers_with_damage">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="241">Swaps the current back buffer being rendered too, to the front for
display and provides information to any system compositor about
what regions of the buffer have changed (damage) with respect to
the last swapped buffer.

This function has the same semantics as
cogl_framebuffer_swap_buffers() except that it additionally allows
applications to pass a list of damaged rectangles which may be
passed on to a compositor so that it can minimize how much of the
screen is redrawn in response to this applications newly swapped
front buffer.

For example if your application is only animating a small object in
the corner of the screen and everything else is remaining static
then it can help the compositor to know that only the bottom right
corner of your newly swapped buffer has really changed with respect
to your previously swapped front buffer.

If @n_rectangles is 0 then the whole buffer will implicitly be
reported as damaged as if cogl_onscreen_swap_buffers() had been
called.

This function also implicitly discards the contents of the color,
depth and stencil buffers as if cogl_framebuffer_discard_buffers()
were used. The significance of the discard is that you should not
expect to be able to start a new frame that incrementally builds on
the contents of the previous frame. If you want to perform
incremental updates to older back buffers then please refer to the
cogl_onscreen_get_buffer_age() api.

Whenever possible it is recommended that applications use this
function instead of cogl_onscreen_swap_buffers() to improve
performance when running under a compositor.

&lt;note&gt;It is highly recommended to use this API in conjunction with
the cogl_onscreen_get_buffer_age() api so that your application can
perform incremental rendering based on old back buffers.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="243">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="244">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="246">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="3">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="swap_region" invoker="swap_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="310">Swaps a region of the back buffer being rendered too, to the front for
display.  @rectangles represents the region as array of @n_rectangles each
defined by 4 sequential (x, y, width, height) integers.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="312">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="313">An array of integer 4-tuples representing rectangles as
             (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="315">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="3">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_dirty_callback"
              c:identifier="cogl_onscreen_add_dirty_callback">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="520">Installs a @callback function that will be called whenever the
window system has lost the contents of a region of the onscreen
buffer and the application should redraw it to repair the buffer.
For example this may happen in a window system without a compositor
if a window that was previously covering up the onscreen window has
been moved causing a region of the onscreen to be exposed.

The @callback will be passed a #CoglOnscreenDirtyInfo struct which
describes a rectangle containing the newly dirtied region. Note that
this may be called multiple times to describe a non-rectangular
region composed of multiple smaller rectangles.

The dirty events are separate from %COGL_FRAME_EVENT_SYNC events so
the application should also listen for this event before rendering
the dirty region to ensure that the framebuffer is actually ready
for rendering.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="549"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="545">a #CoglOnscreenDirtyClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="OnscreenDirtyClosure"
                c:type="CoglOnscreenDirtyClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="522">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="523">A callback function to call for dirty events</doc>
            <type name="OnscreenDirtyCallback"
                  c:type="CoglOnscreenDirtyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="524">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="525">An optional callback to destroy @user_data when the
          @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_frame_callback"
              c:identifier="cogl_onscreen_add_frame_callback">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="408">Installs a @callback function that will be called for significant
events relating to the given @onscreen framebuffer.

The @callback will be used to notify when the system compositor is
ready for this application to render a new frame. In this case
%COGL_FRAME_EVENT_SYNC will be passed as the event argument to the
given @callback in addition to the #CoglFrameInfo corresponding to
the frame being acknowledged by the compositor.

The @callback will also be called to notify when the frame has
ended. In this case %COGL_FRAME_EVENT_COMPLETE will be passed as
the event argument to the given @callback in addition to the
#CoglFrameInfo corresponding to the newly presented frame.  The
meaning of "ended" here simply means that no more timing
information will be collected within the corresponding
#CoglFrameInfo and so this is a good opportunity to analyse the
given info. It does not necessarily mean that the GPU has finished
rendering the corresponding frame.

We highly recommend throttling your application according to
%COGL_FRAME_EVENT_SYNC events so that your application can avoid
wasting resources, drawing more frames than your system compositor
can display.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="444"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="440">a #CoglFrameClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="FrameClosure" c:type="CoglFrameClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="410">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="411">A callback function to call for frame events</doc>
            <type name="FrameCallback" c:type="CoglFrameCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="412">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="413">An optional callback to destroy @user_data
          when the @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_frame_info"
              c:identifier="cogl_onscreen_add_frame_info"
              introspectable="0">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="307"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="direct_scanout"
              c:identifier="cogl_onscreen_direct_scanout"
              introspectable="0"
              throws="1">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="297"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_age"
              c:identifier="cogl_onscreen_get_buffer_age">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="172">Gets the current age of the buffer contents.

This function allows applications to query the age of the current
back buffer contents for a #CoglOnscreen as the number of frames
elapsed since the contents were most recently defined.

These age values exposes enough information to applications about
how Cogl internally manages back buffers to allow applications to
re-use the contents of old frames and minimize how much must be
redrawn for the next frame.

The back buffer contents can either be reported as invalid (has an
age of 0) or it may be reported to be the same contents as from n
frames prior to the current frame.

The queried value remains valid until the next buffer swap.

&lt;note&gt;One caveat is that under X11 the buffer age does not reflect
changes to buffer contents caused by the window systems. X11
applications must track Expose events to determine what buffer
regions need to additionally be repaired each frame.&lt;/note&gt;

The recommended way to take advantage of this buffer age api is to
build up a circular buffer of length 3 for tracking damage regions
over the last 3 frames and when starting a new frame look at the
age of the buffer and combine the damage regions for the current
frame with the damage regions of previous @age frames so you know
everything that must be redrawn to update the old contents for the
new frame.

&lt;note&gt;If the system doesn't not support being able to track the age
of back buffers then this function will always return 0 which
implies that the contents are undefined.&lt;/note&gt;

&lt;note&gt;The %COGL_FEATURE_ID_BUFFER_AGE feature can optionally be
explicitly checked to determine if Cogl is currently tracking the
age of #CoglOnscreen back buffer contents. If this feature is
missing then this function will always return 0.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="219"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="215">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="174">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_counter"
              c:identifier="cogl_onscreen_get_frame_counter">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="571">Gets the value of the framebuffers frame counter. This is
a counter that increases by one each time
cogl_onscreen_swap_buffers() or cogl_onscreen_swap_region()
is called.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="582"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="579">the current frame counter value</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hide" c:identifier="cogl_onscreen_hide">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="126">This requests to make @onscreen invisible to the user.

Actually the precise semantics of this function depend on the
window system currently in use, and if you don't have a
multi-windowining system this function may in-fact do nothing.

This function does not implicitly allocate the given @onscreen
framebuffer before hiding it.

&lt;note&gt;Since Cogl doesn't explicitly track the visibility status of
onscreen framebuffers it won't try to avoid redundant window system
requests e.g. to show an already visible window. This also means
that it's acceptable to alternatively use native APIs to show and
hide windows without confusing Cogl.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="146"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="128">The onscreen framebuffer to make invisible</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="queue_damage_region"
              c:identifier="cogl_onscreen_queue_damage_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="221">Implementation for https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_partial_update.txt
This immediately queues state to OpenGL that will be used for the
next swap.
This needs to be called every frame.

The expected values are independent of any viewport transforms applied to
the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="237"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="223">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="224">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="226">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_dirty_callback"
              c:identifier="cogl_onscreen_remove_dirty_callback">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="554">Removes a callback and associated user data that were previously
registered using cogl_onscreen_add_dirty_callback().

If a destroy callback was passed to
cogl_onscreen_add_dirty_callback() to destroy the user data then
this will also get called.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="568"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="556">A #CoglOnscreen</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="557">A #CoglOnscreenDirtyClosure returned from
          cogl_onscreen_add_dirty_callback()</doc>
            <type name="OnscreenDirtyClosure"
                  c:type="CoglOnscreenDirtyClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_frame_callback"
              c:identifier="cogl_onscreen_remove_frame_callback">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="449">Removes a callback and associated user data that were previously
registered using cogl_onscreen_add_frame_callback().

If a destroy callback was passed to
cogl_onscreen_add_frame_callback() to destroy the user data then
this will get called.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="463"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="451">A #CoglOnscreen</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="452">A #CoglFrameClosure returned from
          cogl_onscreen_add_frame_callback()</doc>
            <type name="FrameClosure" c:type="CoglFrameClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="show" c:identifier="cogl_onscreen_show">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="98">This requests to make @onscreen visible to the user.

Actually the precise semantics of this function depend on the
window system currently in use, and if you don't have a
multi-windowining system this function may in-fact do nothing.

This function will implicitly allocate the given @onscreen
framebuffer before showing it if it hasn't already been allocated.

When using the Wayland winsys calling this will set the surface to
a toplevel type which will make it appear. If the application wants
to set a different type for the surface, it can avoid calling
cogl_onscreen_show() and set its own type directly with the Wayland
client API via cogl_wayland_onscreen_get_surface().

&lt;note&gt;Since Cogl doesn't explicitly track the visibility status of
onscreen framebuffers it won't try to avoid redundant window system
requests e.g. to show an already visible window. This also means
that it's acceptable to alternatively use native APIs to show and
hide windows without confusing Cogl.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="124"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="100">The onscreen framebuffer to make visible</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="swap_buffers" c:identifier="cogl_onscreen_swap_buffers">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="148">Swaps the current back buffer being rendered too, to the front for display.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.

&lt;note&gt;It is highly recommended that applications use
cogl_onscreen_swap_buffers_with_damage() instead whenever possible
and also use the cogl_onscreen_get_buffer_age() api so they can
perform incremental updates to older buffers instead of having to
render a full buffer for every frame.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="167"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="150">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="frame_info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_buffers_with_damage"
              c:identifier="cogl_onscreen_swap_buffers_with_damage">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="241">Swaps the current back buffer being rendered too, to the front for
display and provides information to any system compositor about
what regions of the buffer have changed (damage) with respect to
the last swapped buffer.

This function has the same semantics as
cogl_framebuffer_swap_buffers() except that it additionally allows
applications to pass a list of damaged rectangles which may be
passed on to a compositor so that it can minimize how much of the
screen is redrawn in response to this applications newly swapped
front buffer.

For example if your application is only animating a small object in
the corner of the screen and everything else is remaining static
then it can help the compositor to know that only the bottom right
corner of your newly swapped buffer has really changed with respect
to your previously swapped front buffer.

If @n_rectangles is 0 then the whole buffer will implicitly be
reported as damaged as if cogl_onscreen_swap_buffers() had been
called.

This function also implicitly discards the contents of the color,
depth and stencil buffers as if cogl_framebuffer_discard_buffers()
were used. The significance of the discard is that you should not
expect to be able to start a new frame that incrementally builds on
the contents of the previous frame. If you want to perform
incremental updates to older back buffers then please refer to the
cogl_onscreen_get_buffer_age() api.

Whenever possible it is recommended that applications use this
function instead of cogl_onscreen_swap_buffers() to improve
performance when running under a compositor.

&lt;note&gt;It is highly recommended to use this API in conjunction with
the cogl_onscreen_get_buffer_age() api so that your application can
perform incremental rendering based on old back buffers.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="287"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="243">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="244">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="246">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_region" c:identifier="cogl_onscreen_swap_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="310">Swaps a region of the back buffer being rendered too, to the front for
display.  @rectangles represents the region as array of @n_rectangles each
defined by 4 sequential (x, y, width, height) integers.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="328"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="312">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="313">An array of integer 4-tuples representing rectangles as
             (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="315">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Framebuffer" c:type="CoglFramebuffer"/>
      </field>
    </class>
    <record name="OnscreenClass"
            c:type="CoglOnscreenClass"
            glib:is-gtype-struct-for="Onscreen">
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="87"/>
      <field name="parent_class" readable="0" private="1">
        <type name="FramebufferClass" c:type="CoglFramebufferClass"/>
      </field>
      <field name="bind">
        <callback name="bind">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="62"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="swap_buffers_with_damage">
        <callback name="swap_buffers_with_damage">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="64"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="243">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="rectangles" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="244">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
              <type name="gint" c:type="const int*"/>
            </parameter>
            <parameter name="n_rectangles" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="246">The number of 4-tuples to be read from @rectangles</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FrameInfo" c:type="CoglFrameInfo*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="swap_region">
        <callback name="swap_region">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="70"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="312">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="rectangles" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="313">An array of integer 4-tuples representing rectangles as
             (x, y, width, height) tuples.</doc>
              <type name="gint" c:type="const int*"/>
            </parameter>
            <parameter name="n_rectangles" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="315">The number of 4-tuples to be read from @rectangles</doc>
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FrameInfo" c:type="CoglFrameInfo*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="queue_damage_region">
        <callback name="queue_damage_region">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="76"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="223">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="rectangles" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="224">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
              <type name="gint" c:type="const int*"/>
            </parameter>
            <parameter name="n_rectangles" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="226">The number of 4-tuples to be read from @rectangles</doc>
              <type name="gint" c:type="int"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="direct_scanout">
        <callback name="direct_scanout" throws="1">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="80"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="scanout" transfer-ownership="none">
              <type name="Scanout" c:type="CoglScanout*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FrameInfo" c:type="CoglFrameInfo*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_buffer_age">
        <callback name="get_buffer_age">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="86"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="215">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="174">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <callback name="OnscreenDirtyCallback" c:type="CoglOnscreenDirtyCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="485">Is a callback that can be registered via
cogl_onscreen_add_dirty_callback() to be called when the windowing
system determines that a region of the onscreen window has been
lost and the application should redraw it.</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="498"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="487">The onscreen that the frame is associated with</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="488">A #CoglOnscreenDirtyInfo struct containing the details of the
  dirty area</doc>
          <type name="OnscreenDirtyInfo"
                c:type="const CoglOnscreenDirtyInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="490">The user pointer passed to
            cogl_onscreen_add_frame_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OnscreenDirtyClosure"
            c:type="CoglOnscreenDirtyClosure"
            glib:type-name="CoglOnscreenDirtyClosure"
            glib:get-type="cogl_onscreen_dirty_closure_get_gtype"
            c:symbol-prefix="onscreen_dirty_closure">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="502">An opaque type that tracks a #CoglOnscreenDirtyCallback and associated
user data. A #CoglOnscreenDirtyClosure pointer will be returned from
cogl_onscreen_add_dirty_callback() and it allows you to remove a
callback later using cogl_onscreen_remove_dirty_callback().</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="510"/>
    </record>
    <record name="OnscreenDirtyInfo" c:type="CoglOnscreenDirtyInfo">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="466">A structure passed to callbacks registered using
cogl_onscreen_add_dirty_callback(). The members describe a
rectangle within the onscreen buffer that should be redrawn.</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="483"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="468">Left edge of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="469">Top edge of the dirty rectangle, measured from the top of the window</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="470">Width of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="471">Height of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <function-macro name="PIPELINE"
                    c:identifier="COGL_PIPELINE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pipeline.h" line="64"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PIXEL_FORMAT_CAN_HAVE_PREMULT"
                    c:identifier="COGL_PIXEL_FORMAT_CAN_HAVE_PREMULT"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="333"/>
      <parameters>
        <parameter name="format">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="PIXEL_FORMAT_MAX_PLANES"
              value="4"
              c:type="COGL_PIXEL_FORMAT_MAX_PLANES">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="275">The maximum number of planes of a pixel format (see also
cogl_pixel_format_get_planes()).</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="281"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PREMULT_BIT" value="128" c:type="COGL_PREMULT_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="66"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PRIMITIVE_TEXTURE"
                    c:identifier="COGL_PRIMITIVE_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl/cogl/deprecated/cogl-type-casts.h"
                       line="50"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PRIVATE"
                    c:identifier="COGL_PRIVATE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-types.h" line="62"/>
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Pipeline"
           c:symbol-prefix="pipeline"
           c:type="CoglPipeline"
           parent="Object"
           glib:type-name="CoglPipeline"
           glib:get-type="cogl_pipeline_get_gtype"
           glib:fundamental="1">
      <constructor name="new" c:identifier="cogl_pipeline_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="74">Allocates and initializes a default simple pipeline that will color
a primitive white.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="84"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="81">a pointer to a new #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="76">a #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_layer_snippet"
              c:identifier="cogl_pipeline_add_layer_snippet">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="476">Adds a shader snippet that will hook on to the given layer of the
pipeline. The exact part of the pipeline that the snippet wraps
around depends on the hook that is given to
cogl_snippet_new(). Note that some hooks can't be used with a layer
and need to be added with cogl_pipeline_add_snippet() instead.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="489"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="478">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="479">The layer to hook the snippet to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="480">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_snippet" c:identifier="cogl_pipeline_add_snippet">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="654">Adds a shader snippet to @pipeline. The snippet will wrap around or
replace some part of the pipeline as defined by the hook point in
@snippet. Note that some hook points are specific to a layer and
must be added with cogl_pipeline_add_layer_snippet() instead.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="665"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="656">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="657">The #CoglSnippet to add to the vertex processing hook</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="cogl_pipeline_copy">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="86">Creates a new pipeline with the configuration copied from the
source pipeline.

We would strongly advise developers to always aim to use
cogl_pipeline_copy() instead of cogl_pipeline_new() whenever there will
be any similarity between two pipelines. Copying a pipeline helps Cogl
keep track of a pipelines ancestry which we may use to help minimize GPU
state changes.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="102"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="99">a pointer to the newly allocated #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="88">a #CoglPipeline object to copy</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_layer" c:identifier="cogl_pipeline_foreach_layer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="129">Iterates all the layer indices of the given @pipeline.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="140"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="131">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="132">A #CoglPipelineLayerCallback to be
           called for each layer index</doc>
            <type name="PipelineLayerCallback"
                  c:type="CoglPipelineLayerCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="134">Private data that will be passed to the
            callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_function"
              c:identifier="cogl_pipeline_get_alpha_test_function">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="172"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="169">The alpha test function of @pipeline.</doc>
          <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="167">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_reference"
              c:identifier="cogl_pipeline_get_alpha_test_reference">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="181"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="178">The alpha test reference value of @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="176">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color" c:identifier="cogl_pipeline_get_color">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="99">Retrieves the current pipeline color.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="107"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="101">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="102">The location to store the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cull_face_mode"
              c:identifier="cogl_pipeline_get_cull_face_mode">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="483"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="479">the cull face mode that was previously set with
cogl_pipeline_set_cull_face_mode().</doc>
          <type name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_state"
              c:identifier="cogl_pipeline_get_depth_state"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="423">Retrieves the current depth state configuration for the given
@pipeline as previously set using cogl_pipeline_set_depth_state().</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="432"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="425">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state_out"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="426">A destination #CoglDepthState struct</doc>
            <type c:type="CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_front_face_winding"
              c:identifier="cogl_pipeline_get_front_face_winding">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="502">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="517"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="514">The @pipeline front face winding</doc>
          <type name="Winding" c:type="CoglWinding"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="504">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_layer_filters"
              c:identifier="cogl_pipeline_get_layer_filters">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="329">Returns the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="340"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="331">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="332">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="333">Return location for the filter used when scaling a texture down.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter*"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="334">Return location for the filter used when magnifying a texture.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_get_layer_point_sprite_coords_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="388">Gets whether point sprite coordinate generation is enabled for this
texture layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="400"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="396">whether the texture coordinates will be replaced with
point sprite coordinates.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="390">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="391">the layer number to check.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_texture"
              c:identifier="cogl_pipeline_get_layer_texture">
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="178"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="174">the texture that was set for the
  given layer of the pipeline or %NULL if no texture was set.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="171">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="172">the index of the layer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_s">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="403">Returns the wrap mode for the 's' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="415"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="411">the wrap mode for the 's' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="405">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="406">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_t">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="431">Returns the wrap mode for the 't' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="443"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="439">the wrap mode for the 't' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="433">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="434">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_layers" c:identifier="cogl_pipeline_get_n_layers">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="318">Retrieves the number of layers defined for the given @pipeline</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="327"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="324">the number of layers</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="320">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_per_vertex_point_size"
              c:identifier="cogl_pipeline_get_per_vertex_point_size">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="344"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="339">%TRUE if the pipeline has per-vertex point size
  enabled or %FALSE otherwise. The per-vertex point size can be
  enabled with cogl_pipeline_set_per_vertex_point_size().</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="338">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point_size"
              c:identifier="cogl_pipeline_get_point_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="301">Get the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="311"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="308">the point size of the @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="303">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uniform_location"
              c:identifier="cogl_pipeline_get_uniform_location">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="144">This is used to get an integer representing the uniform with the
name @uniform_name. The integer can be passed to functions such as
cogl_pipeline_set_uniform_1f() to set the value of a uniform.

This function will always return a valid integer. Ie, unlike
OpenGL, it does not return -1 if the uniform is not available in
this pipeline so it can not be used to test whether uniforms are
present. It is not necessary to set the program on the pipeline
before calling this function.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="162"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="159">A integer representing the location of the given uniform.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="146">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="147">The name of a uniform</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_program"
              c:identifier="cogl_pipeline_get_user_program">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="346">Queries what user program has been associated with the given
@pipeline using cogl_pipeline_set_user_program().</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="356"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="353">The current user program or %NULL.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="348">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_layer" c:identifier="cogl_pipeline_remove_layer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="181">This function removes a layer from your pipeline</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="189"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="183">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="184">Specifies the layer you want to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_test_function"
              c:identifier="cogl_pipeline_set_alpha_test_function">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="145">Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.

The default is %COGL_PIPELINE_ALPHA_FUNC_ALWAYS</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="161"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="147">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="alpha_func" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="148">A @CoglPipelineAlphaFunc constant</doc>
            <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
          </parameter>
          <parameter name="alpha_reference" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="149">A reference point that the chosen alpha function uses
  to compare incoming fragments to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend"
              c:identifier="cogl_pipeline_set_blend"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="183">If not already familiar; please refer &lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt;
for an overview of what blend strings are, and their syntax.

Blending occurs after the alpha test function, and combines fragments with
the framebuffer.

Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:

|[
  &amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
]|

This is the list of source-names usable as blend factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;SRC_COLOR: The color of the incoming fragment&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;DST_COLOR: The color of the framebuffer&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;CONSTANT: The constant set via cogl_pipeline_set_blend_constant()&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The source names can be used according to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source and factor syntax&lt;/link&gt;,
so for example "(1-SRC_COLOR[A])" would be a valid factor, as would
"(CONSTANT[RGB])"

These can also be used as factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;0: (0, 0, 0, 0)&lt;/listitem&gt;
  &lt;listitem&gt;1: (1, 1, 1, 1)&lt;/listitem&gt;
  &lt;listitem&gt;SRC_ALPHA_SATURATE_FACTOR: (f,f,f,1) where f = MIN(SRC_COLOR[A],1-DST_COLOR[A])&lt;/listitem&gt;
&lt;/itemizedlist&gt;

&lt;note&gt;Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.&lt;/note&gt;

&lt;example id="cogl-Blend-Strings-blend-unpremul"&gt;
  &lt;title&gt;Blend Strings/1&lt;/title&gt;
  &lt;para&gt;Blend a non-premultiplied source over a destination with
  premultiplied alpha:&lt;/para&gt;
  &lt;programlisting&gt;
"RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
"A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

&lt;example id="cogl-Blend-Strings-blend-premul"&gt;
  &lt;title&gt;Blend Strings/2&lt;/title&gt;
  &lt;para&gt;Blend a premultiplied source over a destination with
  premultiplied alpha&lt;/para&gt;
  &lt;programlisting&gt;
"RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

The default blend string is:
|[
   RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
]|

That gives normal alpha-blending when the calculated color for the pipeline
is in premultiplied form.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="263"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="257">%TRUE if the blend string was successfully parsed, and the
  described blending is supported by the underlying driver/hardware. If
  there was an error, %FALSE is returned and @error is set accordingly (if
  present).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="185">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="186">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
  describing the desired blend function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend_constant"
              c:identifier="cogl_pipeline_set_blend_constant">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="267">When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="276"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="269">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="constant_color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="270">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color" c:identifier="cogl_pipeline_set_color">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="43">Sets the basic color of the pipeline, used when no lighting is enabled.

Note that if you don't add any layers to the pipeline then the color
will be blended unmodified with the destination; the default blend
expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
semi-transparent red. See cogl_color_premultiply().

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="58"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="45">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="46">The components of the color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4f" c:identifier="cogl_pipeline_set_color4f">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="80">Sets the basic color of the pipeline, used when no lighting is enabled.

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="93"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="82">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="83">The red component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="84">The green component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="85">The blue component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="86">The alpha component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4ub" c:identifier="cogl_pipeline_set_color4ub">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="61">Sets the basic color of the pipeline, used when no lighting is enabled.

The default value is (0xff, 0xff, 0xff, 0xff)</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="74"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="63">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="64">The red component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="65">The green component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="66">The blue component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="67">The alpha component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cull_face_mode"
              c:identifier="cogl_pipeline_set_cull_face_mode">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="454">Sets which faces will be culled when drawing. Face culling can be
used to increase efficiency by avoiding drawing faces that would
get overridden. For example, if a model has gaps so that it is
impossible to see the inside then faces which are facing away from
the screen will never be seen so there is no point in drawing
them. This can be achieved by setting the cull face mode to
%COGL_PIPELINE_CULL_FACE_MODE_BACK.

Face culling relies on the primitives being drawn with a specific
order to represent which faces are facing inside and outside the
model. This order can be specified by calling
cogl_pipeline_set_front_face_winding().</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="473"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="456">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="cull_face_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="457">The new mode to set</doc>
            <type name="PipelineCullFaceMode"
                  c:type="CoglPipelineCullFaceMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_state"
              c:identifier="cogl_pipeline_set_depth_state"
              introspectable="0"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="401">This commits all the depth state configured in @state struct to the
given @pipeline. The configuration values are copied into the
pipeline so there is no requirement to keep the #CoglDepthState
struct around if you don't need it any more.

Note: Since some platforms do not support the depth range feature
it is possible for this function to fail and report an @error.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="419"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="415">TRUE if the GPU supports all the given @state else %FALSE
         and returns an @error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="403">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="404">A #CoglDepthState struct</doc>
            <type c:type="const CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_front_face_winding"
              c:identifier="cogl_pipeline_set_front_face_winding">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="485">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="499"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="487">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="front_winding" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="488">the winding order</doc>
            <type name="Winding" c:type="CoglWinding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine"
              c:identifier="cogl_pipeline_set_layer_combine"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="192">If not already familiar; you can refer
&lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt; for an overview of what blend
strings are and there syntax.

These are all the functions available for texture combining:
&lt;itemizedlist&gt;
  &lt;listitem&gt;REPLACE(arg0) = arg0&lt;/listitem&gt;
  &lt;listitem&gt;MODULATE(arg0, arg1) = arg0 x arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD(arg0, arg1) = arg0 + arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5&lt;/listitem&gt;
  &lt;listitem&gt;INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)&lt;/listitem&gt;
  &lt;listitem&gt;SUBTRACT(arg0, arg1) = arg0 - arg1&lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                             (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                             (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                              (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                              (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;

Refer to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source syntax&lt;/link&gt; for
describing the arguments. The valid source names for texture combining
are:
&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE&lt;/term&gt;
    &lt;listitem&gt;Use the color from the current texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE_0, TEXTURE_1, etc&lt;/term&gt;
    &lt;listitem&gt;Use the color from the specified texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;CONSTANT&lt;/term&gt;
    &lt;listitem&gt;Use the color from the constant given with
    cogl_pipeline_set_layer_combine_constant()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PRIMARY&lt;/term&gt;
    &lt;listitem&gt;Use the color of the pipeline as set with
    cogl_pipeline_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PREVIOUS&lt;/term&gt;
    &lt;listitem&gt;Either use the texture color from the previous layer, or
    if this is layer 0, use the color of the pipeline as set with
    cogl_pipeline_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

&lt;refsect2 id="cogl-Layer-Combine-Examples"&gt;
  &lt;title&gt;Layer Combine Examples&lt;/title&gt;
  &lt;para&gt;This is effectively what the default blending is:&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = MODULATE (PREVIOUS, TEXTURE)
  &lt;/programlisting&gt;&lt;/informalexample&gt;
  &lt;para&gt;This could be used to cross-fade between two images, using
  the alpha component of a constant as the interpolator. The constant
  color is given by calling
  cogl_pipeline_set_layer_combine_constant().&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
  &lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;/refsect2&gt;

&lt;note&gt;You can't give a multiplication factor for arguments as you can
with blending.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="284"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="279">%TRUE if the blend string was successfully parsed, and the
  described texture combining is supported by the underlying driver and
  or hardware. On failure, %FALSE is returned and @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="194">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="195">Specifies the layer you want define a combine function for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="196">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
   describing the desired texture combine function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine_constant"
              c:identifier="cogl_pipeline_set_layer_combine_constant">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="289">When you are using the 'CONSTANT' color source in a layer combine
description then you can use this function to define its value.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="300"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="291">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="292">Specifies the layer you want to specify a constant used
              for texture combining</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="294">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_filters"
              c:identifier="cogl_pipeline_set_layer_filters">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="345">Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.

&lt;note&gt;It is an error to pass anything other than
%COGL_PIPELINE_FILTER_NEAREST or %COGL_PIPELINE_FILTER_LINEAR as
magnification filters since magnification doesn't ever need to
reference values stored in the mipmap chain.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="361"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="347">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="348">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="349">the filter used when scaling a texture down.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="350">the filter used when magnifying a texture.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_matrix"
              c:identifier="cogl_pipeline_set_layer_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="304">This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a pipeline used to fill your geometry.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="314"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="306">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="307">the index for the layer inside @pipeline</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="308">the transformation matrix for the layer</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_max_mipmap_level"
              c:identifier="cogl_pipeline_set_layer_max_mipmap_level">
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="494"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_level" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_null_texture"
              c:identifier="cogl_pipeline_set_layer_null_texture">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="151">Sets the texture for this layer to be the default texture for the
given type. The default texture is a 1x1 pixel white texture.

This function is mostly useful if you want to create a base
pipeline that you want to create multiple copies from using
cogl_pipeline_copy(). In that case this function can be used to
specify the texture type so that any pipeline copies can share the
internal texture type state for efficiency.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="166"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="153">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="154">The layer number to modify</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_set_layer_point_sprite_coords_enabled"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="366">When rendering points, if @enable is %TRUE then the texture
coordinates for this layer will be replaced with coordinates that
vary from 0.0 to 1.0 across the primitive. The top left of the
point will have the coordinates 0.0,0.0 and the bottom right will
have 1.0,1.0. If @enable is %FALSE then the coordinates will be
fixed for the entire point.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="383"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="380">%TRUE if the function succeeds, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="368">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="369">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="370">whether to enable point sprite coord generation.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_texture"
              c:identifier="cogl_pipeline_set_layer_texture">
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="147"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode"
              c:identifier="cogl_pipeline_set_layer_wrap_mode">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="460">Sets the wrap mode for all three coordinates of texture lookups on
this layer. This is equivalent to calling
cogl_pipeline_set_layer_wrap_mode_s() and
cogl_pipeline_set_layer_wrap_mode_t() separately.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="472"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="462">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="463">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="464">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_s">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="418">Sets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="427"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="420">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="421">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="422">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_t">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="447">Sets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="456"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="449">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="450">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="451">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_per_vertex_point_size"
              c:identifier="cogl_pipeline_set_per_vertex_point_size"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="313">Sets whether to use a per-vertex point size or to use the value set
by cogl_pipeline_set_point_size(). If per-vertex point size is
enabled then the point size can be set for an individual point
either by drawing with a #CoglAttribute with the name
cogl_point_size_in or by writing to the GLSL builtin
cogl_point_size_out from a vertex shader snippet.

If per-vertex point size is enabled and this attribute is not used
and cogl_point_size_out is not written to then the results are
undefined.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="332"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="329">%TRUE if the change succeeded or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="315">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="316">whether to enable per-vertex point size</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_point_size"
              c:identifier="cogl_pipeline_set_point_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="279">Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the attribute buffer API. Note that typically the GPU
will only support a limited minimum and maximum range of point
sizes. If the chosen point size is outside that range then the
nearest value within that range will be used instead. The size of a
point is in screen space so it will be the same regardless of any
transformations.

If the point size is set to 0.0 then drawing points with the
pipeline will have undefined results. This is the default value so
if an application wants to draw points it must make sure to use a
pipeline that has an explicit point size set on it.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="298"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="281">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="point_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="282">the new point size.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1f"
              c:identifier="cogl_pipeline_set_uniform_1f">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="519">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
float. It can also be used to set a single member of a float array
uniform.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="537"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="521">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="522">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="523">The new value for the uniform</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1i"
              c:identifier="cogl_pipeline_set_uniform_1i">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="541">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
int. It can also be used to set a single member of a int array
uniform or a sampler uniform.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="559"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="543">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="544">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="545">The new value for the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_float"
              c:identifier="cogl_pipeline_set_uniform_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="563">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any floating point type uniform,
including float arrays and float vectors. For example, to set a
single vec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 float values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="585"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="565">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="566">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="567">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="568">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="569">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_int"
              c:identifier="cogl_pipeline_set_uniform_int">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="591">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any integer type uniform,
including int arrays and int vectors. For example, to set a single
ivec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 int values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="613"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="593">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="594">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="595">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="596">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="597">Pointer to the new values to set</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix"
              c:identifier="cogl_pipeline_set_uniform_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="619">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any matrix type uniform, including
matrix arrays. For example, to set a single mat4 uniform you would
use 4 for @dimensions and 1 for @count. To set an array of 8
mat3 values, you could use 3 for @dimensions and 8 for @count.

If @transpose is %FALSE then the matrix is expected to be in
column-major order or if it is %TRUE then the matrix is in
row-major order. You can pass a #graphene_matrix_t by calling by passing
the result of graphene_matrix_to_float() in @value and setting
@transpose to %FALSE.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="647"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="621">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="622">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dimensions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="623">The size of the matrix</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="624">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="625">Whether to transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="626">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_program"
              c:identifier="cogl_pipeline_set_user_program">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="358">Associates a linked CoglProgram with the given pipeline so that the
program can take full control of vertex and/or fragment processing.

This is an example of how it can be used to associate an ARBfp
program with a #CoglPipeline:
|[
CoglHandle shader;
CoglHandle program;
CoglPipeline *pipeline;

shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
cogl_shader_source (shader,
                    "!!ARBfp1.0\n"
                    "MOV result.color,fragment.color;\n"
                    "END\n");

program = cogl_create_program ();
cogl_program_attach_shader (program, shader);
cogl_program_link (program);

pipeline = cogl_pipeline_new ();
cogl_pipeline_set_user_program (pipeline, program);

cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
cogl_rectangle (0, 0, 100, 100);
]|

It is possibly worth keeping in mind that this API is not part of
the long term design for how we want to expose shaders to Cogl
developers (We are planning on deprecating the cogl_program and
cogl_shader APIs in favour of a "snippet" framework) but in the
meantime we hope this will handle most practical GLSL and ARBfp
requirements.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="398"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="360">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="361">A #CoglHandle to a linked CoglProgram</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-state.h"
           line="110">Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglPipelineAlphaFunc
determines how the comparison is done.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="142"/>
      <member name="never"
              value="512"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NEVER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="112">Never let the fragment through.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LESS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="113">Let the fragment through if the incoming
  alpha value is less than the reference alpha value</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_EQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="115">Let the fragment through if the incoming
  alpha value equals the reference alpha value</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="117">Let the fragment through if the incoming
  alpha value is less than or equal to the reference alpha value</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GREATER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="119">Let the fragment through if the incoming
  alpha value is greater than the reference alpha value</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NOTEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="121">Let the fragment through if the incoming
  alpha value does not equal the reference alpha value</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="123">Let the fragment through if the incoming
  alpha value is greater than or equal to the reference alpha value.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_ALWAYS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="125">Always let the fragment through.</doc>
      </member>
    </enumeration>
    <enumeration name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-state.h"
           line="435">Specifies which faces should be culled. This can be set on a
pipeline using cogl_pipeline_set_cull_face_mode().</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="452"/>
      <member name="none"
              value="0"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_NONE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="437">Neither face will be
 culled. This is the default.</doc>
      </member>
      <member name="front"
              value="1"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_FRONT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="439">Front faces will be culled.</doc>
      </member>
      <member name="back"
              value="2"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BACK">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="440">Back faces will be culled.</doc>
      </member>
      <member name="both"
              value="3"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BOTH">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="441">All faces will be culled.</doc>
      </member>
    </enumeration>
    <enumeration name="PipelineFilter" c:type="CoglPipelineFilter">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-layer-state.h"
           line="43">Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                       line="78"/>
      <member name="nearest"
              value="9728"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="45">Measuring in manhatten distance from the,
  current pixel center, use the nearest texture texel</doc>
      </member>
      <member name="linear"
              value="9729"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="47">Use the weighted average of the 4 texels
  nearest the current pixel center</doc>
      </member>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="49">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_NEAREST criterion</doc>
      </member>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="52">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_LINEAR criterion</doc>
      </member>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="55">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_NEAREST criterion on each one and take
  their weighted average</doc>
      </member>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="59">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_LINEAR criterion on each one and take
  their weighted average</doc>
      </member>
    </enumeration>
    <callback name="PipelineLayerCallback" c:type="CoglPipelineLayerCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline.h"
           line="116">The callback prototype used with cogl_pipeline_foreach_layer() for
iterating all the layers of a @pipeline.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline.h" line="125"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pipeline" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="118">The #CoglPipeline whose layers are being iterated</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="119">The current layer index</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="120">The private data passed to cogl_pipeline_foreach_layer()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="PipelineWrapMode" c:type="CoglPipelineWrapMode">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-layer-state.h"
           line="81">The wrap mode specifies what happens when texture coordinates
outside the range 01 are used. Note that if the filter mode is
anything but %COGL_PIPELINE_FILTER_NEAREST then texels outside the
range 01 might be used even when the coordinate is exactly 0 or 1
because OpenGL will try to sample neighbouring pixels. For example
if you are trying to render the full texture then you may get
artifacts around the edges when the pixels from the other side are
merged in if the wrap mode is set to repeat.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                       line="119"/>
      <member name="repeat"
              value="10497"
              c:identifier="COGL_PIPELINE_WRAP_MODE_REPEAT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="83">The texture will be repeated. This
  is useful for example to draw a tiled background.</doc>
      </member>
      <member name="mirrored_repeat"
              value="33648"
              c:identifier="COGL_PIPELINE_WRAP_MODE_MIRRORED_REPEAT">
      </member>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="85">The coordinates outside the
  range 01 will sample copies of the edge pixels of the
  texture. This is useful to avoid artifacts if only one copy of
  the texture is being rendered.</doc>
      </member>
      <member name="automatic"
              value="519"
              c:identifier="COGL_PIPELINE_WRAP_MODE_AUTOMATIC">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="89">Cogl will try to automatically
  decide which of the above two to use. For cogl_rectangle(), it
  will use repeat mode if any of the texture coordinates are
  outside the range 01, otherwise it will use clamp to edge. For
  cogl_polygon() it will always use repeat mode. For
  cogl_vertex_buffer_draw() it will use repeat mode except for
  layers that have point sprite coordinate generation enabled. This
  is the default value.</doc>
      </member>
    </enumeration>
    <bitfield name="PixelFormat" c:type="CoglPixelFormat">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="139">Pixel formats used by Cogl. For the formats with a byte per
component, the order of the components specify the order in
increasing memory addresses. So for example
%COGL_PIXEL_FORMAT_RGB_888 would have the red component in the
lowest address, green in the next address and blue after that
regardless of the endianness of the system.

For the formats with non byte aligned components the component
order specifies the order within a 16-bit or 32-bit number from
most significant bit to least significant. So for
%COGL_PIXEL_FORMAT_RGB_565, the red component would be in bits
11-15, the green component would be in 6-11 and the blue component
would be in 1-5. Therefore the order in memory depends on the
endianness of the system.

When uploading a texture %COGL_PIXEL_FORMAT_ANY can be used as the
internal format. Cogl will try to pick the best format to use
internally and convert the texture data if necessary.</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="273"/>
      <member name="any" value="0" c:identifier="COGL_PIXEL_FORMAT_ANY">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="141">Any format</doc>
      </member>
      <member name="a_8" value="17" c:identifier="COGL_PIXEL_FORMAT_A_8">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="142">8 bits alpha mask</doc>
      </member>
      <member name="rgb_565"
              value="4"
              c:identifier="COGL_PIXEL_FORMAT_RGB_565">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="147">RGB, 16 bits</doc>
      </member>
      <member name="rgba_4444"
              value="21"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="148">RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551"
              value="22"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="149">RGBA, 16 bits</doc>
      </member>
      <member name="yuv" value="7" c:identifier="COGL_PIXEL_FORMAT_YUV">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="150">Not currently supported</doc>
      </member>
      <member name="g_8" value="8" c:identifier="COGL_PIXEL_FORMAT_G_8">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="151">Single luminance component</doc>
      </member>
      <member name="g_16" value="14" c:identifier="COGL_PIXEL_FORMAT_G_16">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="152">Single luminance component, 16 bits</doc>
      </member>
      <member name="rg_88" value="9" c:identifier="COGL_PIXEL_FORMAT_RG_88">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="143">RG, 16 bits. Note that red-green textures
  are only available if %COGL_FEATURE_ID_TEXTURE_RG is advertised.
  See cogl_texture_set_components() for details.</doc>
      </member>
      <member name="rg_1616"
              value="15"
              c:identifier="COGL_PIXEL_FORMAT_RG_1616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="146">RG, 32 bits</doc>
      </member>
      <member name="rgb_888"
              value="2"
              c:identifier="COGL_PIXEL_FORMAT_RGB_888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="153">RGB, 24 bits</doc>
      </member>
      <member name="bgr_888"
              value="34"
              c:identifier="COGL_PIXEL_FORMAT_BGR_888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="154">BGR, 24 bits</doc>
      </member>
      <member name="rgbx_8888"
              value="3"
              c:identifier="COGL_PIXEL_FORMAT_RGBX_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="155">RGBX, 32 bits</doc>
      </member>
      <member name="rgba_8888"
              value="19"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="156">RGBA, 32 bits</doc>
      </member>
      <member name="bgrx_8888"
              value="35"
              c:identifier="COGL_PIXEL_FORMAT_BGRX_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="157">BGRX, 32 bits</doc>
      </member>
      <member name="bgra_8888"
              value="51"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="158">BGRA, 32 bits</doc>
      </member>
      <member name="xrgb_8888"
              value="67"
              c:identifier="COGL_PIXEL_FORMAT_XRGB_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="159">XRGB, 32 bits</doc>
      </member>
      <member name="argb_8888"
              value="83"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="160">ARGB, 32 bits</doc>
      </member>
      <member name="xbgr_8888"
              value="99"
              c:identifier="COGL_PIXEL_FORMAT_XBGR_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="161">XBGR, 32 bits</doc>
      </member>
      <member name="abgr_8888"
              value="115"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="162">ABGR, 32 bits</doc>
      </member>
      <member name="rgba_1010102"
              value="29"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="163">RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102"
              value="61"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="164">BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="xrgb_2101010"
              value="77"
              c:identifier="COGL_PIXEL_FORMAT_XRGB_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="165">XRGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010"
              value="93"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="166">ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="xbgr_2101010"
              value="109"
              c:identifier="COGL_PIXEL_FORMAT_XBGR_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="167">XBGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010"
              value="125"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="168">ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="rgbx_fp_16161616"
              value="11"
              c:identifier="COGL_PIXEL_FORMAT_RGBX_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="179">RGBX half floating point, 64 bit</doc>
      </member>
      <member name="rgba_fp_16161616"
              value="27"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="180">RGBA half floating point, 64 bit</doc>
      </member>
      <member name="bgrx_fp_16161616"
              value="43"
              c:identifier="COGL_PIXEL_FORMAT_BGRX_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="181">BGRX half floating point, 64 bit</doc>
      </member>
      <member name="bgra_fp_16161616"
              value="59"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="182">BGRA half floating point, 64 bit</doc>
      </member>
      <member name="xrgb_fp_16161616"
              value="75"
              c:identifier="COGL_PIXEL_FORMAT_XRGB_FP_16161616">
      </member>
      <member name="argb_fp_16161616"
              value="91"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="183">ARGB half floating point, 64 bit</doc>
      </member>
      <member name="xbgr_fp_16161616"
              value="107"
              c:identifier="COGL_PIXEL_FORMAT_XBGR_FP_16161616">
      </member>
      <member name="abgr_fp_16161616"
              value="123"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="184">ABGR half floating point, 64 bit</doc>
      </member>
      <member name="rgba_8888_pre"
              value="147"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="169">Premultiplied RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888_pre"
              value="179"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="170">Premultiplied BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888_pre"
              value="211"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="171">Premultiplied ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888_pre"
              value="243"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="172">Premultiplied ABGR, 32 bits</doc>
      </member>
      <member name="rgba_4444_pre"
              value="149"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="173">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551_pre"
              value="150"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="174">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_1010102_pre"
              value="157"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="175">Premultiplied RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102_pre"
              value="189"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="176">Premultiplied BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010_pre"
              value="221"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="177">Premultiplied ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010_pre"
              value="253"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="178">Premultiplied ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="rgba_fp_16161616_pre"
              value="155"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="185">Premultiplied RGBA half floating point, 64 bit</doc>
      </member>
      <member name="bgra_fp_16161616_pre"
              value="187"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="186">Premultiplied BGRA half floating point, 64 bit</doc>
      </member>
      <member name="argb_fp_16161616_pre"
              value="219"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="187">Premultiplied ARGB half floating point, 64 bit</doc>
      </member>
      <member name="abgr_fp_16161616_pre"
              value="251"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="188">Premultiplied ABGR half floating point, 64 bit</doc>
      </member>
      <member name="depth_16"
              value="265"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_16">
      </member>
      <member name="depth_32"
              value="259"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_32">
      </member>
      <member name="depth_24_stencil_8"
              value="771"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8">
      </member>
    </bitfield>
    <bitfield name="ReadPixelsFlags" c:type="CoglReadPixelsFlags">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="444">Flags for cogl_framebuffer_read_pixels_into_bitmap()</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="453"/>
      <member name="read_pixels_color_buffer"
              value="1"
              c:identifier="COGL_READ_PIXELS_COLOR_BUFFER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="446">Read from the color buffer</doc>
      </member>
    </bitfield>
    <enumeration name="RendererError" c:type="CoglRendererError">
      <source-position filename="cogl/cogl/cogl-types.h" line="360"/>
      <member name="xlib_display_open"
              value="0"
              c:identifier="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN">
      </member>
      <member name="bad_constraint"
              value="1"
              c:identifier="COGL_RENDERER_ERROR_BAD_CONSTRAINT">
      </member>
    </enumeration>
    <function-macro name="SNIPPET"
                    c:identifier="COGL_SNIPPET"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-snippet.h" line="340"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="STENCIL_BIT" value="512" c:type="COGL_STENCIL_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="68"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="STRUCT_SIZE_ASSERT"
                    c:identifier="COGL_STRUCT_SIZE_ASSERT"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-types.h" line="71"/>
      <parameters>
        <parameter name="TYPE">
        </parameter>
        <parameter name="SIZE">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Scanout" c:type="CoglScanout" disguised="1" opaque="1">
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="49"/>
      <function name="error_quark" c:identifier="cogl_scanout_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </record>
    <enumeration name="ScanoutError"
                 c:type="CoglScanoutError"
                 glib:error-domain="cogl-scanout-error-quark">
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="96"/>
      <member name="scanout_error_inhibited"
              value="0"
              c:identifier="COGL_SCANOUT_ERROR_INHIBITED">
      </member>
    </enumeration>
    <enumeration name="ShaderType" c:type="CoglShaderType">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="222">Types of shaders</doc>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="233"/>
      <member name="vertex" value="0" c:identifier="COGL_SHADER_TYPE_VERTEX">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="224">A program for processing vertices</doc>
      </member>
      <member name="fragment"
              value="1"
              c:identifier="COGL_SHADER_TYPE_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="225">A program for processing fragments</doc>
      </member>
    </enumeration>
    <class name="Snippet"
           c:symbol-prefix="snippet"
           c:type="CoglSnippet"
           parent="Object"
           glib:type-name="CoglSnippet"
           glib:get-type="cogl_snippet_get_gtype"
           glib:fundamental="1">
      <constructor name="new" c:identifier="cogl_snippet_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="674">Allocates and initializes a new snippet with the given source strings.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="688"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="685">a pointer to a new #CoglSnippet</doc>
          <type name="Snippet" c:type="CoglSnippet*"/>
        </return-value>
        <parameters>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="676">The point in the pipeline that this snippet will wrap around
  or replace.</doc>
            <type name="SnippetHook" c:type="CoglSnippetHook"/>
          </parameter>
          <parameter name="declarations"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="678">The source code for the declarations for this
  snippet or %NULL. See cogl_snippet_set_declarations().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="post"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="680">The source code to run after the hook point where this
  shader snippet is attached or %NULL. See cogl_snippet_set_post().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_declarations"
              c:identifier="cogl_snippet_get_declarations">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="741"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="737">the source string that was set with
  cogl_snippet_set_declarations() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="735">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hook" c:identifier="cogl_snippet_get_hook">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="700"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="696">the hook that was set when cogl_snippet_new()
  was called.</doc>
          <type name="SnippetHook" c:type="CoglSnippetHook"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="694">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_post" c:identifier="cogl_snippet_get_post">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="825"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="821">the source string that was set with
  cogl_snippet_set_post() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="819">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pre" c:identifier="cogl_snippet_get_pre">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="769"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="765">the source string that was set with
  cogl_snippet_set_pre() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="763">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_replace" c:identifier="cogl_snippet_get_replace">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="797"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="793">the source string that was set with
  cogl_snippet_set_replace() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="791">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_declarations"
              c:identifier="cogl_snippet_set_declarations">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="714">Sets a source string that will be inserted in the global scope of
the generated shader when this snippet is used on a pipeline. This
string is typically used to declare uniforms, attributes or
functions that will be used by the other parts of the snippets.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="730"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="716">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="declarations" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="717">The new source string for the declarations section
  of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_post" c:identifier="cogl_snippet_set_post">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="799">Sets a source string that will be inserted after the hook point in
the generated shader for the pipeline that this snippet is attached
to. Please see the documentation of each hook point in
#CoglPipeline for a description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="814"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="801">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="post" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="802">The new source string for the post section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pre" c:identifier="cogl_snippet_set_pre">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="743">Sets a source string that will be inserted before the hook point in
the generated shader for the pipeline that this snippet is attached
to. Please see the documentation of each hook point in
#CoglPipeline for a description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="758"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="745">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="pre" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="746">The new source string for the pre section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_replace" c:identifier="cogl_snippet_set_replace">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="771">Sets a source string that will be used instead of any generated
source code or any previous snippets for this hook point. Please
see the documentation of each hook point in #CoglPipeline for a
description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="786"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="773">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="replace" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="774">The new source string for the replace section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="SnippetHook" c:type="CoglSnippetHook">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-snippet.h"
           line="352">#CoglSnippetHook is used to specify a location within a
#CoglPipeline where the code of the snippet should be used when it
is attached to a pipeline.

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_VERTEX_GLOBALS&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet at the beginning of the global section of the
shader for the vertex processing. Any declarations here can be
shared with all other snippets that are attached to a vertex hook.
Only the declarations string is used and the other strings are
ignored.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_FRAGMENT_GLOBALS&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet at the beginning of the global section of the
shader for the fragment processing. Any declarations here can be
shared with all other snippets that are attached to a fragment
hook. Only the declarations string is used and the other strings
are ignored.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_VERTEX&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the vertex processing
stage of the pipeline. This gives a chance for the application to
modify the vertex attributes generated by the shader. Typically the
snippet will modify cogl_color_out or cogl_position_out builtins.
&lt;/para&gt;
&lt;para&gt;
The declarations string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The pre string in @snippet will be inserted at the top of the
main() function before any vertex processing is done.
&lt;/para&gt;
&lt;para&gt;
The replace string in @snippet will be used instead of the
generated vertex processing if it is present. This can be used if
the application wants to provide a complete vertex shader and
doesn't need the generated output from Cogl.
&lt;/para&gt;
&lt;para&gt;
The post string in @snippet will be inserted after all of the
standard vertex processing is done. This can be used to modify the
outputs.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_VERTEX_TRANSFORM&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the vertex transform stage.
Typically the snippet will use the cogl_modelview_matrix,
cogl_projection_matrix and cogl_modelview_projection_matrix matrices and the
cogl_position_in attribute. The hook must write to cogl_position_out.
The default processing for this hook will multiply cogl_position_in by
the combined modelview-projection matrix and store it on cogl_position_out.
&lt;/para&gt;
&lt;para&gt;
The declarations string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The pre string in @snippet will be inserted at the top of the
main() function before the vertex transform is done.
&lt;/para&gt;
&lt;para&gt;
The replace string in @snippet will be used instead of the
generated vertex transform if it is present.
&lt;/para&gt;
&lt;para&gt;
The post string in @snippet will be inserted after all of the
standard vertex transformation is done. This can be used to modify the
cogl_position_out in addition to the default processing.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_POINT_SIZE&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the point size
calculation step within the vertex shader stage. The snippet should
write to the builtin cogl_point_size_out with the new point size.
The snippet can either read cogl_point_size_in directly and write a
new value or first read an existing value in cogl_point_size_out
that would be set by a previous snippet. Note that this hook is
only used if cogl_pipeline_set_per_vertex_point_size() is enabled
on the pipeline.
&lt;/para&gt;
&lt;para&gt;
The declarations string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The pre string in @snippet will be inserted just before
calculating the point size.
&lt;/para&gt;
&lt;para&gt;
The replace string in @snippet will be used instead of the
generated point size calculation if it is present.
&lt;/para&gt;
&lt;para&gt;
The post string in @snippet will be inserted after the
standard point size calculation is done. This can be used to modify
cogl_point_size_out in addition to the default processing.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_FRAGMENT&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the fragment processing
stage of the pipeline. This gives a chance for the application to
modify the fragment color generated by the shader. Typically the
snippet will modify cogl_color_out.
&lt;/para&gt;
&lt;para&gt;
The declarations string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The pre string in @snippet will be inserted at the top of the
main() function before any fragment processing is done.
&lt;/para&gt;
&lt;para&gt;
The replace string in @snippet will be used instead of the
generated fragment processing if it is present. This can be used if
the application wants to provide a complete fragment shader and
doesn't need the generated output from Cogl.
&lt;/para&gt;
&lt;para&gt;
The post string in @snippet will be inserted after all of the
standard fragment processing is done. At this point the generated
value for the rest of the pipeline state will already be in
cogl_color_out so the application can modify the result by altering
this variable.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM&lt;/glossterm&gt;
   &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the texture coordinate
transformation of a particular layer. This can be used to replace
the processing for a layer or to modify the results.
&lt;/para&gt;
&lt;para&gt;
Within the snippet code for this hook there are two extra
variables. The first is a mat4 called cogl_matrix which represents
the user matrix for this layer. The second is called cogl_tex_coord
and represents the incoming and outgoing texture coordinate. On
entry to the hook, cogl_tex_coord contains the value of the
corresponding texture coordinate attribute for this layer. The hook
is expected to modify this variable. The output will be passed as a
varying to the fragment processing stage. The default code will
just multiply cogl_matrix by cogl_tex_coord and store the result in
cogl_tex_coord.
&lt;/para&gt;
&lt;para&gt;
The declarations string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The pre string in @snippet will be inserted just before the
fragment processing for this layer. At this point cogl_tex_coord
still contains the value of the texture coordinate attribute.
&lt;/para&gt;
&lt;para&gt;
If a replace string is given then this will be used instead of
the default fragment processing for this layer. The snippet can
modify cogl_tex_coord or leave it as is to apply no transformation.
&lt;/para&gt;
&lt;para&gt;
The post string in @snippet will be inserted just after the
transformation. At this point cogl_tex_coord will contain the
results of the transformation but it can be further modified by the
snippet.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_LAYER_FRAGMENT&lt;/glossterm&gt;
   &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the fragment processing
of a particular layer. This can be used to replace the processing
for a layer or to modify the results.
&lt;/para&gt;
&lt;para&gt;
Within the snippet code for this hook there is an extra vec4
variable called cogl_layer. This contains the resulting color
that will be used for the layer. This can be modified in the post
section or it the default processing can be replaced entirely using
the replace section.
&lt;/para&gt;
&lt;para&gt;
The declarations string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The pre string in @snippet will be inserted just before the
fragment processing for this layer.
&lt;/para&gt;
&lt;para&gt;
If a replace string is given then this will be used instead of
the default fragment processing for this layer. The snippet must write to
the cogl_layer variable in that case.
&lt;/para&gt;
&lt;para&gt;
The post string in @snippet will be inserted just after the
fragment processing for the layer. The results can be modified by changing
the value of the cogl_layer variable.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_TEXTURE_LOOKUP&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the texture lookup part
of a given layer. This gives a chance for the application to modify
the coordinates that will be used for the texture lookup or to
alter the returned texel.
&lt;/para&gt;
&lt;para&gt;
Within the snippet code for this hook there are three extra
variables available. cogl_sampler is a sampler object
representing the sampler for the layer where the snippet is
attached. cogl_tex_coord is a vec4 which contains the texture
coordinates that will be used for the texture lookup. This can be
modified. cogl_texel will contain the result of the texture
lookup. This can also be modified.
&lt;/para&gt;
&lt;para&gt;
The declarations string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The pre string in @snippet will be inserted at the top of the
main() function before any fragment processing is done. This is a
good place to modify the cogl_tex_coord variable.
&lt;/para&gt;
&lt;para&gt;
If a replace string is given then this will be used instead of a
the default texture lookup. The snippet would typically use its own
sampler in this case.
&lt;/para&gt;
&lt;para&gt;
The post string in @snippet will be inserted after texture lookup
has been performed. Here the snippet can modify the cogl_texel
variable to alter the returned texel.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;</doc>
      <source-position filename="cogl/cogl/cogl-snippet.h" line="672"/>
      <member name="vertex" value="0" c:identifier="COGL_SNIPPET_HOOK_VERTEX">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="360">A hook for the entire vertex processing
  stage of the pipeline.</doc>
      </member>
      <member name="vertex_transform"
              value="1"
              c:identifier="COGL_SNIPPET_HOOK_VERTEX_TRANSFORM">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="362">A hook for the vertex transformation.</doc>
      </member>
      <member name="vertex_globals"
              value="2"
              c:identifier="COGL_SNIPPET_HOOK_VERTEX_GLOBALS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="354">A hook for declaring global data
  that can be shared with all other snippets that are on a vertex
  hook.</doc>
      </member>
      <member name="point_size"
              value="3"
              c:identifier="COGL_SNIPPET_HOOK_POINT_SIZE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="363">A hook for manipulating the point
  size of a vertex. This is only used if
  cogl_pipeline_set_per_vertex_point_size() is enabled on the
  pipeline.</doc>
      </member>
      <member name="fragment"
              value="2048"
              c:identifier="COGL_SNIPPET_HOOK_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="367">A hook for the entire fragment
  processing stage of the pipeline.</doc>
      </member>
      <member name="fragment_globals"
              value="2049"
              c:identifier="COGL_SNIPPET_HOOK_FRAGMENT_GLOBALS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="357">A hook for declaring global
  data wthat can be shared with all other snippets that are on a
  fragment hook.</doc>
      </member>
      <member name="texture_coord_transform"
              value="4096"
              c:identifier="COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="369">A hook for applying the
  layer matrix to a texture coordinate for a layer.</doc>
      </member>
      <member name="layer_fragment"
              value="6144"
              c:identifier="COGL_SNIPPET_HOOK_LAYER_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="371">A hook for the fragment
  processing of a particular layer.</doc>
      </member>
      <member name="texture_lookup"
              value="6145"
              c:identifier="COGL_SNIPPET_HOOK_TEXTURE_LOOKUP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="373">A hook for the texture lookup
  stage of a given layer in a pipeline.</doc>
      </member>
    </enumeration>
    <enumeration name="StereoMode" c:type="CoglStereoMode">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="455">Represents how draw should affect the two buffers
of a stereo framebuffer. See cogl_framebuffer_set_stereo_mode().</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="469"/>
      <member name="both" value="0" c:identifier="COGL_STEREO_BOTH">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="457">draw to both stereo buffers</doc>
      </member>
      <member name="left" value="1" c:identifier="COGL_STEREO_LEFT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="458">draw only to the left stereo buffer</doc>
      </member>
      <member name="right" value="2" c:identifier="COGL_STEREO_RIGHT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="459">draw only to the left stereo buffer</doc>
      </member>
    </enumeration>
    <enumeration name="SystemError" c:type="CoglSystemError">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="205">Error enumeration for Cogl

The @COGL_SYSTEM_ERROR_UNSUPPORTED error can be thrown for a
variety of reasons. For example:

&lt;itemizedlist&gt;
 &lt;listitem&gt;&lt;para&gt;You've tried to use a feature that is not
  advertised by cogl_has_feature().&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The GPU can not handle the configuration you have
  requested. An example might be if you try to use too many texture
  layers in a single #CoglPipeline&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The driver does not support some
  configuration.&lt;/para&gt;&lt;/listiem&gt;
&lt;/itemizedlist&gt;

Currently this is only used by Cogl API marked as experimental so
this enum should also be considered experimental.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="234"/>
      <member name="unsupported"
              value="0"
              c:identifier="COGL_SYSTEM_ERROR_UNSUPPORTED">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="207">You tried to use a feature or
   configuration not currently available.</doc>
      </member>
      <member name="no_memory"
              value="1"
              c:identifier="COGL_SYSTEM_ERROR_NO_MEMORY">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="209">You tried to allocate a resource
   such as a texture and there wasn't enough memory.</doc>
      </member>
    </enumeration>
    <function-macro name="TEXTURE"
                    c:identifier="COGL_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture.h" line="48"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D"
                    c:identifier="COGL_TEXTURE_2D"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="60"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_SLICED"
                    c:identifier="COGL_TEXTURE_2D_SLICED"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="70"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TEXTURE_MAX_WASTE"
              value="127"
              c:type="COGL_TEXTURE_MAX_WASTE">
      <source-position filename="cogl/cogl/cogl-texture.h" line="71"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="TRACE_BEGIN"
                    c:identifier="COGL_TRACE_BEGIN"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="105"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_BEGIN_ANCHORED"
                    c:identifier="COGL_TRACE_BEGIN_ANCHORED"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="133"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_BEGIN_SCOPED"
                    c:identifier="COGL_TRACE_BEGIN_SCOPED"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="114"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_DESCRIBE"
                    c:identifier="COGL_TRACE_DESCRIBE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="124"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="description">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_END"
                    c:identifier="COGL_TRACE_END"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="110"/>
      <parameters>
        <parameter name="Name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_SCOPED_ANCHOR"
                    c:identifier="COGL_TRACE_SCOPED_ANCHOR"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="128"/>
      <parameters>
        <parameter name="Name">
        </parameter>
      </parameters>
    </function-macro>
    <interface name="Texture"
               c:symbol-prefix="texture"
               c:type="CoglTexture"
               glib:type-name="CoglTexture"
               glib:get-type="cogl_texture_get_gtype">
      <prerequisite name="Object"/>
      <function name="error_quark" c:identifier="cogl_texture_error_quark">
        <source-position filename="cogl/cogl/cogl-texture.h" line="106"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <method name="allocate" c:identifier="cogl_texture_allocate" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="459">Explicitly allocates the storage for the given @texture which
allows you to be sure that there is enough memory for the
texture and if not then the error can be handled gracefully.

&lt;note&gt;Normally applications don't need to use this api directly
since the texture will be implicitly allocated when data is set on
the texture, or if the texture is attached to a #CoglOffscreen
framebuffer and rendered too.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="478"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="473">%TRUE if the texture was successfully allocated,
              otherwise %FALSE and @error will be updated if it
              wasn't %NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="461">A #CoglTexture</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_components" c:identifier="cogl_texture_get_components">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="169">Queries what components the given @texture stores internally as set
via cogl_texture_set_components().

For textures created by the _with_size constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="182"/>
        <return-value transfer-ownership="none">
          <type name="TextureComponents" c:type="CoglTextureComponents"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="171">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="cogl_texture_get_data">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="302">Copies the pixel data from a cogl texture to system memory.

&lt;note&gt;Don't pass the value of cogl_texture_get_rowstride() as the
@rowstride argument, the rowstride should be the rowstride you
want for the destination @data buffer not the rowstride of the
source texture&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="322"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="319">the size of the texture data in bytes</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="304">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="305">the #CoglPixelFormat to store the texture as.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="306">the rowstride of @data in bytes or pass 0 to calculate
            from the bytes-per-pixel of @format multiplied by the
            @texture width.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="309">memory location to write the @texture's contents,
or %NULL to only query the data size through the return value.</doc>
            <array zero-terminated="0" c:type="uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_gl_texture" c:identifier="cogl_texture_get_gl_texture">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="281">Queries the GL handles for a GPU side texture through its #CoglTexture.

If the texture is spliced the data for the first sub texture will be
queried.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="298"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="294">%TRUE if the handle was successfully retrieved, %FALSE
  if the handle was invalid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="283">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="out_gl_handle"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="284">pointer to return location for the
  textures GL handle, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
          <parameter name="out_gl_target"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="286">pointer to return location for the
  GL target type, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_texture_get_height">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="245">Queries the height of a cogl texture.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="254"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="251">the height of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="247">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_waste" c:identifier="cogl_texture_get_max_waste">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="256">Queries the maximum wasted (unused) pixels in one dimension of a GPU side
texture.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="266"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="263">the maximum waste</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="258">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_premultiplied"
              c:identifier="cogl_texture_get_premultiplied">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="217">Queries the pre-multiplied alpha status for internally stored red,
green and blue components for the given @texture as set by
cogl_texture_set_premultiplied().

By default the pre-multiplied state is @TRUE.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="232"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="227">%TRUE if red, green and blue components are
              internally stored pre-multiplied by the alpha
              value or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="219">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_texture_get_width">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="234">Queries the width of a cogl texture.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="243"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="240">the width of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="236">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_get_data_supported"
              c:identifier="cogl_texture_is_get_data_supported"
              introspectable="0">
        <source-position filename="cogl/cogl/cogl-texture.h" line="485"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_sliced" c:identifier="cogl_texture_is_sliced">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="268">Queries if a texture is sliced (stored as multiple GPU side tecture
objects).</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="279"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="275">%TRUE if the texture is sliced, %FALSE if the texture
  is stored as a single GPU texture</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="270">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_components" c:identifier="cogl_texture_set_components">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="141">Affects the internal storage format for this texture by specifying
what components will be required for sampling later.

This api affects how data is uploaded to the GPU since unused
components can potentially be discarded from source data.

For textures created by the _with_size constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.

Note that the %COGL_TEXTURE_COMPONENTS_RG format is not available
on all drivers. The availability can be determined by checking for
the %COGL_FEATURE_ID_TEXTURE_RG feature. If this format is used on
a driver where it is not available then %COGL_TEXTURE_ERROR_FORMAT
will be raised when the texture is allocated. Even if the feature
is not available then %COGL_PIXEL_FORMAT_RG_88 can still be used as
an image format as long as %COGL_TEXTURE_COMPONENTS_RG isn't used
as the texture's components.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="166"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="143">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="components" transfer-ownership="none">
            <type name="TextureComponents" c:type="CoglTextureComponents"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="cogl_texture_set_data" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="367">@texture a #CoglTexture.
Sets all the pixels for a given mipmap @level by copying the pixel
data pointed to by the @data argument into the given @texture.

@data should point to the first pixel to copy corresponding
to the top left of the mipmap @level being set.

If @rowstride equals 0 then it will be automatically calculated
from the width of the mipmap level and the bytes-per-pixel for the
given @format.

A mipmap @level of 0 corresponds to the largest, base image of a
texture and @level 1 is half the width and height of level 0. If
dividing any dimension of the previous level by two results in a
fraction then round the number down (floor()), but clamp to 1
something like this:

|[
 next_width = MAX (1, floor (prev_width));
]|

You can determine the number of mipmap levels for a given texture
like this:

|[
 n_levels = 1 + floor (log2 (max_dimension));
]|

Where %max_dimension is the larger of cogl_texture_get_width() and
cogl_texture_get_height().

It is an error to pass a @level number &gt;= the number of levels that
@texture can have according to the above calculation.

&lt;note&gt;Since the storage for a #CoglTexture is allocated lazily then
if the given @texture has not previously been allocated then this
api can return %FALSE and throw an exceptional @error if there is
not enough memory to allocate storage for @texture.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="420"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="416">%TRUE if the data upload was successful, and
              %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="370">the #CoglPixelFormat used in the source @data buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="371">rowstride of the source @data buffer (computed from
            the texture width and @format if it equals 0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="373">the source data, pointing to the first top-left pixel to set</doc>
            <array zero-terminated="0" c:type="const uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="374">The mipmap level to update (Normally 0 for the largest,
        base texture)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_premultiplied"
              c:identifier="cogl_texture_set_premultiplied">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="184">Affects the internal storage format for this texture by specifying
whether red, green and blue color components should be stored as
pre-multiplied alpha values.

This api affects how data is uploaded to the GPU since Cogl will
convert source data to have premultiplied or unpremultiplied
components according to this state.

For example if you create a texture via
cogl_texture_2d_new_with_size() and then upload data via
cogl_texture_set_data() passing a source format of
%COGL_PIXEL_FORMAT_RGBA_8888 then Cogl will internally multiply the
red, green and blue components of the source data by the alpha
component, for each pixel so that the internally stored data has
pre-multiplied alpha components. If you instead upload data that
already has pre-multiplied components by passing
%COGL_PIXEL_FORMAT_RGBA_8888_PRE as the source format to
cogl_texture_set_data() then the data can be uploaded without being
converted.

By default the @premultipled state is @TRUE.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="214"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="186">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="premultiplied" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="187">Whether any internally stored red, green or blue
                components are pre-multiplied by an alpha
                component.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region" c:identifier="cogl_texture_set_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="327">Sets the pixels in a rectangular subregion of @texture from an in-memory
buffer containing pixel data.

&lt;note&gt;The region set can't be larger than the source @data&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="354"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="350">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="329">a #CoglTexture.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="330">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="331">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="332">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="333">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="334">width of destination region to write. (Must be less
  than or equal to @width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="336">height of destination region to write. (Must be less
  than or equal to @height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="338">width of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="339">height of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="340">the #CoglPixelFormat used in the source buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="341">rowstride of source buffer (computed from width if none
specified)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="343">the actual pixel data.</doc>
            <array zero-terminated="0" c:type="const uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_region_from_bitmap"
              c:identifier="cogl_texture_set_region_from_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="427">Copies a specified source region from @bitmap to the position
(@src_x, @src_y) of the given destination texture @handle.

&lt;note&gt;The region updated can't be larger than the source
bitmap&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="450"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="446">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="429">a #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="430">upper left coordinate to use from the source bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="431">upper left coordinate to use from the source bitmap</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="432">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="433">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="434">width of destination region to write. (Must be less
  than or equal to the bitmap width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="436">height of destination region to write. (Must be less
  than or equal to the bitmap height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="438">The source bitmap to read from</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <class name="Texture2D"
           c:symbol-prefix="texture_2d"
           c:type="CoglTexture2D"
           parent="Object"
           glib:type-name="CoglTexture2D"
           glib:get-type="cogl_texture_2d_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_new_from_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="214">Creates a low-level #CoglTexture2D texture based on data residing
in a #CoglBitmap.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="235"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="232">A newly allocated #CoglTexture2D</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="216">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_2d_new_from_data"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="174">Creates a low-level #CoglTexture2D texture based on data residing
in memory.

&lt;note&gt;This api will always immediately allocate GPU memory for the
texture and upload the given data so that the @data pointer does
not need to remain valid once this function returns. This means it
is not possible to configure the texture before it is allocated. If
you do need to configure the texture before allocation (to specify
constraints on the internal format for example) then you can
instead create a #CoglBitmap for your data and use
cogl_texture_2d_new_from_bitmap() or use
cogl_texture_2d_new_with_size() and then upload data using
cogl_texture_set_data()&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="206"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="200">A newly allocated #CoglTexture2D, or if
         the size is not supported (because it is too large or a
         non-power-of-two size that the hardware doesn't support)
         it will return %NULL and set @error.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="176">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="177">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="178">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="179">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="180">the memory offset in bytes between the starts of
   scanlines in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="183">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_egl_image_external"
                   c:identifier="cogl_texture_2d_new_from_egl_image_external"
                   introspectable="0"
                   throws="1">
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="261"/>
        <return-value transfer-ownership="full">
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="alloc"
                     transfer-ownership="none"
                     scope="notified"
                     closure="4"
                     destroy="5">
            <type name="Texture2DEGLImageExternalAlloc"
                  c:type="CoglTexture2DEGLImageExternalAlloc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_texture_2d_new_from_file"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="147">Creates a low-level #CoglTexture2D texture from an image file.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="170"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="166">A newly created #CoglTexture2D or %NULL on failure
              and @error will be updated.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="149">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="150">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_format"
                   c:identifier="cogl_texture_2d_new_with_format"
                   version="2.0"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="89">Creates a low-level #CoglTexture2D texture with a given @width and
@height that your GPU can texture from directly.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="115"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="110">A new #CoglTexture2D object with no storage yet allocated.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="91">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="92">Width of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="93">Height of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="94">format of the texture to allocate</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_new_with_size"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="120">Creates a low-level #CoglTexture2D texture with a given @width and
@height that your GPU can texture from directly.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="143"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="140">A new #CoglTexture2D object with no storage yet allocated.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="122">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="123">Width of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="124">Height of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="egl_image_external_alloc_finish"
              c:identifier="cogl_texture_2d_egl_image_external_alloc_finish">
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="273"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tex_2d" transfer-ownership="none">
            <type name="Texture2D" c:type="CoglTexture2D*"/>
          </instance-parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="egl_image_external_bind"
              c:identifier="cogl_texture_2d_egl_image_external_bind">
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="270"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tex_2d" transfer-ownership="none">
            <type name="Texture2D" c:type="CoglTexture2D*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <callback name="Texture2DEGLImageExternalAlloc"
              c:type="CoglTexture2DEGLImageExternalAlloc"
              throws="1">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="253"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="tex_2d" transfer-ownership="none">
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Texture2DSliced"
           c:symbol-prefix="texture_2d_sliced"
           c:type="CoglTexture2DSliced"
           parent="Object"
           glib:type-name="CoglTexture2DSliced"
           glib:get-type="cogl_texture_2d_sliced_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_sliced_new_from_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d-sliced.h"
             line="233">Creates a new #CoglTexture2DSliced texture based on data residing
in a bitmap.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size is
larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                         line="273"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d-sliced.h"
               line="269">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="bmp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="235">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="236">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_2d_sliced_new_from_data"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d-sliced.h"
             line="170">Creates a new #CoglTexture2DSliced texture based on data residing
in memory.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

&lt;note&gt;This api will always immediately allocate GPU memory for all
the required texture slices and upload the given data so that the
@data pointer does not need to remain valid once this function
returns. This means it is not possible to configure the texture
before it is allocated. If you do need to configure the texture
before allocation (to specify constraints on the internal format
for example) then you can instead create a #CoglBitmap for your
data and use cogl_texture_2d_sliced_new_from_bitmap() or use
cogl_texture_2d_sliced_new_with_size() and then upload data using
cogl_texture_set_data()&lt;/note&gt;

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
due to impossible slicing constraints if a negative @max_waste
value is given. If the given virtual texture size is larger than is
supported by the hardware but slicing is disabled the texture size
would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                         line="224"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d-sliced.h"
               line="220">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="172">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="173">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="174">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="176">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="175">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="180">the memory offset in bytes between the start of each
   row in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="183">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_texture_2d_sliced_new_from_file"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d-sliced.h"
             line="124">Creates a #CoglTexture2DSliced from an image file.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size is
larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                         line="165"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d-sliced.h"
               line="161">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="126">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="127">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="128">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_sliced_new_with_size"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d-sliced.h"
             line="80">Creates a #CoglTexture2DSliced that may internally be comprised of
1 or more #CoglTexture2D textures depending on GPU limitations.
For example if the GPU only supports power-of-two sized textures
then a sliced texture will turn a non-power-of-two size into a
combination of smaller power-of-two sized textures. If the
requested texture size is larger than is supported by the hardware
then the texture will be sliced into smaller textures that can be
accessed by the hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size size
is larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                         line="119"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d-sliced.h"
               line="115">A new #CoglTexture2DSliced object with no storage
         allocated yet.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="82">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="83">The virtual width of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="84">The virtual height of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="85">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <enumeration name="TextureComponents" c:type="CoglTextureComponents">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture.h"
           line="120">See cogl_texture_set_components().</doc>
      <source-position filename="cogl/cogl/cogl-texture.h" line="139"/>
      <member name="a" value="1" c:identifier="COGL_TEXTURE_COMPONENTS_A">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="122">Only the alpha component</doc>
      </member>
      <member name="rg" value="2" c:identifier="COGL_TEXTURE_COMPONENTS_RG">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="123">Red and green components. Note that
  this can only be used if the %COGL_FEATURE_ID_TEXTURE_RG feature
  is advertised.</doc>
      </member>
      <member name="rgb" value="3" c:identifier="COGL_TEXTURE_COMPONENTS_RGB">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="126">Red, green and blue components</doc>
      </member>
      <member name="rgba"
              value="4"
              c:identifier="COGL_TEXTURE_COMPONENTS_RGBA">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="127">Red, green, blue and alpha components</doc>
      </member>
      <member name="depth"
              value="5"
              c:identifier="COGL_TEXTURE_COMPONENTS_DEPTH">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="128">Only a depth component</doc>
      </member>
    </enumeration>
    <enumeration name="TextureError" c:type="CoglTextureError">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture.h"
           line="88">Error codes that can be thrown when allocating textures.</doc>
      <source-position filename="cogl/cogl/cogl-texture.h" line="103"/>
      <member name="size" value="0" c:identifier="COGL_TEXTURE_ERROR_SIZE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="90">Unsupported size</doc>
      </member>
      <member name="format" value="1" c:identifier="COGL_TEXTURE_ERROR_FORMAT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="91">Unsupported format</doc>
      </member>
      <member name="bad_parameter"
              value="2"
              c:identifier="COGL_TEXTURE_ERROR_BAD_PARAMETER">
      </member>
      <member name="type" value="3" c:identifier="COGL_TEXTURE_ERROR_TYPE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="92">A primitive texture type that is
  unsupported by the driver was used</doc>
      </member>
    </enumeration>
    <record name="TextureVertex" c:type="CoglTextureVertex">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="154">Used to specify vertex information when calling cogl_polygon()</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="172"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="156">Model x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="157">Model y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="158">Model z-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="tx" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="159">Texture x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ty" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="160">Texture y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="161">The color to use at this vertex. This is ignored if
  use_color is %FALSE when calling cogl_polygon()</doc>
        <type name="Color" c:type="CoglColor"/>
      </field>
    </record>
    <record name="TimestampQuery"
            c:type="CoglTimestampQuery"
            disguised="1"
            opaque="1">
      <source-position filename="cogl/cogl/cogl-context.h" line="43"/>
    </record>
    <record name="TraceContext"
            c:type="CoglTraceContext"
            disguised="1"
            opaque="1">
      <source-position filename="cogl/cogl/cogl-trace.h" line="40"/>
    </record>
    <record name="TraceHead" c:type="CoglTraceHead">
      <source-position filename="cogl/cogl/cogl-trace.h" line="47"/>
      <field name="begin_time" writable="1">
        <type name="guint64" c:type="uint64_t"/>
      </field>
      <field name="name" writable="1">
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="description" writable="1">
        <type name="utf8" c:type="char*"/>
      </field>
    </record>
    <record name="UserDataKey" c:type="CoglUserDataKey">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-object.h"
           line="92">A #CoglUserDataKey is used to declare a key for attaching data to a
#CoglObject using cogl_object_set_user_data. The typedef only exists as a
formality to make code self documenting since only the unique address of a
#CoglUserDataKey is used.

Typically you would declare a static #CoglUserDataKey and set private data
on an object something like this:

|[
static CoglUserDataKey path_private_key;

static void
destroy_path_private_cb (void *data)
{
  g_free (data);
}

static void
my_path_set_data (CoglPipeline *pipeline, void *data)
{
  cogl_object_set_user_data (COGL_OBJECT (pipeline),
                             &amp;private_key,
                             data,
                             destroy_pipeline_private_cb);
}
]|</doc>
      <source-position filename="cogl/cogl/cogl-object.h" line="125"/>
      <field name="unused" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-object.h"
             line="94">ignored.</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <enumeration name="VerticesMode" c:type="CoglVerticesMode">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="283">Different ways of interpreting vertices when drawing.</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="309"/>
      <member name="points" value="0" c:identifier="COGL_VERTICES_MODE_POINTS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="285">FIXME, equivalent to
&lt;constant&gt;GL_POINTS&lt;/constant&gt;</doc>
      </member>
      <member name="lines" value="1" c:identifier="COGL_VERTICES_MODE_LINES">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="287">FIXME, equivalent to &lt;constant&gt;GL_LINES&lt;/constant&gt;</doc>
      </member>
      <member name="line_loop"
              value="2"
              c:identifier="COGL_VERTICES_MODE_LINE_LOOP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="288">FIXME, equivalent to
&lt;constant&gt;GL_LINE_LOOP&lt;/constant&gt;</doc>
      </member>
      <member name="line_strip"
              value="3"
              c:identifier="COGL_VERTICES_MODE_LINE_STRIP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="290">FIXME, equivalent to
&lt;constant&gt;GL_LINE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangles"
              value="4"
              c:identifier="COGL_VERTICES_MODE_TRIANGLES">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="292">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLES&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_strip"
              value="5"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_STRIP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="294">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_fan"
              value="6"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_FAN">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="296">FIXME, equivalent to &lt;constant&gt;GL_TRIANGLE_FAN&lt;/constant&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="Winding" c:type="CoglWinding">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="414">Enum used to represent the two directions of rotation. This can be
used to set the front face for culling by calling
cogl_pipeline_set_front_face_winding().</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="427"/>
      <member name="clockwise" value="0" c:identifier="COGL_WINDING_CLOCKWISE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="416">Vertices are in a clockwise order</doc>
      </member>
      <member name="counter_clockwise"
              value="1"
              c:identifier="COGL_WINDING_COUNTER_CLOCKWISE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="417">Vertices are in a counter-clockwise order</doc>
      </member>
    </enumeration>
    <enumeration name="WinsysFeature" c:type="CoglWinsysFeature">
      <source-position filename="cogl/cogl/cogl-types.h" line="412"/>
      <member name="vblank_counter"
              value="0"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_COUNTER">
      </member>
      <member name="vblank_wait"
              value="1"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_WAIT">
      </member>
      <member name="texture_from_pixmap"
              value="2"
              c:identifier="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP">
      </member>
      <member name="swap_buffers_event"
              value="3"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT">
      </member>
      <member name="swap_region"
              value="4"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION">
      </member>
      <member name="swap_region_throttle"
              value="5"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE">
      </member>
      <member name="swap_region_synchronized"
              value="6"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED">
      </member>
      <member name="buffer_age"
              value="7"
              c:identifier="COGL_WINSYS_FEATURE_BUFFER_AGE">
      </member>
      <member name="sync_and_complete_event"
              value="8"
              c:identifier="COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT">
      </member>
      <member name="n_features"
              value="9"
              c:identifier="COGL_WINSYS_FEATURE_N_FEATURES">
      </member>
    </enumeration>
    <callback name="XlibFilterFunc"
              c:type="CoglXlibFilterFunc"
              introspectable="0">
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="88"/>
      <return-value transfer-ownership="none">
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="event" transfer-ownership="none">
          <type c:type="XEvent*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="_ColorSizeCheck" c:type="_CoglColorSizeCheck">
      <source-position filename="cogl/cogl/cogl-types.h" line="152"/>
      <field name="compile_time_assert_CoglColor_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_TextureVertexSizeCheck"
            c:type="_CoglTextureVertexSizeCheck">
      <source-position filename="cogl/cogl/cogl-types.h" line="173"/>
      <field name="compile_time_assert_CoglTextureVertex_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <function name="blend_string_error_quark"
              c:identifier="cogl_blend_string_error_quark">
      <source-position filename="cogl/cogl/cogl-types.h" line="201"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="blit_framebuffer"
              c:identifier="cogl_blit_framebuffer"
              throws="1">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-framebuffer.h"
           line="1295">@return FALSE for an immediately detected error, TRUE otherwise.

This blits a region of the color buffer of the source buffer
to the destination buffer. This function should only be
called if the COGL_FEATURE_ID_BLIT_FRAMEBUFFER feature is
advertised.

The source and destination rectangles are defined in offscreen
framebuffer orientation. When copying between an offscreen and
onscreen framebuffers, the image is y-flipped accordingly.

The two buffers must have the same value types (e.g. floating-point,
unsigned int, signed int, or fixed-point), but color formats do not
need to match. This limitation comes from OpenGL ES 3.0 definition
of glBlitFramebuffer.

Note that this function differs a lot from the glBlitFramebuffer
function provided by the GL_EXT_framebuffer_blit extension. Notably
it doesn't support having different sizes for the source and
destination rectangle. This doesn't seem
like a particularly useful feature. If the application wanted to
scale the results it may make more sense to draw a primitive
instead.

The GL function is documented to be affected by the scissor. This
function therefore ensure that an empty clip stack is flushed
before performing the blit which means the scissor is effectively
ignored.

The function also doesn't support specifying the buffers to copy
and instead only the color buffer is copied. When copying the depth
or stencil buffers the extension on GLES2.0 only supports copying
the full buffer which would be awkward to document with this
API. If we wanted to support that feature it may be better to have
a separate function to copy the entire buffer for a given mask.

The @c error argument is optional, it can be NULL. If it is not NULL
and this function returns FALSE, an error object with a code from
COGL_SYSTEM_ERROR will be created.</doc>
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1348"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="framebuffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1297">The source #CoglFramebuffer</doc>
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
        <parameter name="dst" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1298">The destination #CoglFramebuffer</doc>
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
        <parameter name="src_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1299">Source x position</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="src_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1300">Source y position</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dst_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1301">Destination x position</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dst_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1302">Destination y position</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1303">Width of region to copy</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1304">Height of region to copy</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="clear_object"
                    c:identifier="cogl_clear_object"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-object.h"
           line="78">Clears a reference to a #CoglObject.

@object_ptr must not be %NULL.

If the reference is %NULL then this function does nothing.
Otherwise, the reference count of the object is decreased using
cogl_object_unref() and the pointer is set to %NULL.</doc>
      <source-position filename="cogl/cogl/cogl-object.h" line="90"/>
      <parameters>
        <parameter name="object_ptr">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-object.h"
               line="80">a pointer to a #CoglObject reference</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="clutter_winsys_has_feature_CLUTTER"
              c:identifier="cogl_clutter_winsys_has_feature_CLUTTER">
      <source-position filename="cogl/cogl/deprecated/cogl-clutter.h"
                       line="40"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <type name="WinsysFeature" c:type="CoglWinsysFeature"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="cogl">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl.h"
           line="126">General utility functions for COGL.</doc>
    </docsection>
    <docsection name="cogl-bitmap">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-bitmap.h"
           line="59">Cogl allows loading image data into memory as CoglBitmaps without
loading them immediately into GPU textures.

#CoglBitmap is available since Cogl 1.0</doc>
    </docsection>
    <docsection name="cogl-color">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="37">#CoglColor is a simple structure holding the definition of a color such
that it can be efficiently used by GL</doc>
    </docsection>
    <docsection name="cogl-context">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="54">A #CoglContext is the top most sandbox of Cogl state for an
application or toolkit. Its main purpose is to act as a sandbox
for the memory management of state objects. Normally an application
will only create a single context since there is no way to share
resources between contexts.

For those familiar with OpenGL or perhaps Cairo it should be
understood that unlike these APIs a Cogl context isn't a rendering
context as such. In other words Cogl doesn't aim to provide a state
machine style model for configuring rendering parameters. Most
rendering state in Cogl is directly associated with user managed
objects called pipelines and geometry is drawn with a specific
pipeline object to a framebuffer object and those 3 things fully
define the state for drawing. This is an important part of Cogl's
design since it helps you write orthogonal rendering components
that can all access the same GPU without having to worry about
what state other components have left you with.

&lt;note&gt;&lt;para&gt;Cogl does not maintain internal references to the context for
resources that depend on the context so applications. This is to
help applications control the lifetime a context without us needing to
introduce special api to handle the breakup of internal circular
references due to internal resources and caches associated with the
context.

One a context has been destroyed then all directly or indirectly
dependent resources will be in an inconsistent state and should not
be manipulated or queried in any way.

For applications that rely on the operating system to clean up
resources this policy shouldn't affect them, but for applications
that need to carefully destroy and re-create Cogl contexts multiple
times throughout their lifetime (such as Android applications) they
should be careful to destroy all context dependent resources, such as
framebuffers or textures etc before unrefing and destroying the
context.&lt;/para&gt;&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cogl-framebuffer">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-framebuffer.h"
           line="49">Framebuffers are a collection of buffers that can be rendered too.
A framebuffer may be comprised of one or more color buffers, an
optional depth buffer and an optional stencil buffer. Other
configuration parameters are associated with framebuffers too such
as whether the framebuffer supports multi-sampling (an anti-aliasing
technique) or dithering.

There are two kinds of framebuffer in Cogl, #CoglOnscreen
framebuffers and #CoglOffscreen framebuffers. As the names imply
offscreen framebuffers are for rendering something offscreen
(perhaps to a texture which is bound as one of the color buffers).
The exact semantics of onscreen framebuffers depends on the window
system backend that you are using, but typically you can expect
rendering to a #CoglOnscreen framebuffer will be immediately
visible to the user.

If you want to create a new framebuffer then you should start by
looking at the #CoglOnscreen and #CoglOffscreen constructor
functions, such as cogl_offscreen_new_with_texture() or
cogl_onscreen_new(). The #CoglFramebuffer interface deals with
all aspects that are common between those two types of framebuffer.

Setup of a new CoglFramebuffer happens in two stages. There is a
configuration stage where you specify all the options and ancillary
buffers you want associated with your framebuffer and then when you
are happy with the configuration you can "allocate" the framebuffer
using cogl_framebuffer_allocate(). Technically explicitly calling
cogl_framebuffer_allocate() is optional for convenience and the
framebuffer will automatically be allocated when you first try to
draw to it, but if you do the allocation manually then you can
also catch any possible errors that may arise from your
configuration.</doc>
    </docsection>
    <docsection name="cogl-offscreen">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-offscreen.h"
           line="44">Cogl allows creating and operating on offscreen framebuffers.</doc>
    </docsection>
    <docsection name="cogl-pipeline">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline.h"
           line="50">Cogl allows creating and manipulating objects representing the full
configuration of the GPU pipeline. In simplified terms the GPU
pipeline takes primitive geometry as the input, it first performs
vertex processing, allowing you to deform your geometry, then
rasterizes that (turning it from pure geometry into fragments) then
performs fragment processing including depth testing and texture
mapping. Finally it blends the result with the framebuffer.</doc>
    </docsection>
    <docsection name="cogl-pixel-format">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="48">The pixel format of an image descrbes how the bits of each pixel are
represented in memory. For example: an image can be laid out as one long
sequence of pixels, where each pixel is a sequence of 8 bits of Red, Green
and Blue. The amount of bits that are used can be different for each pixel
format, as well as the components (for example an Alpha layer to include
transparency, or non_RGBA).

Other examples of factors that can influence the layout in memory are the
system's endianness.</doc>
    </docsection>
    <docsection name="cogl-shaders">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="43">Cogl allows accessing the GL programmable pipeline in order to create
vertex and fragment shaders.

When using GLSL Cogl provides replacement names for most of the
builtin varyings and uniforms. It is recommended to use these names
wherever possible to increase portability between OpenGL 2.0 and
GLES 2.0. GLES 2.0 does not have most of the builtins under their
original names so they will only work with the Cogl names.

For use in all GLSL shaders, the Cogl builtins are as follows:

&lt;tip&gt;
&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_modelview_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The current modelview matrix. This is equivalent to
   #gl_ModelViewMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_projection_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The current projection matrix. This is equivalent to
   #gl_ProjectionMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_modelview_projection_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The combined modelview and projection matrix. A vertex shader
   would typically use this to transform the incoming vertex
   position. The separate modelview and projection matrices are
   usually only needed for lighting calculations. This is
   equivalent to #gl_ModelViewProjectionMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_texture_matrix&lt;/emphasis&gt;[]&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An array of matrices for transforming the texture
   coordinates. This is equivalent to #gl_TextureMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;
&lt;/tip&gt;

In a vertex shader, the following are also available:

&lt;tip&gt;
&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_position_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming vertex position. This is equivalent to #gl_Vertex.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_color_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming vertex color. This is equivalent to #gl_Color.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_tex_coord_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for the first texture unit. This is
   equivalent to #gl_MultiTexCoord0.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_tex_coord0_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for the first texture unit. This is
   equivalent to #gl_MultiTexCoord0. There is also
   #cogl_tex_coord1_in and so on.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec3
        &lt;emphasis&gt;cogl_normal_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The normal of the vertex. This is equivalent to #gl_Normal.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec4
        &lt;emphasis&gt;cogl_position_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated position of the vertex. This must be written to
   in all vertex shaders. This is equivalent to #gl_Position.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float
        &lt;emphasis&gt;cogl_point_size_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated size of a point. This is equivalent to #gl_PointSize.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
        &lt;emphasis&gt;cogl_color_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
        &lt;emphasis&gt;cogl_tex_coord_out&lt;/emphasis&gt;[]&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An array of calculated texture coordinates for a vertex. This is
   equivalent to #gl_TexCoord.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;
&lt;/tip&gt;

In a fragment shader, the following are also available:

&lt;tip&gt;
&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4 &lt;emphasis&gt;cogl_color_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
             &lt;emphasis&gt;cogl_tex_coord_in&lt;/emphasis&gt;[]&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An array of calculated texture coordinates for a vertex. This is
   equivalent to #gl_TexCoord.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec4 &lt;emphasis&gt;cogl_color_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The final calculated color of the fragment. All fragment shaders
   must write to this variable. This is equivalent to
   #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float &lt;emphasis&gt;cogl_depth_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An optional output variable specifying the depth value to use
   for this fragment. This is equivalent to #gl_FragDepth.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;bool &lt;emphasis&gt;cogl_front_facing&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   A readonly variable that will be true if the current primitive
   is front facing. This can be used to implement two-sided
   coloring algorithms. This is equivalent to #gl_FrontFacing.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;
&lt;/tip&gt;

It's worth nothing that this API isn't what Cogl would like to have
in the long term and it may be removed in Cogl 2.0. The
experimental #CoglShader API is the proposed replacement.</doc>
    </docsection>
    <docsection name="cogl-snippet">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-snippet.h"
           line="42">#CoglSnippet&lt;!-- --&gt;s are used to modify or replace parts of a
#CoglPipeline using GLSL. GLSL is a programming language supported
by OpenGL on programmable hardware to provide a more flexible
description of what should be rendered. A description of GLSL
itself is outside the scope of this documentation but any good
OpenGL book should help to describe it.

Unlike in OpenGL, when using GLSL with Cogl it is possible to write
short snippets to replace small sections of the pipeline instead of
having to replace the whole of either the vertex or fragment
pipelines. Of course it is also possible to replace the whole of
the pipeline if needed.

Each snippet is a standalone chunk of code which would attach to
the pipeline at a particular point. The code is split into four
separate strings (all of which are optional):

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;declarations&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
The code in this string will be inserted outside of any function in
the global scope of the shader. This can be used to declare
uniforms, attributes, varyings and functions to be used by the
snippet.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;pre&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
The code in this string will be inserted before the hook point.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;post&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
The code in this string will be inserted after the hook point. This
can be used to modify the results of the builtin generated code for
that hook point.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;replace&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
If present the code in this string will replace the generated code
for the hook point.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

All of the strings apart from the declarations string of a pipeline
are generated in a single function so they can share variables
declared from one string in another. The scope of the code is
limited to each snippet so local variables declared in the snippet
will not collide with variables declared in another
snippet. However, code in the 'declarations' string is global to
the shader so it is the application's responsibility to ensure that
variables declared here will not collide with those from other
snippets.

The snippets can be added to a pipeline with
cogl_pipeline_add_snippet() or
cogl_pipeline_add_layer_snippet(). Which function to use depends on
which hook the snippet is targeting. The snippets are all
generated in the order they are added to the pipeline. That is, the
post strings are executed in the order they are added to the
pipeline and the pre strings are executed in reverse order. If any
replace strings are given for a snippet then any other snippets
with the same hook added before that snippet will be ignored. The
different hooks are documented under #CoglSnippetHook.

For portability with GLES2, it is recommended not to use the GLSL
builtin names such as gl_FragColor. Instead there are replacement
names under the cogl_* namespace which can be used instead. These
are:

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_modelview_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The current modelview matrix. This is equivalent to
   #gl_ModelViewMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_projection_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The current projection matrix. This is equivalent to
   #gl_ProjectionMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_modelview_projection_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The combined modelview and projection matrix. A vertex shader
   would typically use this to transform the incoming vertex
   position. The separate modelview and projection matrices are
   usually only needed for lighting calculations. This is
   equivalent to #gl_ModelViewProjectionMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_texture_matrix&lt;/emphasis&gt;[]&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An array of matrices for transforming the texture
   coordinates. This is equivalent to #gl_TextureMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

In a vertex shader, the following are also available:

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_position_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming vertex position. This is equivalent to #gl_Vertex.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_color_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming vertex color. This is equivalent to #gl_Color.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_tex_coord_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for layer 0. This is an alternative name
   for #cogl_tex_coord0_in.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_tex_coord0_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for the layer 0. This is equivalent to
   #gl_MultiTexCoord0. There will also be #cogl_tex_coord1_in and
   so on if more layers are added to the pipeline.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec3
        &lt;emphasis&gt;cogl_normal_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The normal of the vertex. This is equivalent to #gl_Normal.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec4
        &lt;emphasis&gt;cogl_position_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated position of the vertex. This must be written to
   in all vertex shaders. This is equivalent to #gl_Position.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float
        &lt;emphasis&gt;cogl_point_size_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming point size from the cogl_point_size_in attribute.
   This is only available if
   cogl_pipeline_set_per_vertex_point_size() is set on the
   pipeline.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float
        &lt;emphasis&gt;cogl_point_size_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated size of a point. This is equivalent to #gl_PointSize.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
        &lt;emphasis&gt;cogl_color_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
        &lt;emphasis&gt;cogl_tex_coord0_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated texture coordinate for layer 0 of the pipeline.
   This is equivalent to #gl_TexCoord[0]. There will also be
   #cogl_tex_coord1_out and so on if more layers are added to the
   pipeline. In the fragment shader, this varying is called
   #cogl_tex_coord0_in.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

In a fragment shader, the following are also available:

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4 &lt;emphasis&gt;cogl_color_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
             &lt;emphasis&gt;cogl_tex_coord0_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for layer 0. This is equivalent to
   #gl_TexCoord[0]. There will also be #cogl_tex_coord1_in and so
   on if more layers are added to the pipeline.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec4 &lt;emphasis&gt;cogl_color_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The final calculated color of the fragment. All fragment shaders
   must write to this variable. This is equivalent to
   #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float &lt;emphasis&gt;cogl_depth_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An optional output variable specifying the depth value to use
   for this fragment. This is equivalent to #gl_FragDepth.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;bool &lt;emphasis&gt;cogl_front_facing&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   A readonly variable that will be true if the current primitive
   is front facing. This can be used to implement two-sided
   coloring algorithms. This is equivalent to #gl_FrontFacing.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec2 &lt;emphasis&gt;cogl_point_coord&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   When rendering points, this will contain a vec2 which represents
   the position within the point of the current fragment.
   vec2(0.0,0.0) will be the topleft of the point and vec2(1.0,1.0)
   will be the bottom right. Note that there is currently a bug in
   Cogl where when rendering to an offscreen buffer these
   coordinates will be upside-down. The value is undefined when not
   rendering points.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

Here is an example of using a snippet to add a desaturate effect to the
generated color on a pipeline.

&lt;programlisting&gt;
  CoglPipeline *pipeline = cogl_pipeline_new ();

  /&lt;!-- --&gt;* Set up the pipeline here, ie by adding a texture or other
     layers *&lt;!-- --&gt;/

  /&lt;!-- --&gt;* Create the snippet. The first string is the declarations which
     we will use to add a uniform. The second is the 'post' string which
     will contain the code to perform the desaturation. *&lt;!-- --&gt;/
  CoglSnippet *snippet =
    cogl_snippet_new (COGL_SNIPPET_HOOK_FRAGMENT,
                      "uniform float factor;",
                      "float gray = dot (vec3 (0.299, 0.587, 0.114), "
                      "                  cogl_color_out.rgb);"
                      "cogl_color_out.rgb = mix (vec3 (gray),"
                      "                          cogl_color_out.rgb,"
                      "                          factor);");

  /&lt;!-- --&gt;* Add it to the pipeline *&lt;!-- --&gt;/
  cogl_pipeline_add_snippet (pipeline, snippet);
  /&lt;!-- --&gt;* The pipeline keeps a reference to the snippet
     so we don't need to *&lt;!-- --&gt;/
  cogl_object_unref (snippet);

  /&lt;!-- --&gt;* Update the custom uniform on the pipeline *&lt;!-- --&gt;/
  int location = cogl_pipeline_get_uniform_location (pipeline, "factor");
  cogl_pipeline_set_uniform_1f (pipeline, location, 0.5f);

  /&lt;!-- --&gt;* Now we can render with the snippet as usual *&lt;!-- --&gt;/
  cogl_push_source (pipeline);
  cogl_rectangle (0, 0, 10, 10);
  cogl_pop_source ();
&lt;/programlisting&gt;</doc>
    </docsection>
    <docsection name="cogl-texture">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture.h"
           line="62">Cogl allows creating and manipulating textures using a uniform
API that tries to hide all the various complexities of creating,
loading and manipulating textures.</doc>
    </docsection>
    <docsection name="cogl-texture-2d">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture-2d.h"
           line="48">These functions allow low-level 2D textures to be allocated. These
differ from sliced textures for example which may internally be
made up of multiple 2D textures, or atlas textures where Cogl must
internally modify user texture coordinates before they can be used
by the GPU.</doc>
    </docsection>
    <docsection name="cogl-texture-2d-sliced">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture-2d-sliced.h"
           line="38">These functions allow high-level meta textures (See the
#CoglMetaTexture interface) to be allocated that may internally be
comprised of multiple 2D texture "slices" with power-of-two sizes.

This API can be useful when working with GPUs that don't have
native support for non-power-of-two textures or if you want to load
a texture that is larger than the GPUs maximum texture size limits.

The algorithm for slicing works by first trying to map a virtual
size to the next larger power-of-two size and then seeing how many
wasted pixels that would result in. For example if you have a
virtual texture that's 259 texels wide, the next pot size = 512 and
the amount of waste would be 253 texels. If the amount of waste is
above a max-waste threshold then we would next slice that texture
into one that's 256 texels and then looking at how many more texels
remain unallocated after that we choose the next power-of-two size.
For the example of a 259 texel image that would mean having a 256
texel wide texture, leaving 3 texels unallocated so we'd then
create a 4 texel wide texture - now there is only one texel of
waste. The algorithm continues to slice the right most textures
until the amount of waste is less than or equal to a specified
max-waste threshold. The same logic for slicing from left to right
is also applied from top to bottom.</doc>
    </docsection>
    <docsection name="cogl-types">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="50">General types used by various Cogl functions.</doc>
    </docsection>
    <function name="color_equal"
              c:identifier="cogl_color_equal"
              moved-to="Color.equal">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="435">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="448"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="445">%TRUE if the two colors are the same.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="437">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="438">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_init_from_hsl"
              c:identifier="cogl_color_init_from_hsl"
              moved-to="Color.init_from_hsl">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="468">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="479"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="470">return location for a #CoglColor</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="hue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="471">hue value, in the 0 .. 360 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="saturation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="472">saturation value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="luminance" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="473">luminance value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_program"
              c:identifier="cogl_create_program"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="295">Create a new cogl program object that can be used to replace parts of the GL
rendering pipeline with custom code.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="306"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="301">a new cogl program.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
    </function>
    <function name="create_shader"
              c:identifier="cogl_create_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="235">Create a new shader handle, use cogl_shader_source() to set the
source code to be used on it.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="247"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="242">a new shader handle.</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="shader_type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="237">COGL_SHADER_TYPE_VERTEX or COGL_SHADER_TYPE_FRAGMENT.</doc>
          <type name="ShaderType" c:type="CoglShaderType"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_object_foreach_type"
              c:identifier="cogl_debug_object_foreach_type">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-object.h"
           line="202">Invokes @func once for each type of object that Cogl uses and
passes a count of the number of objects for that type. This is
intended to be used solely for debugging purposes to track down
issues with objects leaking.</doc>
      <source-position filename="cogl/cogl/cogl-object.h" line="213"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-object.h"
               line="204">A callback function for each type</doc>
          <type name="DebugObjectForeachTypeCallback"
                c:type="CoglDebugObjectForeachTypeCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-object.h"
               line="205">A pointer to pass to @func</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_object_print_instances"
              c:identifier="cogl_debug_object_print_instances">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-object.h"
           line="216">Prints a list of all the object types that Cogl uses along with the
number of objects of that type that are currently in use. This is
intended to be used solely for debugging purposes to track down
issues with objects leaking.</doc>
      <source-position filename="cogl/cogl/cogl-object.h" line="225"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="egl_texture_2d_new_from_image"
              c:identifier="cogl_egl_texture_2d_new_from_image"
              introspectable="0"
              throws="1">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="245"/>
      <return-value>
        <type name="Texture2D" c:type="CoglTexture2D*"/>
      </return-value>
      <parameters>
        <parameter name="ctx" transfer-ownership="none">
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="image" transfer-ownership="none">
          <type c:type="EGLImageKHR"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <type name="EglImageFlags" c:type="CoglEglImageFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="flush" c:identifier="cogl_flush">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl1-context.h"
           line="65">This function should only need to be called in exceptional circumstances.

As an optimization Cogl drawing functions may batch up primitives
internally, so if you are trying to use raw GL outside of Cogl you stand a
better chance of being successful if you ask Cogl to flush any batched
geometry before making your state changes.

It only ensure that the underlying driver is issued all the commands
necessary to draw the batched primitives. It provides no guarantees about
when the driver will complete the rendering.

This provides no guarantees about the GL state upon returning and to avoid
confusing Cogl you should aim to restore any changes you make before
resuming use of Cogl.

If you are making state changes with the intention of affecting Cogl drawing
primitives you are 100% on your own since you stand a good chance of
conflicting with Cogl internals. For example clutter-gst which currently
uses direct GL calls to bind ARBfp programs will very likely break when Cogl
starts to use ARBfb programs itself for the material API.</doc>
      <source-position filename="cogl/cogl/cogl1-context.h" line="90"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="foreach_feature" c:identifier="cogl_foreach_feature">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="252">Iterates through all the context level features currently supported
for a given @context and for each feature @callback is called.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="263"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="254">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="call"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="255">A #CoglFeatureCallback called for each
           supported feature</doc>
          <type name="FeatureCallback" c:type="CoglFeatureCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="257">Private data to pass to the callback</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_graphics_reset_status"
              c:identifier="cogl_get_graphics_reset_status">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="289">Returns the graphics reset status as reported by
GetGraphicsResetStatusARB defined in the ARB_robustness extension.

Note that Cogl doesn't normally enable the ARB_robustness
extension in which case this will only ever return
#COGL_GRAPHICS_RESET_STATUS_NO_ERROR.

Applications must explicitly use a backend specific method to
request that errors get reported such as X11's
cogl_xlib_renderer_request_reset_on_video_memory_purge().</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="307"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="304">a #CoglGraphicsResetStatus</doc>
        <type name="GraphicsResetStatus" c:type="CoglGraphicsResetStatus"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="291">a #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_proc_address"
              c:identifier="cogl_get_proc_address"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl1-context.h"
           line="47">Gets a pointer to a given GL or GL ES extension function. This acts
as a wrapper around glXGetProcAddress() or whatever is the
appropriate function for the current backend.

&lt;note&gt;This function should not be used to query core opengl API
symbols since eglGetProcAddress for example doesn't allow this and
and may return a junk pointer if you do.&lt;/note&gt;</doc>
      <source-position filename="cogl/cogl/cogl1-context.h" line="63"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl1-context.h"
             line="59">a pointer to the requested function or %NULL if the
  function is not available.</doc>
        <type name="GObject.Callback" c:type="GCallback"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl1-context.h"
               line="49">the name of the function.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_get_type" c:identifier="cogl_handle_get_type">
      <source-position filename="cogl/cogl/cogl-types.h" line="87"/>
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="has_feature" c:identifier="cogl_has_feature">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="207">Checks if a given @feature is currently available

Cogl does not aim to be a lowest common denominator API, it aims to
expose all the interesting features of GPUs to application which
means applications have some responsibility to explicitly check
that certain features are available before depending on them.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="223"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="219">%TRUE if the @feature is currently supported or %FALSE if
not.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="209">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="210">A #CoglFeatureID</doc>
          <type name="FeatureID" c:type="CoglFeatureID"/>
        </parameter>
      </parameters>
    </function>
    <function name="has_features"
              c:identifier="cogl_has_features"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="225">Checks if a list of features are all currently available.

This checks all of the listed features using cogl_has_feature() and
returns %TRUE if all the features are available or %FALSE
otherwise.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="240"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="236">%TRUE if all the features are available, %FALSE
otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="227">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="228">A 0 terminated list of CoglFeatureID&lt;!-- --&gt;s</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="is_bitmap" c:identifier="cogl_is_bitmap">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-bitmap.h"
           line="233">Checks whether @object is a #CoglBitmap</doc>
      <source-position filename="cogl/cogl/cogl-bitmap.h" line="243"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="239">%TRUE if the passed @object represents a bitmap,
  and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="235">a #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_context" c:identifier="cogl_is_context">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="153">Gets whether the given object references an existing context object.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="163"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="159">%TRUE if the @object references a #CoglContext,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="155">An object or %NULL</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_frame_info" c:identifier="cogl_is_frame_info">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-frame-info.h"
           line="64">Gets whether the given object references a #CoglFrameInfo.</doc>
      <source-position filename="cogl/cogl/cogl-frame-info.h" line="74"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="70">%TRUE if the object references a #CoglFrameInfo
  and %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="66">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_framebuffer" c:identifier="cogl_is_framebuffer">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-framebuffer.h"
           line="1283">Gets whether the given object references a #CoglFramebuffer.</doc>
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1293"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1289">%TRUE if the object references a #CoglFramebuffer
  and %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1285">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_pipeline" c:identifier="cogl_is_pipeline">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline.h"
           line="104">Gets whether the given @object references an existing pipeline object.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline.h" line="114"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="110">%TRUE if the @object references a #CoglPipeline,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="106">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_program"
              c:identifier="cogl_is_program"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="308">Gets whether the given handle references an existing program object.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="321"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="314">%TRUE if the handle references a program,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="310">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_shader"
              c:identifier="cogl_is_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="249">Gets whether the given handle references an existing shader object.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="261"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="255">%TRUE if the handle references a shader,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="251">A CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_snippet" c:identifier="cogl_is_snippet">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-snippet.h"
           line="702">Gets whether the given @object references an existing snippet object.</doc>
      <source-position filename="cogl/cogl/cogl-snippet.h" line="712"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="708">%TRUE if the @object references a #CoglSnippet,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="704">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture" c:identifier="cogl_is_texture">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture.h"
           line="108">Gets whether the given object references a texture object.</doc>
      <source-position filename="cogl/cogl/cogl-texture.h" line="118"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="114">%TRUE if the @object references a texture, and
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="110">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_2d" c:identifier="cogl_is_texture_2d">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture-2d.h"
           line="76">Gets whether the given object references an existing #CoglTexture2D
object.</doc>
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="87"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="83">%TRUE if the object references a #CoglTexture2D,
  %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="78">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_2d_sliced"
              c:identifier="cogl_is_texture_2d_sliced">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture-2d-sliced.h"
           line="276">Gets whether the given object references a #CoglTexture2DSliced.</doc>
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="286"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d-sliced.h"
             line="282">%TRUE if the object references a #CoglTexture2DSliced
  and %FALSE otherwise.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d-sliced.h"
               line="278">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_tracing" c:identifier="cogl_is_tracing">
      <source-position filename="cogl/cogl/cogl-trace.h" line="68"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="pixel_format_get_bytes_per_pixel"
              c:identifier="cogl_pixel_format_get_bytes_per_pixel">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="283">Queries the number of bytes per pixel for a given format in the given plane.</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="294"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="291">The number of bytes per pixel in the given format's given plane.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="285">The pixel format</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="plane" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="286">The index of the plane (should not be more than the number of planes
        in the given format).</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_format_get_n_planes"
              c:identifier="cogl_pixel_format_get_n_planes">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="336">Returns the number of planes the given CoglPixelFormat specifies.</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="345"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="342">The no. of planes of @format (at most %COGL_PIXEL_FORMAT_MAX_PLANES)</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="338">The format for which to get the number of planes</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_format_to_string"
              c:identifier="cogl_pixel_format_to_string">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="347">Returns a string representation of @format, useful for debugging purposes.</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="356"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="353">A string representation of @format.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="349">a #CoglPixelFormat</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_attach_shader"
              c:identifier="cogl_program_attach_shader"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="323">Attaches a shader to a program object. A program can have multiple
vertex or fragment shaders but only one of them may provide a
main() function. It is allowed to use a program with only a vertex
shader or only a fragment shader.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="337"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program_handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="325">a #CoglHandle for a shdaer program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="shader_handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="326">a #CoglHandle for a vertex of fragment shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_get_uniform_location"
              c:identifier="cogl_program_get_uniform_location"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="354">Retrieve the location (offset) of a uniform variable in a shader program,
a uniform is a variable that is constant for all vertices/fragments for a
shader object and is possible to modify as an external parameter.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="368"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="363">the offset of a uniform in a specified program.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="356">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="357">the name of a uniform.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_link"
              c:identifier="cogl_program_link"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="340">Links a program making it ready for use. Note that calling this
function is optional. If it is not called the program will
automatically be linked the first time it is used.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="352"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="342">a #CoglHandle for a shader program.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1f"
              c:identifier="cogl_program_set_uniform_1f"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="371">Changes the value of a floating point uniform for the given linked
@program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="384"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="373">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="374">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="376">the new value of the uniform.</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_1i"
              c:identifier="cogl_program_set_uniform_1i"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="388">Changes the value of an integer uniform for the given linked
@program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="401"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="390">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="391">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="393">the new value of the uniform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_float"
              c:identifier="cogl_program_set_uniform_float"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="405">Changes the value of a float vector uniform, or uniform array for
the given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="422"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="407">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="408">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="410">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="412">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="414">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_int"
              c:identifier="cogl_program_set_uniform_int"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="428">Changes the value of a int vector uniform, or uniform array for
the given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="445"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="430">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="431">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="433">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="435">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="437">the new value of the uniform[s].</doc>
          <array length="3" zero-terminated="0" c:type="const int*">
            <type name="gint" c:type="int"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="program_set_uniform_matrix"
              c:identifier="cogl_program_set_uniform_matrix"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="451">Changes the value of a matrix uniform, or uniform array in the
given linked @program.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="469"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="program" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="453">A #CoglHandle for a linked program</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="uniform_location" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="454">the uniform location retrieved from
   cogl_program_get_uniform_location().</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dimensions" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="456">The dimensions of the matrix. So for for example pass
   2 for a 2x2 matrix or 3 for 3x3.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="458">For uniform arrays this is the array length otherwise just
pass 1</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="transpose" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="460">Whether to transpose the matrix when setting the uniform.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="461">the new value of the uniform.</doc>
          <array length="3" zero-terminated="0" c:type="const float*">
            <type name="gfloat" c:type="float"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="scanout_error_quark"
              c:identifier="cogl_scanout_error_quark"
              moved-to="Scanout.error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="set_tracing_disabled_on_thread"
              c:identifier="cogl_set_tracing_disabled_on_thread">
      <source-position filename="cogl/cogl/cogl-trace.h" line="75"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="main_context" transfer-ownership="none">
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_tracing_enabled_on_thread"
              c:identifier="cogl_set_tracing_enabled_on_thread">
      <source-position filename="cogl/cogl/cogl-trace.h" line="71"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="main_context" transfer-ownership="none">
          <type name="GLib.MainContext" c:type="GMainContext*"/>
        </parameter>
        <parameter name="group" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_get_type"
              c:identifier="cogl_shader_get_type"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="281">Retrieves the type of a shader #CoglHandle</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="293"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="287">%COGL_SHADER_TYPE_VERTEX if the shader is a vertex processor
         or %COGL_SHADER_TYPE_FRAGMENT if the shader is a fragment processor</doc>
        <type name="ShaderType" c:type="CoglShaderType"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="283">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="shader_source"
              c:identifier="cogl_shader_source"
              deprecated="1"
              deprecated-version="1.16">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="263">Replaces the current source associated with a shader with a new
one.

Please see &lt;link
linkend="cogl-Shaders-and-Programmable-Pipeline.description"&gt;above&lt;/link&gt;
for a description of the recommended format for the shader code.</doc>
      <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="278"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="shader" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="265">#CoglHandle for a shader.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
        <parameter name="source" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="266">Shader source.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="start_tracing_with_fd"
              c:identifier="cogl_start_tracing_with_fd"
              throws="1">
      <source-position filename="cogl/cogl/cogl-trace.h" line="61"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="start_tracing_with_path"
              c:identifier="cogl_start_tracing_with_path"
              throws="1">
      <source-position filename="cogl/cogl/cogl-trace.h" line="57"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="stop_tracing" c:identifier="cogl_stop_tracing">
      <source-position filename="cogl/cogl/cogl-trace.h" line="65"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="texture_error_quark"
              c:identifier="cogl_texture_error_quark"
              moved-to="Texture.error_quark">
      <source-position filename="cogl/cogl/cogl-texture.h" line="106"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="trace_describe" c:identifier="cogl_trace_describe">
      <source-position filename="cogl/cogl/cogl-trace.h" line="89"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="head" transfer-ownership="none">
          <type name="TraceHead" c:type="CoglTraceHead*"/>
        </parameter>
        <parameter name="description" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="trace_end" c:identifier="cogl_trace_end">
      <source-position filename="cogl/cogl/cogl-trace.h" line="86"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="head" transfer-ownership="none">
          <type name="TraceHead" c:type="CoglTraceHead*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_add_filter"
              c:identifier="cogl_xlib_renderer_add_filter"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-xlib-renderer.h"
           line="91">Adds a callback function that will receive all native events. The
function can stop further processing of the event by return
%COGL_FILTER_REMOVE.</doc>
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="102"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="93">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="94">the callback function</doc>
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="95">user data passed to @func when called</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_display"
              c:identifier="cogl_xlib_renderer_get_display"
              introspectable="0">
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="151"/>
      <return-value>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_get_foreign_display"
              c:identifier="cogl_xlib_renderer_get_foreign_display"
              introspectable="0">
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="129"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-xlib-renderer.h"
             line="124">the foreign Xlib display that will be used by any Xlib based
winsys backend. The display needs to be set with
cogl_xlib_renderer_set_foreign_display() before this function is called.</doc>
        <type c:type="Display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="122">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_handle_event"
              c:identifier="cogl_xlib_renderer_handle_event"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-xlib-renderer.h"
           line="59">This function processes a single event; it can be used to hook into
external event retrieval (for example that done by Clutter or
GDK).</doc>
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="75"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-xlib-renderer.h"
             line="68">#CoglFilterReturn. %COGL_FILTER_REMOVE indicates that
Cogl has internally handled the event and the caller should do no
further processing. %COGL_FILTER_CONTINUE indicates that Cogl is
either not interested in the event, or has used the event to update
internal state without taking any exclusive action.</doc>
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="61">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="62">pointer to an XEvent structure</doc>
          <type c:type="XEvent*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_remove_filter"
              c:identifier="cogl_xlib_renderer_remove_filter"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-xlib-renderer.h"
           line="106">Removes a callback that was previously added with
cogl_xlib_renderer_add_filter().</doc>
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="116"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="108">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" closure="2">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="109">the callback function</doc>
          <type name="XlibFilterFunc" c:type="CoglXlibFilterFunc"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="110">user data given when the callback was installed</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_request_reset_on_video_memory_purge"
              c:identifier="cogl_xlib_renderer_request_reset_on_video_memory_purge"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-xlib-renderer.h"
           line="153">Sets whether Cogl should make use of the
NV_robustness_video_memory_purge extension, if exposed by the
driver, by initializing the GLX context appropriately.

The extension is only useful when running on certain versions of
the NVIDIA driver. Quoting from the spec:

"The NVIDIA OpenGL driver architecture on Linux has a limitation:
 resources located in video memory are not persistent across certain
 events. VT switches, suspend/resume events, and mode switching
 events may erase the contents of video memory. Any resource that
 is located exclusively in video memory, such as framebuffer objects
 (FBOs), will be lost."

"This extension provides a way for applications to discover when video
 memory content has been lost, so that the application can re-populate
 the video memory content as necessary."

"Any driver that exposes this extension is a driver that considers
 video memory to be volatile. Once the driver stack has been
 improved, the extension will no longer be exposed."

cogl_get_graphics_reset_status() needs to be called at least once
every frame to find out if video memory was purged.

Note that this doesn't cause Cogl to enable robust buffer access
but other context reset errors may still happen and be reported via
cogl_get_graphics_reset_status() if external factors cause the
driver to trigger them.

This defaults to %FALSE and is effective only if called before
cogl_display_setup() .</doc>
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="192"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="155">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="enable" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="156">The new value</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_foreign_display"
              c:identifier="cogl_xlib_renderer_set_foreign_display"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-xlib-renderer.h"
           line="131">Sets a foreign Xlib display that Cogl will use for and Xlib based winsys
backend.

Note that calling this function will automatically disable Cogl's
event retrieval. Cogl still needs to see all of the X events so the
application should also use cogl_xlib_renderer_handle_event() if it
uses this function.</doc>
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="144"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="133">a #CoglRenderer</doc>
          <type c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none">
          <type c:type="Display*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
