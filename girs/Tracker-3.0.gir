<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="tracker-sparql-3.0"/>
  <c:include name="libtracker-sparql/tracker-sparql.h"/>
  <namespace name="Tracker"
             version="3.0"
             shared-library="libtracker-sparql-3.0.so.0"
             c:identifier-prefixes="Tracker"
             c:symbol-prefixes="tracker">
    <class name="Batch"
           c:symbol-prefix="batch"
           c:type="TrackerBatch"
           version="3.1"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TrackerBatch"
           glib:get-type="tracker_batch_get_type"
           glib:type-struct="BatchClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-batch.c"
           line="21">`TrackerBatch` executes a series of SPARQL updates and RDF data
insertions within a transaction.

A batch is created with [method@Tracker.SparqlConnection.create_batch].
To add resources use [method@Tracker.Batch.add_resource],
[method@Tracker.Batch.add_sparql] or [method@Batch.add_statement].

When a batch is ready for execution, use [method@Tracker.Batch.execute]
or [method@Tracker.Batch.execute_async]. The batch is executed as a single
transaction, it will succeed or fail entirely.

This object has a single use, after the batch is executed it can
only be finished and freed.

The mapping of blank node labels is global in a `TrackerBatch`,
referencing the same blank node label in different operations in
a batch will resolve to the same resource.</doc>
      <source-position filename="src/libtracker-sparql/tracker-batch.h"
                       line="37"/>
      <method name="add_rdf"
              c:identifier="tracker_batch_add_rdf"
              version="3.6">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="368">Inserts the RDF data contained in @stream as part of @batch.

The RDF data will be inserted in the given @default_graph if one is provided,
or the anonymous graph if @default_graph is %NULL. Any RDF data that has a
graph specified (e.g. using the `GRAPH` clause in the Trig format) will
be inserted in the specified graph instead of @default_graph.

The @flags argument is reserved for future expansions, currently
%TRACKER_DESERIALIZE_FLAGS_NONE must be passed.</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="370">A `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="371">Deserialization flags</doc>
            <type name="DeserializeFlags" c:type="TrackerDeserializeFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="372">RDF format of data in stream</doc>
            <type name="RdfFormat" c:type="TrackerRdfFormat"/>
          </parameter>
          <parameter name="default_graph" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="373">Default graph that will receive the RDF data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="374">Input stream with RDF data</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_resource"
              c:identifier="tracker_batch_add_resource"
              version="3.1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="202">Adds the RDF represented by @resource to @batch.</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="53"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="204">A `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="graph"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="205">RDF graph to insert the resource to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="206">A [class@Tracker.Resource]</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_sparql"
              c:identifier="tracker_batch_add_sparql"
              version="3.1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="180">Adds an SPARQL update string to @batch.</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="49"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="182">A `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="183">A SPARQL update string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_statement"
              c:identifier="tracker_batch_add_statement"
              shadowed-by="add_statementv"
              version="3.5"
              introspectable="0">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="226">Adds a [class@Tracker.SparqlStatement] containing an SPARQL update. The statement will
be executed once in the batch, with the parameters bound as specified in the
variable arguments.

The variable arguments are a NULL terminated set of variable name, type [type@GObject.Type],
and value. The value C type must correspond to the given [type@GObject.Type]. For example, for
a statement that has a single `~name` parameter, it could be given a value for execution
with the following code:

```c
tracker_batch_add_statement (batch, stmt,
                             "name", G_TYPE_STRING, "John Smith",
                             NULL);
```

A [class@Tracker.SparqlStatement] may be used on multiple [method@Tracker.Batch.add_statement]
calls with the same or different values, on the same or different `TrackerBatch`
objects.

This function should only be called on [class@Tracker.SparqlStatement] objects
obtained through [method@Tracker.SparqlConnection.update_statement] or
update statements loaded through [method@Tracker.SparqlConnection.load_statement_from_gresource].</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="58"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="228">a `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="229">a [class@Tracker.SparqlStatement] containing a SPARQL update</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="230">NULL-terminated list of parameters bound to @stmt, in triplets of name, type and value.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="add_statementv"
              c:identifier="tracker_batch_add_statementv"
              shadows="add_statement"
              version="3.5">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="308">Adds a [class@Tracker.SparqlStatement] containing an SPARQL update. The statement will
be executed once in the batch, with the values bound as specified by @variable_names
and @values.

For example, for a statement that has a single `~name` parameter,
it could be given a value for execution with the given code:

```c
const char *names = { "name" };
const GValue values[G_N_ELEMENTS (names)] = { 0, };

g_value_init (&amp;values[0], G_TYPE_STRING);
g_value_set_string (&amp;values[0], "John Smith");
tracker_batch_add_statementv (batch, stmt,
                              G_N_ELEMENTS (names),
                              names, values);
```
```python
batch.add_statement(stmt, ['name'], ['John Smith']);
```
```js
batch.add_statement(stmt, ['name'], ['John Smith']);
```

A [class@Tracker.SparqlStatement] may be used on multiple [method@Tracker.Batch.add_statement]
calls with the same or different values, on the same or different `TrackerBatch`
objects.

This function should only be called on [class@Tracker.SparqlStatement] objects
obtained through [method@Tracker.SparqlConnection.update_statement] or
update statements loaded through [method@Tracker.SparqlConnection.load_statement_from_gresource].</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="63"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="310">A `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="311">A [class@Tracker.SparqlStatement] containing a SPARQL update</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </parameter>
          <parameter name="n_values" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="312">The number of bound parameters</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="variable_names" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="313">The names of each bound parameter</doc>
            <array length="1" zero-terminated="0" c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="values" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="314">The values of each bound parameter</doc>
            <array length="1" zero-terminated="0" c:type="const GValue*">
              <type name="GObject.Value" c:type="GValue"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="execute"
              c:identifier="tracker_batch_execute"
              version="3.1"
              throws="1"
              glib:async-func="execute_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="408">Executes the batch. This operations happens synchronously.</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="77"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-batch.c"
               line="416">%TRUE of there were no errors, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="410">a `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="411">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="execute_async"
              c:identifier="tracker_batch_execute_async"
              version="3.1"
              glib:finish-func="execute_finish"
              glib:sync-func="execute">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="436">Executes the batch. This operation happens asynchronously, when
finished @callback will be executed.</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="82"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="438">A `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="439">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="440">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="442">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="execute_finish"
              c:identifier="tracker_batch_execute_finish"
              version="3.1"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="466">Finishes the operation started with [method@Tracker.Batch.execute_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="88"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-batch.c"
               line="474">%TRUE of there were no errors, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="468">A `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="469">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tracker_batch_get_connection"
              glib:get-property="connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="161">Returns the [class@Tracker.SparqlConnection] that this batch was created
from.</doc>
        <source-position filename="src/libtracker-sparql/tracker-batch.h"
                         line="46"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-batch.c"
               line="168">The SPARQL connection of this batch.</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="batch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-batch.c"
                 line="163">A `TrackerBatch`</doc>
            <type name="Batch" c:type="TrackerBatch*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-batch.c"
             line="130">The [class@Tracker.SparqlConnection] the batch belongs to.</doc>
        <type name="SparqlConnection"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="BatchClass"
            c:type="TrackerBatchClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Batch">
      <source-position filename="src/libtracker-sparql/tracker-batch.h"
                       line="37"/>
    </record>
    <function-macro name="CHECK_VERSION"
                    c:identifier="TRACKER_CHECK_VERSION"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-version.h"
           line="214">This macro essentially does the same thing as
tracker_check_version() but as a pre-processor operation rather
than a run-time operation. It will evaluate true or false based the
version passed in and the version available.

&lt;example&gt;
&lt;title&gt;Simple version check example&lt;/title&gt;
An example of how to make sure you have the version of Tracker
installed to run your code.
&lt;programlisting&gt;
if (!TRACKER_CHECK_VERSION (0, 10, 7)) {
        g_error ("Tracker version 0.10.7 or above is needed");
}
&lt;/programlisting&gt;
&lt;/example&gt;</doc>
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="236"/>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-version.h"
               line="216">the required major version.</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-version.h"
               line="217">the required minor version.</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-version.h"
               line="218">the required micro version.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_1_FOR"
                    c:identifier="TRACKER_DEPRECATED_IN_3_1_FOR"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="67"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_2_FOR"
                    c:identifier="TRACKER_DEPRECATED_IN_3_2_FOR"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="82"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_3_FOR"
                    c:identifier="TRACKER_DEPRECATED_IN_3_3_FOR"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="97"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_4_FOR"
                    c:identifier="TRACKER_DEPRECATED_IN_3_4_FOR"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="112"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_5_FOR"
                    c:identifier="TRACKER_DEPRECATED_IN_3_5_FOR"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="127"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_6_FOR"
                    c:identifier="TRACKER_DEPRECATED_IN_3_6_FOR"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="142"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_3_7_FOR"
                    c:identifier="TRACKER_DEPRECATED_IN_3_7_FOR"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="157"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="DeserializeFlags"
                 glib:type-name="TrackerDeserializeFlags"
                 glib:get-type="tracker_deserialize_flags_get_type"
                 c:type="TrackerDeserializeFlags">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-connection.h"
           line="68">Flags affecting deserialization from a RDF data format.</doc>
      <member name="none"
              value="0"
              c:identifier="TRACKER_DESERIALIZE_FLAGS_NONE"
              glib:nick="none"
              glib:name="TRACKER_DESERIALIZE_FLAGS_NONE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="70">No flags.</doc>
      </member>
    </enumeration>
    <function-macro name="ENDPOINT_DBUS"
                    c:identifier="TRACKER_ENDPOINT_DBUS"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-endpoint-dbus.h"
                       line="35"/>
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENDPOINT_DBUS_CLASS"
                    c:identifier="TRACKER_ENDPOINT_DBUS_CLASS"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-endpoint-dbus.h"
                       line="36"/>
      <parameters>
        <parameter name="c">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENDPOINT_DBUS_GET_CLASS"
                    c:identifier="TRACKER_ENDPOINT_DBUS_GET_CLASS"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-endpoint-dbus.h"
                       line="39"/>
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ENDPOINT_HTTP"
                    c:identifier="TRACKER_ENDPOINT_HTTP"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-endpoint-http.h"
                       line="35"/>
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Endpoint"
           c:symbol-prefix="endpoint"
           c:type="TrackerEndpoint"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TrackerEndpoint"
           glib:get-type="tracker_endpoint_get_type"
           glib:type-struct="EndpointClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-endpoint.c"
           line="56">`TrackerEndpoint` is a helper object to make RDF triple stores represented
by a [class@Tracker.SparqlConnection] publicly available to other processes/hosts.

This is a base abstract object, see [class@Tracker.EndpointDBus] to make
RDF triple stores available to other processes in the same machine, and
[class@Tracker.EndpointHttp] to make it available to other hosts in the
network.

When the RDF triple store represented by a [class@Tracker.SparqlConnection]
is made public this way, other peers may connect to the database using
[ctor@Tracker.SparqlConnection.bus_new] or [ctor@Tracker.SparqlConnection.remote_new]
to access this endpoint exclusively, or they may use the `SERVICE &lt;uri&gt; { ... }` SPARQL
syntax from their own [class@Tracker.SparqlConnection]s to expand their data set.

By default, and as long as the underlying [class@Tracker.SparqlConnection]
allows SPARQL updates and RDF graph changes, endpoints will allow updates
and modifications to happen through them. Use [method@Tracker.Endpoint.set_readonly]
to change this behavior.

By default, endpoints allow access to every RDF graph in the triple store
and further external SPARQL endpoints to the queries performed on it. Use
[method@Tracker.Endpoint.set_allowed_graphs] and
[method@Tracker.Endpoint.set_allowed_services] to change this behavior. Users do
not typically need to do this for D-Bus endpoints, as these do already have a layer
of protection with the Tracker portal. This is the mechanism used by the portal
itself. This access control API may not interoperate with other SPARQL endpoint
implementations than Tracker.</doc>
      <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                       line="37"/>
      <method name="get_allowed_graphs"
              c:identifier="tracker_endpoint_get_allowed_graphs"
              glib:get-property="allowed-graphs"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="579">Returns the list of RDF graphs that the endpoint allows
access for.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                         line="61"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-endpoint.c"
               line="586">The list of allowed RDF graphs</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="endpoint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="581">The endpoint</doc>
            <type name="Endpoint" c:type="TrackerEndpoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_allowed_services"
              c:identifier="tracker_endpoint_get_allowed_services"
              glib:get-property="allowed-services"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="520">Returns the list of external SPARQL endpoints that are
allowed to be accessed through this endpoint.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                         line="54"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-endpoint.c"
               line="527">The list of allowed services</doc>
          <array c:type="GStrv">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="endpoint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="522">The endpoint</doc>
            <type name="Endpoint" c:type="TrackerEndpoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_readonly"
              c:identifier="tracker_endpoint_get_readonly"
              glib:get-property="readonly"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="458">Returns whether the endpoint is readonly, thus SPARQL update
queries are disallowed.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                         line="47"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-endpoint.c"
               line="465">%TRUE if the endpoint is readonly</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="endpoint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="460">The endpoint</doc>
            <type name="Endpoint" c:type="TrackerEndpoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sparql_connection"
              c:identifier="tracker_endpoint_get_sparql_connection"
              glib:get-property="sparql-connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="413">Returns the [class@Tracker.SparqlConnection] that this endpoint proxies
to a wider audience.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                         line="40"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-endpoint.c"
               line="420">The proxied SPARQL connection</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="endpoint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="415">a `TrackerEndpoint`</doc>
            <type name="Endpoint" c:type="TrackerEndpoint*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_allowed_graphs"
              c:identifier="tracker_endpoint_set_allowed_graphs"
              glib:set-property="allowed-graphs"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="542">Sets the list of RDF graphs that this endpoint will allow access
for. Any explicit (e.g. `GRAPH` keyword) or implicit (e.g. through the
default anonymous graph) access to RDF graphs unespecified in this
list in SPARQL queries will be seen as if those graphs did not exist, or
(equivalently) had an empty set. Changes to these graphs through SPARQL
updates will also be disallowed.

If @graphs is %NULL, access will be allowed to every RDF graph stored
in the endpoint, this is the default behavior. If you want to forbid access
to all RDF graphs, use an empty list.

The empty string (`""`) is allowed as a special value, to allow access
to the stock anonymous graph. All graph names are otherwise dependent
on the endpoint and its contained data.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                         line="57"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="endpoint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="544">The endpoint</doc>
            <type name="Endpoint" c:type="TrackerEndpoint*"/>
          </instance-parameter>
          <parameter name="graphs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="545">List of allowed graphs, or %NULL to allow all graphs</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_allowed_services"
              c:identifier="tracker_endpoint_set_allowed_services"
              glib:set-property="allowed-services"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="480">Sets the list of external SPARQL endpoints that this endpoint
will allow access for. Access through the `SERVICE` SPARQL syntax
will fail for services not specified in this list.

If @services is %NULL, access will be allowed to every external endpoint,
this is the default behavior. If you want to forbid access to all
external SPARQL endpoints, use an empty list.

This affects both remote SPARQL endpoints accessed through HTTP,
and external SPARQL endpoints offered through D-Bus. For the latter,
the following syntax is allowed to describe them as an URI:

`DBUS_URI = 'dbus:' [ ('system' | 'session') ':' ]? dbus-name [ ':' object-path ]?`

If the system/session part is omitted, it will default to the session
bus. If the object path is omitted, the `/org/freedesktop/Tracker3/Endpoint`
[class@Tracker.EndpointDBus] default will be assumed.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                         line="50"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="endpoint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="482">The endpoint</doc>
            <type name="Endpoint" c:type="TrackerEndpoint*"/>
          </instance-parameter>
          <parameter name="services" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="483">List of allowed services, or %NULL to allow all services</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_readonly"
              c:identifier="tracker_endpoint_set_readonly"
              glib:set-property="readonly"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="430">Sets whether the endpoint will be readonly. Readonly endpoints
will not allow SPARQL update queries. The underlying
[class@Tracker.SparqlConnection] may be readonly of its own, this
method does not change its behavior in any way.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                         line="43"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="endpoint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="432">The endpoint</doc>
            <type name="Endpoint" c:type="TrackerEndpoint*"/>
          </instance-parameter>
          <parameter name="readonly" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint.c"
                 line="433">Whether the endpoint will be readonly</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="allowed-graphs"
                version="3.7"
                writable="1"
                transfer-ownership="none"
                setter="set_allowed_graphs"
                getter="get_allowed_graphs">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="214">RDF graphs that are allowed to be accessed
through queries to this endpoint. See
tracker_endpoint_set_allowed_graphs().</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="allowed-services"
                version="3.7"
                writable="1"
                transfer-ownership="none"
                setter="set_allowed_services"
                getter="get_allowed_services">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="199">External SPARQL endpoints that are allowed to be
accessed through queries to this endpint. See
tracker_endpoint_set_allowed_services().</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="readonly"
                version="3.7"
                writable="1"
                transfer-ownership="none"
                setter="set_readonly"
                getter="get_readonly"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="184">Whether the endpoint allows SPARQL updates or not. See
tracker_endpoint_set_readonly().</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="sparql-connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_sparql_connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint.c"
             line="173">The [class@Tracker.SparqlConnection] being proxied by this endpoint.</doc>
        <type name="SparqlConnection"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="EndpointClass"
            c:type="TrackerEndpointClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Endpoint">
      <source-position filename="src/libtracker-sparql/tracker-endpoint.h"
                       line="37"/>
    </record>
    <class name="EndpointDBus"
           c:symbol-prefix="endpoint_dbus"
           c:type="TrackerEndpointDBus"
           parent="Endpoint"
           glib:type-name="TrackerEndpointDBus"
           glib:get-type="tracker_endpoint_dbus_get_type">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
           line="22">`TrackerEndpointDBus` makes the RDF data in a [class@Tracker.SparqlConnection]
accessible to other processes via DBus.

This object is a [class@Tracker.Endpoint] subclass that exports
a [class@Tracker.SparqlConnection] so its RDF data is accessible to other
processes through the given [class@Gio.DBusConnection].

```c
// This process already has org.example.Endpoint bus name
endpoint = tracker_endpoint_dbus_new (sparql_connection,
                                      dbus_connection,
                                      NULL,
                                      NULL,
                                      &amp;error);

// From another process
connection = tracker_sparql_connection_bus_new ("org.example.Endpoint",
                                                NULL,
                                                dbus_connection,
                                                &amp;error);
```

The `TrackerEndpointDBus` will manage a DBus object at the given path
with the `org.freedesktop.Tracker3.Endpoint` interface, if no path is
given the object will be at the default `/org/freedesktop/Tracker3/Endpoint`
location.

Access to D-Bus endpoints may be managed via the
[signal@Tracker.EndpointDBus::block-call] signal, the boolean
return value expressing whether the request is blocked or not.
Inspection of the requester address is left up to the user. The
default value allows all requests independently of their provenance.

However, moderating access to D-Bus interfaces is typically not necessary
in user code, as access to public D-Bus endpoints will be transparently
managed through the Tracker portal service for applications sandboxed
via XDG portals. These already have access to D-Bus SPARQL endpoints and
their data naturally filtered as defined in the application manifest.

A `TrackerEndpointDBus` may be created on a different thread/main
context from the one that created [class@Tracker.SparqlConnection].</doc>
      <implements name="Gio.Initable"/>
      <constructor name="new"
                   c:identifier="tracker_endpoint_dbus_new"
                   throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
             line="1201">Registers a Tracker endpoint object at @object_path on @dbus_connection.
The default object path is `/org/freedesktop/Tracker3/Endpoint`.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint-dbus.h"
                         line="50"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
               line="1212">a `TrackerEndpointDBus` object.</doc>
          <type name="EndpointDBus" c:type="TrackerEndpointDBus*"/>
        </return-value>
        <parameters>
          <parameter name="sparql_connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
                 line="1203">The [class@Tracker.SparqlConnection] being made public</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </parameter>
          <parameter name="dbus_connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
                 line="1204">#GDBusConnection to expose the DBus object over</doc>
            <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="object_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
                 line="1205">The object path to use, or %NULL to use the default</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
                 line="1206">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="dbus-connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
             line="1169">The [class@Gio.DBusConnection] where the connection is proxied through.</doc>
        <type name="Gio.DBusConnection"/>
      </property>
      <property name="object-path"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint-dbus.c"
             line="1180">The DBus object path that this endpoint manages.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <glib:signal name="block-call">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <class name="EndpointHttp"
           c:symbol-prefix="endpoint_http"
           c:type="TrackerEndpointHttp"
           version="3.1"
           parent="Endpoint"
           glib:type-name="TrackerEndpointHttp"
           glib:get-type="tracker_endpoint_http_get_type">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-endpoint-http.c"
           line="22">`TrackerEndpointHttp` makes the RDF data in a [class@Tracker.SparqlConnection]
accessible to other hosts via HTTP.

This object is a [class@Tracker.Endpoint] subclass that exports
a [class@Tracker.SparqlConnection] so its RDF data is accessible via HTTP
requests on the given port. This endpoint implementation is compliant
with the [SPARQL protocol specifications](https://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/)
and may interoperate with other implementations.

```c
// This host has "example.local" hostname
endpoint = tracker_endpoint_http_new (sparql_connection,
                                      8080,
                                      tls_certificate,
                                      NULL,
                                      &amp;error);

// From another host
connection = tracker_sparql_connection_remote_new ("http://example.local:8080/sparql");
```

Access to HTTP endpoints may be managed via the
[signal@Tracker.EndpointHttp::block-remote-address] signal, the boolean
return value expressing whether the connection is blocked or not.
Inspection of the requester address is left up to the user. The
default value allows all requests independently of their provenance,
users are encouraged to add a handler.

If the provided [class@Gio.TlsCertificate] is %NULL, the endpoint will allow
plain HTTP connections. Users are encouraged to provide a certificate
in order to use HTTPS.

As a security measure, and in compliance specifications,
the HTTP endpoint does not handle database updates or modifications in any
way. The database content is considered to be entirely managed by the
process that creates the HTTP endpoint and owns the [class@Tracker.SparqlConnection].

A `TrackerEndpointHttp` may be created on a different thread/main
context from the one that created [class@Tracker.SparqlConnection].</doc>
      <implements name="Gio.Initable"/>
      <constructor name="new"
                   c:identifier="tracker_endpoint_http_new"
                   version="3.1"
                   throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint-http.c"
             line="462">Sets up a Tracker endpoint to listen via HTTP, in the given @port.
If @certificate is not %NULL, HTTPS may be used to connect to the
endpoint.</doc>
        <source-position filename="src/libtracker-sparql/tracker-endpoint-http.h"
                         line="46"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-endpoint-http.c"
               line="474">a `TrackerEndpointHttp` object.</doc>
          <type name="EndpointHttp" c:type="TrackerEndpointHttp*"/>
        </return-value>
        <parameters>
          <parameter name="sparql_connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-http.c"
                 line="464">The [class@Tracker.SparqlConnection] being made public</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-http.c"
                 line="465">HTTP port to handle incoming requests</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="certificate"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-http.c"
                 line="466">Optional [type@Gio.TlsCertificate] to use for encription</doc>
            <type name="Gio.TlsCertificate" c:type="GTlsCertificate*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-http.c"
                 line="467">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <property name="http-certificate"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint-http.c"
             line="441">[class@Gio.TlsCertificate] to encrypt the communication.</doc>
        <type name="Gio.TlsCertificate"/>
      </property>
      <property name="http-port"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="8080">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint-http.c"
             line="429">HTTP port used to listen requests.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <glib:signal name="block-remote-address">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-endpoint-http.c"
             line="411">Allows control over the connections stablished. The given
address is that of the requesting peer.

Returning %FALSE in this handler allows the connection,
returning %TRUE blocks it. The default with no signal
handlers connected is %FALSE.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="address" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-endpoint-http.c"
                 line="414">The socket address of the remote connection</doc>
            <type name="Gio.SocketAddress"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <function-macro name="IS_ENDPOINT_DBUS"
                    c:identifier="TRACKER_IS_ENDPOINT_DBUS"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-endpoint-dbus.h"
                       line="37"/>
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ENDPOINT_DBUS_CLASS"
                    c:identifier="TRACKER_IS_ENDPOINT_DBUS_CLASS"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-endpoint-dbus.h"
                       line="38"/>
      <parameters>
        <parameter name="c">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ENDPOINT_HTTP"
                    c:identifier="TRACKER_IS_ENDPOINT_HTTP"
                    introspectable="0">
      <source-position filename="src/libtracker-sparql/tracker-endpoint-http.h"
                       line="36"/>
      <parameters>
        <parameter name="o">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="MAJOR_VERSION" value="3" c:type="TRACKER_MAJOR_VERSION">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-version-generated.h"
           line="3">The major version of the Tracker library.

Like #tracker_major_version, but intended to be used at application compile time.</doc>
      <source-position filename="src/libtracker-sparql/tracker-version-generated.h"
                       line="10"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="3" c:type="TRACKER_MICRO_VERSION">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-version-generated.h"
           line="21">The micro version of the Tracker library.

Like #tracker_micro_version, but intended to be used at application compile time.</doc>
      <source-position filename="src/libtracker-sparql/tracker-version-generated.h"
                       line="28"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="7" c:type="TRACKER_MINOR_VERSION">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-version-generated.h"
           line="12">The minor version of the Tracker library.

Like #tracker_minor_version, but intended to be used at application compile time.</doc>
      <source-position filename="src/libtracker-sparql/tracker-version-generated.h"
                       line="19"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="NamespaceManager"
           c:symbol-prefix="namespace_manager"
           c:type="TrackerNamespaceManager"
           parent="GObject.Object"
           glib:type-name="TrackerNamespaceManager"
           glib:get-type="tracker_namespace_manager_get_type"
           glib:type-struct="NamespaceManagerClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-namespace-manager.c"
           line="49">`TrackerNamespaceManager` object represents a mapping between namespaces and
their shortened prefixes.

This object keeps track of namespaces, and allows you to assign
short prefixes for them to avoid frequent use of full namespace IRIs. The syntax
used is that of [Compact URIs (CURIEs)](https://www.w3.org/TR/2010/NOTE-curie-20101216).

Usually you will want to use a namespace manager obtained through
[method@Tracker.SparqlConnection.get_namespace_manager] from the
[class@Tracker.SparqlConnection] that manages the RDF data, as that will
contain all prefixes and namespaces that are pre-defined by its ontology.</doc>
      <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                       line="35"/>
      <constructor name="new" c:identifier="tracker_namespace_manager_new">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="99">Creates a new, empty `TrackerNamespaceManager` instance.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="38"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-namespace-manager.c"
               line="104">a new `TrackerNamespaceManager` instance</doc>
          <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
        </return-value>
      </constructor>
      <function name="get_default"
                c:identifier="tracker_namespace_manager_get_default"
                deprecated="1"
                deprecated-version="3.3">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="116">Returns the global `TrackerNamespaceManager` that contains a set of well-known
namespaces and prefixes, such as `rdf:`, `rdfs:`, `nie:`, `tracker:`, etc.

Note that the list of prefixes and namespaces is hardcoded in
libtracker-sparql. It may not correspond with the installed set of
ontologies, if they have been modified since they were installed.</doc>
        <doc-deprecated xml:space="preserve">Use [method@Tracker.SparqlConnection.get_namespace_manager] instead.</doc-deprecated>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="40"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-namespace-manager.c"
               line="126">a global, shared `TrackerNamespaceManager` instance</doc>
          <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
        </return-value>
      </function>
      <method name="add_prefix"
              c:identifier="tracker_namespace_manager_add_prefix">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="208">Adds @prefix as the recognised abbreviaton of @namespace.

Only one prefix is allowed for a given namespace, and all prefixes must
be unique.

Since 3.3, The `TrackerNamespaceManager` instances obtained through
[method@Tracker.SparqlConnection.get_namespace_manager] are "sealed",
this API call should not performed on those.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="54"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="210">A `TrackerNamespaceManager`</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="211">a short, unique prefix to identify @namespace</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="ns" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="212">the URL of the given namespace</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="compress_uri"
              c:identifier="tracker_namespace_manager_compress_uri"
              version="3.3">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="313">If @uri begins with one of the namespaces known to this
`TrackerNamespaceManager`, then the return value will be the
compressed URI. Otherwise, %NULL will be returned.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="46"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-namespace-manager.c"
               line="322">(nullable): the compressed URI</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="315">a `TrackerNamespaceManager`</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </instance-parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="316">a URI or compact URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="expand_uri"
              c:identifier="tracker_namespace_manager_expand_uri">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="269">If @compact_uri begins with one of the prefixes known to this
`TrackerNamespaceManager`, then the return value will be the
expanded URI. Otherwise, a copy of @compact_uri will be returned.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="43"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-namespace-manager.c"
               line="278">The possibly expanded URI in a newly-allocated string.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="271">a `TrackerNamespaceManager`</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </instance-parameter>
          <parameter name="compact_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="272">a URI or compact URI</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="tracker_namespace_manager_foreach">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="391">Calls @func for each known prefix / URI pair.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="60"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="393">a `TrackerNamespaceManager`</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="394">the function to call for each prefix / URI pair</doc>
            <type name="GLib.HFunc" c:type="GHFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="395">user data to pass to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_prefix"
              c:identifier="tracker_namespace_manager_has_prefix">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="163">Returns whether @prefix is known.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="49"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-namespace-manager.c"
               line="170">%TRUE if the `TrackerNamespaceManager` knows about @prefix, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="165">a `TrackerNamespaceManager`</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="166">a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_prefix"
              c:identifier="tracker_namespace_manager_lookup_prefix">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="185">Looks up the namespace URI corresponding to @prefix, or %NULL if the prefix
is not known.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="51"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-namespace-manager.c"
               line="193">a string owned by the `TrackerNamespaceManager`, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="187">a `TrackerNamespaceManager`</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </instance-parameter>
          <parameter name="prefix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="188">a string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print_turtle"
              c:identifier="tracker_namespace_manager_print_turtle">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-namespace-manager.c"
             line="359">Writes out all namespaces as `@prefix` statements in
the [Turtle](https://www.w3.org/TR/turtle/) RDF format.</doc>
        <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                         line="57"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-namespace-manager.c"
               line="366">a newly-allocated string</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-namespace-manager.c"
                 line="361">a `TrackerNamespaceManager`</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="NamespaceManagerClass"
            c:type="TrackerNamespaceManagerClass"
            glib:is-gtype-struct-for="NamespaceManager">
      <source-position filename="src/libtracker-sparql/tracker-namespace-manager.h"
                       line="35"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="Notifier"
           c:symbol-prefix="notifier"
           c:type="TrackerNotifier"
           parent="GObject.Object"
           glib:type-name="TrackerNotifier"
           glib:get-type="tracker_notifier_get_type"
           glib:type-struct="NotifierClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-notifier.c"
           line="20">`TrackerNotifier` allows receiving notification on changes
in the data stored by a [class@Tracker.SparqlConnection].

This object may be created through [method@Tracker.SparqlConnection.create_notifier],
events can then be listened for by connecting to the
[signal@Tracker.Notifier::events] signal.

Not every change is notified, only RDF resources with a
class that has the [nrl:notify](nrl-ontology.html#nrl:notify)
property defined by the ontology will be notified upon changes.

Database changes are communicated through [struct@Tracker.NotifierEvent] events on
individual graph/resource pairs. The event type obtained through
[method@Tracker.NotifierEvent.get_event_type] will determine the type of event.
Insertion of new resources is notified through
%TRACKER_NOTIFIER_EVENT_CREATE events, deletion of
resources is notified through %TRACKER_NOTIFIER_EVENT_DELETE
events, and changes on any property of the resource is notified
through %TRACKER_NOTIFIER_EVENT_UPDATE events.

The events happen in reaction to database changes, after a `TrackerNotifier`
received an event of type %TRACKER_NOTIFIER_EVENT_DELETE, the resource will
not exist anymore and only the information in the [struct@Tracker.NotifierEvent]
will remain.

Similarly, when receiving an event of type %TRACKER_NOTIFIER_EVENT_UPDATE,
the resource will have already changed, so the data previous to the update is
no longer available.

The [signal@Tracker.Notifier::events] signal is emitted in the thread-default
main context of the thread where the `TrackerNotifier` instance was created.</doc>
      <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                       line="36"/>
      <method name="signal_subscribe"
              c:identifier="tracker_notifier_signal_subscribe">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.c"
             line="845">Listens to notification events from a remote DBus SPARQL endpoint.

If @connection refers to a message bus (system/session), @service must refer
to a D-Bus name (either unique or well-known). If @connection is a non-message
bus (e.g. a peer-to-peer D-Bus connection) the @service argument may be %NULL.

If the @object_path argument is %NULL, the default
`/org/freedesktop/Tracker3/Endpoint` path will be
used. If @graph is %NULL, all graphs will be listened for.

The signal subscription can be removed with
[method@Tracker.Notifier.signal_unsubscribe].

Note that this call is not necessary to receive notifications on
a connection obtained through [ctor@Tracker.SparqlConnection.bus_new],
only to listen to update notifications from additional DBus endpoints.</doc>
        <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                         line="61"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-notifier.c"
               line="870">An ID for this subscription</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="notifier" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="847">A `TrackerNotifier`</doc>
            <type name="Notifier" c:type="TrackerNotifier*"/>
          </instance-parameter>
          <parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="848">A [class@Gio.DBusConnection]</doc>
            <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="849">DBus service name to subscribe to events for, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="850">DBus object path to subscribe to events for, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="graph"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="851">Graph to listen events for, or %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="signal_unsubscribe"
              c:identifier="tracker_notifier_signal_unsubscribe">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.c"
             line="935">Undoes a signal subscription done through [method@Tracker.Notifier.signal_subscribe].

The @handler_id argument was previously obtained during signal subscription creation.</doc>
        <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                         line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notifier" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="937">A `TrackerNotifier`</doc>
            <type name="Notifier" c:type="TrackerNotifier*"/>
          </instance-parameter>
          <parameter name="handler_id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="938">A signal subscription handler ID</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <property name="connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.c"
             line="815">SPARQL connection to listen to.</doc>
        <type name="SparqlConnection"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="events">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.c"
             line="796">Notifies of changes in the Tracker database.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="799">The SPARQL service that originated the events, %NULL for the local store</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="graph" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="800">The graph where the events happened on, %NULL for the default anonymous graph</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="events" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="801">A [type@GLib.PtrArray] of [struct@Tracker.NotifierEvent]</doc>
            <array name="GLib.PtrArray">
              <type name="NotifierEvent"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="NotifierClass"
            c:type="TrackerNotifierClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Notifier">
      <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                       line="36"/>
    </record>
    <record name="NotifierEvent"
            c:type="TrackerNotifierEvent"
            opaque="1"
            glib:type-name="TrackerNotifierEvent"
            glib:get-type="tracker_notifier_event_get_type"
            c:symbol-prefix="notifier_event">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-notifier.h"
           line="38">The &lt;structname&gt;TrackerNotifierEvent&lt;/structname&gt; struct represents a
change event in the stored data.</doc>
      <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                       line="44"/>
      <method name="get_event_type"
              c:identifier="tracker_notifier_event_get_event_type">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.c"
             line="968">Returns the event type.</doc>
        <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                         line="75"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-notifier.c"
               line="974">The event type</doc>
          <type name="NotifierEventType" c:type="TrackerNotifierEventType"/>
        </return-value>
        <parameters>
          <instance-parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="970">A `TrackerNotifierEvent`</doc>
            <type name="NotifierEvent" c:type="TrackerNotifierEvent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_id" c:identifier="tracker_notifier_event_get_id">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.c"
             line="983">Returns the tracker:id of the element being notified upon. This is a #gint64
which is used as efficient internal identifier for the resource.</doc>
        <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                         line="77"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-notifier.c"
               line="990">the resource ID</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="985">A `TrackerNotifierEvent`</doc>
            <type name="NotifierEvent" c:type="TrackerNotifierEvent*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_urn" c:identifier="tracker_notifier_event_get_urn">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.c"
             line="999">Returns the Uniform Resource Name of the element. This is Tracker's
public identifier for the resource.

This URN is an unique string identifier for the resource being
notified upon, typically of the form `urn:uuid:...`.</doc>
        <source-position filename="src/libtracker-sparql/tracker-notifier.h"
                         line="79"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-notifier.c"
               line="1009">The element URN</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-notifier.c"
                 line="1001">A `TrackerNotifierEvent`</doc>
            <type name="NotifierEvent" c:type="TrackerNotifierEvent*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="NotifierEventType"
                 glib:type-name="TrackerNotifierEventType"
                 glib:get-type="tracker_notifier_event_type_get_type"
                 c:type="TrackerNotifierEventType">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-notifier.h"
           line="46">Notifier event types.</doc>
      <member name="create"
              value="0"
              c:identifier="TRACKER_NOTIFIER_EVENT_CREATE"
              glib:nick="create"
              glib:name="TRACKER_NOTIFIER_EVENT_CREATE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.h"
             line="48">An element was created.</doc>
      </member>
      <member name="delete"
              value="1"
              c:identifier="TRACKER_NOTIFIER_EVENT_DELETE"
              glib:nick="delete"
              glib:name="TRACKER_NOTIFIER_EVENT_DELETE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.h"
             line="49">An element was deleted.</doc>
      </member>
      <member name="update"
              value="2"
              c:identifier="TRACKER_NOTIFIER_EVENT_UPDATE"
              glib:nick="update"
              glib:name="TRACKER_NOTIFIER_EVENT_UPDATE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-notifier.h"
             line="50">An element was updated.</doc>
      </member>
    </enumeration>
    <constant name="PREFIX_DC"
              value="http://purl.org/dc/elements/1.1/"
              c:type="TRACKER_PREFIX_DC">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="60">The Prefix of the DC (Dublin Core) namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="65"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_MFO"
              value="http://tracker.api.gnome.org/ontology/v3/mfo#"
              c:type="TRACKER_PREFIX_MFO">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="113">The Prefix of the MFO namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="118"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_NAO"
              value="http://tracker.api.gnome.org/ontology/v3/nao#"
              c:type="TRACKER_PREFIX_NAO">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="90">The Prefix of the NAO namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="95"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_NCO"
              value="http://tracker.api.gnome.org/ontology/v3/nco#"
              c:type="TRACKER_PREFIX_NCO">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="83">The Prefix of the NCO namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="88"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_NFO"
              value="http://tracker.api.gnome.org/ontology/v3/nfo#"
              c:type="TRACKER_PREFIX_NFO">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="97">The Prefix of the NFO namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="102"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_NIE"
              value="http://tracker.api.gnome.org/ontology/v3/nie#"
              c:type="TRACKER_PREFIX_NIE">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="76">The Prefix of the NIE namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="81"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_NMM"
              value="http://tracker.api.gnome.org/ontology/v3/nmm#"
              c:type="TRACKER_PREFIX_NMM">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="104">The Prefix of the RDF namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="109"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_NRL"
              value="http://tracker.api.gnome.org/ontology/v3/nrl#"
              c:type="TRACKER_PREFIX_NRL">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="69">The Prefix of the NRL namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="74"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_OSINFO"
              value="http://tracker.api.gnome.org/ontology/v3/osinfo#"
              c:type="TRACKER_PREFIX_OSINFO">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="127">The Prefix of the Osinfo namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="132"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_RDF"
              value="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
              c:type="TRACKER_PREFIX_RDF">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="32">The Prefix of the RDF namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="37"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_RDFS"
              value="http://www.w3.org/2000/01/rdf-schema#"
              c:type="TRACKER_PREFIX_RDFS">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="39">The Prefix of the RDFS namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="44"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_SLO"
              value="http://tracker.api.gnome.org/ontology/v3/slo#"
              c:type="TRACKER_PREFIX_SLO">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="120">The Prefix of the SLO namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="125"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_TRACKER"
              value="http://tracker.api.gnome.org/ontology/v3/tracker#"
              c:type="TRACKER_PREFIX_TRACKER">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="53">The Prefix of the Tracker namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="58"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="PREFIX_XSD"
              value="http://www.w3.org/2001/XMLSchema#"
              c:type="TRACKER_PREFIX_XSD">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-ontologies.h"
           line="46">The Prefix of the XSD namespace</doc>
      <source-position filename="src/libtracker-sparql/tracker-ontologies.h"
                       line="51"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <enumeration name="RdfFormat"
                 glib:type-name="TrackerRdfFormat"
                 glib:get-type="tracker_rdf_format_get_type"
                 c:type="TrackerRdfFormat">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-enums.h"
           line="25">Describes a RDF format to be used in data exchange.</doc>
      <member name="turtle"
              value="0"
              c:identifier="TRACKER_RDF_FORMAT_TURTLE"
              glib:nick="turtle"
              glib:name="TRACKER_RDF_FORMAT_TURTLE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-enums.h"
             line="27">Turtle format
  ([http://www.w3.org/ns/formats/Turtle](http://www.w3.org/ns/formats/Turtle))</doc>
      </member>
      <member name="trig"
              value="1"
              c:identifier="TRACKER_RDF_FORMAT_TRIG"
              glib:nick="trig"
              glib:name="TRACKER_RDF_FORMAT_TRIG">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-enums.h"
             line="29">Trig format
  ([http://www.w3.org/ns/formats/Trig](http://www.w3.org/ns/formats/Trig))</doc>
      </member>
      <member name="json_ld"
              value="2"
              c:identifier="TRACKER_RDF_FORMAT_JSON_LD"
              glib:nick="json-ld"
              glib:name="TRACKER_RDF_FORMAT_JSON_LD">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-enums.h"
             line="31">JSON-LD format
  ([http://www.w3.org/ns/formats/JSON-LD](http://www.w3.org/ns/formats/JSON-LD)).
  This value was added in version 3.5.</doc>
      </member>
      <member name="last"
              value="3"
              c:identifier="TRACKER_RDF_FORMAT_LAST"
              glib:nick="last"
              glib:name="TRACKER_RDF_FORMAT_LAST">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-enums.h"
             line="34">The total number of RDF formats</doc>
      </member>
    </enumeration>
    <class name="Resource"
           c:symbol-prefix="resource"
           c:type="TrackerResource"
           parent="GObject.Object"
           glib:type-name="TrackerResource"
           glib:get-type="tracker_resource_get_type"
           glib:type-struct="ResourceClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-resource.c"
           line="49">`TrackerResource` is an in-memory representation of RDF data about a given resource.

This object keeps track of a set of properties for a given resource, and can
also link to other `TrackerResource` objects to form trees or graphs of RDF
data. See [method@Tracker.Resource.set_relation] and [method@Tracker.Resource.set_uri]
on how to link a `TrackerResource` to other RDF data.

`TrackerResource` may also hold data about literal values, added through
the specialized [method@Tracker.Resource.set_int64], [method@Tracker.Resource.set_string],
etc family of functions, or the generic [method@Tracker.Resource.set_gvalue] method.

Since RDF properties may be multi-valued, for every `set` call there exists
another `add` call (e.g. [method@Tracker.Resource.add_int64], [method@Tracker.Resource.add_string]
and so on). The `set` methods do also reset any previously value the
property might hold for the given resource.

Resources may have an IRI set at creation through [ctor@Tracker.Resource.new],
or set afterwards through [method@Tracker.Resource.set_identifier]. Resources
without a name will represent a blank node, and will be dealt with as such
during database insertions.

`TrackerResource` performs no validation on the data being coherent as per
any ontology. Errors will be found out at the time of using the TrackerResource
for e.g. database updates.

Once the RDF data is built in memory, the (tree of) `TrackerResource` may be
converted to a RDF format through [method@Tracker.Resource.print_rdf], or
directly inserted into a database through [method@Tracker.Batch.add_resource]
or [method@Tracker.SparqlConnection.update_resource].</doc>
      <source-position filename="src/libtracker-sparql/tracker-resource.h"
                       line="32"/>
      <constructor name="new" c:identifier="tracker_resource_new">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="260">Creates a TrackerResource instance.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="35"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="266">a newly created `TrackerResource`.</doc>
          <type name="Resource" c:type="TrackerResource*"/>
        </return-value>
        <parameters>
          <parameter name="identifier"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="262">A string containing a URI, or %NULL.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="deserialize" c:identifier="tracker_resource_deserialize">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1854">Deserializes a `TrackerResource` previously serialized with
[method@Tracker.Resource.serialize]. It is implied that both ends
use a common [class@Tracker.NamespaceManager].</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="128"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1862">A TrackerResource, or %NULL if
         deserialization fails.</doc>
          <type name="Resource" c:type="TrackerResource*"/>
        </return-value>
        <parameters>
          <parameter name="variant" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1856">a [type@GLib.Variant]</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_boolean" c:identifier="tracker_resource_add_boolean">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="641">Adds a boolean property. Previous values for the same property are kept.

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method corresponds to [xsd:boolean](xsd-ontology.html#xsd:boolean).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="61"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="643">The `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="644">A string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="645">The property boolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_datetime"
              c:identifier="tracker_resource_add_datetime"
              version="3.2">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="780">Adds a date property as a [type@GLib.DateTime]. Previous values for the
same property are kept.

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method corresponds to [xsd:date](xsd-ontology.html#xsd:date) and
[xsd:dateTime](xsd-ontology.html#xsd:dateTime).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="77"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="782">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="783">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="784">the property object</doc>
            <type name="GLib.DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_double" c:identifier="tracker_resource_add_double">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="656">Adds a numeric property with double precision. Previous values for the same property are kept.

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method corresponds to [xsd:double](xsd-ontology.html#xsd:double).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="63"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="658">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="659">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="660">the property object</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_gvalue" c:identifier="tracker_resource_add_gvalue">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="527">Add @value to the list of values for given property.

You can pass any kind of [struct@GObject.Value] for @value, but serialization functions will
normally only be able to serialize URIs/relationships and fundamental value
types (string, int, etc.).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="59"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="529">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="530">a string identifying the property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="531">an initialised [struct@GObject.Value]</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_int" c:identifier="tracker_resource_add_int">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="671">Adds a numeric property with integer precision. Previous values for the same property are kept.

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="65"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="673">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="674">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="675">the property object</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_int64" c:identifier="tracker_resource_add_int64">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="686">Adds a numeric property with 64-bit integer precision. Previous values for the same property are kept.

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="688">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="689">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="690">the property object</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_relation" c:identifier="tracker_resource_add_relation">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="701">Adds a resource property as a `TrackerResource`. Previous values for the same property are kept.

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
that points to a non-literal class (i.e. a subclass of
[rdfs:Resource](rdf-ontology.html#rdfs:Resource)).

This method produces similar RDF to [method@Tracker.Resource.add_uri],
although in this function the URI will depend on the identifier
set on @resource.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="69"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="703">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="704">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="705">the property object</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_string" c:identifier="tracker_resource_add_string">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="745">Adds a string property. Previous values for the same property are kept.

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method corresponds to [xsd:string](xsd-ontology.html#xsd:string).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="73"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="747">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="748">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="749">the property object</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_take_relation"
              c:identifier="tracker_resource_add_take_relation">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="722">Adds a resource property as a `TrackerResource`. Previous values for the same property are kept.
Takes ownership on the given @resource.

This method is meant to RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
that points to a non-literal class (i.e. a subclass of
[rdfs:Resource](rdf-ontology.html#rdfs:Resource)).

This function produces similar RDF to [method@Tracker.Resource.add_uri],
although in this function the URI will depend on the identifier
set on @resource. This function takes ownership of @resource.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="71"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="724">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="725">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="resource" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="726">the property object</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_uri" c:identifier="tracker_resource_add_uri">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="760">Adds a resource property as an URI string. Previous values for the same property are kept.

This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
that points to a non-literal class (i.e. a subclass of
[rdfs:Resource](rdf-ontology.html#rdfs:Resource)).

This method is meant for RDF properties allowing multiple values, see
[nrl:maxCardinality](nrl-ontology.html#nrl:maxCardinality).

This function produces similar RDF to [method@Tracker.Resource.add_relation], although
it requires that the URI is previously known.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="75"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="762">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="763">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="764">the property object</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_boolean"
              c:identifier="tracker_resource_get_first_boolean">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="875">Returns the first boolean object previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="83"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="882">the first boolean object</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="877">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="878">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_datetime"
              c:identifier="tracker_resource_get_first_datetime"
              version="3.2">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="952">Returns the first [type@GLib.DateTime] previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="97"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="959">the first GDateTime object</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="954">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="955">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_double"
              c:identifier="tracker_resource_get_first_double">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="886">Returns the first double object previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="85"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="893">the first double object</doc>
          <type name="gdouble" c:type="double"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="888">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="889">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_int"
              c:identifier="tracker_resource_get_first_int">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="897">Returns the first integer object previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="87"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="904">the first integer object</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="899">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="900">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_int64"
              c:identifier="tracker_resource_get_first_int64">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="908">Returns the first integer object previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="89"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="915">the first integer object</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="910">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="911">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_relation"
              c:identifier="tracker_resource_get_first_relation">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="919">Returns the first resource object previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="91"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="926">the first resource object</doc>
          <type name="Resource" c:type="TrackerResource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="921">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="922">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_string"
              c:identifier="tracker_resource_get_first_string">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="930">Returns the first string object previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="93"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="937">the first string object</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="932">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="933">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_uri"
              c:identifier="tracker_resource_get_first_uri">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="941">Returns the first resource object previously assigned to a property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="95"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="948">the first resource object as an URI.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="943">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="944">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_identifier"
              c:identifier="tracker_resource_get_identifier"
              glib:get-property="identifier">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="964">Returns the identifier of a resource.

If the identifier was set to NULL, the identifier returned will be a locally
unique SPARQL blank node identifier, such as `_:123`.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="100"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="973">a string owned by the resource</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="966">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_properties"
              c:identifier="tracker_resource_get_properties">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1063">Gets the list of properties defined in @resource</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="107"/>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1069">The list of properties.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1065">a `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_property_overwrite"
              c:identifier="tracker_resource_get_property_overwrite"
              version="3.1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1975">Returns whether the prior values for this property would be deleted
in the SPARQL issued by @resource.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="131"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1983">#TRUE if the property would be overwritten</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1977">a `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1978">a string identifying the property to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_values" c:identifier="tracker_resource_get_values">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="799">Returns the list of all known values of the given property.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="80"/>
        <return-value transfer-ownership="container" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="806">a [struct@GLib.List] of
  [struct@GObject.Value] instances. The list should be freed with [func@GLib.List.free]</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="GObject.Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="801">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="802">a string identifying the property to look up</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="identifier_compare_func"
              c:identifier="tracker_resource_identifier_compare_func">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1017">A helper function that compares a `TrackerResource` by its identifier
string.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="104"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1025">an integer less than, equal to, or greater than zero, if the
         resource identifier is &lt;, == or &gt; than @identifier</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1019">a `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="identifier" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1020">a string identifying the resource</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print_jsonld"
              c:identifier="tracker_resource_print_jsonld"
              deprecated="1"
              deprecated-version="3.5">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1605">Serialize all the information in @resource as a JSON-LD document.

See &lt;http://www.jsonld.org/&gt; for more information on the JSON-LD
serialization format.

The @namespaces object is used to expand any compact URI values. In most
cases you should pass the one returned by [method@Tracker.SparqlConnection.get_namespace_manager]
from the connection that is the intended recipient of this data.</doc>
        <doc-deprecated xml:space="preserve">Use [method@Tracker.Resource.print_rdf] instead.</doc-deprecated>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="116"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1620">a newly-allocated string containing JSON-LD data.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1607">a `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="namespaces"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1608">a set of prefixed URLs, or %NULL to use the
    Nepomuk set</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print_rdf"
              c:identifier="tracker_resource_print_rdf"
              version="3.4">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1656">Serialize all the information in @resource into the selected RDF format.

The @namespaces object is used to expand any compact URI values. In most
cases you should pass the one returned by [method@Tracker.SparqlConnection.get_namespace_manager]
from the connection that is the intended recipient of this data.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="119"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1670">a newly-allocated string containing RDF data in the requested format.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1658">a `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="namespaces" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1659">a set of prefixed URLs</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1660">RDF format of the printed string</doc>
            <type name="RdfFormat" c:type="TrackerRdfFormat"/>
          </parameter>
          <parameter name="graph"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1661">target graph of the resource RDF, or %NULL for the
default graph</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print_sparql_update"
              c:identifier="tracker_resource_print_sparql_update">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1526">Generates a SPARQL command to update a database with the information
stored in @resource.

The @namespaces object is used to expand any compact URI values. In most
cases you should pass the one returned by [method@Tracker.SparqlConnection.get_namespace_manager]
from the connection that is the intended recipient of this data.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="113"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1541">a newly-allocated string containing a SPARQL update command.</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1528">a `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="namespaces"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1529">a set of prefixed URLs, or %NULL to use the
    Nepomuk set</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </parameter>
          <parameter name="graph_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1531">the URN of the graph the data should be added to,
    or %NULL</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="print_turtle"
              c:identifier="tracker_resource_print_turtle"
              deprecated="1"
              deprecated-version="3.4">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1294">Serialize all the information in @resource as a Turtle document.

The generated Turtle should correspond to this standard:
&lt;https://www.w3.org/TR/2014/REC-turtle-20140225/&gt;

The @namespaces object is used to expand any compact URI values. In most
cases you should pass the one returned by [method@Tracker.SparqlConnection.get_namespace_manager]
from the connection that is the intended recipient of this data.</doc>
        <doc-deprecated xml:space="preserve">Use [method@Tracker.Resource.print_rdf] instead.</doc-deprecated>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="110"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1309">a newly-allocated string</doc>
          <type name="utf8" c:type="char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1296">a `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="namespaces"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1297">a set of prefixed URLs, or %NULL to use the
    Nepomuk set</doc>
            <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
          </parameter>
        </parameters>
      </method>
      <method name="serialize" c:identifier="tracker_resource_serialize">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="1778">Serializes a `TrackerResource` to a [type@GLib.Variant] in a lossless way.
All child resources are subsequently serialized. It is implied
that both ends use a common [class@Tracker.NamespaceManager].</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="125"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-resource.c"
               line="1786">A variant describing the resource,
         the reference is floating.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="1780">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_boolean" c:identifier="tracker_resource_set_boolean">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="398">Sets a boolean property. Replaces any previous value.

This method corresponds to [xsd:boolean](xsd-ontology.html#xsd:boolean).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="40"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="400">The `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="401">A string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="402">The property boolean value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_datetime"
              c:identifier="tracker_resource_set_datetime"
              version="3.2">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="512">Sets a date property as a [type@GLib.DateTime]. Replaces any previous value.

This method corresponds to [xsd:date](xsd-ontology.html#xsd:date) and
[xsd:dateTime](xsd-ontology.html#xsd:dateTime).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="56"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="514">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="515">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="516">the property object</doc>
            <type name="GLib.DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_double" c:identifier="tracker_resource_set_double">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="410">Sets a numeric property with double precision. Replaces any previous value.

This method corresponds to [xsd:double](xsd-ontology.html#xsd:double).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="42"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="412">The `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="413">A string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="414">The property object</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_gvalue" c:identifier="tracker_resource_set_gvalue">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="286">Replace any previously existing value for @property_uri with @value.

When serialising to SPARQL, any properties that were set with this function
will get a corresponding DELETE statement to remove any existing values in
the database.

You can pass any kind of [struct@GObject.Value] for @value, but serialization functions will
normally only be able to serialize URIs/relationships and fundamental value
types (string, int, etc.).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="38"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="288">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="289">a string identifying the property to set</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="290">an initialised [struct@GObject.Value]</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_identifier"
              c:identifier="tracker_resource_set_identifier"
              glib:set-property="identifier">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="990">Changes the identifier of a `TrackerResource`. The identifier should be a
URI or compact URI, but this is not necessarily enforced. Invalid
identifiers may cause errors when serializing the resource or trying to
insert the results in a database.

If the identifier is set to %NULL, a SPARQL blank node identifier such as
`_:123` is assigned to the resource.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="102"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="992">A `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="identifier"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="993">a string identifying the resource</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int" c:identifier="tracker_resource_set_int">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="422">Sets a numeric property with integer precision. Replaces any previous value.

This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="44"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="424">The `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="425">A string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="426">The property object</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_int64" c:identifier="tracker_resource_set_int64">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="434">Sets a numeric property with 64-bit integer precision. Replaces any previous value.

This method corresponds to [xsd:integer](xsd-ontology.html#xsd:integer).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="46"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="436">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="437">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="438">the property object</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_relation" c:identifier="tracker_resource_set_relation">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="446">Sets a resource property as a `TrackerResource`. Replaces any previous value.

This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
that points to a non-literal class (i.e. a subclass of
[rdfs:Resource](rdf-ontology.html#rdfs:Resource)).

This function produces similar RDF to [method@Tracker.Resource.set_uri],
although in this function the URI will depend on the identifier
set on @resource.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="48"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="448">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="449">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="450">the property object</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="tracker_resource_set_string">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="483">Sets a string property. Replaces any previous value.

This method corresponds to [xsd:string](xsd-ontology.html#xsd:string).</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="52"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="485">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="486">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="487">the property object</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_take_relation"
              c:identifier="tracker_resource_set_take_relation">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="464">Sets a resource property as a `TrackerResource`. Replaces any previous value.
Takes ownership on the given @resource.

This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
that points to a non-literal class (i.e. a subclass of
[rdfs:Resource](rdf-ontology.html#rdfs:Resource)).

This function produces similar RDF to [method@Tracker.Resource.set_uri],
although in this function the URI will depend on the identifier
set on @resource.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="50"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="466">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="467">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="resource" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="468">the property object</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uri" c:identifier="tracker_resource_set_uri">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="495">Sets a resource property as an URI string. Replaces any previous value.

This method applies to properties with a [rdfs:range](rdf-ontology.html#rdfs:range)
that points to a non-literal class (i.e. a subclass of
[rdfs:Resource](rdf-ontology.html#rdfs:Resource)).

This function produces similar RDF to [method@Tracker.Resource.set_relation], although
it requires that the URI is previously known.</doc>
        <source-position filename="src/libtracker-sparql/tracker-resource.h"
                         line="54"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="497">the `TrackerResource`</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </instance-parameter>
          <parameter name="property_uri" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="498">a string identifying the property to modify</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-resource.c"
                 line="499">the property object</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <property name="identifier"
                writable="1"
                transfer-ownership="none"
                setter="set_identifier"
                getter="get_identifier"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-resource.c"
             line="160">The URI identifier for this class, or %NULL for a
blank node.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="ResourceClass"
            c:type="TrackerResourceClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Resource">
      <source-position filename="src/libtracker-sparql/tracker-resource.h"
                       line="32"/>
    </record>
    <enumeration name="SerializeFlags"
                 glib:type-name="TrackerSerializeFlags"
                 glib:get-type="tracker_serialize_flags_get_type"
                 c:type="TrackerSerializeFlags">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-connection.h"
           line="58">Flags affecting serialization into a RDF data format.</doc>
      <member name="none"
              value="0"
              c:identifier="TRACKER_SERIALIZE_FLAGS_NONE"
              glib:nick="none"
              glib:name="TRACKER_SERIALIZE_FLAGS_NONE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="60">No flags.</doc>
      </member>
    </enumeration>
    <class name="SparqlConnection"
           c:symbol-prefix="sparql_connection"
           c:type="TrackerSparqlConnection"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TrackerSparqlConnection"
           glib:get-type="tracker_sparql_connection_get_type"
           glib:type-struct="SparqlConnectionClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-connection.c"
           line="20">`TrackerSparqlConnection` holds a connection to a RDF triple store.

This triple store may be of three types:

 - Local to the process, created through [ctor@Tracker.SparqlConnection.new].
 - A HTTP SPARQL endpoint over the network, created through
   [ctor@Tracker.SparqlConnection.remote_new]
 - A DBus SPARQL endpoint owned by another process in the same machine, created
   through [ctor@Tracker.SparqlConnection.bus_new]

When creating a local triple store, it is required to give details about its
structure. This is done by passing a location to an ontology, see more
on how are [ontologies defined](ontologies.html). A local database may be
stored in a filesystem location, or it may reside in memory.

A `TrackerSparqlConnection` is private to the calling process, it can be
exposed to other hosts/processes via a [class@Tracker.Endpoint], see
[ctor@Tracker.EndpointDBus.new] and [ctor@Tracker.EndpointHttp.new].

When issuing SPARQL queries and updates, it is recommended that these are
created through [class@Tracker.SparqlStatement] to avoid the SPARQL
injection class of bugs, see [method@Tracker.SparqlConnection.query_statement]
and [method@Tracker.SparqlConnection.update_statement]. For SPARQL updates
it is also possible to use a "builder" approach to generate RDF data, see
[class@Tracker.Resource]. It is also possible to create [class@Tracker.SparqlStatement]
objects for SPARQL queries and updates from SPARQL strings embedded in a
[struct@Gio.Resource], see [method@Tracker.SparqlConnection.load_statement_from_gresource].

To get the best performance, it is recommended that SPARQL updates are clustered
through [class@Tracker.Batch].

`TrackerSparqlConnection` also offers a number of methods for the simple cases,
[method@Tracker.SparqlConnection.query] may be used when there is a SPARQL
query string directly available, and the [method@Tracker.SparqlConnection.update]
family of functions may be used for one-off updates. All functions have asynchronous
variants.

When a SPARQL query is executed, a [class@Tracker.SparqlCursor] will be obtained
to iterate over the query results.

Depending on the ontology definition, `TrackerSparqlConnection` may emit
notifications whenever resources of certain types get insert, modified or
deleted from the triple store (see [nrl:notify](nrl-ontology.html#nrl:notify).
These notifications can be handled via a [class@Tracker.Notifier] obtained with
[method@Tracker.SparqlConnection.create_notifier].

After done with a connection, it is recommended to call [method@Tracker.SparqlConnection.close]
or [method@Tracker.SparqlConnection.close_async] explicitly to cleanly close the
connection and prevent consistency checks on future runs. The triple store
connection will be implicitly closed when the `TrackerSparqlConnection` object
is disposed.

A `TrackerSparqlConnection` may be used from multiple threads, asynchronous
updates are executed sequentially on arrival order, asynchronous
queries are dispatched in a thread pool.

If you ever have the need to procedurally compose SPARQL query strings, consider
the use of [func@Tracker.sparql_escape_string] for literal strings and
the [func@Tracker.sparql_escape_uri] family of functions for URIs.</doc>
      <source-position filename="src/libtracker-sparql/tracker-connection.h"
                       line="82"/>
      <constructor name="bus_new"
                   c:identifier="tracker_sparql_connection_bus_new"
                   throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1277">@service_name (nullable): The name of the D-Bus service to connect to, or %NULL if not using a message bus.
Connects to a database owned by another process on the
local machine via DBus.

When using a message bus (session/system), the @service_name argument will
be used to describe the remote endpoint, either by unique or well-known D-Bus
names. If not using a message bus (e.g. peer-to-peer D-Bus connections) the
@service_name may be %NULL.

The D-Bus object path of the remote endpoint will be given through
@object_path, %NULL may be used to use the default
`/org/freedesktop/Tracker3/Endpoint` path.

The D-Bus connection used to set up the connection may be given through
the @dbus_connection argument. Using %NULL will resort to the default session
bus.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="111"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="1300">a new `TrackerSparqlConnection`.</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <parameter name="service_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1280">The path to the object, or %NULL to use the default.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dbus_connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1281">The [type@Gio.DBusConnection] to use, or %NULL to use the session bus</doc>
            <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="bus_new_finish"
                   c:identifier="tracker_sparql_connection_bus_new_finish"
                   version="3.1"
                   throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1379">Finishes the operation started with [func@Tracker.SparqlConnection.bus_new_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="123"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="1386">a new `TrackerSparqlConnection`.</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1381">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new"
                   c:identifier="tracker_sparql_connection_new"
                   throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1136">Creates or opens a process-local database.

This method should only be used for databases owned by the current process.
To connect to databases managed by other processes, use
[ctor@Tracker.SparqlConnection.bus_new].

If @store is %NULL, the database will be created in memory.

If defined, the @ontology argument must point to a location containing
suitable `.ontology` files in Turtle format. These define the structure of
the triple store. You can learn more about [ontologies](ontologies.html),
or you can use the stock Nepomuk ontologies by calling
[func@Tracker.sparql_get_ontology_nepomuk].

If opening an existing database, it is possible to pass %NULL as the
@ontology location, the ontology will be introspected from the database.
Passing a %NULL @ontology will raise an error if the database does not exist.

If a database is opened without the #TRACKER_SPARQL_CONNECTION_FLAG_READONLY
flag enabled, and the given @ontology holds differences with the current
data layout, migration to the new structure will be attempted. This operation
may raise an error. In particular, not all migrations are possible without
causing data loss and Tracker will refuse to delete data during a migration.
The database is always left in a consistent state, either prior or posterior
to migration.

Operations on a [class@Tracker.SparqlConnection] resulting on a
[error@Tracker.SparqlError.CORRUPT] error will have the event recorded
persistently through a `.meta.corrupted` file alongside the database files.
If the database is opened without the [flags@Tracker.SparqlConnectionFlags.READONLY]
flag and the file is found, this constructor will attempt to repair the
database. In that situation, this constructor will either return a valid
[class@Tracker.SparqlConnection] if the database was repaired successfully, or
raise a [error@Tracker.SparqlError.CORRUPT] error if the database remains
corrupted.

It is considered a developer error to ship ontologies that contain format
errors, or that fail at migrations.

It is encouraged to use `resource:///` URI locations for @ontology wherever
possible, so the triple store structure is tied to the executable binary,
and in order to minimize disk seeks during `TrackerSparqlConnection`
initialization.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="94"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="1188">a new `TrackerSparqlConnection`.</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1138">Connection flags to define the SPARQL connection behavior</doc>
            <type name="SparqlConnectionFlags"
                  c:type="TrackerSparqlConnectionFlags"/>
          </parameter>
          <parameter name="store"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1139">The directory that contains the database as a [iface@Gio.File], or %NULL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="ontology"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1140">The directory that contains the database schemas as a [iface@Gio.File], or %NULL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1141">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_finish"
                   c:identifier="tracker_sparql_connection_new_finish"
                   throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1258">Finishes the operation started with [func@Tracker.SparqlConnection.new_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="107"/>
        <return-value transfer-ownership="full">
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1260">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="remote_new"
                   c:identifier="tracker_sparql_connection_remote_new">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1119">Creates a connection to a remote HTTP SPARQL endpoint.

The connection is made using the libsoup HTTP library. The connection will
normally use the `https://` or `http://` protocols.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="127"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="1128">a new remote `TrackerSparqlConnection`.</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <parameter name="uri_base" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1121">Base URI of the remote connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="bus_new_async"
                c:identifier="tracker_sparql_connection_bus_new_async"
                version="3.1"
                glib:finish-func="bus_new_finish">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1339">Connects asynchronously to a database owned by another process on the
local machine via DBus.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="116"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1341">The name of the D-Bus service to connect to.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="object_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1342">The path to the object, or %NULL to use the default.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="dbus_connection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1343">The [class@Gio.DBusConnection] to use, or %NULL to use the session bus</doc>
            <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1344">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1345">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1347">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_async"
                c:identifier="tracker_sparql_connection_new_async"
                glib:finish-func="new_finish">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1222">Creates or opens a process-local database asynchronously.

See [ctor@Tracker.SparqlConnection.new] for more information.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="100"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1224">Connection flags to define the SPARQL connection behavior</doc>
            <type name="SparqlConnectionFlags"
                  c:type="TrackerSparqlConnectionFlags"/>
          </parameter>
          <parameter name="store"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1225">The directory that contains the database as a [iface@Gio.File], or %NULL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="ontology"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1226">The directory that contains the database schemas as a [iface@Gio.File], or %NULL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1227">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1228">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1230">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="close" c:identifier="tracker_sparql_connection_close">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="760">Closes a SPARQL connection.

No other API calls than g_object_unref() should happen after this call.

This call is blocking. All pending updates will be flushed, and the
store databases will be closed orderly. All ongoing SELECT queries
will be cancelled. Notifiers will no longer emit events.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="227"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="762">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="close_async"
              c:identifier="tracker_sparql_connection_close_async"
              glib:finish-func="close_finish">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="780">Closes a SPARQL connection asynchronously.

No other API calls than g_object_unref() should happen after this call.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="257"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="782">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="783">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="784">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="786">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="close_finish"
              c:identifier="tracker_sparql_connection_close_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="806">Finishes the operation started with [method@Tracker.SparqlConnection.close_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="263"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="814">%FALSE if some error occurred, %TRUE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="808">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="809">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_batch"
              c:identifier="tracker_sparql_connection_create_batch">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="827">Creates a new [class@Tracker.Batch] to store and execute SPARQL updates.

If the connection is readonly or cannot issue SPARQL updates, %NULL will be returned.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="190"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="835">(nullable): A new [class@Tracker.Batch]</doc>
          <type name="Batch" c:type="TrackerBatch*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="829">a `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_notifier"
              c:identifier="tracker_sparql_connection_create_notifier">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="736">Creates a new [class@Tracker.Notifier] to receive notifications about changes in @connection.

See [class@Tracker.Notifier] documentation for information about how to use this
object.

Connections to HTTP endpoints will return %NULL.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="224"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="747">A newly created notifier.</doc>
          <type name="Notifier" c:type="TrackerNotifier*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="738">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="deserialize_async"
              c:identifier="tracker_sparql_connection_deserialize_async"
              version="3.4"
              glib:finish-func="deserialize_finish">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="988">Loads the RDF data contained in @stream into the given @connection.

This is an asynchronous operation, @callback will be invoked when the
data has been fully inserted to @connection.

The RDF data will be inserted in the given @default_graph if one is provided,
or the anonymous graph if @default_graph is %NULL. Any RDF data that has a
graph specified (e.g. using the `GRAPH` clause in the Trig format) will
be inserted in the specified graph instead of @default_graph.

The @flags argument is reserved for future expansions, currently
%TRACKER_DESERIALIZE_FLAGS_NONE must be passed.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="243"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="990">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="991">Deserialization flags</doc>
            <type name="DeserializeFlags" c:type="TrackerDeserializeFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="992">RDF format of data in stream</doc>
            <type name="RdfFormat" c:type="TrackerRdfFormat"/>
          </parameter>
          <parameter name="default_graph" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="993">Default graph that will receive the RDF data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="994">Input stream with RDF data</doc>
            <type name="Gio.InputStream" c:type="GInputStream*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="995">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="996">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="998">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="deserialize_finish"
              c:identifier="tracker_sparql_connection_deserialize_finish"
              version="3.4"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1042">Finishes the operation started with [method@Tracker.SparqlConnection.deserialize_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="252"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="1050">%TRUE if all data was inserted successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1044">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1045">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_namespace_manager"
              c:identifier="tracker_sparql_connection_get_namespace_manager">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="646">Returns a [class@Tracker.NamespaceManager] that contains all
prefixes in the ontology of @connection.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="209"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="653">a [class@Tracker.NamespaceManager] with the prefixes of @connection.</doc>
          <type name="NamespaceManager" c:type="TrackerNamespaceManager*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="648">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_statement_from_gresource"
              c:identifier="tracker_sparql_connection_load_statement_from_gresource"
              version="3.3"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="848">Prepares a [class@Tracker.SparqlStatement] for the SPARQL contained as a [struct@Gio.Resource]
file at @resource_path.

SPARQL Query files typically have the .rq extension. This will use
[method@Tracker.SparqlConnection.query_statement] or [method@Tracker.SparqlConnection.update_statement]
underneath to indistinctly return SPARQL query or update statements.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="268"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="862">A prepared statement</doc>
          <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="850">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="resource_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="851">The resource path of the file to parse.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="852">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="map_connection"
              c:identifier="tracker_sparql_connection_map_connection"
              version="3.3">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="1068">Maps a `TrackerSparqlConnection` onto another through a `private:@handle_name` URI.

This can be accessed via the SERVICE SPARQL syntax in
queries from @connection. E.g.:

```c
tracker_sparql_connection_map_connection (connection,
                                          "other-connection",
                                          other_connection);
```

```sparql
SELECT ?u {
  SERVICE &lt;private:other-connection&gt; {
    ?u a rdfs:Resource
  }
}
```

This is useful to interrelate data from multiple
`TrackerSparqlConnection` instances maintained by the same process,
without creating a public endpoint for @service_connection.

@connection may only be a `TrackerSparqlConnection` created via
[ctor@Tracker.SparqlConnection.new] and [func@Tracker.SparqlConnection.new_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="274"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1070">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="handle_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1071">Handle name for @service_connection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="service_connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="1072">a `TrackerSparqlConnection` to use from @connection</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query"
              c:identifier="tracker_sparql_connection_query"
              throws="1"
              glib:async-func="query_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="140">Executes a SPARQL query on @connection.

This method is synchronous and will block until the query
is executed. See [method@Tracker.SparqlConnection.query_async]
for an asynchronous variant.

If the query is partially built from user input or other
untrusted sources, special care is required about possible
SPARQL injection. In order to avoid it entirely, it is recommended
to use [class@Tracker.SparqlStatement]. The function
[func@Tracker.sparql_escape_string] exists as a last resort,
but its use is not recommended.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="130"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="160">a [class@Tracker.SparqlCursor] with the results.</doc>
          <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="142">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="143">String containing the SPARQL query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="144">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_async"
              c:identifier="tracker_sparql_connection_query_async"
              glib:finish-func="query_finish"
              glib:sync-func="query">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="185">Executes asynchronously a SPARQL query on @connection

If the query is partially built from user input or other
untrusted sources, special care is required about possible
SPARQL injection. In order to avoid it entirely, it is recommended
to use [class@Tracker.SparqlStatement]. The function
[func@Tracker.sparql_escape_string] exists as a last resort,
but its use is not recommended.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="136"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="187">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="188">String containing the SPARQL query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="189">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="190">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="192">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_finish"
              c:identifier="tracker_sparql_connection_query_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="221">Finishes the operation started with [method@Tracker.SparqlConnection.query_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="142"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="229">a [class@Tracker.SparqlCursor] with the results.</doc>
          <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="223">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="224">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_statement"
              c:identifier="tracker_sparql_connection_query_statement"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="668">Prepares the given `SELECT`/`ASK`/`DESCRIBE`/`CONSTRUCT` SPARQL query as a
[class@Tracker.SparqlStatement].

This prepared statement can be executed through [method@Tracker.SparqlStatement.execute]
or [method@Tracker.SparqlStatement.serialize_async] families of functions.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="212"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="681">A prepared statement</doc>
          <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="670">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="671">The SPARQL query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="672">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="serialize_async"
              c:identifier="tracker_sparql_connection_serialize_async"
              version="3.3"
              glib:finish-func="serialize_finish">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="913">Serializes a `DESCRIBE` or `CONSTRUCT` query into the specified RDF format.

This is an asynchronous operation, @callback will be invoked when
the data is available for reading.

The SPARQL endpoint may not support the specified format, in that case
an error will be raised.

The @flags argument is reserved for future expansions, currently
%TRACKER_SERIALIZE_FLAGS_NONE must be passed.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="230"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="915">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="916">Serialization flags</doc>
            <type name="SerializeFlags" c:type="TrackerSerializeFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="917">Output RDF format</doc>
            <type name="RdfFormat" c:type="TrackerRdfFormat"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="918">SPARQL query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="919">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="920">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="922">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="serialize_finish"
              c:identifier="tracker_sparql_connection_serialize_finish"
              version="3.3"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="962">Finishes the operation started with [method@Tracker.SparqlConnection.serialize_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="238"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="970">A [class@Gio.InputStream] to read RDF content.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="964">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="965">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update"
              c:identifier="tracker_sparql_connection_update"
              throws="1"
              glib:async-func="update_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="251">Executes a SPARQL update on @connection.

This method is synchronous and will block until the update
is finished. See [method@Tracker.SparqlConnection.update_async]
for an asynchronous variant.

It is recommented to consider the usage of [class@Tracker.Batch]
to cluster database updates. Frequent isolated SPARQL updates
through this method will have a degraded performance in comparison.

If the query is partially built from user input or other
untrusted sources, special care is required about possible
SPARQL injection. In order to avoid it entirely, it is recommended
to use [class@Tracker.SparqlStatement], or to build the SPARQL
input through [class@Tracker.Resource]. The function
[func@Tracker.sparql_escape_string] exists as a last resort,
but its use is not recommended.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="147"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="253">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="254">String containing the SPARQL update query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="255">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_array_async"
              c:identifier="tracker_sparql_connection_update_array_async"
              glib:finish-func="update_array_finish">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="356">Executes asynchronously an array of SPARQL updates. All updates in the
array are handled within a single transaction.

If the query is partially built from user input or other
untrusted sources, special care is required about possible
SPARQL injection. In order to avoid it entirely, it is recommended
to use [class@Tracker.SparqlStatement], or to build the SPARQL
input through [class@Tracker.Resource]. The function
[func@Tracker.sparql_escape_string] exists as a last resort,
but its use is not recommended.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="162"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="358">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="359">An array of strings containing the SPARQL update queries</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
          <parameter name="sparql_length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="360">The amount of strings you pass as @sparql</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="361">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="362">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="364">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_array_finish"
              c:identifier="tracker_sparql_connection_update_array_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="397">Finishes the operation started with [method@Tracker.SparqlConnection.update_array_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="169"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="405">#TRUE if there were no errors.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="399">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="400">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_async"
              c:identifier="tracker_sparql_connection_update_async"
              glib:finish-func="update_finish"
              glib:sync-func="update">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="293">Executes asynchronously a SPARQL update.

It is recommented to consider the usage of [class@Tracker.Batch]
to cluster database updates. Frequent isolated SPARQL updates
through this method will have a degraded performance in comparison.

If the query is partially built from user input or other
untrusted sources, special care is required about possible
SPARQL injection. In order to avoid it entirely, it is recommended
to use [class@Tracker.SparqlStatement], or to build the SPARQL
input through [class@Tracker.Resource]. The function
[func@Tracker.sparql_escape_string] exists as a last resort,
but its use is not recommended.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="152"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="295">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="296">String containing the SPARQL update query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="297">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="298">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="300">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_blank"
              c:identifier="tracker_sparql_connection_update_blank"
              deprecated="1"
              deprecated-version="3.5"
              throws="1"
              glib:async-func="update_blank_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="422">Executes a SPARQL update and returns the names of the generated blank nodes.

This method is synchronous and will block until the update
is finished. See [method@Tracker.SparqlConnection.update_blank_async]
for an asynchronous variant.

The @sparql query should be built with [class@Tracker.Resource], or
its parts correctly escaped using [func@Tracker.sparql_escape_string],
otherwise SPARQL injection is possible.

The format string of the `GVariant` is `aaa{ss}` (an array of an array
of dictionaries). The first array represents each INSERT that may exist in
the SPARQL string. The second array represents each new node for a given
WHERE clause. The last array holds a string pair with the blank node name
(e.g. `foo` for the blank node `_:foo`) and the URN that was generated for
it. For most updates the first two outer arrays will only contain one item.</doc>
        <doc-deprecated xml:space="preserve">This function makes the expectation that blank nodes have
a durable name that persist. The SPARQL and RDF specs define a much more
reduced scope for blank node labels. This function advises a behavior that
goes against that reduced scope, and will directly make the returned values
meaningless if the #TRACKER_SPARQL_CONNECTION_FLAGS_ANONYMOUS_BNODES flag
is defined in the connection.

Users that want names generated for them, should look for other methods
(e.g. IRIs containing UUIDv4 strings).</doc-deprecated>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="193"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="446">a [type@GLib.Variant] with the generated URNs.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="424">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="425">String containing the SPARQL update query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="426">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_blank_async"
              c:identifier="tracker_sparql_connection_update_blank_async"
              deprecated="1"
              deprecated-version="3.5"
              glib:finish-func="update_blank_finish"
              glib:sync-func="update_blank">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="475">Executes asynchronously a SPARQL update and returns the names of the generated blank nodes.

See the [method@Tracker.SparqlConnection.update_blank] documentation to
learn the differences with [method@Tracker.SparqlConnection.update].</doc>
        <doc-deprecated xml:space="preserve">See [method@Tracker.SparqlConnection.update_blank].</doc-deprecated>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="198"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="477">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="478">String containing the SPARQL update query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="479">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="480">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="482">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_blank_finish"
              c:identifier="tracker_sparql_connection_update_blank_finish"
              deprecated="1"
              deprecated-version="3.5"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="510">Finishes the operation started with [method@Tracker.SparqlConnection.update_blank_async].

This method returns the URNs of the generated nodes, if any. See the
[method@Tracker.SparqlConnection.update_blank] documentation for the interpretation
of the returned [type@GLib.Variant].</doc>
        <doc-deprecated xml:space="preserve">See [method@Tracker.SparqlConnection.update_blank].</doc-deprecated>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="204"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="522">a [type@GLib.Variant] with the generated URNs.</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="512">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="513">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_finish"
              c:identifier="tracker_sparql_connection_update_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="334">Finishes the operation started with [method@Tracker.SparqlConnection.update_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="158"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="336">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="337">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_resource"
              c:identifier="tracker_sparql_connection_update_resource"
              version="3.1"
              throws="1"
              glib:async-func="update_resource_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="540">Inserts a resource as described by @resource on the given @graph.

This method is synchronous and will block until the update
is finished. See [method@Tracker.SparqlConnection.update_resource_async]
for an asynchronous variant.

It is recommented to consider the usage of [class@Tracker.Batch]
to cluster database updates. Frequent isolated SPARQL updates
through this method will have a degraded performance in comparison.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="173"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="558">#TRUE if there were no errors.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="542">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="graph"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="543">RDF graph where the resource should be inserted/updated, or %NULL for the default graph</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="544">A [class@Tracker.Resource]</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="545">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_resource_async"
              c:identifier="tracker_sparql_connection_update_resource_async"
              version="3.1"
              glib:finish-func="update_resource_finish"
              glib:sync-func="update_resource">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="581">Inserts asynchronously a resource as described by @resource on the given @graph.

It is recommented to consider the usage of [class@Tracker.Batch]
to cluster database updates. Frequent isolated SPARQL updates
through this method will have a degraded performance in comparison.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="179"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="583">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="graph"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="584">RDF graph where the resource should be inserted/updated, or %NULL for the default graph</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="resource" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="585">A [class@Tracker.Resource]</doc>
            <type name="Resource" c:type="TrackerResource*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="586">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="587">User-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="589">User-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_resource_finish"
              c:identifier="tracker_sparql_connection_update_resource_finish"
              version="3.1"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="620">Finishes the operation started with [method@Tracker.SparqlConnection.update_resource_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="186"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="628">#TRUE if there were no errors.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="622">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="623">A [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_statement"
              c:identifier="tracker_sparql_connection_update_statement"
              version="3.5"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.c"
             line="700">Prepares the given `INSERT`/`DELETE` SPARQL as a [class@Tracker.SparqlStatement].

This prepared statement can be executed through
the [method@Tracker.SparqlStatement.update] family of functions.</doc>
        <source-position filename="src/libtracker-sparql/tracker-connection.h"
                         line="218"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-connection.c"
               line="712">A prepared statement</doc>
          <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
        </return-value>
        <parameters>
          <instance-parameter name="connection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="702">A `TrackerSparqlConnection`</doc>
            <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
          </instance-parameter>
          <parameter name="sparql" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="703">The SPARQL update</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-connection.c"
                 line="704">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SparqlConnectionClass"
            c:type="TrackerSparqlConnectionClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="SparqlConnection">
      <source-position filename="src/libtracker-sparql/tracker-connection.h"
                       line="82"/>
    </record>
    <bitfield name="SparqlConnectionFlags"
              glib:type-name="TrackerSparqlConnectionFlags"
              glib:get-type="tracker_sparql_connection_flags_get_type"
              c:type="TrackerSparqlConnectionFlags">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-connection.h"
           line="35">Connection flags to modify #TrackerSparqlConnection behavior.</doc>
      <member name="none"
              value="0"
              c:identifier="TRACKER_SPARQL_CONNECTION_FLAGS_NONE"
              glib:nick="none"
              glib:name="TRACKER_SPARQL_CONNECTION_FLAGS_NONE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="37">No flags.</doc>
      </member>
      <member name="readonly"
              value="1"
              c:identifier="TRACKER_SPARQL_CONNECTION_FLAGS_READONLY"
              glib:nick="readonly"
              glib:name="TRACKER_SPARQL_CONNECTION_FLAGS_READONLY">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="38">Connection is readonly.</doc>
      </member>
      <member name="fts_enable_stemmer"
              value="2"
              c:identifier="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_ENABLE_STEMMER"
              glib:nick="fts-enable-stemmer"
              glib:name="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_ENABLE_STEMMER">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="39">Word stemming is applied to FTS search terms.</doc>
      </member>
      <member name="fts_enable_unaccent"
              value="4"
              c:identifier="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_ENABLE_UNACCENT"
              glib:nick="fts-enable-unaccent"
              glib:name="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_ENABLE_UNACCENT">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="40">Unaccenting is applied to FTS search terms.</doc>
      </member>
      <member name="fts_enable_stop_words"
              value="8"
              c:identifier="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_ENABLE_STOP_WORDS"
              glib:nick="fts-enable-stop-words"
              glib:name="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_ENABLE_STOP_WORDS">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="41">FTS Search terms are filtered through a stop word list. This flag is deprecated since Tracker 3.6, and will do nothing.</doc>
      </member>
      <member name="fts_ignore_numbers"
              value="16"
              c:identifier="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_IGNORE_NUMBERS"
              glib:nick="fts-ignore-numbers"
              glib:name="TRACKER_SPARQL_CONNECTION_FLAGS_FTS_IGNORE_NUMBERS">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="42">Ignore numbers in FTS search terms.</doc>
      </member>
      <member name="anonymous_bnodes"
              value="32"
              c:identifier="TRACKER_SPARQL_CONNECTION_FLAGS_ANONYMOUS_BNODES"
              glib:nick="anonymous-bnodes"
              glib:name="TRACKER_SPARQL_CONNECTION_FLAGS_ANONYMOUS_BNODES">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-connection.h"
             line="43">Treat blank nodes as specified in
  SPARQL 1.1 syntax. Namely, they cannot be used as URIs. This flag is available since Tracker 3.3.</doc>
      </member>
    </bitfield>
    <class name="SparqlCursor"
           c:symbol-prefix="sparql_cursor"
           c:type="TrackerSparqlCursor"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TrackerSparqlCursor"
           glib:get-type="tracker_sparql_cursor_get_type"
           glib:type-struct="SparqlCursorClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-cursor.c"
           line="19">`TrackerSparqlCursor` provides the methods to iterate the results of a SPARQL query.

Cursors are obtained through e.g. [method@Tracker.SparqlStatement.execute]
or [method@Tracker.SparqlConnection.query] after the SPARQL query has been
executed.

When created, a cursor does not point to any element, [method@Tracker.SparqlCursor.next]
is necessary to iterate one by one to the first (and following) results.
When the cursor iterated across all rows in the result set, [method@Tracker.SparqlCursor.next]
will return %FALSE with no error set.

On each row, it is possible to extract the result values through the
[method@Tracker.SparqlCursor.get_integer], [method@Tracker.SparqlCursor.get_string], etc... family
of methods. The column index of those functions starts at 0. The number of columns is
dependent on the SPARQL query issued, but may be checked at runtime through the
[method@Tracker.SparqlCursor.get_n_columns] method.

After a cursor is iterated, it is recommended to call [method@Tracker.SparqlCursor.close]
explicitly to free up resources for other users of the same [class@Tracker.SparqlConnection],
this is especially important in garbage collected languages. These resources
will be also implicitly freed on cursor object finalization.

It is possible to use a given `TrackerSparqlCursor` in other threads than
the one it was created from. It must be however used from just one thread
at any given time.</doc>
      <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                       line="34"/>
      <method name="close" c:identifier="tracker_sparql_cursor_close">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="488">Closes the cursor. The object can only be freed after this call.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="96"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="490">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_boolean"
              c:identifier="tracker_sparql_cursor_get_boolean">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="345">Retrieve a boolean for the current row in @column.

If the row/column do not have a boolean value, the result is
undefined, see [method@Tracker.SparqlCursor.get_value_type].</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="78"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="355">a boolean value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="347">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="348">column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tracker_sparql_cursor_get_connection"
              glib:get-property="connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="228">Returns the [class@Tracker.SparqlConnection] associated with this
`TrackerSparqlCursor`.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="64"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="235">the cursor [class@Tracker.SparqlConnection]. The
returned object must not be unreferenced by the caller.</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="230">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_datetime"
              c:identifier="tracker_sparql_cursor_get_datetime"
              version="3.2">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="466">Retrieves a [type@GLib.DateTime] pointer for the current row in @column.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="93"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="473">[type@GLib.DateTime] object, or %NULL if the given column does not
  contain a [xsd:date](xsd-ontology.html#xsd:date) or [xsd:dateTime](xsd-ontology.html#xsd:dateTime).</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="468">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="469">Column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_double"
              c:identifier="tracker_sparql_cursor_get_double">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="367">Retrieve a double for the current row in @column.

If the row/column do not have a integer or double value, the result is
undefined, see [method@Tracker.SparqlCursor.get_value_type].</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="81"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="377">a double value.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="369">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="370">column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_integer"
              c:identifier="tracker_sparql_cursor_get_integer">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="389">Retrieve an integer for the current row in @column.

If the row/column do not have an integer value, the result is
undefined, see [method@Tracker.SparqlCursor.get_value_type].</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="84"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="399">a 64-bit integer value.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="391">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="392">column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_langstring"
              c:identifier="tracker_sparql_cursor_get_langstring"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="309">Retrieves a string representation of the data in the current
row in @column. If the string has language information (i.e. it is
a `rdf:langString`](rdf-ontology.html#rdf:langString)), the language
tag will be returned in the location provided through @langtag. This
language tag will typically be in a format conforming
[RFC 5646](https://www.rfc-editor.org/rfc/rfc5646.html).</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="73"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="324">a string which must not be freed. %NULL is returned if
the column is not in the `[0, n_columns]` range, or if the row/column
refer to a nullable optional value in the result set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="311">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="312">column number to retrieve</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="langtag"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="313">language tag of the returned string, or %NULL if the
  string has no language tag</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="315">length of the returned string</doc>
            <type name="glong" c:type="glong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_columns"
              c:identifier="tracker_sparql_cursor_get_n_columns"
              glib:get-property="n-columns">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="260">Retrieves the number of columns available in the result set.

This method should only be called after a successful
[method@Tracker.SparqlCursor.next], otherwise its return value
will be undefined.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="66"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="270">The number of columns returned in the result set.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="262">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string"
              c:identifier="tracker_sparql_cursor_get_string">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="280">Retrieves a string representation of the data in the current
row in @column.

Any type may be converted to a string. If the value is not bound
(See [method@Tracker.SparqlCursor.is_bound]) this method will return %NULL.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="69"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="292">a string which must not be freed. %NULL is returned if
the column is not in the `[0, n_columns]` range, or if the row/column
refer to a nullable optional value in the result set.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="282">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="283">column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="284">length of the returned string, or %NULL</doc>
            <type name="glong" c:type="glong*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_value_type"
              c:identifier="tracker_sparql_cursor_get_value_type">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="411">Returns the data type bound to the current row and the given @column.

If the column is unbound, the value will be %TRACKER_SPARQL_VALUE_TYPE_UNBOUND.
See also [method@Tracker.SparqlCursor.is_bound].

Values of type #TRACKER_SPARQL_VALUE_TYPE_RESOURCE and
#TRACKER_SPARQL_VALUE_TYPE_BLANK_NODE can be considered equivalent, the
difference is the resource being referenced as a named IRI or a blank
node.

All other [enum@Tracker.SparqlValueType] value types refer to literal values.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="87"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="428">a [enum@Tracker.SparqlValueType] expressing the content type of
  the given column for the current row.</doc>
          <type name="SparqlValueType" c:type="TrackerSparqlValueType"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="413">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="414">column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_variable_name"
              c:identifier="tracker_sparql_cursor_get_variable_name">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="442">Retrieves the name of the given @column.

This name will be defined at the SPARQL query, either
implicitly from the names of the variables returned in
the resultset, or explicitly through the `AS ?var` SPARQL
syntax.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="90"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="454">The name of the given column.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="444">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="445">column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_bound" c:identifier="tracker_sparql_cursor_is_bound">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="502">Returns whether the given @column has a bound value in the current row.

This may not be the case through e.g. the `OPTIONAL { }` SPARQL syntax.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="511">a %TRUE or %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="504">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="column" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="505">column number to retrieve (first one is 0)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="next"
              c:identifier="tracker_sparql_cursor_next"
              throws="1"
              glib:async-func="next_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="522">Iterates the cursor to the next result.

If the cursor was not started, it will point to the first result after
this call. This operation is completely synchronous and it may block,
see [method@Tracker.SparqlCursor.next_async] for an asynchronous variant.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="103"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="534">%FALSE if there are no more results or if an error is found, otherwise %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="524">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="525">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_async"
              c:identifier="tracker_sparql_cursor_next_async"
              glib:finish-func="next_finish"
              glib:sync-func="next">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="558">Iterates the cursor asyncronously to the next result.

If the cursor was not started, it will point to the first result after
this operation completes.

In the period between this call and the corresponding
[method@Tracker.SparqlCursor.next_finish] call, the other cursor methods
should not be used, nor their results trusted. The cursor should only
be iterated once at a time.</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="108"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="560">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="561">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="562">user-defined [type@Gio.AsyncReadyCallback] to be called when
           asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="564">user-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_finish"
              c:identifier="tracker_sparql_cursor_next_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="591">Finishes the asynchronous iteration to the next result started with
[method@Tracker.SparqlCursor.next_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="114"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-cursor.c"
               line="600">%FALSE if there are no more results or if an error is found, otherwise %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="593">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="594">a [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rewind"
              c:identifier="tracker_sparql_cursor_rewind"
              deprecated="1"
              deprecated-version="3.5">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="624">Resets the iterator to point back to the first result.</doc>
        <doc-deprecated xml:space="preserve">This function only works on cursors
from direct [class@Tracker.SparqlConnection] objects and cannot work
reliably across all cursor types. Issue a different query to
obtain a new cursor.</doc-deprecated>
        <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                         line="119"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cursor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-cursor.c"
                 line="626">a `TrackerSparqlCursor`</doc>
            <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="198">The [class@Tracker.SparqlConnection] used to retrieve the results.</doc>
        <type name="SparqlConnection"/>
      </property>
      <property name="n-columns"
                transfer-ownership="none"
                getter="get_n_columns"
                default-value="0">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.c"
             line="212">Number of columns available in the result set.</doc>
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SparqlCursorClass"
            c:type="TrackerSparqlCursorClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="SparqlCursor">
      <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                       line="34"/>
    </record>
    <enumeration name="SparqlError"
                 glib:type-name="TrackerSparqlError"
                 glib:get-type="tracker_sparql_error_get_type"
                 c:type="TrackerSparqlError"
                 glib:error-domain="tracker-sparql-error-quark">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-error.h"
           line="29">Error domain for Tracker Sparql. Errors in this domain will be from the
[error@Tracker.SparqlError] enumeration. See [struct@GLib.Error] for more information on error
domains.</doc>
      <member name="constraint"
              value="0"
              c:identifier="TRACKER_SPARQL_ERROR_CONSTRAINT"
              glib:nick="constraint"
              glib:name="TRACKER_SPARQL_ERROR_CONSTRAINT">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="31">Subject is not in the domain of a property or
                            trying to set multiple values for a single valued
                            property.</doc>
      </member>
      <member name="internal"
              value="1"
              c:identifier="TRACKER_SPARQL_ERROR_INTERNAL"
              glib:nick="internal"
              glib:name="TRACKER_SPARQL_ERROR_INTERNAL">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="34">Internal error.</doc>
      </member>
      <member name="no_space"
              value="2"
              c:identifier="TRACKER_SPARQL_ERROR_NO_SPACE"
              glib:nick="no-space"
              glib:name="TRACKER_SPARQL_ERROR_NO_SPACE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="35">There was no disk space available to perform the request.</doc>
      </member>
      <member name="ontology_not_found"
              value="3"
              c:identifier="TRACKER_SPARQL_ERROR_ONTOLOGY_NOT_FOUND"
              glib:nick="ontology-not-found"
              glib:name="TRACKER_SPARQL_ERROR_ONTOLOGY_NOT_FOUND">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="36">The specified ontology wasn't found.</doc>
      </member>
      <member name="open_error"
              value="4"
              c:identifier="TRACKER_SPARQL_ERROR_OPEN_ERROR"
              glib:nick="open-error"
              glib:name="TRACKER_SPARQL_ERROR_OPEN_ERROR">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="37">Problem encountered while opening the database.</doc>
      </member>
      <member name="parse"
              value="5"
              c:identifier="TRACKER_SPARQL_ERROR_PARSE"
              glib:nick="parse"
              glib:name="TRACKER_SPARQL_ERROR_PARSE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="38">Error parsing the SPARQL string.</doc>
      </member>
      <member name="query_failed"
              value="6"
              c:identifier="TRACKER_SPARQL_ERROR_QUERY_FAILED"
              glib:nick="query-failed"
              glib:name="TRACKER_SPARQL_ERROR_QUERY_FAILED">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="39">Problem while executing the query.</doc>
      </member>
      <member name="type"
              value="7"
              c:identifier="TRACKER_SPARQL_ERROR_TYPE"
              glib:nick="type"
              glib:name="TRACKER_SPARQL_ERROR_TYPE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="40">Type constraint failed when trying to insert data.</doc>
      </member>
      <member name="unknown_class"
              value="8"
              c:identifier="TRACKER_SPARQL_ERROR_UNKNOWN_CLASS"
              glib:nick="unknown-class"
              glib:name="TRACKER_SPARQL_ERROR_UNKNOWN_CLASS">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="41">Unknown class.</doc>
      </member>
      <member name="unknown_graph"
              value="9"
              c:identifier="TRACKER_SPARQL_ERROR_UNKNOWN_GRAPH"
              glib:nick="unknown-graph"
              glib:name="TRACKER_SPARQL_ERROR_UNKNOWN_GRAPH">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="42">Unknown graph.</doc>
      </member>
      <member name="unknown_property"
              value="10"
              c:identifier="TRACKER_SPARQL_ERROR_UNKNOWN_PROPERTY"
              glib:nick="unknown-property"
              glib:name="TRACKER_SPARQL_ERROR_UNKNOWN_PROPERTY">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="43">Unknown property.</doc>
      </member>
      <member name="unsupported"
              value="11"
              c:identifier="TRACKER_SPARQL_ERROR_UNSUPPORTED"
              glib:nick="unsupported"
              glib:name="TRACKER_SPARQL_ERROR_UNSUPPORTED">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="44">Unsupported feature or method.</doc>
      </member>
      <member name="missing_last_modified_header"
              value="12"
              c:identifier="TRACKER_SPARQL_ERROR_MISSING_LAST_MODIFIED_HEADER"
              glib:nick="missing-last-modified-header"
              glib:name="TRACKER_SPARQL_ERROR_MISSING_LAST_MODIFIED_HEADER">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="45">The ontology doesn't contain nrl:lastModified header</doc>
      </member>
      <member name="incomplete_property_definition"
              value="13"
              c:identifier="TRACKER_SPARQL_ERROR_INCOMPLETE_PROPERTY_DEFINITION"
              glib:nick="incomplete-property-definition"
              glib:name="TRACKER_SPARQL_ERROR_INCOMPLETE_PROPERTY_DEFINITION">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="46">The property is not completely defined.</doc>
      </member>
      <member name="corrupt"
              value="14"
              c:identifier="TRACKER_SPARQL_ERROR_CORRUPT"
              glib:nick="corrupt"
              glib:name="TRACKER_SPARQL_ERROR_CORRUPT">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="47">A soft/hard corruption was found in the database during operation.
  If this error is obtained during regular operations with an existing [class@Tracker.SparqlConnection],
  the corruption was newly found. This event will be persistently recorded so that the
  [func@Tracker.SparqlConnection.new_async] constructor (or its synchronous variant) will
  perform database repair attempts. If this error is obtained during one of those constructors, the
  database could not be repaired automatically and data loss is unavoidable. It is left to the discretion
  of the API user to set up the appropriate fallbacks in this situation, to replace the
  database and recover from the error. See [ctor@Tracker.SparqlConnection.new] documentation
  for more information on corruption handling.</doc>
      </member>
      <member name="last"
              value="15"
              c:identifier="TRACKER_SPARQL_ERROR_LAST"
              glib:nick="last"
              glib:name="TRACKER_SPARQL_ERROR_LAST">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-error.h"
             line="56">The total number of error codes.</doc>
      </member>
      <function name="quark" c:identifier="tracker_sparql_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="SparqlStatement"
           c:symbol-prefix="sparql_statement"
           c:type="TrackerSparqlStatement"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TrackerSparqlStatement"
           glib:get-type="tracker_sparql_statement_get_type"
           glib:type-struct="SparqlStatementClass">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-statement.c"
           line="19">`TrackerSparqlStatement` represents a prepared statement for a SPARQL query.

The SPARQL query will be internally compiled into the format that is most
optimal to execute the query many times. For connections created
through [ctor@Tracker.SparqlConnection.new] that will be a
SQLite compiled statement.

The SPARQL query may contain parameterized variables expressed via the
`~` prefix in the SPARQL syntax (e.g. `~var`), these may happen anywhere
in the SPARQL where a literal or variable would typically happen. These
parameterized variables may be mapped to arbitrary values prior to
execution. The `TrackerSparqlStatement` may be reused for future
queries with different values.

The argument bindings may be changed through the [method@Tracker.SparqlStatement.bind_int],
[method@Tracker.SparqlStatement.bind_int], etc... family of functions. Those functions
receive a @name argument corresponding for the variable name in the SPARQL query
(eg. `"var"` for `~var`) and a value to map the variable to.

Once all arguments have a value, the query may be executed through
[method@Tracker.SparqlStatement.execute_async] or [method@Tracker.SparqlStatement.execute].

It is possible to use any `TrackerSparqlStatement` from other threads than
the one it was created from. However, binding values and executing the
statement must only happen from one thread at a time. It is possible to reuse
the `TrackerSparqlStatement` right after [method@Tracker.SparqlStatement.execute_async]
was called, there is no need to wait for [method@Tracker.SparqlStatement.execute_finish].

In some circumstances, it is possible that the query needs to be recompiled
from the SPARQL source. This will happen transparently.</doc>
      <source-position filename="src/libtracker-sparql/tracker-statement.h"
                       line="34"/>
      <method name="bind_boolean"
              c:identifier="tracker_sparql_statement_bind_boolean">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="211">Binds the boolean @value to the parameterized variable given by @name.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="49"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="213">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="214">variable name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="215">value</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_datetime"
              c:identifier="tracker_sparql_statement_bind_datetime"
              version="3.2">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="296">Binds the [type@GLib.DateTime] @value to the parameterized variable given by @name.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="68"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="298">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="299">variable name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="300">value</doc>
            <type name="GLib.DateTime" c:type="GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_double"
              c:identifier="tracker_sparql_statement_bind_double">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="253">Binds the double @value to the parameterized variable given by @name.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="59"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="255">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="256">variable name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="257">value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_int" c:identifier="tracker_sparql_statement_bind_int">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="232">Binds the integer @value to the parameterized variable given by @name.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="54"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="234">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="235">variable name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="236">value</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_langstring"
              c:identifier="tracker_sparql_statement_bind_langstring"
              version="3.7">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="321">Binds the @value to the parameterized variable given by @name, tagged
with the language defined by @langtag. The language tag should follow
[RFC 5646](https://www.rfc-editor.org/rfc/rfc5646.html). The parameter
will be represented as a [`rdf:langString`](rdf-ontology.html#rdf:langString).</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="72"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="323">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="324">variable name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="325">value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="langtag" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="326">language tag</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="bind_string"
              c:identifier="tracker_sparql_statement_bind_string">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="274">Binds the string @value to the parameterized variable given by @name.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="276">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="277">variable name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="278">value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_bindings"
              c:identifier="tracker_sparql_statement_clear_bindings">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="559">Clears all bindings.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="107"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="561">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="execute"
              c:identifier="tracker_sparql_statement_execute"
              throws="1"
              glib:async-func="execute_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="352">Executes the `SELECT` or `ASK` SPARQL query with the currently bound values.

This function also works for `DESCRIBE` and `CONSTRUCT` queries that
retrieve data from the triple store. These query forms that return
RDF data are however more useful together with [method@Tracker.SparqlStatement.serialize_async].

This function should only be called on `TrackerSparqlStatement` objects
obtained through [method@Tracker.SparqlConnection.query_statement] or
SELECT/CONSTRUCT/DESCRIBE statements loaded through
[method@Tracker.SparqlConnection.load_statement_from_gresource].
An error will be raised if this method is called on a `INSERT` or `DELETE`
SPARQL query.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="78"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-statement.c"
               line="371">A `TrackerSparqlCursor` with the query results.</doc>
          <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="354">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="355">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="execute_async"
              c:identifier="tracker_sparql_statement_execute_async"
              glib:finish-func="execute_finish"
              glib:sync-func="execute">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="395">Executes asynchronously the `SELECT` or `ASK` SPARQL query with the currently bound values.

This function also works for `DESCRIBE` and `CONSTRUCT` queries that
retrieve data from the triple store. These query forms that return
RDF data are however more useful together with [method@Tracker.SparqlStatement.serialize_async].

This function should only be called on `TrackerSparqlStatement` objects
obtained through [method@Tracker.SparqlConnection.query_statement] or
SELECT/CONSTRUCT/DESCRIBE statements loaded through
[method@Tracker.SparqlConnection.load_statement_from_gresource].
An error will be raised if this method is called on a `INSERT` or `DELETE`
SPARQL query.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="83"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="397">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="398">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="399">user-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="401">user-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="execute_finish"
              c:identifier="tracker_sparql_statement_execute_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="431">Finishes the asynchronous operation started through
[method@Tracker.SparqlStatement.execute_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="89"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-statement.c"
               line="440">A `TrackerSparqlCursor` with the query results.</doc>
          <type name="SparqlCursor" c:type="TrackerSparqlCursor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="433">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="res" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="434">a [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_connection"
              c:identifier="tracker_sparql_statement_get_connection"
              glib:get-property="connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="175">Returns the [class@Tracker.SparqlConnection] that this statement was created for.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="43"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-statement.c"
               line="181">The SPARQL connection of this statement.</doc>
          <type name="SparqlConnection" c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="177">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sparql"
              c:identifier="tracker_sparql_statement_get_sparql"
              glib:get-property="sparql">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="193">Returns the SPARQL string that this prepared statement holds.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="46"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-statement.c"
               line="199">The contained SPARQL query</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="195">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="serialize_async"
              c:identifier="tracker_sparql_statement_serialize_async"
              version="3.3"
              glib:finish-func="serialize_finish">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="573">Serializes a `DESCRIBE` or `CONSTRUCT` query into the given RDF @format.

The query @stmt was created from must be either a `DESCRIBE` or `CONSTRUCT`
query, an error will be raised otherwise.

This is an asynchronous operation, @callback will be invoked when the
data is available for reading.

The SPARQL endpoint may not support the specified format, in that case
an error will be raised.

The @flags argument is reserved for future expansions, currently
#TRACKER_SERIALIZE_FLAGS_NONE must be passed.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="94"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="575">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="576">serialization flags</doc>
            <type name="SerializeFlags" c:type="TrackerSerializeFlags"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="577">RDF format of the serialized data</doc>
            <type name="RdfFormat" c:type="TrackerRdfFormat"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="578">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="579">user-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="581">user-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="serialize_finish"
              c:identifier="tracker_sparql_statement_serialize_finish"
              version="3.3"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="620">Finishes the asynchronous operation started through
[method@Tracker.SparqlStatement.serialize_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="102"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-statement.c"
               line="629">a [class@Gio.InputStream] to read RDF content.</doc>
          <type name="Gio.InputStream" c:type="GInputStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="622">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="623">a [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update"
              c:identifier="tracker_sparql_statement_update"
              version="3.5"
              throws="1"
              glib:async-func="update_async">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="464">Executes the `INSERT`/`DELETE` SPARQL query series with the currently bound values.

This function should only be called on `TrackerSparqlStatement` objects
obtained through [method@Tracker.SparqlConnection.update_statement] or
`INSERT`/`DELETE` statements loaded through
[method@Tracker.SparqlConnection.load_statement_from_gresource].
An error will be raised if this method is called on
`SELECT`/`ASK`/`DESCRIBE`/`CONSTRUCT` SPARQL queries.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="110"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-statement.c"
               line="479">%TRUE if the update finished with no errors, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="466">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="467">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_async"
              c:identifier="tracker_sparql_statement_update_async"
              version="3.5"
              glib:finish-func="update_finish"
              glib:sync-func="update">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="497">Executes asynchronously the `INSERT`/`DELETE` SPARQL query series with the currently bound values.

This function should only be called on `TrackerSparqlStatement` objects
obtained through [method@Tracker.SparqlConnection.update_statement] or
`INSERT`/`DELETE` statements loaded through
[method@Tracker.SparqlConnection.load_statement_from_gresource].
An error will be raised if this method is called on
`SELECT`/`ASK`/`DESCRIBE`/`CONSTRUCT` SPARQL queries.</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="115"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="499">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="500">Optional [type@Gio.Cancellable]</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="501">user-defined [type@Gio.AsyncReadyCallback] to be called when
           the asynchronous operation is finished.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="503">user-defined data to be passed to @callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_finish"
              c:identifier="tracker_sparql_statement_update_finish"
              version="3.5"
              throws="1">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="531">Finishes the asynchronous update started through
[method@Tracker.SparqlStatement.update_async].</doc>
        <source-position filename="src/libtracker-sparql/tracker-statement.h"
                         line="121"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-statement.c"
               line="540">%TRUE if the update finished with no errors, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="533">a `TrackerSparqlStatement`</doc>
            <type name="SparqlStatement" c:type="TrackerSparqlStatement*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="src/libtracker-sparql/tracker-statement.c"
                 line="534">a [type@Gio.AsyncResult] with the result of the operation</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <property name="connection"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_connection">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="143">The [class@Tracker.SparqlConnection] the statement was created for.</doc>
        <type name="SparqlConnection"/>
      </property>
      <property name="sparql"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_sparql"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-statement.c"
             line="157">SPARQL query stored in this statement.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="SparqlStatementClass"
            c:type="TrackerSparqlStatementClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="SparqlStatement">
      <source-position filename="src/libtracker-sparql/tracker-statement.h"
                       line="34"/>
    </record>
    <enumeration name="SparqlValueType" c:type="TrackerSparqlValueType">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-cursor.h"
           line="39">Enumeration with the possible types of the cursor's cells</doc>
      <source-position filename="src/libtracker-sparql/tracker-cursor.h"
                       line="61"/>
      <member name="unbound"
              value="0"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_UNBOUND">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="41">Unbound value type</doc>
      </member>
      <member name="uri"
              value="1"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_URI">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="42">Uri value type, rdfs:Resource</doc>
      </member>
      <member name="string"
              value="2"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_STRING">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="43">String value type, xsd:string or rdf:langString</doc>
      </member>
      <member name="integer"
              value="3"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_INTEGER">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="44">Integer value type, xsd:integer</doc>
      </member>
      <member name="double"
              value="4"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_DOUBLE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="45">Double value type, xsd:double</doc>
      </member>
      <member name="datetime"
              value="5"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_DATETIME">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="46">Datetime value type, xsd:dateTime</doc>
      </member>
      <member name="blank_node"
              value="6"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_BLANK_NODE">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="47">Blank node value type</doc>
      </member>
      <member name="boolean"
              value="7"
              c:identifier="TRACKER_SPARQL_VALUE_TYPE_BOOLEAN">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-cursor.h"
             line="48">Boolean value type, xsd:boolean</doc>
      </member>
    </enumeration>
    <function name="check_version" c:identifier="tracker_check_version">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-version.c"
           line="33">Checks that the Tracker library in use is compatible with the given version.

Generally you would pass in the constants
[const@Tracker.MAJOR_VERSION], [const@Tracker.MINOR_VERSION], [const@Tracker.MICRO_VERSION]
as the three arguments to this function; that produces
a check that the library in use is compatible with
the version of Tracker the application or module was compiled
against.

Compatibility is defined by two things: first the version
of the running library is newer than the version
@required_major.@required_minor.@required_micro. Second
the running library must be binary compatible with the
version @required_major.@required_minor.@required_micro
(same major version.)</doc>
      <source-position filename="src/libtracker-sparql/tracker-version.h"
                       line="243"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-version.c"
             line="55">%NULL if the Tracker library is compatible with the
  given version, or a string describing the version mismatch.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="required_major" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-version.c"
               line="35">the required major version.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="required_minor" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-version.c"
               line="36">the required minor version.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="required_micro" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-version.c"
               line="37">the required micro version.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="sparql_error_quark"
              c:identifier="tracker_sparql_error_quark"
              moved-to="SparqlError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="sparql_escape_string"
              c:identifier="tracker_sparql_escape_string">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-utils.c"
           line="26">Escapes @literal so it is suitable for insertion in
SPARQL queries as string literals.

Manual construction of query strings based user input is best
avoided at all cost, use of #TrackerSparqlStatement is recommended
instead.</doc>
      <source-position filename="src/libtracker-sparql/tracker-utils.h"
                       line="38"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-utils.c"
             line="37">the escaped string</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="literal" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-utils.c"
               line="28">a string to escape</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sparql_escape_uri"
              c:identifier="tracker_sparql_escape_uri">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-uri.c"
           line="279">Escapes a string for use as a URI.</doc>
      <source-position filename="src/libtracker-sparql/tracker-utils.h"
                       line="35"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-uri.c"
             line="285">a newly-allocated string holding the result.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-uri.c"
               line="281">a string to be escaped, following the tracker sparql rules</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="sparql_escape_uri_printf"
              c:identifier="tracker_sparql_escape_uri_printf"
              introspectable="0">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-uri.c"
           line="255">Formats and escapes a string for use as a URI. This function takes variadic arguments.</doc>
      <source-position filename="src/libtracker-sparql/tracker-utils.h"
                       line="32"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-uri.c"
             line="263">a newly-allocated string holding the result.The returned string
should be freed with g_free() when no longer needed.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-uri.c"
               line="257">a standard printf() format string, but notice
    &lt;link linkend="string-precision"&gt;string precision pitfalls&lt;/link&gt; documented in g_strdup_printf()</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-uri.c"
               line="259">the parameters to insert into the format string</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="sparql_escape_uri_vprintf"
              c:identifier="tracker_sparql_escape_uri_vprintf"
              introspectable="0">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-uri.c"
           line="150">Formats and escapes a string for use as a URI. This function takes a `va_list`.

Similar to the standard C vsprintf() function but safer, since it
calculates the maximum space required and allocates memory to hold
the result.</doc>
      <source-position filename="src/libtracker-sparql/tracker-utils.h"
                       line="29"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-uri.c"
             line="162">a newly-allocated string holding the result.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-uri.c"
               line="152">a standard printf() format string, but notice
    &lt;link linkend="string-precision"&gt;string precision pitfalls&lt;/link&gt; documented in g_strdup_printf()</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="args" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="src/libtracker-sparql/tracker-uri.c"
               line="154">the list of parameters to insert into the format string</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="sparql_get_ontology_nepomuk"
              c:identifier="tracker_sparql_get_ontology_nepomuk">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-utils.c"
           line="103">Returns a path to the built-in Nepomuk ontologies.</doc>
      <source-position filename="src/libtracker-sparql/tracker-utils.h"
                       line="44"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-utils.c"
             line="108">a #GFile instance.</doc>
        <type name="Gio.File" c:type="GFile*"/>
      </return-value>
    </function>
    <function name="sparql_get_uuid_urn"
              c:identifier="tracker_sparql_get_uuid_urn">
      <doc xml:space="preserve"
           filename="src/libtracker-sparql/tracker-utils.c"
           line="90">Creates a fresh UUID-based URN.</doc>
      <source-position filename="src/libtracker-sparql/tracker-utils.h"
                       line="40"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="src/libtracker-sparql/tracker-utils.c"
             line="95">A newly generated UUID URN.</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
    </function>
  </namespace>
</repository>
