<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <include name="Tracker" version="1.0"/>
  <c:include name="libtracker-miner/tracker-miner.h"/>
  <namespace name="TrackerMiner"
             version="1.0"
             shared-library="libtracker-miner-1.0.so.0"
             c:identifier-prefixes="Tracker"
             c:symbol-prefixes="tracker">
    <interface name="DataProvider"
               c:symbol-prefix="data_provider"
               c:type="TrackerDataProvider"
               glib:type-name="TrackerDataProvider"
               glib:get-type="tracker_data_provider_get_type"
               glib:type-struct="DataProviderIface">
      <doc xml:space="preserve">An interface to enumerate URIs and feed the data to Tracker.</doc>
      <virtual-method name="begin" invoker="begin" version="1.2" throws="1">
        <doc xml:space="preserve">Creates a #TrackerEnumerator to enumerate children at the URI
provided by @url.

The attributes value is a string that specifies the file attributes
that should be gathered. It is not an error if it's not possible to
read a particular requested attribute from a file - it just won't
be set. attributes should be a comma-separated list of attributes
or attribute wildcards. The wildcard "*" means all attributes, and
a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
G_FILE_ATTRIBUTE_STANDARD_NAME. See g_file_enumerate_children() for
more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TrackerEnumerator or %NULL on failure.
This must be freed with g_object_unref().</doc>
          <type name="Enumerator" c:type="TrackerEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to enumerate</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #TrackerDirectoryFlags</doc>
            <type name="DirectoryFlags" c:type="TrackerDirectoryFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="begin_async" invoker="begin_async" version="1.2">
        <doc xml:space="preserve">Precisely the same operation as tracker_data_provider_begin()
is performing, but asynchronously.

When all i/o for the operation is finished the @callback will be
called with the requested information.

See the documentation of #TrackerDataProvider for information about the
order of returned files.

In case of a partial error the callback will be called with any
succeeding items and no error, and on the next request the error
will be reported. If a request is cancelled the callback will be
called with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to enumerate</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #TrackerDirectoryFlags</doc>
            <type name="DirectoryFlags" c:type="TrackerDirectoryFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="6">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="begin_finish"
                      invoker="begin_finish"
                      version="1.2"
                      throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with
tracker_data_provider_begin_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TrackerEnumerator or %NULL on failure.
This must be freed with g_object_unref().</doc>
          <type name="Enumerator" c:type="TrackerEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="end" invoker="end" version="1.2" throws="1">
        <doc xml:space="preserve">Closes any caches or operations related to creating the
#TrackerEnumerator to enumerate data at @url.

The attributes value is a string that specifies the file attributes
that should be gathered. It is not an error if it's not possible to
read a particular requested attribute from a file - it just won't
be set. attributes should be a comma-separated list of attributes
or attribute wildcards. The wildcard "*" means all attributes, and
a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
G_FILE_ATTRIBUTE_STANDARD_NAME. See g_file_enumerate_children() for
more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, otherwise %FALSE and @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator originally created by
tracker_data_provider_begin().</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="end_async" invoker="end_async" version="1.2">
        <doc xml:space="preserve">Precisely the same operation as tracker_data_provider_end()
is performing, but asynchronously.

When all i/o for the operation is finished the @callback will be
called with the requested information.

See the documentation of #TrackerDataProvider for information about the
order of returned files.

In case of a partial error the callback will be called with any
succeeding items and no error, and on the next request the error
will be reported. If a request is cancelled the callback will be
called with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator originally created by
tracker_data_provider_begin().</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="4">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="end_finish"
                      invoker="end_finish"
                      version="1.2"
                      throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with
tracker_data_provider_end_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, otherwise %FALSE and @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="begin"
              c:identifier="tracker_data_provider_begin"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Creates a #TrackerEnumerator to enumerate children at the URI
provided by @url.

The attributes value is a string that specifies the file attributes
that should be gathered. It is not an error if it's not possible to
read a particular requested attribute from a file - it just won't
be set. attributes should be a comma-separated list of attributes
or attribute wildcards. The wildcard "*" means all attributes, and
a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
G_FILE_ATTRIBUTE_STANDARD_NAME. See g_file_enumerate_children() for
more details.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TrackerEnumerator or %NULL on failure.
This must be freed with g_object_unref().</doc>
          <type name="Enumerator" c:type="TrackerEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to enumerate</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #TrackerDirectoryFlags</doc>
            <type name="DirectoryFlags" c:type="TrackerDirectoryFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="begin_async"
              c:identifier="tracker_data_provider_begin_async"
              version="1.2">
        <doc xml:space="preserve">Precisely the same operation as tracker_data_provider_begin()
is performing, but asynchronously.

When all i/o for the operation is finished the @callback will be
called with the requested information.

See the documentation of #TrackerDataProvider for information about the
order of returned files.

In case of a partial error the callback will be called with any
succeeding items and no error, and on the next request the error
will be reported. If a request is cancelled the callback will be
called with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="url" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to enumerate</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve">an attribute query string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">a set of #TrackerDirectoryFlags</doc>
            <type name="DirectoryFlags" c:type="TrackerDirectoryFlags"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="begin_finish"
              c:identifier="tracker_data_provider_begin_finish"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with
tracker_data_provider_begin_async().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TrackerEnumerator or %NULL on failure.
This must be freed with g_object_unref().</doc>
          <type name="Enumerator" c:type="TrackerEnumerator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="end"
              c:identifier="tracker_data_provider_end"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Closes any caches or operations related to creating the
#TrackerEnumerator to enumerate data at @url.

The attributes value is a string that specifies the file attributes
that should be gathered. It is not an error if it's not possible to
read a particular requested attribute from a file - it just won't
be set. attributes should be a comma-separated list of attributes
or attribute wildcards. The wildcard "*" means all attributes, and
a wildcard like "standard::*" means all attributes in the standard
namespace. An example attribute query be "standard::*,owner::user".
The standard attributes are available as defines, like
G_FILE_ATTRIBUTE_STANDARD_NAME. See g_file_enumerate_children() for
more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, otherwise %FALSE and @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator originally created by
tracker_data_provider_begin().</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="end_async"
              c:identifier="tracker_data_provider_end_async"
              version="1.2">
        <doc xml:space="preserve">Precisely the same operation as tracker_data_provider_end()
is performing, but asynchronously.

When all i/o for the operation is finished the @callback will be
called with the requested information.

See the documentation of #TrackerDataProvider for information about the
order of returned files.

In case of a partial error the callback will be called with any
succeeding items and no error, and on the next request the error
will be reported. If a request is cancelled the callback will be
called with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator originally created by
tracker_data_provider_begin().</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="end_finish"
              c:identifier="tracker_data_provider_end_finish"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with
tracker_data_provider_end_async().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, otherwise %FALSE and @error is set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="data_provider" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDataProvider.</doc>
            <type name="DataProvider" c:type="TrackerDataProvider*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="DataProviderIface"
            c:type="TrackerDataProviderIface"
            glib:is-gtype-struct-for="DataProvider">
      <doc xml:space="preserve">Virtual methods left to implement.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">Parent interface type.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="begin">
        <callback name="begin" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #TrackerEnumerator or %NULL on failure.
This must be freed with g_object_unref().</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="data_provider" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerDataProvider</doc>
              <type name="DataProvider" c:type="TrackerDataProvider*"/>
            </parameter>
            <parameter name="url" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile to enumerate</doc>
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #TrackerDirectoryFlags</doc>
              <type name="DirectoryFlags" c:type="TrackerDirectoryFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="begin_async">
        <callback name="begin_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="data_provider" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerDataProvider.</doc>
              <type name="DataProvider" c:type="TrackerDataProvider*"/>
            </parameter>
            <parameter name="url" transfer-ownership="none">
              <doc xml:space="preserve">a #GFile to enumerate</doc>
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <doc xml:space="preserve">an attribute query string</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve">a set of #TrackerDirectoryFlags</doc>
              <type name="DirectoryFlags" c:type="TrackerDirectoryFlags"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="7">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="7">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="begin_finish">
        <callback name="begin_finish" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a #TrackerEnumerator or %NULL on failure.
This must be freed with g_object_unref().</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </return-value>
          <parameters>
            <parameter name="data_provider" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerDataProvider.</doc>
              <type name="DataProvider" c:type="TrackerDataProvider*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end">
        <callback name="end" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, otherwise %FALSE and @error is set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="data_provider" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerDataProvider</doc>
              <type name="DataProvider" c:type="TrackerDataProvider*"/>
            </parameter>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerEnumerator originally created by
tracker_data_provider_begin().</doc>
              <type name="Enumerator" c:type="TrackerEnumerator*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end_async">
        <callback name="end_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="data_provider" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerDataProvider.</doc>
              <type name="DataProvider" c:type="TrackerDataProvider*"/>
            </parameter>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerEnumerator originally created by
tracker_data_provider_begin().</doc>
              <type name="Enumerator" c:type="TrackerEnumerator*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="5">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="5">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="end_finish">
        <callback name="end_finish" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, otherwise %FALSE and @error is set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="data_provider" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerDataProvider.</doc>
              <type name="DataProvider" c:type="TrackerDataProvider*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_tracker_reserved1" introspectable="0">
        <callback name="_tracker_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved2" introspectable="0">
        <callback name="_tracker_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved3" introspectable="0">
        <callback name="_tracker_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved4" introspectable="0">
        <callback name="_tracker_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved5" introspectable="0">
        <callback name="_tracker_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved6" introspectable="0">
        <callback name="_tracker_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved7" introspectable="0">
        <callback name="_tracker_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved8" introspectable="0">
        <callback name="_tracker_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <class name="Decorator"
           c:symbol-prefix="decorator"
           c:type="TrackerDecorator"
           parent="Miner"
           abstract="1"
           glib:type-name="TrackerDecorator"
           glib:get-type="tracker_decorator_get_type"
           glib:type-struct="DecoratorClass">
      <doc xml:space="preserve">Abstract miner object for passive extended metadata indexing, i.e.
data past the basic information such as file name, size, etc.</doc>
      <implements name="Gio.Initable"/>
      <function name="error_quark"
                c:identifier="tracker_decorator_error_quark"
                version="0.18.">
        <doc xml:space="preserve">Gives the caller the #GQuark used to identify #TrackerDecorator errors
in #GError structures. The #GQuark is used as the domain for the error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark used for the domain of a #GError.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <virtual-method name="finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="items_available">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="delete_id"
              c:identifier="tracker_decorator_delete_id"
              version="0.18.">
        <doc xml:space="preserve">Deletes resource needing extended metadata extraction from the
queue. @id is the same IDs emitted by tracker-store when the database is
updated for consistency. For details, see the GraphUpdated signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator.</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">an ID.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_class_names"
              c:identifier="tracker_decorator_get_class_names"
              version="0.18.">
        <doc xml:space="preserve">This function returns a string list of class names which are being
updated with extended metadata. An example would be 'nfo:Document'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a const gchar** or #NULL.</doc>
          <array c:type="const gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator.</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data_source"
              c:identifier="tracker_decorator_get_data_source"
              version="0.18.">
        <doc xml:space="preserve">The unique string identifying this #TrackerDecorator that has
extracted the extended metadata. This is essentially an identifier
so it's clear WHO has extracted this extended metadata.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a const gchar* or #NULL if an error happened.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator.</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_items"
              c:identifier="tracker_decorator_get_n_items"
              version="0.18.">
        <doc xml:space="preserve">Get the number of items left in the queue to be processed. This
indicates content that may already exist in Tracker but is waiting
to be further flurished with metadata with a 2nd pass extraction or
index.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of items queued to be processed, always &gt;= 0.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="next"
              c:identifier="tracker_decorator_next"
              version="0.18.">
        <doc xml:space="preserve">Processes the next resource in the queue to have extended metadata
extracted. If the item in the queue has been completed already, it
signals it's completion instead.

This function will give a #GError if the miner is paused at the
time it is called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator.</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">a #GAsyncReadyCallback.</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user_data for @callback.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_finish"
              c:identifier="tracker_decorator_next_finish"
              version="0.18."
              throws="1">
        <doc xml:space="preserve">Should be called in the callback function provided to
tracker_decorator_next() to return the result of the task be it an
error or not.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #TrackerDecoratorInfo on success or
 #NULL on error. Free with tracker_decorator_info_unref().</doc>
          <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator.</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_id"
              c:identifier="tracker_decorator_prepend_id"
              version="0.18.">
        <doc xml:space="preserve">Adds resource needing extended metadata extraction to the queue.
@id is the same IDs emitted by tracker-store when the database is updated for
consistency. For details, see the GraphUpdated signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator.</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the resource ID.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="class_name_id" transfer-ownership="none">
            <doc xml:space="preserve">the ID of the resource's class.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_priority_rdf_types"
              c:identifier="tracker_decorator_set_priority_rdf_types"
              version="0.18.">
        <doc xml:space="preserve">Re-evaluate the priority queues internally to ensure that
@rdf_types are handled before all other content. This is useful for
applications that need their content available sooner than the
standard time it would take to index content.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecorator</doc>
            <type name="Decorator" c:type="TrackerDecorator*"/>
          </instance-parameter>
          <parameter name="rdf_types" transfer-ownership="none">
            <doc xml:space="preserve">a string array of rdf types</doc>
            <type name="utf8" c:type="const gchar* const*"/>
          </parameter>
        </parameters>
      </method>
      <property name="class-names" writable="1" transfer-ownership="none">
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="commit-batch-size"
                writable="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="data-source"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="priority-rdf-types"
                readable="0"
                writable="1"
                transfer-ownership="none">
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <field name="parent_instance">
        <type name="Miner" c:type="TrackerMiner"/>
      </field>
      <field name="priv">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="finished" when="last" version="0.18.">
        <doc xml:space="preserve">The ::finished signal will be emitted whenever the
#TrackerDecorator has finished extracted extended metadata
for resources in the database.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="items-available" when="last" version="0.18.">
        <doc xml:space="preserve">The ::items-available signal will be emitted whenever the
#TrackerDecorator sees resources that are available for
extended metadata extraction.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="DecoratorClass"
            c:type="TrackerDecoratorClass"
            glib:is-gtype-struct-for="Decorator">
      <doc xml:space="preserve">An implementation that takes care of extracting extra metadata
specific to file types by talking to tracker-extract.

Based on #TrackerMinerClass.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent object class.</doc>
        <type name="MinerClass" c:type="TrackerMinerClass"/>
      </field>
      <field name="items_available">
        <callback name="items_available">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="decorator" transfer-ownership="none">
              <type name="Decorator" c:type="TrackerDecorator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finished">
        <callback name="finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="decorator" transfer-ownership="none">
              <type name="Decorator" c:type="TrackerDecorator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <doc xml:space="preserve">Reserved for future API improvements.</doc>
        <array zero-terminated="0" c:type="gpointer" fixed-size="10">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="DecoratorError" c:type="TrackerDecoratorError">
      <doc xml:space="preserve">Possible errors returned when calling tracker_decorator_next_finish().</doc>
      <member name="empty"
              value="0"
              c:identifier="TRACKER_DECORATOR_ERROR_EMPTY">
        <doc xml:space="preserve">There is no item to be processed
next. It is entirely possible to have a ::items_available signal
emitted and then have this error when calling
tracker_decorator_next_finish() because the signal may apply to a
class which we're not interested in. For example, a new nmo:Email
might have been added to Tracker, but we might only be interested
in nfo:Document. This case would give this error.</doc>
      </member>
      <member name="paused"
              value="1"
              c:identifier="TRACKER_DECORATOR_ERROR_PAUSED">
        <doc xml:space="preserve">No work was done or will be done
because the miner is currently paused.</doc>
      </member>
    </enumeration>
    <class name="DecoratorFS"
           c:symbol-prefix="decorator_fs"
           c:type="TrackerDecoratorFS"
           parent="Decorator"
           abstract="1"
           glib:type-name="TrackerDecoratorFS"
           glib:get-type="tracker_decorator_fs_get_type"
           glib:type-struct="DecoratorFSClass">
      <doc xml:space="preserve">A decorator object.</doc>
      <implements name="Gio.Initable"/>
      <method name="prepend_file"
              c:identifier="tracker_decorator_fs_prepend_file"
              version="1.2">
        <doc xml:space="preserve">Prepends a file for processing.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the tracker:id of the element corresponding to the file</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="decorator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorFS</doc>
            <type name="DecoratorFS" c:type="TrackerDecoratorFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to process</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Decorator" c:type="TrackerDecorator"/>
      </field>
      <field name="priv">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </class>
    <record name="DecoratorFSClass"
            c:type="TrackerDecoratorFSClass"
            glib:is-gtype-struct-for="DecoratorFS">
      <doc xml:space="preserve">A class that takes care of resources on mount points added or
removed, this is based on #TrackerDecoratorClass.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent object class.</doc>
        <type name="DecoratorClass" c:type="TrackerDecoratorClass"/>
      </field>
      <field name="padding">
        <doc xml:space="preserve">Reserved for future API improvements.</doc>
        <array zero-terminated="0" c:type="gpointer" fixed-size="10">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DecoratorInfo"
            c:type="TrackerDecoratorInfo"
            glib:type-name="TrackerDecoratorInfo"
            glib:get-type="tracker_decorator_info_get_type"
            c:symbol-prefix="decorator_info">
      <method name="get_mimetype"
              c:identifier="tracker_decorator_info_get_mimetype"
              version="0.18.">
        <doc xml:space="preserve">A MIME¹ type is a way of describing the content type of a file or
set of data. An example would be 'text/plain' for a clear text
document or file.

¹: http://en.wikipedia.org/wiki/MIME</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the MIME type for #TrackerDecoratorInfo on success or #NULL on error.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorInfo.</doc>
            <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sparql"
              c:identifier="tracker_decorator_info_get_sparql"
              version="0.18.">
        <doc xml:space="preserve">A #TrackerSparqlBuilder allows the caller to extract the final
SPARQL used to insert the extracted metadata into the database for
the resource being processed.

This function calls g_task_get_task_data() on the return value of
tracker_decorator_info_get_task().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #TrackerSparqlBuilder on success or #NULL on error.</doc>
          <type name="Tracker.SparqlBuilder" c:type="TrackerSparqlBuilder*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorInfo.</doc>
            <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_task"
              c:identifier="tracker_decorator_info_get_task"
              version="0.18.">
        <doc xml:space="preserve">Get the #GTask associated with retrieving extended metadata and
information for a URN in Tracker.

The task object's data (accessible with g_task_get_task_data()) is the
#TrackerSparqlBuilder that you must populate with the results of the
metadata extraction. This can also be accessed with
tracker_decorator_info_get_sparql().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GTask for #TrackerDecoratorInfo on
success or #NULL if there is no existing #GTask.</doc>
          <type name="Gio.Task" c:type="GTask*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorInfo.</doc>
            <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_url"
              c:identifier="tracker_decorator_info_get_url"
              version="0.18.">
        <doc xml:space="preserve">A URL is a Uniform Resource Locator and should be a location associated
with a resource in the database. For example, 'file:///tmp/foo.txt'.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URL for #TrackerDecoratorInfo on success or #NULL on error.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorInfo.</doc>
            <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_urn"
              c:identifier="tracker_decorator_info_get_urn"
              version="0.18.">
        <doc xml:space="preserve">A URN is a Uniform Resource Name and should be a unique identifier
for a resource in the database.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the URN for #TrackerDecoratorInfo on success or #NULL on error.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorInfo.</doc>
            <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref"
              c:identifier="tracker_decorator_info_ref"
              version="0.18.">
        <doc xml:space="preserve">Increases the reference count of @info by 1.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same @info passed in, or %NULL on error.</doc>
          <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorInfo</doc>
            <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref"
              c:identifier="tracker_decorator_info_unref"
              version="0.18.">
        <doc xml:space="preserve">Decreases the reference count of @info by 1 and frees it when the
reference count reaches 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerDecoratorInfo</doc>
            <type name="DecoratorInfo" c:type="TrackerDecoratorInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="DirectoryFlags"
              glib:type-name="TrackerDirectoryFlags"
              glib:get-type="tracker_directory_flags_get_type"
              c:type="TrackerDirectoryFlags">
      <member name="none"
              value="0"
              c:identifier="TRACKER_DIRECTORY_FLAG_NONE"
              glib:nick="none">
      </member>
      <member name="recurse"
              value="2"
              c:identifier="TRACKER_DIRECTORY_FLAG_RECURSE"
              glib:nick="recurse">
      </member>
      <member name="check_mtime"
              value="4"
              c:identifier="TRACKER_DIRECTORY_FLAG_CHECK_MTIME"
              glib:nick="check-mtime">
      </member>
      <member name="monitor"
              value="8"
              c:identifier="TRACKER_DIRECTORY_FLAG_MONITOR"
              glib:nick="monitor">
      </member>
      <member name="ignore"
              value="16"
              c:identifier="TRACKER_DIRECTORY_FLAG_IGNORE"
              glib:nick="ignore">
      </member>
      <member name="preserve"
              value="32"
              c:identifier="TRACKER_DIRECTORY_FLAG_PRESERVE"
              glib:nick="preserve">
      </member>
      <member name="priority"
              value="64"
              c:identifier="TRACKER_DIRECTORY_FLAG_PRIORITY"
              glib:nick="priority">
      </member>
      <member name="no_stat"
              value="128"
              c:identifier="TRACKER_DIRECTORY_FLAG_NO_STAT"
              glib:nick="no-stat">
      </member>
      <member name="check_deleted"
              value="256"
              c:identifier="TRACKER_DIRECTORY_FLAG_CHECK_DELETED"
              glib:nick="check-deleted">
      </member>
    </bitfield>
    <interface name="Enumerator"
               c:symbol-prefix="enumerator"
               c:type="TrackerEnumerator"
               glib:type-name="TrackerEnumerator"
               glib:get-type="tracker_enumerator_get_type"
               glib:type-struct="EnumeratorIface">
      <doc xml:space="preserve">An interface to enumerate URIs and feed the data to Tracker.</doc>
      <virtual-method name="next" invoker="next" version="1.2" throws="1">
        <doc xml:space="preserve">Enumerates to the next piece of data according to the @enumerator
implementation.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">Returns a #gpointer with the next item
from the @enumerator, or %NULL when @error is set or the operation
was cancelled in @cancellable. The data must be freed. The function
to free depends on the data returned by the enumerator and the
#TrackerDataProvider that created the @enumerator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_async" invoker="next_async" version="1.2">
        <doc xml:space="preserve">Precisely the same operation as tracker_enumerator_next()
is performing, but asynchronously.

When all i/o for the operation is finished the @callback will be
called with the requested information.

In case of a partial error the callback will be called with any
succeeding items and no error, and on the next request the error
will be reported. If a request is cancelled the callback will be
called with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator.</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="3">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="next_finish"
                      invoker="next_finish"
                      version="1.2"
                      throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with
tracker_enumerator_next_async().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">Returns a #gpointer with the next item
from the @enumerator, or %NULL when @error is set or the operation
was cancelled in @cancellable. The data must be freed. The function
to free depends on the data returned by the enumerator and the
#TrackerDataProvider that created the @enumerator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator.</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="next"
              c:identifier="tracker_enumerator_next"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Enumerates to the next piece of data according to the @enumerator
implementation.</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">Returns a #gpointer with the next item
from the @enumerator, or %NULL when @error is set or the operation
was cancelled in @cancellable. The data must be freed. The function
to free depends on the data returned by the enumerator and the
#TrackerDataProvider that created the @enumerator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_async"
              c:identifier="tracker_enumerator_next_async"
              version="1.2">
        <doc xml:space="preserve">Precisely the same operation as tracker_enumerator_next()
is performing, but asynchronously.

When all i/o for the operation is finished the @callback will be
called with the requested information.

In case of a partial error the callback will be called with any
succeeding items and no error, and on the next request the error
will be reported. If a request is cancelled the callback will be
called with %G_IO_ERROR_CANCELLED.

During an async request no other sync and async calls are allowed,
and will result in %G_IO_ERROR_PENDING errors.

Any outstanding i/o request with higher priority (lower numerical
value) will be executed before an outstanding request with lower
priority. Default priority is %G_PRIORITY_DEFAULT.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator.</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </instance-parameter>
          <parameter name="io_priority" transfer-ownership="none">
            <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the data to pass to callback function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="next_finish"
              c:identifier="tracker_enumerator_next_finish"
              version="1.2"
              throws="1">
        <doc xml:space="preserve">Finishes the asynchronous operation started with
tracker_enumerator_next_async().</doc>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve">Returns a #gpointer with the next item
from the @enumerator, or %NULL when @error is set or the operation
was cancelled in @cancellable. The data must be freed. The function
to free depends on the data returned by the enumerator and the
#TrackerDataProvider that created the @enumerator.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="enumerator" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerEnumerator.</doc>
            <type name="Enumerator" c:type="TrackerEnumerator*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve">a #GAsyncResult.</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <record name="EnumeratorIface"
            c:type="TrackerEnumeratorIface"
            glib:is-gtype-struct-for="Enumerator">
      <doc xml:space="preserve">Virtual methods left to implement.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">Parent interface type.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="next">
        <callback name="next" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">Returns a #gpointer with the next item
from the @enumerator, or %NULL when @error is set or the operation
was cancelled in @cancellable. The data must be freed. The function
to free depends on the data returned by the enumerator and the
#TrackerDataProvider that created the @enumerator.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerEnumerator</doc>
              <type name="Enumerator" c:type="TrackerEnumerator*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to ignore.</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_async">
        <callback name="next_async">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerEnumerator.</doc>
              <type name="Enumerator" c:type="TrackerEnumerator*"/>
            </parameter>
            <parameter name="io_priority" transfer-ownership="none">
              <doc xml:space="preserve">the [I/O priority][io-priority] of the request</doc>
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">optional #GCancellable object, %NULL to
ignore</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="4">
              <doc xml:space="preserve">a #GAsyncReadyCallback to call when the
request is satisfied</doc>
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="4">
              <doc xml:space="preserve">the data to pass to callback function</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="next_finish">
        <callback name="next_finish" throws="1">
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve">Returns a #gpointer with the next item
from the @enumerator, or %NULL when @error is set or the operation
was cancelled in @cancellable. The data must be freed. The function
to free depends on the data returned by the enumerator and the
#TrackerDataProvider that created the @enumerator.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </return-value>
          <parameters>
            <parameter name="enumerator" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerEnumerator.</doc>
              <type name="Enumerator" c:type="TrackerEnumerator*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve">a #GAsyncResult.</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_tracker_reserved1" introspectable="0">
        <callback name="_tracker_reserved1">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved2" introspectable="0">
        <callback name="_tracker_reserved2">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved3" introspectable="0">
        <callback name="_tracker_reserved3">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved4" introspectable="0">
        <callback name="_tracker_reserved4">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved5" introspectable="0">
        <callback name="_tracker_reserved5">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved6" introspectable="0">
        <callback name="_tracker_reserved6">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved7" introspectable="0">
        <callback name="_tracker_reserved7">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="_tracker_reserved8" introspectable="0">
        <callback name="_tracker_reserved8">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
    </record>
    <enumeration name="FilterPolicy"
                 glib:type-name="TrackerFilterPolicy"
                 glib:get-type="tracker_filter_policy_get_type"
                 c:type="TrackerFilterPolicy">
      <member name="deny"
              value="0"
              c:identifier="TRACKER_FILTER_POLICY_DENY"
              glib:nick="deny">
      </member>
      <member name="accept"
              value="1"
              c:identifier="TRACKER_FILTER_POLICY_ACCEPT"
              glib:nick="accept">
      </member>
    </enumeration>
    <enumeration name="FilterType"
                 glib:type-name="TrackerFilterType"
                 glib:get-type="tracker_filter_type_get_type"
                 c:type="TrackerFilterType">
      <member name="file"
              value="0"
              c:identifier="TRACKER_FILTER_FILE"
              glib:nick="file">
      </member>
      <member name="directory"
              value="1"
              c:identifier="TRACKER_FILTER_DIRECTORY"
              glib:nick="directory">
      </member>
      <member name="parent_directory"
              value="2"
              c:identifier="TRACKER_FILTER_PARENT_DIRECTORY"
              glib:nick="parent-directory">
      </member>
    </enumeration>
    <class name="IndexingTree"
           c:symbol-prefix="indexing_tree"
           c:type="TrackerIndexingTree"
           parent="GObject.Object"
           glib:type-name="TrackerIndexingTree"
           glib:get-type="tracker_indexing_tree_get_type"
           glib:type-struct="IndexingTreeClass">
      <doc xml:space="preserve">Base object used to configure indexing within #TrackerMinerFS items.</doc>
      <constructor name="new"
                   c:identifier="tracker_indexing_tree_new"
                   version="0.14.0">
        <doc xml:space="preserve">Returns a newly created #TrackerIndexingTree</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TrackerIndexingTree</doc>
          <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_root"
                   c:identifier="tracker_indexing_tree_new_with_root"
                   version="1.2.2">
        <doc xml:space="preserve">If @root is %NULL, the default value is 'file:///'. Using %NULL
here is the equivalent to calling tracker_indexing_tree_new() which
takes no @root argument.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #TrackerIndexingTree</doc>
          <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
        </return-value>
        <parameters>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">The top level URL</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="child_updated">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="indexing_tree" transfer-ownership="none">
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="child" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="directory_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="indexing_tree" transfer-ownership="none">
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="directory" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="directory_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="indexing_tree" transfer-ownership="none">
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="directory" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="directory_updated">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="indexing_tree" transfer-ownership="none">
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="directory" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add" c:identifier="tracker_indexing_tree_add">
        <doc xml:space="preserve">Adds a directory to the indexing tree with the
given configuration flags.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">#GFile pointing to a directory</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Configuration flags for the directory</doc>
            <type name="DirectoryFlags" c:type="TrackerDirectoryFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_filter"
              c:identifier="tracker_indexing_tree_add_filter">
        <doc xml:space="preserve">Adds a new filter for basenames.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">filter type</doc>
            <type name="FilterType" c:type="TrackerFilterType"/>
          </parameter>
          <parameter name="glob_string" transfer-ownership="none">
            <doc xml:space="preserve">glob-style string for the filter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_filters"
              c:identifier="tracker_indexing_tree_clear_filters">
        <doc xml:space="preserve">Clears all filters of a given type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">filter type to clear</doc>
            <type name="FilterType" c:type="TrackerFilterType"/>
          </parameter>
        </parameters>
      </method>
      <method name="file_is_indexable"
              c:identifier="tracker_indexing_tree_file_is_indexable">
        <doc xml:space="preserve">returns %TRUE if @file should be indexed according to the
parameters given through tracker_indexing_tree_add() and
tracker_indexing_tree_add_filter().

If @file_type is #G_FILE_TYPE_UNKNOWN, file type will be queried to the
file system.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file should be indexed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="file_type" transfer-ownership="none">
            <doc xml:space="preserve">a #GFileType</doc>
            <type name="Gio.FileType" c:type="GFileType"/>
          </parameter>
        </parameters>
      </method>
      <method name="file_is_root"
              c:identifier="tracker_indexing_tree_file_is_root"
              version="1.2.">
        <doc xml:space="preserve">Evaluates if the URL represented by @file is the same of that for
the root of the @tree.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file matches the URL canonically, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile to compare</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="file_matches_filter"
              c:identifier="tracker_indexing_tree_file_matches_filter">
        <doc xml:space="preserve">Returns %TRUE if @file matches any filter of the given filter type.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @file is filtered.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">filter type</doc>
            <type name="FilterType" c:type="TrackerFilterType"/>
          </parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_default_policy"
              c:identifier="tracker_indexing_tree_get_default_policy"
              version="0.18.">
        <doc xml:space="preserve">Get the default filtering policies for @tree when indexing content.
Some content is black listed or white listed and the default policy
for that is returned here. The @filter allows specific type of
policies to be returned, for example, the default policy for files
(#TRACKER_FILTER_FILE).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Either #TRACKER_FILTER_POLICY_DENY or
#TRACKER_FILTER_POLICY_ALLOW.</doc>
          <type name="FilterPolicy" c:type="TrackerFilterPolicy"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerFilterType</doc>
            <type name="FilterType" c:type="TrackerFilterType"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_filter_hidden"
              c:identifier="tracker_indexing_tree_get_filter_hidden"
              version="0.18.">
        <doc xml:space="preserve">Describes if the @tree should index hidden content. To change this
setting, see tracker_indexing_tree_set_filter_hidden().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if hidden files are indexed, otherwise %TRUE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_master_root"
              c:identifier="tracker_indexing_tree_get_master_root"
              version="1.2.">
        <doc xml:space="preserve">Returns the #GFile that represents the master root location for all
indexing locations. For example, if
&lt;filename&gt;file:///etc&lt;/filename&gt; is an indexed path and so was
&lt;filename&gt;file:///home/user&lt;/filename&gt;, the master root is
&lt;filename&gt;file:///&lt;/filename&gt;. Only one scheme per @tree can be
used, so you can not mix &lt;filename&gt;http&lt;/filename&gt; and
&lt;filename&gt;file&lt;/filename&gt; roots in @tree.

The return value should &lt;emphasis&gt;NEVER&lt;/emphasis&gt; be %NULL. In
cases where no root is given, we fallback to
&lt;filename&gt;file:///&lt;/filename&gt;.

Roots explained:

- master root = top most level root node,
  e.g. file:///

- config root = a root node from GSettings,
  e.g. file:///home/martyn/Documents

- root = ANY root, normally config root, but it can also apply to
  roots added for devices, which technically are not a config root or a
  master root.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the effective root for all locations, or
%NULL on error. The root is owned by @tree and should not be freed.
It can be referenced using g_object_ref().</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_root" c:identifier="tracker_indexing_tree_get_root">
        <doc xml:space="preserve">Returns the #GFile that was previously added through tracker_indexing_tree_add()
and would equal or contain @file, or %NULL if none applies.

If the return value is non-%NULL, @directory_flags would contain the
#TrackerDirectoryFlags applying to @file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the effective parent in @tree, or %NULL</doc>
          <type name="Gio.File" c:type="GFile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="directory_flags"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for the applying #TrackerDirectoryFlags</doc>
            <type name="DirectoryFlags" c:type="TrackerDirectoryFlags*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_roots"
              c:identifier="tracker_indexing_tree_list_roots">
        <doc xml:space="preserve">Returns the list of indexing roots in @tree</doc>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">The list
         of roots, the list itself must be freed with g_list_free(),
         the list elements are owned by @tree and should not be
         freed.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Gio.File"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="notify_update"
              c:identifier="tracker_indexing_tree_notify_update"
              version="1.10">
        <doc xml:space="preserve">Signals either #TrackerIndexingTree::directory-updated or
#TrackerIndexingTree::child-updated on the given file and
returns #TRUE. If @file is not indexed according to the
#TrackerIndexingTree, #FALSE is returned.

If @recursive is #TRUE, #TrackerIndexingTree::directory-updated
will be emitted on the indexing roots that are contained in @file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if a signal is emitted.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="recursive" transfer-ownership="none">
            <doc xml:space="preserve">Whether contained indexing roots are affected by the update</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="parent_is_indexable"
              c:identifier="tracker_indexing_tree_parent_is_indexable">
        <doc xml:space="preserve">returns %TRUE if @parent should be indexed based on its contents.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @parent should be indexed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">parent directory</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="children" transfer-ownership="none">
            <doc xml:space="preserve">children within @parent</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Gio.File"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="tracker_indexing_tree_remove">
        <doc xml:space="preserve">Removes @directory from the indexing tree, note that
only directories previously added with tracker_indexing_tree_add()
can be effectively removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">#GFile pointing to a directory</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_policy"
              c:identifier="tracker_indexing_tree_set_default_policy"
              version="0.18.">
        <doc xml:space="preserve">Set the default @policy (to allow or deny) for content in @tree
based on the type - in this case @filter. Here, @filter is a file
or directory and there are some other options too.

For example, you can (by default), disable indexing all directories
using this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerFilterType</doc>
            <type name="FilterType" c:type="TrackerFilterType"/>
          </parameter>
          <parameter name="policy" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerFilterPolicy</doc>
            <type name="FilterPolicy" c:type="TrackerFilterPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_filter_hidden"
              c:identifier="tracker_indexing_tree_set_filter_hidden"
              version="0.18.">
        <doc xml:space="preserve">When indexing content, sometimes it is preferable to ignore hidden
content, for example, files prefixed with &amp;quot;.&amp;quot;. This is
common for files in a home directory which are usually config
files.

Sets the indexing policy for @tree with hidden files and content.
To ignore hidden files, @filter_hidden should be %TRUE, otherwise
%FALSE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tree" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerIndexingTree</doc>
            <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
          </instance-parameter>
          <parameter name="filter_hidden" transfer-ownership="none">
            <doc xml:space="preserve">a boolean</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="filter-hidden" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="root"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Gio.File"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <glib:signal name="child-updated" when="last" version="1.10">
        <doc xml:space="preserve">The ::child-updated signal may be emitted to notify
about possible changes on children of a root.

#TrackerIndexingTree does not emit those by itself,
those may be triggered through tracker_indexing_tree_notify_update().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="root" transfer-ownership="none">
            <doc xml:space="preserve">the root of this child</doc>
            <type name="Gio.File"/>
          </parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">the updated child</doc>
            <type name="Gio.File"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="directory-added" when="last" version="0.14.0">
        <doc xml:space="preserve">the ::directory-added signal is emitted when a new
directory is added to the list of other directories which
are to be considered for indexing. Typically this is
signalled when the tracker_indexing_tree_add() API is
called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="directory-removed" when="last" version="0.14.0">
        <doc xml:space="preserve">the ::directory-removed signal is emitted when a
directory is removed from the list of other directories
which are to be considered for indexing. Typically this is
signalled when the tracker_indexing_tree_remove() API is
called.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="directory-updated" when="last" version="0.14.0">
        <doc xml:space="preserve">The ::directory-updated signal is emitted on a root
when either its indexing flags change (e.g. due to consecutive
calls to tracker_indexing_tree_add()), or anytime an update is
requested through tracker_indexing_tree_notify_update().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="IndexingTreeClass"
            c:type="TrackerIndexingTreeClass"
            glib:is-gtype-struct-for="IndexingTree">
      <doc xml:space="preserve">Class for the #TrackerIndexingTree.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent object class</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="directory_added">
        <callback name="directory_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indexing_tree" transfer-ownership="none">
              <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
            </parameter>
            <parameter name="directory" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="directory_removed">
        <callback name="directory_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indexing_tree" transfer-ownership="none">
              <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
            </parameter>
            <parameter name="directory" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="directory_updated">
        <callback name="directory_updated">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indexing_tree" transfer-ownership="none">
              <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
            </parameter>
            <parameter name="directory" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="child_updated">
        <callback name="child_updated">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indexing_tree" transfer-ownership="none">
              <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
            </parameter>
            <parameter name="root" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="child" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <doc xml:space="preserve">Reserved for future API improvements.</doc>
        <array zero-terminated="0" c:type="gpointer" fixed-size="9">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <constant name="MINER_DBUS_INTERFACE"
              value="org.freedesktop.Tracker1.Miner"
              c:type="TRACKER_MINER_DBUS_INTERFACE"
              version="0.8.">
      <doc xml:space="preserve">The name of the D-Bus interface to use for all data miners that
inter-operate with Tracker.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MINER_DBUS_NAME_PREFIX"
              value="org.freedesktop.Tracker1.Miner."
              c:type="TRACKER_MINER_DBUS_NAME_PREFIX"
              version="0.8.">
      <doc xml:space="preserve">D-Bus name prefix to use for all data miners. This allows custom
miners to be written using @TRACKER_MINER_DBUS_NAME_PREFIX + "Files" for
example and would show up on D-Bus under
&amp;quot;org.freedesktop.Tracker1.Miner.Files&amp;quot;.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MINER_DBUS_PATH_PREFIX"
              value="/org/freedesktop/Tracker1/Miner/"
              c:type="TRACKER_MINER_DBUS_PATH_PREFIX"
              version="0.8.">
      <doc xml:space="preserve">D-Bus path prefix to use for all data miners. This allows custom
miners to be written using @TRACKER_MINER_DBUS_PATH_PREFIX + "Files" for
example and would show up on D-Bus under
&amp;quot;/org/freedesktop/Tracker1/Miner/Files&amp;quot;.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="MINER_ERROR_DOMAIN"
              value="TrackerMiner"
              c:type="TRACKER_MINER_ERROR_DOMAIN"
              version="0.8.">
      <doc xml:space="preserve">Used as the domain for any #GErrors reported by @TrackerMiner objects.</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Miner"
           c:symbol-prefix="miner"
           c:type="TrackerMiner"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="TrackerMiner"
           glib:get-type="tracker_miner_get_type"
           glib:type-struct="MinerClass">
      <doc xml:space="preserve">Abstract miner object.</doc>
      <implements name="Gio.Initable"/>
      <function name="error_quark"
                c:identifier="tracker_miner_error_quark"
                version="0.8">
        <doc xml:space="preserve">Gives the caller the #GQuark used to identify #TrackerMiner errors
in #GError structures. The #GQuark is used as the domain for the error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark used for the domain of a #GError.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <virtual-method name="ignore_next_update"
                      invoker="ignore_next_update"
                      version="0.8">
        <doc xml:space="preserve">Tells the miner to mark @urls are to ignore on next update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
          <parameter name="urls" transfer-ownership="none">
            <doc xml:space="preserve">the urls to mark as to ignore on next update</doc>
            <array c:type="const GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="paused">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="progress">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
          <parameter name="status" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="resumed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="started">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stopped">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_connection"
              c:identifier="tracker_miner_get_connection"
              version="0.10">
        <doc xml:space="preserve">Gets the #TrackerSparqlConnection initialized by @miner</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #TrackerSparqlConnection.</doc>
          <type name="Tracker.SparqlConnection"
                c:type="TrackerSparqlConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_connection"
              c:identifier="tracker_miner_get_dbus_connection"
              version="0.10">
        <doc xml:space="preserve">Gets the #GDBusConnection initialized by @miner</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GDBusConnection.</doc>
          <type name="Gio.DBusConnection" c:type="GDBusConnection*"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_full_name"
              c:identifier="tracker_miner_get_dbus_full_name"
              version="0.10">
        <doc xml:space="preserve">Gets the DBus name registered by @miner</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant string which should not be modified by the caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dbus_full_path"
              c:identifier="tracker_miner_get_dbus_full_path"
              version="0.10">
        <doc xml:space="preserve">Gets the DBus path registered by @miner</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a constant string which should not be modified by the caller.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_pause_reasons"
              c:identifier="tracker_miner_get_n_pause_reasons"
              version="0.10.5">
        <doc xml:space="preserve">Returns the number of pause reasons holding @miner from
indexing contents.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The number of current pause reasons</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ignore_next_update"
              c:identifier="tracker_miner_ignore_next_update"
              version="0.8">
        <doc xml:space="preserve">Tells the miner to mark @urls are to ignore on next update.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
          <parameter name="urls" transfer-ownership="none">
            <doc xml:space="preserve">the urls to mark as to ignore on next update</doc>
            <array c:type="const GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="is_paused"
              c:identifier="tracker_miner_is_paused"
              version="0.10">
        <doc xml:space="preserve">Returns #TRUE if the miner is paused.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if the miner is paused.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_started"
              c:identifier="tracker_miner_is_started"
              version="0.8">
        <doc xml:space="preserve">Returns #TRUE if the miner has been started.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if the miner is already started.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pause"
              c:identifier="tracker_miner_pause"
              version="0.8"
              throws="1">
        <doc xml:space="preserve">Asks @miner to pause. On success the cookie ID is returned,
this is what must be used in tracker_miner_resume() to resume
operations. On failure @error will be set and -1 will be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The pause cookie ID.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
          <parameter name="reason" transfer-ownership="none">
            <doc xml:space="preserve">reason to pause</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resume"
              c:identifier="tracker_miner_resume"
              version="0.8"
              throws="1">
        <doc xml:space="preserve">Asks the miner to resume processing. The cookie must be something
returned by tracker_miner_pause(). The miner won't actually resume
operations until all pause requests have been resumed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#TRUE if the cookie was valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
          <parameter name="cookie" transfer-ownership="none">
            <doc xml:space="preserve">pause cookie</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="tracker_miner_start" version="0.8">
        <doc xml:space="preserve">Tells the miner to start processing data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="tracker_miner_stop" version="0.8">
        <doc xml:space="preserve">Tells the miner to stop processing data.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMiner</doc>
            <type name="Miner" c:type="TrackerMiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="introspection-handler"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="introspection-xml"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="progress"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="remaining-time"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="status"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="MinerPrivate" c:type="TrackerMinerPrivate*"/>
      </field>
      <glib:signal name="ignore-next-update" when="last" version="0.8">
        <doc xml:space="preserve">the ::ignore-next-update signal is emitted in the miner
right after it has been asked to mark @urls as to ignore on next update
through tracker_miner_ignore_next_update().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="urls" transfer-ownership="none">
            <doc xml:space="preserve">the urls to mark as ignore on next update</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="paused" when="last" version="0.8">
        <doc xml:space="preserve">the ::paused signal is emitted whenever
there is any reason to pause, either
internal (through tracker_miner_pause()) or
external (through DBus, see #TrackerMinerManager).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="progress" when="last" version="0.12">
        <doc xml:space="preserve">the ::progress signal will be emitted by TrackerMiner implementations
to indicate progress about the data mining process. @status will
contain a translated string with the current miner status and @progress
will indicate how much has been processed so far. @remaining_time will
give the number expected of seconds to finish processing, 0 if the
value cannot be estimated, and -1 if its not applicable.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="status" transfer-ownership="none">
            <doc xml:space="preserve">miner status</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="progress" transfer-ownership="none">
            <doc xml:space="preserve">a #gdouble indicating miner progress, from 0 to 1.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="remaining_time" transfer-ownership="none">
            <doc xml:space="preserve">a #gint indicating the reamaining processing time, in
seconds.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="resumed" when="last" version="0.8">
        <doc xml:space="preserve">the ::resumed signal is emitted whenever
all reasons to pause have disappeared, see
tracker_miner_resume() and #TrackerMinerManager.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="started" when="last" version="0.8">
        <doc xml:space="preserve">the ::started signal is emitted in the miner
right after it has been started through
tracker_miner_start().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="stopped" when="last" version="0.8">
        <doc xml:space="preserve">the ::stopped signal is emitted in the miner
right after it has been stopped through
tracker_miner_stop().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="MinerClass"
            c:type="TrackerMinerClass"
            glib:is-gtype-struct-for="Miner">
      <doc xml:space="preserve">Virtual methods left to implement.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">parent object class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="started">
        <callback name="started">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <type name="Miner" c:type="TrackerMiner*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stopped">
        <callback name="stopped">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <type name="Miner" c:type="TrackerMiner*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="paused">
        <callback name="paused">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <type name="Miner" c:type="TrackerMiner*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="resumed">
        <callback name="resumed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <type name="Miner" c:type="TrackerMiner*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="progress">
        <callback name="progress">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <type name="Miner" c:type="TrackerMiner*"/>
            </parameter>
            <parameter name="status" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="progress" transfer-ownership="none">
              <type name="gdouble" c:type="gdouble"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ignore_next_update">
        <callback name="ignore_next_update">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <doc xml:space="preserve">a #TrackerMiner</doc>
              <type name="Miner" c:type="TrackerMiner*"/>
            </parameter>
            <parameter name="urls" transfer-ownership="none">
              <doc xml:space="preserve">the urls to mark as to ignore on next update</doc>
              <array c:type="const GStrv">
                <type name="utf8"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <doc xml:space="preserve">Reserved for future API improvements.</doc>
        <array zero-terminated="0" c:type="gpointer" fixed-size="10">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="MinerError" c:type="TrackerMinerError">
      <doc xml:space="preserve">Possible errors returned when calling #TrackerMiner APIs or
subclassed miners where the error is generic to all miners.</doc>
      <member name="name_missing"
              value="0"
              c:identifier="TRACKER_MINER_ERROR_NAME_MISSING">
        <doc xml:space="preserve">No name was given when creating
the miner. The name is crucial for D-Bus presence and a host of
other things.</doc>
      </member>
      <member name="name_unavailable"
              value="1"
              c:identifier="TRACKER_MINER_ERROR_NAME_UNAVAILABLE">
        <doc xml:space="preserve">The name trying to be used
for the miner was not available, possibly because the miner is
already running with the same name in another process.</doc>
      </member>
      <member name="paused"
              value="2"
              c:identifier="TRACKER_MINER_ERROR_PAUSED">
        <doc xml:space="preserve">Given by miners when an API is used at
the time the miner itself is paused and such actions should be avoided.</doc>
      </member>
      <member name="paused_already"
              value="3"
              c:identifier="TRACKER_MINER_ERROR_PAUSED_ALREADY">
        <doc xml:space="preserve">The pause request has already
been given by the same application with the same reason. Duplicate
pause calls with the same reason by the same application can not
be carried out.</doc>
      </member>
      <member name="invalid_cookie"
              value="4"
              c:identifier="TRACKER_MINER_ERROR_INVALID_COOKIE">
        <doc xml:space="preserve">When pausing a miner, a cookie
(or @gint based ID) is given. That cookie must be used to resume a
previous pause request. If the cookie is unrecognised, this error
is given.</doc>
      </member>
    </enumeration>
    <class name="MinerFS"
           c:symbol-prefix="miner_fs"
           c:type="TrackerMinerFS"
           parent="Miner"
           abstract="1"
           glib:type-name="TrackerMinerFS"
           glib:get-type="tracker_miner_fs_get_type"
           glib:type-struct="MinerFSClass">
      <doc xml:space="preserve">Abstract miner implementation to get data from the filesystem.</doc>
      <implements name="Gio.Initable"/>
      <function name="error_quark"
                c:identifier="tracker_miner_fs_error_quark"
                version="1.2.">
        <doc xml:space="preserve">Gives the caller the #GQuark used to identify #TrackerMinerFS errors
in #GError structures. The #GQuark is used as the domain for the error.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GQuark used for the domain of a #GError.</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <virtual-method name="finished">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="elapsed" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="directories_found" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="directories_ignored" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="files_found" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="files_ignored" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="finished_root">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="root" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="directories_found" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="directories_ignored" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="files_found" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="files_ignored" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ignore_next_update_file">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <type name="Tracker.SparqlBuilder" c:type="TrackerSparqlBuilder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="process_file">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <type name="Tracker.SparqlBuilder" c:type="TrackerSparqlBuilder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="process_file_attributes">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <type name="Tracker.SparqlBuilder" c:type="TrackerSparqlBuilder*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="remove_file">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="children_only" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <type name="Tracker.SparqlBuilder" c:type="TrackerSparqlBuilder*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="writeback_file" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="rdf_types" transfer-ownership="none">
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="results" transfer-ownership="none">
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <type name="gpointer" c:type="gpointer"/>
            </array>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_directory_without_parent"
              c:identifier="tracker_miner_fs_add_directory_without_parent"
              version="0.10">
        <doc xml:space="preserve">Tells the miner-fs that the given #GFile corresponds to a
directory which was created in the store without a specific
parent object. In this case, when regenerating internal
caches, an extra query will be done so that these elements
are taken into account.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_directory"
              c:identifier="tracker_miner_fs_check_directory"
              version="0.10">
        <doc xml:space="preserve">Tells the filesystem miner to check and index a directory,
this file must be part of the usual crawling directories
of #TrackerMinerFS. See tracker_miner_fs_directory_add().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the directory to check</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="check_parents" transfer-ownership="none">
            <doc xml:space="preserve">whether to check parents and eligibility or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_directory_with_priority"
              c:identifier="tracker_miner_fs_check_directory_with_priority"
              version="0.10">
        <doc xml:space="preserve">Tells the filesystem miner to check and index a directory at
a given priority, this file must be part of the usual crawling
directories of #TrackerMinerFS. See tracker_miner_fs_directory_add().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the directory to check</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the priority of the check task</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="check_parents" transfer-ownership="none">
            <doc xml:space="preserve">whether to check parents and eligibility or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_file"
              c:identifier="tracker_miner_fs_check_file"
              version="0.10">
        <doc xml:space="preserve">Tells the filesystem miner to check and index a file,
this file must be part of the usual crawling directories
of #TrackerMinerFS. See tracker_miner_fs_directory_add().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the file to check</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="check_parents" transfer-ownership="none">
            <doc xml:space="preserve">whether to check parents and eligibility or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_file_with_priority"
              c:identifier="tracker_miner_fs_check_file_with_priority"
              version="0.10">
        <doc xml:space="preserve">Tells the filesystem miner to check and index a file at
a given priority, this file must be part of the usual
crawling directories of #TrackerMinerFS. See
tracker_miner_fs_directory_add().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the file to check</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">the priority of the check task</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="check_parents" transfer-ownership="none">
            <doc xml:space="preserve">whether to check parents and eligibility or not</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="directory_add"
              c:identifier="tracker_miner_fs_directory_add"
              version="0.8">
        <doc xml:space="preserve">Tells the filesystem miner to inspect a directory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the directory to inspect</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="recurse" transfer-ownership="none">
            <doc xml:space="preserve">whether the directory should be inspected recursively</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="directory_remove"
              c:identifier="tracker_miner_fs_directory_remove"
              version="0.8">
        <doc xml:space="preserve">Removes a directory from being inspected by @fs. Note that only directory
 watches are removed.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the directory was successfully removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the directory to be removed</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="directory_remove_full"
              c:identifier="tracker_miner_fs_directory_remove_full"
              version="0.10">
        <doc xml:space="preserve">Removes a directory from being inspected by @fs, and removes all
associated metadata of the directory (and its contents) from the
store.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the directory was successfully removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the directory to be removed</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="file_notify"
              c:identifier="tracker_miner_fs_file_notify"
              version="0.8">
        <doc xml:space="preserve">Notifies @fs that all processing on @file has been finished, if any error
happened during file data processing, it should be passed in @error, else
that parameter will contain %NULL to reflect success.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError with the error that happened during processing, or %NULL.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <method name="force_mtime_checking"
              c:identifier="tracker_miner_fs_force_mtime_checking"
              version="0.12">
        <doc xml:space="preserve">Tells @fs to force mtime checking (regardless of the global mtime check
configuration) on the given @directory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile representing the directory</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="force_recheck"
              c:identifier="tracker_miner_fs_force_recheck">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data_provider"
              c:identifier="tracker_miner_fs_get_data_provider"
              version="1.2">
        <doc xml:space="preserve">Returns the #TrackerDataProvider implementation, which is being used
to supply #GFile and #GFileInfo content to Tracker.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #TrackerDataProvider supplying content</doc>
          <type name="DataProvider" c:type="TrackerDataProvider*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_indexing_tree"
              c:identifier="tracker_miner_fs_get_indexing_tree">
        <doc xml:space="preserve">Returns the #TrackerIndexingTree which determines
what files/directories are indexed by @fs</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #TrackerIndexingTree
         holding the indexing configuration</doc>
          <type name="IndexingTree" c:type="TrackerIndexingTree*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_initial_crawling"
              c:identifier="tracker_miner_fs_get_initial_crawling"
              version="0.10">
        <doc xml:space="preserve">Returns a boolean which indicates if the indexing tree is crawled
upon start up or not. This may be set to %FALSE if working
prodominently with cloud data where you can't perform these checks.
By default and for local file systems, this is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if a file system structure is crawled for new
updates on start up, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mtime_checking"
              c:identifier="tracker_miner_fs_get_mtime_checking"
              version="0.10">
        <doc xml:space="preserve">Returns a boolean used to identify if file modification time checks
are performed when processing content. This may be set to %FALSE if
working prodominently with cloud data where you can't perform these
checks. By default and for local file systems, this is enabled.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if mtime checks for directories against the database
are done when @fs crawls the file system, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_parent_urn"
              c:identifier="tracker_miner_fs_get_parent_urn"
              version="0.8">
        <doc xml:space="preserve">If @file is currently being processed by @fs, this function
will return the parent folder URN if any. This function is
useful to set the nie:belongsToContainer relationship. The
processing order of #TrackerMinerFS guarantees that a folder
has been already fully processed for indexing before any
children is processed, so most usually this function should
return non-%NULL.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The parent folder URN, or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile obtained in #TrackerMinerFS::process-file</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_throttle"
              c:identifier="tracker_miner_fs_get_throttle"
              version="0.8">
        <doc xml:space="preserve">Gets the current throttle value, see
tracker_miner_fs_set_throttle() for more details.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a double representing a value between 0.0 and 1.0.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_urn"
              c:identifier="tracker_miner_fs_get_urn"
              version="0.8">
        <doc xml:space="preserve">If the item exists in the store, this function retrieves
the URN for a #GFile being currently processed.

If @file is not being currently processed by @fs, or doesn't
exist in the store yet, %NULL will be returned.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The URN containing the data associated to @file,
         or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile obtained in #TrackerMinerFS::process-file</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_items_to_process"
              c:identifier="tracker_miner_fs_has_items_to_process"
              version="0.10">
        <doc xml:space="preserve">The @fs keeps many priority queus for content it is processing.
This function returns %TRUE if the sum of all (or any) priority
queues is more than 0. This includes items deleted, created,
updated, moved or being written back.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if there are items to process in the internal
queues, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_urn"
              c:identifier="tracker_miner_fs_query_urn"
              version="0.10">
        <doc xml:space="preserve">If the item exists in the store, this function retrieves
the URN of the given #GFile

If @file doesn't exist in the store yet, %NULL will be returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string with the URN containing the data associated
         to @file, or %NULL.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_initial_crawling"
              c:identifier="tracker_miner_fs_set_initial_crawling"
              version="0.10">
        <doc xml:space="preserve">Tells the @fs that crawling the #TrackerIndexingTree should happen
initially. This is actually required to set up file system monitor
using technologies like inotify, etc.

Setting this to #FALSE can dramatically improve the start up the
crawling of the @fs.

The down side is that using this consistently means that some files
on the disk may be out of date with files in the database.

The main purpose of this function is for systems where a @fs is
running the entire time and where it is very unlikely that a file
could be changed outside between startup and shutdown of the
process using this API.

The default if not set directly is that @do_initial_crawling is %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="do_initial_crawling" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mtime_checking"
              c:identifier="tracker_miner_fs_set_mtime_checking"
              version="0.10">
        <doc xml:space="preserve">Tells the miner-fs that during the crawling phase, directory mtime
checks should or shouldn't be performed against the database to
make sure we have the most up to date version of the file being
checked at the time. Setting this to #FALSE can dramatically
improve the start up the crawling of the @fs.

The down side is that using this consistently means that some files
on the disk may be out of date with files in the database.

The main purpose of this function is for systems where a @fs is
running the entire time and where it is very unlikely that a file
could be changed outside between startup and shutdown of the
process using this API.

The default if not set directly is that @mtime_checking is %TRUE.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="mtime_checking" transfer-ownership="none">
            <doc xml:space="preserve">a #gboolean</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_throttle"
              c:identifier="tracker_miner_fs_set_throttle"
              version="0.8">
        <doc xml:space="preserve">Tells the filesystem miner to throttle its operations. A value of
0.0 means no throttling at all, so the miner will perform
operations at full speed, 1.0 is the slowest value. With a value of
1.0, the @fs is typically waiting one full second before handling
the next batch of queued items to be processed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="throttle" transfer-ownership="none">
            <doc xml:space="preserve">a double between 0.0 and 1.0</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="writeback_file"
              c:identifier="tracker_miner_fs_writeback_file"
              version="0.10.20">
        <doc xml:space="preserve">Tells the filesystem miner to writeback a file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">#GFile for the file to check</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="rdf_types" transfer-ownership="none">
            <doc xml:space="preserve">A #GStrv with rdf types</doc>
            <array c:type="GStrv">
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="results" transfer-ownership="none">
            <doc xml:space="preserve">A array of results from the preparation query</doc>
            <array name="GLib.PtrArray" c:type="GPtrArray*">
              <array>
                <type name="utf8"/>
              </array>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="writeback_notify"
              c:identifier="tracker_miner_fs_writeback_notify"
              version="0.10.20">
        <doc xml:space="preserve">Notifies @fs that all writing back on @file has been finished, if any error
happened during file data processing, it should be passed in @error, else
that parameter will contain %NULL to reflect success.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="fs" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerFS</doc>
            <type name="MinerFS" c:type="TrackerMinerFS*"/>
          </instance-parameter>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File" c:type="GFile*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">a #GError with the error that happened during processing, or %NULL.</doc>
            <type name="GLib.Error" c:type="const GError*"/>
          </parameter>
        </parameters>
      </method>
      <property name="data-provider"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="DataProvider"/>
      </property>
      <property name="initial-crawling" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="mtime-checking"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="processing-pool-ready-limit"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="processing-pool-wait-limit"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="root"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Gio.File"/>
      </property>
      <property name="throttle" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <field name="parent">
        <type name="Miner" c:type="TrackerMiner"/>
      </field>
      <field name="priv">
        <type name="MinerFSPrivate" c:type="TrackerMinerFSPrivate*"/>
      </field>
      <glib:signal name="finished" when="last" version="0.8">
        <doc xml:space="preserve">The ::finished signal is emitted when @miner_fs has finished
all pending processing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="elapsed" transfer-ownership="none">
            <doc xml:space="preserve">elapsed time since mining was started</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="directories_found" transfer-ownership="none">
            <doc xml:space="preserve">number of directories found</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="directories_ignored" transfer-ownership="none">
            <doc xml:space="preserve">number of ignored directories</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="files_found" transfer-ownership="none">
            <doc xml:space="preserve">number of files found</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="files_ignored" transfer-ownership="none">
            <doc xml:space="preserve">number of ignored files</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="finished-root" when="last" version="1.2">
        <doc xml:space="preserve">The ::finished-crawl signal is emitted when @miner_fs has
finished finding all resources that need to be indexed
with the root location of @file. At this point, it's likely
many are still in the queue to be added to the database,
but this gives some indication that a location is
processed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="ignore-next-update-file"
                   when="last"
                   version="0.8"
                   deprecated="1"
                   deprecated-version="0.12">
        <doc xml:space="preserve">The ::ignore-next-update-file signal is emitted whenever a file should
be marked as to ignore on next update, and it's metadata prepared for that.

@builder is the #TrackerSparqlBuilder where all sparql updates
to be performed for @file will be appended.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success
         %FALSE on failure</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerSparqlBuilder</doc>
            <type name="Tracker.SparqlBuilder"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="process-file" when="last" version="0.8">
        <doc xml:space="preserve">The ::process-file signal is emitted whenever a file should
be processed, and it's metadata extracted.

@builder is the #TrackerSparqlBuilder where all sparql updates
to be performed for @file will be appended.

This signal allows both synchronous and asynchronous extraction,
in the synchronous case @cancellable can be safely ignored. In
either case, on successful metadata extraction, implementations
must call tracker_miner_fs_file_notify() to indicate that
processing has finished on @file, so the miner can execute
the SPARQL updates and continue processing other files.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file is accepted for processing,
         %FALSE if the file should be ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerSparqlBuilder</doc>
            <type name="Tracker.SparqlBuilder"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="process-file-attributes" when="last" version="0.10">
        <doc xml:space="preserve">The ::process-file-attributes signal is emitted whenever a file should
be processed, but only the attribute-related metadata extracted.

@builder is the #TrackerSparqlBuilder where all sparql updates
to be performed for @file will be appended. For the properties being
updated, the DELETE statements should be included as well.

This signal allows both synchronous and asynchronous extraction,
in the synchronous case @cancellable can be safely ignored. In
either case, on successful metadata extraction, implementations
must call tracker_miner_fs_file_notify() to indicate that
processing has finished on @file, so the miner can execute
the SPARQL updates and continue processing other files.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file is accepted for processing,
         %FALSE if the file should be ignored.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerSparqlBuilder</doc>
            <type name="Tracker.SparqlBuilder"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="remove-file" when="last" version="1.8">
        <doc xml:space="preserve">The ::remove-file signal will be emitted on files that need removal
according to the miner configuration (either the files themselves are
deleted, or the directory/contents no longer need inspection according
to miner configuration and their location.

This operation is always assumed to be recursive, the @children_only
argument will be %TRUE if for any reason the topmost directory needs
to stay (e.g. moved from a recursively indexed directory tree to a
non-recursively indexed location).

The @builder argument can be used to provide additional SPARQL
deletes and updates necessary around the deletion of those items. If
the return value of this signal is %TRUE, @builder is expected to
contain all relevant deletes for this operation.

If the return value of this signal is %FALSE, the miner will apply
its default behavior, which is deleting all triples that correspond
to the affected URIs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if @builder contains all the necessary operations to
         delete the affected resources, %FALSE to let the miner
         implicitly handle the deletion.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
          <parameter name="children_only" transfer-ownership="none">
            <doc xml:space="preserve">#TRUE if only the children of @file are to be deleted</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="builder" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerSparqlBuilder</doc>
            <type name="Tracker.SparqlBuilder"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="writeback-file" when="last" version="0.10.20">
        <doc xml:space="preserve">The ::writeback-file signal is emitted whenever a file must be written
back</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="file" transfer-ownership="none">
            <doc xml:space="preserve">a #GFile</doc>
            <type name="Gio.File"/>
          </parameter>
          <parameter name="rdf_types" transfer-ownership="none">
            <doc xml:space="preserve">the set of RDF types</doc>
            <array>
              <type name="utf8"/>
            </array>
          </parameter>
          <parameter name="results" transfer-ownership="none">
            <doc xml:space="preserve">a set of results prepared by the preparation query</doc>
            <array name="GLib.PtrArray">
              <array>
                <type name="utf8"/>
              </array>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GCancellable</doc>
            <type name="Gio.Cancellable"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="MinerFSClass"
            c:type="TrackerMinerFSClass"
            glib:is-gtype-struct-for="MinerFS">
      <doc xml:space="preserve">Prototype for the abstract class, @process_file must be implemented
in the deriving class in order to actually extract data.</doc>
      <field name="parent">
        <doc xml:space="preserve">parent object class</doc>
        <type name="MinerClass" c:type="TrackerMinerClass"/>
      </field>
      <field name="process_file">
        <callback name="process_file">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="fs" transfer-ownership="none">
              <type name="MinerFS" c:type="TrackerMinerFS*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <type name="Tracker.SparqlBuilder"
                    c:type="TrackerSparqlBuilder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ignore_next_update_file">
        <callback name="ignore_next_update_file">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="fs" transfer-ownership="none">
              <type name="MinerFS" c:type="TrackerMinerFS*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <type name="Tracker.SparqlBuilder"
                    c:type="TrackerSparqlBuilder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finished">
        <callback name="finished">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="fs" transfer-ownership="none">
              <type name="MinerFS" c:type="TrackerMinerFS*"/>
            </parameter>
            <parameter name="elapsed" transfer-ownership="none">
              <type name="gdouble" c:type="gdouble"/>
            </parameter>
            <parameter name="directories_found" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="directories_ignored" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="files_found" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="files_ignored" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="process_file_attributes">
        <callback name="process_file_attributes">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="fs" transfer-ownership="none">
              <type name="MinerFS" c:type="TrackerMinerFS*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <type name="Tracker.SparqlBuilder"
                    c:type="TrackerSparqlBuilder*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="writeback_file" introspectable="0">
        <callback name="writeback_file" introspectable="0">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="fs" transfer-ownership="none">
              <type name="MinerFS" c:type="TrackerMinerFS*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="rdf_types" transfer-ownership="none">
              <array c:type="GStrv">
                <type name="utf8"/>
              </array>
            </parameter>
            <parameter name="results" transfer-ownership="none">
              <array name="GLib.PtrArray" c:type="GPtrArray*">
                <type name="gpointer" c:type="gpointer"/>
              </array>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finished_root">
        <callback name="finished_root">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="fs" transfer-ownership="none">
              <type name="MinerFS" c:type="TrackerMinerFS*"/>
            </parameter>
            <parameter name="root" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="directories_found" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="directories_ignored" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="files_found" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
            <parameter name="files_ignored" transfer-ownership="none">
              <type name="gint" c:type="gint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="remove_file">
        <callback name="remove_file">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="fs" transfer-ownership="none">
              <type name="MinerFS" c:type="TrackerMinerFS*"/>
            </parameter>
            <parameter name="file" transfer-ownership="none">
              <type name="Gio.File" c:type="GFile*"/>
            </parameter>
            <parameter name="children_only" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="builder" transfer-ownership="none">
              <type name="Tracker.SparqlBuilder"
                    c:type="TrackerSparqlBuilder*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <doc xml:space="preserve">Reserved for future API improvements.</doc>
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="MinerFSError"
                 version="1.2."
                 c:type="TrackerMinerFSError">
      <doc xml:space="preserve">Possible errors returned when calling creating new objects based on
the #TrackerMinerFS type and other APIs available with this class.</doc>
      <member name="miner_fs_error_init"
              value="0"
              c:identifier="TRACKER_MINER_FS_ERROR_INIT">
        <doc xml:space="preserve">There was an error during
initialization of the object. The specific details are in the
message.</doc>
      </member>
    </enumeration>
    <record name="MinerFSPrivate" c:type="TrackerMinerFSPrivate" disguised="1">
    </record>
    <class name="MinerOnline"
           c:symbol-prefix="miner_online"
           c:type="TrackerMinerOnline"
           parent="Miner"
           abstract="1"
           glib:type-name="TrackerMinerOnline"
           glib:get-type="tracker_miner_online_get_type"
           glib:type-struct="MinerOnlineClass">
      <doc xml:space="preserve">Abstract miner object for data requiring connectivity.</doc>
      <implements name="Gio.Initable"/>
      <virtual-method name="connected">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <type name="MinerOnline" c:type="TrackerMinerOnline*"/>
          </instance-parameter>
          <parameter name="network" transfer-ownership="none">
            <type name="NetworkType" c:type="TrackerNetworkType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="disconnected">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <type name="MinerOnline" c:type="TrackerMinerOnline*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_network_type"
              c:identifier="tracker_miner_online_get_network_type"
              version="0.18.">
        <doc xml:space="preserve">Get the type of network this data @miner uses to index content.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #TrackerNetworkType on success or #TRACKER_NETWORK_TYPE_NONE on error.</doc>
          <type name="NetworkType" c:type="TrackerNetworkType"/>
        </return-value>
        <parameters>
          <instance-parameter name="miner" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerMinerOnline.</doc>
            <type name="MinerOnline" c:type="TrackerMinerOnline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="network-type" transfer-ownership="none">
        <type name="NetworkType"/>
      </property>
      <field name="parent_instance">
        <type name="Miner" c:type="TrackerMiner"/>
      </field>
      <glib:signal name="connected" when="last" version="0.18.0">
        <doc xml:space="preserve">the ::connected signal is emitted when a specific @type of
network becomes connected.

Return values of #TRUE from this signal indicate whether a
#TrackerMiner should resume indexing or not upon ::connected.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a #TrackerNetworkType</doc>
            <type name="NetworkType"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="disconnected" when="last" version="0.18.0">
        <doc xml:space="preserve">the ::disconnected signal is emitted when a specific @type of
network becomes disconnected.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="MinerOnlineClass"
            c:type="TrackerMinerOnlineClass"
            glib:is-gtype-struct-for="MinerOnline"
            version="0.18.">
      <doc xml:space="preserve">Virtual methods that can be overridden.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">a #TrackerMinerClass</doc>
        <type name="MinerClass" c:type="TrackerMinerClass"/>
      </field>
      <field name="connected">
        <callback name="connected">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <type name="MinerOnline" c:type="TrackerMinerOnline*"/>
            </parameter>
            <parameter name="network" transfer-ownership="none">
              <type name="NetworkType" c:type="TrackerNetworkType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="disconnected">
        <callback name="disconnected">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="miner" transfer-ownership="none">
              <type name="MinerOnline" c:type="TrackerMinerOnline*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding">
        <doc xml:space="preserve">Reserved for future API improvements.</doc>
        <array zero-terminated="0" c:type="gpointer" fixed-size="10">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="MinerPrivate" c:type="TrackerMinerPrivate" disguised="1">
    </record>
    <enumeration name="NetworkType"
                 glib:type-name="TrackerNetworkType"
                 glib:get-type="tracker_network_type_get_type"
                 c:type="TrackerNetworkType">
      <member name="none"
              value="0"
              c:identifier="TRACKER_NETWORK_TYPE_NONE"
              glib:nick="none">
      </member>
      <member name="unknown"
              value="1"
              c:identifier="TRACKER_NETWORK_TYPE_UNKNOWN"
              glib:nick="unknown">
      </member>
      <member name="gprs"
              value="2"
              c:identifier="TRACKER_NETWORK_TYPE_GPRS"
              glib:nick="gprs">
      </member>
      <member name="edge"
              value="3"
              c:identifier="TRACKER_NETWORK_TYPE_EDGE"
              glib:nick="edge">
      </member>
      <member name="3g"
              value="4"
              c:identifier="TRACKER_NETWORK_TYPE_3G"
              glib:nick="3g">
      </member>
      <member name="lan"
              value="5"
              c:identifier="TRACKER_NETWORK_TYPE_LAN"
              glib:nick="lan">
      </member>
    </enumeration>
  </namespace>
</repository>
