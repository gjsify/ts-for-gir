<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:doc="http://www.gtk.org/introspection/doc/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="libsecret-1"/>
  <c:include name="libsecret/secret.h"/>
  <doc:format name="unknown"/>
  <namespace name="Secret"
             version="1"
             shared-library="libsecret-1.so.0"
             c:identifier-prefixes="Secret"
             c:symbol-prefixes="secret">
    <constant name="BACKEND_EXTENSION_POINT_NAME"
              value="secret-backend"
              c:type="SECRET_BACKEND_EXTENSION_POINT_NAME">
      <doc xml:space="preserve"
           filename="libsecret/secret-backend.c"
           line="70">Extension point for the secret backend.</doc>
      <source-position filename="libsecret/secret-backend.h" line="96"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <interface name="Backend"
               c:symbol-prefix="backend"
               c:type="SecretBackend"
               version="0.19.0"
               stability="Stable"
               glib:type-name="SecretBackend"
               glib:get-type="secret_backend_get_type"
               glib:type-struct="BackendInterface">
      <doc xml:space="preserve"
           filename="libsecret/secret-backend.c"
           line="27">#SecretBackend represents a backend implementation of password
storage.</doc>
      <source-position filename="libsecret/secret-backend.h" line="94"/>
      <prerequisite name="Gio.AsyncInitable"/>
      <function name="get"
                c:identifier="secret_backend_get"
                version="0.19.0"
                glib:finish-func="get_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="202">Get a #SecretBackend instance.

If such a backend already exists, then the same backend is returned.

If @flags contains any flags of which parts of the secret backend to
ensure are initialized, then those will be initialized before completing.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-backend.h" line="103"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-backend.c"
                 line="204">flags for which service functionality to ensure is initialized</doc>
            <type name="BackendFlags" c:type="SecretBackendFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-backend.c"
                 line="205">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-backend.c"
                 line="206">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-backend.c"
                 line="207">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_finish"
                c:identifier="secret_backend_get_finish"
                version="0.19.0"
                throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="258">Complete an asynchronous operation to get a #SecretBackend.</doc>
        <source-position filename="libsecret/secret-backend.h" line="108"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-backend.c"
               line="265">a new reference to a #SecretBackend proxy, which
  should be released with [method@GObject.Object.unref].</doc>
          <type name="Backend" c:type="SecretBackend*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-backend.c"
                 line="260">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="clear" glib:finish-func="clear_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="47">implementation of [func@password_clear], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="74"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="schema" transfer-ownership="none">
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="4">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clear_finish" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="48">implementation of [func@password_clear_finish], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="80"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ensure_for_flags"
                      glib:finish-func="ensure_for_flags_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="41">implementation of reinitialization step in constructor, optional</doc>
        <source-position filename="libsecret/secret-backend.h" line="42"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="BackendFlags" c:type="SecretBackendFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="3">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="ensure_for_flags_finish" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="42">implementation of reinitialization step in constructor, optional</doc>
        <source-position filename="libsecret/secret-backend.h" line="47"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup" glib:finish-func="lookup_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="45">implementation of [func@password_lookup], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="schema" transfer-ownership="none">
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="4">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="lookup_finish" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="46">implementation of [func@password_lookup_finish], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="70"/>
        <return-value transfer-ownership="full">
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="search" glib:finish-func="search_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="49">implementation of [func@password_search], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="84"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="schema" transfer-ownership="none">
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="SearchFlags" c:type="SecretSearchFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="5">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="search_finish" introspectable="0" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="50">implementation of [func@password_search_finish], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="91"/>
        <return-value>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="store" glib:finish-func="store_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="43">implementation of [func@password_store], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="51"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="schema" transfer-ownership="none">
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="gpointer" c:type="gpointer"/>
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
          <parameter name="collection" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="7">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="7">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="store_finish" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="44">implementation of [func@password_store_finish], required</doc>
        <source-position filename="libsecret/secret-backend.h" line="60"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Backend" c:type="SecretBackend*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <property name="flags"
                version="0.19.0"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="SECRET_SERVICE_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="83">A set of flags describing which parts of the secret backend have
been initialized.</doc>
        <type name="ServiceFlags"/>
      </property>
    </interface>
    <enumeration name="BackendFlags"
                 version="0.19.0"
                 glib:type-name="SecretBackendFlags"
                 glib:get-type="secret_backend_flags_get_type"
                 c:type="SecretBackendFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-backend.c"
           line="57">Flags which determine which parts of the #SecretBackend are initialized.</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_BACKEND_NONE"
              glib:nick="none"
              glib:name="SECRET_BACKEND_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="59">no flags for initializing the #SecretBackend</doc>
      </member>
      <member name="open_session"
              value="2"
              c:identifier="SECRET_BACKEND_OPEN_SESSION"
              glib:nick="open-session"
              glib:name="SECRET_BACKEND_OPEN_SESSION">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="60">establish a session for transfer of secrets
  while initializing the #SecretBackend</doc>
      </member>
      <member name="load_collections"
              value="4"
              c:identifier="SECRET_BACKEND_LOAD_COLLECTIONS"
              glib:nick="load-collections"
              glib:name="SECRET_BACKEND_LOAD_COLLECTIONS">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="62">load collections while initializing the
  #SecretBackend</doc>
      </member>
    </enumeration>
    <record name="BackendInterface"
            c:type="SecretBackendInterface"
            glib:is-gtype-struct-for="Backend"
            version="0.19.0">
      <doc xml:space="preserve"
           filename="libsecret/secret-backend.c"
           line="38">The interface for #SecretBackend.</doc>
      <source-position filename="libsecret/secret-backend.h" line="94"/>
      <field name="parent_iface">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="40">the parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="ensure_for_flags">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="41">implementation of reinitialization step in constructor, optional</doc>
        <callback name="ensure_for_flags">
          <source-position filename="libsecret/secret-backend.h" line="42"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="BackendFlags" c:type="SecretBackendFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="4">
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="4">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="ensure_for_flags_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="42">implementation of reinitialization step in constructor, optional</doc>
        <callback name="ensure_for_flags_finish" throws="1">
          <source-position filename="libsecret/secret-backend.h" line="47"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="store">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="43">implementation of [func@password_store], required</doc>
        <callback name="store">
          <source-position filename="libsecret/secret-backend.h" line="51"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="schema" transfer-ownership="none">
              <type name="Schema" c:type="const SecretSchema*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
            <parameter name="collection" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="label" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="Value" c:type="SecretValue*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="8">
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="8">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="store_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="44">implementation of [func@password_store_finish], required</doc>
        <callback name="store_finish" throws="1">
          <source-position filename="libsecret/secret-backend.h" line="60"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="45">implementation of [func@password_lookup], required</doc>
        <callback name="lookup">
          <source-position filename="libsecret/secret-backend.h" line="64"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="schema" transfer-ownership="none">
              <type name="Schema" c:type="const SecretSchema*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="5">
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="5">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="lookup_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="46">implementation of [func@password_lookup_finish], required</doc>
        <callback name="lookup_finish" throws="1">
          <source-position filename="libsecret/secret-backend.h" line="70"/>
          <return-value transfer-ownership="full">
            <type name="Value" c:type="SecretValue*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="47">implementation of [func@password_clear], required</doc>
        <callback name="clear">
          <source-position filename="libsecret/secret-backend.h" line="74"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="schema" transfer-ownership="none">
              <type name="Schema" c:type="const SecretSchema*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="5">
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="5">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clear_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="48">implementation of [func@password_clear_finish], required</doc>
        <callback name="clear_finish" throws="1">
          <source-position filename="libsecret/secret-backend.h" line="80"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="search">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="49">implementation of [func@password_search], required</doc>
        <callback name="search">
          <source-position filename="libsecret/secret-backend.h" line="84"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="schema" transfer-ownership="none">
              <type name="Schema" c:type="const SecretSchema*"/>
            </parameter>
            <parameter name="attributes" transfer-ownership="none">
              <type name="GLib.HashTable" c:type="GHashTable*">
                <type name="gpointer" c:type="gpointer"/>
                <type name="gpointer" c:type="gpointer"/>
              </type>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="SearchFlags" c:type="SecretSearchFlags"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="6">
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="6">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="search_finish" introspectable="0">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="50">implementation of [func@password_search_finish], required</doc>
        <callback name="search_finish" introspectable="0" throws="1">
          <source-position filename="libsecret/secret-backend.h" line="91"/>
          <return-value>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Backend" c:type="SecretBackend*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function-macro name="CHECK_VERSION"
                    c:identifier="SECRET_CHECK_VERSION"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-version.h"
           line="43">Returns `TRUE` if using libsecret is newer than or equal to the
given version.</doc>
      <source-position filename="libsecret/secret-version.h" line="52"/>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve"
               filename="libsecret/secret-version.h"
               line="45">major version to be satisfied</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve"
               filename="libsecret/secret-version.h"
               line="46">minor version to be satisfied</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve"
               filename="libsecret/secret-version.h"
               line="47">micro version to be satisfied</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECTION"
                    c:identifier="SECRET_COLLECTION"
                    introspectable="0">
      <source-position filename="libsecret/secret-collection.h" line="40"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECTION_CLASS"
                    c:identifier="SECRET_COLLECTION_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-collection.h" line="41"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="COLLECTION_DEFAULT"
              value="default"
              c:type="SECRET_COLLECTION_DEFAULT">
      <doc xml:space="preserve"
           filename="libsecret/secret-collection.c"
           line="70">An alias to the default collection.

This can be passed to [func@password_store] [func@Collection.for_alias].</doc>
      <source-position filename="libsecret/secret-types.h" line="42"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="COLLECTION_GET_CLASS"
                    c:identifier="SECRET_COLLECTION_GET_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-collection.h" line="44"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="COLLECTION_SESSION"
              value="session"
              c:type="SECRET_COLLECTION_SESSION">
      <doc xml:space="preserve"
           filename="libsecret/secret-collection.c"
           line="78">An alias to the session collection, which will be cleared when the user ends
the session.

This can be passed to [func@password_store], [func@Collection.for_alias] or
similar functions.</doc>
      <source-position filename="libsecret/secret-types.h" line="44"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <class name="Collection"
           c:symbol-prefix="collection"
           c:type="SecretCollection"
           stability="Stable"
           parent="Gio.DBusProxy"
           glib:type-name="SecretCollection"
           glib:get-type="secret_collection_get_type"
           glib:type-struct="CollectionClass">
      <doc xml:space="preserve"
           filename="libsecret/secret-collection.c"
           line="29">A proxy object representing a collection of secrets in the Secret Service.

#SecretCollection represents a collection of secret items stored in the
Secret Service.

A collection can be in a locked or unlocked state. Use
[method@SecretService.lock] or [method@SecretService.unlock] to lock or
unlock the collection.

Use the [property@SecretCollection:items] property or
[method@SecretCollection.get_items] to lookup the items in the collection.
There may not be any items exposed when the collection is locked.</doc>
      <source-position filename="libsecret/secret-collection.h" line="62"/>
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.DBusInterface"/>
      <implements name="Gio.Initable"/>
      <constructor name="new_for_dbus_path_finish"
                   c:identifier="secret_collection_new_for_dbus_path_finish"
                   introspectable="0"
                   throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="73">Finish asynchronous operation to get a new collection proxy for a
collection in the secret service.</doc>
        <source-position filename="libsecret/secret-paths.h" line="42"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="81">the new collection, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Collection" c:type="SecretCollection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="75">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_dbus_path_sync"
                   c:identifier="secret_collection_new_for_dbus_path_sync"
                   introspectable="0"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="105">Get a new collection proxy for a collection in the secret service.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-paths.h" line="45"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="123">the new collection, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Collection" c:type="SecretCollection*"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="107">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="collection_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="108">the D-Bus path of the collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="109">options for the collection initialization</doc>
            <type name="CollectionFlags" c:type="SecretCollectionFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="110">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="create"
                c:identifier="secret_collection_create"
                glib:finish-func="create_finish"
                glib:sync-func="create_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1063">Create a new collection in the secret service.

This method returns immediately and completes asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that are required.

An @alias is a well-known tag for a collection, such as 'default' (ie: the
default collection to store items in). This allows other applications to
easily identify and share a collection. If you specify an @alias, and a
collection with that alias already exists, then a new collection will not
be created. The previous one will be returned instead.

If @service is %NULL, then [func@Service.get] will be called to get the
default [class@Service] proxy.</doc>
        <source-position filename="libsecret/secret-collection.h" line="97"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1065">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1066">label for the new collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="alias"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1067">alias to assign to the collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1068">currently unused</doc>
            <type name="CollectionCreateFlags"
                  c:type="SecretCollectionCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1069">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1070">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1071">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="create_finish"
                c:identifier="secret_collection_create_finish"
                throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1126">Finish operation to create a new collection in the secret service.</doc>
        <source-position filename="libsecret/secret-collection.h" line="105"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1133">the new collection, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Collection" c:type="SecretCollection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1128">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="create_sync"
                c:identifier="secret_collection_create_sync"
                throws="1"
                glib:async-func="create">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1154">Create a new collection in the secret service.

This method may block indefinitely and should not be used in user interface
threads. The secret service may prompt the user. [method@Service.prompt]
will be used to handle any prompts that are required.

An @alias is a well-known tag for a collection, such as `default` (ie: the
default collection to store items in). This allows other applications to
easily identify and share a collection. If you specify an @alias, and a
collection with that alias already exists, then a new collection will not
be created. The previous one will be returned instead.

If @service is %NULL, then [func@Service.get_sync] will be called to get the
default [class@Service] proxy.</doc>
        <source-position filename="libsecret/secret-collection.h" line="108"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1178">the new collection, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Collection" c:type="SecretCollection*"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1156">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1157">label for the new collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="alias"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1158">alias to assign to the collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1159">currently unused</doc>
            <type name="CollectionCreateFlags"
                  c:type="SecretCollectionCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1160">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="for_alias"
                c:identifier="secret_collection_for_alias"
                glib:finish-func="for_alias_finish"
                glib:sync-func="for_alias_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="2110">Lookup which collection is assigned to this alias. Aliases help determine
well known collections, such as 'default'.

If @service is %NULL, then [func@Service.get] will be called to get the
default [class@Service] proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-collection.h" line="66"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2112">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2113">the alias to lookup</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2114">options for the collection initialization</doc>
            <type name="CollectionFlags" c:type="SecretCollectionFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2115">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2116">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2117">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="for_alias_finish"
                c:identifier="secret_collection_for_alias_finish"
                throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="2161">Finish an asynchronous operation to lookup which collection is assigned
to an alias.</doc>
        <source-position filename="libsecret/secret-collection.h" line="73"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="2169">the collection, or %NULL if none assigned to the alias</doc>
          <type name="Collection" c:type="SecretCollection*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2163">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="for_alias_sync"
                c:identifier="secret_collection_for_alias_sync"
                throws="1"
                glib:async-func="for_alias">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="2189">Lookup which collection is assigned to this alias. Aliases help determine
well known collections, such as `default`.

If @service is %NULL, then [func@Service.get_sync] will be called to get the
default [class@Service] proxy.

This method may block and should not be used in user interface threads.</doc>
        <source-position filename="libsecret/secret-collection.h" line="76"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="2205">the collection, or %NULL if none assigned to the alias</doc>
          <type name="Collection" c:type="SecretCollection*"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2191">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2192">the alias to lookup</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2193">options for the collection initialization</doc>
            <type name="CollectionFlags" c:type="SecretCollectionFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="2194">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_dbus_path"
                c:identifier="secret_collection_new_for_dbus_path"
                introspectable="0"
                stability="Unstable"
                glib:finish-func="new_for_dbus_path_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="26">Get a new collection proxy for a collection in the secret service.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-paths.h" line="35"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="28">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="collection_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="29">the D-Bus path of the collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="30">options for the collection initialization</doc>
            <type name="CollectionFlags" c:type="SecretCollectionFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="31">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="32">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="33">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="delete"
              c:identifier="secret_collection_delete"
              glib:finish-func="delete_finish"
              glib:sync-func="delete_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1626">Delete this collection.

This method returns immediately and completes asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that show up.</doc>
        <source-position filename="libsecret/secret-collection.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1628">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1629">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1630">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1631">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_finish"
              c:identifier="secret_collection_delete_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1662">Complete operation to delete this collection.</doc>
        <source-position filename="libsecret/secret-collection.h" line="139"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1670">whether the collection was successfully deleted or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1664">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1665">asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_sync"
              c:identifier="secret_collection_delete_sync"
              throws="1"
              glib:async-func="delete">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1689">Delete this collection.

This method may block indefinitely and should not be used in user interface
threads. The secret service may prompt the user. [method@Service.prompt] will
be used to handle any prompts that show up.</doc>
        <source-position filename="libsecret/secret-collection.h" line="143"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1701">whether the collection was successfully deleted or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1691">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1692">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_created"
              c:identifier="secret_collection_get_created"
              glib:get-property="created">
        <attribute name="org.gtk.Method.get_property" value="created"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1949">Get the created date and time of the collection.

The return value is the number of seconds since the unix epoch, January 1st
1970.</doc>
        <source-position filename="libsecret/secret-collection.h" line="172"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1958">the created date and time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1951">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="secret_collection_get_flags"
              glib:get-property="flags">
        <attribute name="org.gtk.Method.get_property" value="flags"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1745">Get the flags representing what features of the #SecretCollection proxy
have been initialized.

Use [method@Collection.load_items] to initialize further features and change
the flags.</doc>
        <source-position filename="libsecret/secret-collection.h" line="149"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1755">the flags for features initialized</doc>
          <type name="CollectionFlags" c:type="SecretCollectionFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1747">the secret collection proxy</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_items" c:identifier="secret_collection_get_items">
        <attribute name="org.gtk.Method.get_property" value="items"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1774">Get the list of items in this collection.</doc>
        <source-position filename="libsecret/secret-collection.h" line="151"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1780">a list of items, when
  done, the list should be freed with [func@GLib.List.free], and each item
  should be released with [method@GObject.Object.unref]</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Item"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1776">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_label"
              c:identifier="secret_collection_get_label"
              glib:get-property="label">
        <attribute name="org.gtk.Method.get_property" value="label"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1817">Get the label of this collection.</doc>
        <source-position filename="libsecret/secret-collection.h" line="153"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1823">the label, which should be freed with
  [func@GLib.free]</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1819">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_locked"
              c:identifier="secret_collection_get_locked"
              glib:get-property="locked">
        <attribute name="org.gtk.Method.get_property" value="locked"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1921">Get whether the collection is locked or not.

Use [method@Service.lock] or [method@Service.unlock] to lock or unlock the
collection.</doc>
        <source-position filename="libsecret/secret-collection.h" line="170"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1930">whether the collection is locked or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1923">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modified"
              c:identifier="secret_collection_get_modified"
              glib:get-property="modified">
        <attribute name="org.gtk.Method.get_property" value="modified"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1977">Get the modified date and time of the collection.

The return value is the number of seconds since the unix epoch, January 1st
1970.</doc>
        <source-position filename="libsecret/secret-collection.h" line="174"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1986">the modified date and time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1979">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="secret_collection_get_service"
              glib:get-property="service">
        <attribute name="org.gtk.Method.get_property" value="service"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1730">Get the Secret Service object that this collection was created with.</doc>
        <source-position filename="libsecret/secret-collection.h" line="147"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1736">the Secret Service object</doc>
          <type name="Service" c:type="SecretService*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1732">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_items"
              c:identifier="secret_collection_load_items"
              glib:finish-func="load_items_finish"
              glib:sync-func="load_items_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="781">Ensure that the #SecretCollection proxy has loaded all the items present
in the Secret Service.

This affects the result of [method@Collection.get_items].

For collections returned from [method@Service.get_collections] the items will
have already been loaded.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-collection.h" line="82"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="783">the secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="784">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="785">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="786">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_items_finish"
              c:identifier="secret_collection_load_items_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="849">Complete an asynchronous operation to ensure that the #SecretCollection proxy
has loaded all the items present in the Secret Service.</doc>
        <source-position filename="libsecret/secret-collection.h" line="87"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="858">whether the load was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="851">the secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="852">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_items_sync"
              c:identifier="secret_collection_load_items_sync"
              throws="1"
              glib:async-func="load_items">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="877">Ensure that the #SecretCollection proxy has loaded all the items present
in the Secret Service. This affects the result of
[method@Collection.get_items].

For collections returned from [method@Service.get_collections] the items
will have already been loaded.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-collection.h" line="91"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="893">whether the load was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="879">the secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="880">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh" c:identifier="secret_collection_refresh">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="942">Refresh the properties on this collection. This fires off a request to
refresh, and the properties will be updated later.

Calling this method is not normally necessary, as the secret service
will notify the client when properties change.</doc>
        <source-position filename="libsecret/secret-collection.h" line="95"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="944">the collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="search"
              c:identifier="secret_collection_search"
              glib:finish-func="search_finish"
              glib:sync-func="search_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1399">Search for items matching the @attributes in the @collection.
The @attributes should be a table of string keys and string values.

If %SECRET_SEARCH_ALL is set in @flags, then all the items matching the
search will be returned. Otherwise only the first item will be returned.
This is almost always the unlocked item that was most recently stored.

If %SECRET_SEARCH_UNLOCK is set in @flags, then items will be unlocked
if necessary. In either case, locked and unlocked items will match the
search and be returned. If the unlock fails, the search does not fail.

If %SECRET_SEARCH_LOAD_SECRETS is set in @flags, then the items will have
their secret values loaded and available via [method@Item.get_secret].

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-collection.h" line="115"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1401">a secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1402">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1403">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1404">search option flags</doc>
            <type name="SearchFlags" c:type="SecretSearchFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1405">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1406">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1407">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_finish"
              c:identifier="secret_collection_search_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1460">Complete asynchronous operation to search for items in a collection.</doc>
        <source-position filename="libsecret/secret-collection.h" line="123"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1468">
  a list of items that matched the search</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Item"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1462">the secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1463">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_for_dbus_paths"
              c:identifier="secret_collection_search_for_dbus_paths"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="search_for_dbus_paths_finish"
              glib:sync-func="search_for_dbus_paths_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="304">Search for items in @collection matching the @attributes, and return their
DBus object paths.

Only the specified collection is searched. The @attributes should be a table
of string keys and string values.

This function returns immediately and completes asynchronously.

When your callback is called use [method@Collection.search_for_dbus_paths_finish]
to get the results of this function. Only the DBus object paths of the
items will be returned. If you would like [class@Item] objects to be returned
instead, then use the [method@Collection.search] function.</doc>
        <source-position filename="libsecret/secret-paths.h" line="51"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="306">the secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="307">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="308">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="309">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="310">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="311">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_for_dbus_paths_finish"
              c:identifier="secret_collection_search_for_dbus_paths_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="362">Complete asynchronous operation to search for items in a collection.

DBus object paths of the items will be returned. If you would to have
[class@Item] objects to be returned instead, then use the
[method@Collection.search] and [method@Collection.search_finish] functions.</doc>
        <source-position filename="libsecret/secret-paths.h" line="58"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="376">an array of DBus object
  paths for matching items.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="364">the secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="365">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_for_dbus_paths_sync"
              c:identifier="secret_collection_search_for_dbus_paths_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="search_for_dbus_paths">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="403">Search for items matching the @attributes in @collection, and return their
DBus object paths.

The @attributes should be a table of string keys and string values.

This function may block indefinitely. Use the asynchronous version
in user interface threads.

DBus object paths of the items will be returned. If you would to have
[class@Item] objects to be returned instead, then use the
[method@Collection.search_sync] function.</doc>
        <source-position filename="libsecret/secret-paths.h" line="62"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="425">an array of DBus object
  paths for matching items.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="405">the secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="406">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="407">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="408">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_sync"
              c:identifier="secret_collection_search_sync"
              throws="1"
              glib:async-func="search">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1531">Search for items matching the @attributes in the @collection.
The @attributes should be a table of string keys and string values.

If %SECRET_SEARCH_ALL is set in @flags, then all the items matching the
search will be returned. Otherwise only the first item will be returned.
This is almost always the unlocked item that was most recently stored.

If %SECRET_SEARCH_UNLOCK is set in @flags, then items will be unlocked
if necessary. In either case, locked and unlocked items will match the
search and be returned. If the unlock fails, the search does not fail.

If %SECRET_SEARCH_LOAD_SECRETS is set in @flags, then the items will have
their secret values loaded and available via [method@Item.get_secret].

This function may block indefinitely. Use the asynchronous version
in user interface threads.</doc>
        <source-position filename="libsecret/secret-collection.h" line="127"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1557">
  a list of items that matched the search</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Item"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1533">a secret collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1534">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1535">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1536">search option flags</doc>
            <type name="SearchFlags" c:type="SecretSearchFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1537">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label"
              c:identifier="secret_collection_set_label"
              glib:set-property="label"
              glib:finish-func="set_label_finish"
              glib:sync-func="set_label_sync">
        <attribute name="org.gtk.Method.set_property" value="label"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1843">Set the label of this collection.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-collection.h" line="155"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1845">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1846">a new label</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1847">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1848">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1849">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label_finish"
              c:identifier="secret_collection_set_label_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1871">Complete asynchronous operation to set the label of this collection.</doc>
        <source-position filename="libsecret/secret-collection.h" line="161"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1879">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1873">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1874">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label_sync"
              c:identifier="secret_collection_set_label_sync"
              throws="1"
              glib:async-func="set_label">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="1893">Set the label of this collection.

This function may block indefinitely. Use the asynchronous version
in user interface threads.</doc>
        <source-position filename="libsecret/secret-collection.h" line="165"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-collection.c"
               line="1905">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1895">a collection</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1896">a new label</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-collection.c"
                 line="1897">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="created"
                writable="1"
                transfer-ownership="none"
                getter="get_created"
                default-value="0">
        <attribute name="org.gtk.Property.get"
                   value="secret_collection_get_created"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="485">The date and time (in seconds since the UNIX epoch) that this
collection was created.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="flags"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_flags"
                default-value="SECRET_COLLECTION_NONE">
        <attribute name="org.gtk.Property.get"
                   value="secret_collection_get_flags"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="439">A set of flags describing which parts of the secret collection have
been initialized.</doc>
        <type name="CollectionFlags"/>
      </property>
      <property name="items" introspectable="0" transfer-ownership="none">
        <attribute name="org.gtk.Property.get"
                   value="secret_collection_get_items"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="450">A list of [class@Item] objects representing the items that are in
this collection. This list will be empty if the collection is locked.</doc>
        <type/>
      </property>
      <property name="label"
                writable="1"
                transfer-ownership="none"
                setter="set_label"
                getter="get_label"
                default-value="NULL">
        <attribute name="org.gtk.Property.get"
                   value="secret_collection_get_label"/>
        <attribute name="org.gtk.Property.set"
                   value="secret_collection_set_label"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="460">The human readable label for the collection.

Setting this property will result in the label of the collection being
set asynchronously. To properly track the changing of the label use the
[method@Collection.set_label] function.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="locked"
                transfer-ownership="none"
                getter="get_locked"
                default-value="TRUE">
        <attribute name="org.gtk.Property.get"
                   value="secret_collection_get_locked"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="473">Whether the collection is locked or not.

To lock or unlock a collection use the [method@Service.lock] or
[method@Service.unlock] functions.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="modified"
                writable="1"
                transfer-ownership="none"
                getter="get_modified"
                default-value="0">
        <attribute name="org.gtk.Property.get"
                   value="secret_collection_get_modified"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="495">The date and time (in seconds since the UNIX epoch) that this
collection was last modified.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="service"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_service">
        <attribute name="org.gtk.Property.get"
                   value="secret_collection_get_service"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="429">The [class@Service] object that this collection is associated with and
uses to interact with the actual D-Bus Secret Service.</doc>
        <type name="Service"/>
      </property>
      <field name="parent">
        <type name="Gio.DBusProxy" c:type="GDBusProxy"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="CollectionPrivate" c:type="SecretCollectionPrivate*"/>
      </field>
    </class>
    <record name="CollectionClass"
            c:type="SecretCollectionClass"
            glib:is-gtype-struct-for="Collection">
      <doc xml:space="preserve"
           filename="libsecret/secret-collection.c"
           line="48">The class for #SecretCollection.</doc>
      <source-position filename="libsecret/secret-collection.h" line="62"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="50">the parent class</doc>
        <type name="Gio.DBusProxyClass" c:type="GDBusProxyClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="CollectionCreateFlags"
              glib:type-name="SecretCollectionCreateFlags"
              glib:get-type="secret_collection_create_flags_get_type"
              c:type="SecretCollectionCreateFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-collection.c"
           line="63">Flags for [func@Collection.create].</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_COLLECTION_CREATE_NONE"
              glib:nick="none"
              glib:name="SECRET_COLLECTION_CREATE_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="65">no flags</doc>
      </member>
    </bitfield>
    <bitfield name="CollectionFlags"
              glib:type-name="SecretCollectionFlags"
              glib:get-type="secret_collection_flags_get_type"
              c:type="SecretCollectionFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-collection.c"
           line="55">Flags which determine which parts of the #SecretCollection proxy are initialized.</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_COLLECTION_NONE"
              glib:nick="none"
              glib:name="SECRET_COLLECTION_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="57">no flags</doc>
      </member>
      <member name="load_items"
              value="2"
              c:identifier="SECRET_COLLECTION_LOAD_ITEMS"
              glib:nick="load-items"
              glib:name="SECRET_COLLECTION_LOAD_ITEMS">
        <doc xml:space="preserve"
             filename="libsecret/secret-collection.c"
             line="58">items have or should be loaded</doc>
      </member>
    </bitfield>
    <record name="CollectionPrivate"
            c:type="SecretCollectionPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libsecret/secret-collection.h" line="48"/>
    </record>
    <enumeration name="Error"
                 stability="Stable"
                 glib:type-name="SecretError"
                 glib:get-type="secret_error_get_type"
                 c:type="SecretError">
      <doc xml:space="preserve"
           filename="libsecret/secret-util.c"
           line="22">Errors returned by the Secret Service.

None of the errors are appropriate for display to the user. It is up to the
application to handle them appropriately.</doc>
      <member name="protocol"
              value="1"
              c:identifier="SECRET_ERROR_PROTOCOL"
              glib:nick="protocol"
              glib:name="SECRET_ERROR_PROTOCOL">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="24">received an invalid data or message from the Secret
  Service</doc>
      </member>
      <member name="is_locked"
              value="2"
              c:identifier="SECRET_ERROR_IS_LOCKED"
              glib:nick="is-locked"
              glib:name="SECRET_ERROR_IS_LOCKED">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="26">the item or collection is locked and the operation
  cannot be performed</doc>
      </member>
      <member name="no_such_object"
              value="3"
              c:identifier="SECRET_ERROR_NO_SUCH_OBJECT"
              glib:nick="no-such-object"
              glib:name="SECRET_ERROR_NO_SUCH_OBJECT">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="28">no such item or collection found in the Secret
  Service</doc>
      </member>
      <member name="already_exists"
              value="4"
              c:identifier="SECRET_ERROR_ALREADY_EXISTS"
              glib:nick="already-exists"
              glib:name="SECRET_ERROR_ALREADY_EXISTS">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="30">a relevant item or collection already exists</doc>
      </member>
      <member name="invalid_file_format"
              value="5"
              c:identifier="SECRET_ERROR_INVALID_FILE_FORMAT"
              glib:nick="invalid-file-format"
              glib:name="SECRET_ERROR_INVALID_FILE_FORMAT">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="31">the file format is not valid</doc>
      </member>
      <member name="mismatched_schema"
              value="6"
              c:identifier="SECRET_ERROR_MISMATCHED_SCHEMA"
              version="0.21.2"
              glib:nick="mismatched-schema"
              glib:name="SECRET_ERROR_MISMATCHED_SCHEMA">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="40">the xdg:schema attribute of the table does not match the schema name</doc>
      </member>
      <member name="no_matching_attribute"
              value="7"
              c:identifier="SECRET_ERROR_NO_MATCHING_ATTRIBUTE"
              version="0.21.2"
              glib:nick="no-matching-attribute"
              glib:name="SECRET_ERROR_NO_MATCHING_ATTRIBUTE">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="47">attribute contained in table not found in corresponding schema</doc>
      </member>
      <member name="wrong_type"
              value="8"
              c:identifier="SECRET_ERROR_WRONG_TYPE"
              version="0.21.2"
              glib:nick="wrong-type"
              glib:name="SECRET_ERROR_WRONG_TYPE">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="54">attribute could not be parsed according to its type reported in the table's
schema</doc>
      </member>
      <member name="empty_table"
              value="9"
              c:identifier="SECRET_ERROR_EMPTY_TABLE"
              version="0.21.2"
              glib:nick="empty-table"
              glib:name="SECRET_ERROR_EMPTY_TABLE">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="62">attribute list passed to secret_attributes_validate has no elements to
validate</doc>
      </member>
      <function name="get_quark" c:identifier="secret_error_get_quark">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="105">Get the error quark.</doc>
        <source-position filename="libsecret/secret-types.h" line="28"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-util.c"
               line="110">the quark</doc>
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <function-macro name="IS_COLLECTION"
                    c:identifier="SECRET_IS_COLLECTION"
                    introspectable="0">
      <source-position filename="libsecret/secret-collection.h" line="42"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_COLLECTION_CLASS"
                    c:identifier="SECRET_IS_COLLECTION_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-collection.h" line="43"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ITEM"
                    c:identifier="SECRET_IS_ITEM"
                    introspectable="0">
      <source-position filename="libsecret/secret-item.h" line="43"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ITEM_CLASS"
                    c:identifier="SECRET_IS_ITEM_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-item.h" line="44"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PROMPT"
                    c:identifier="SECRET_IS_PROMPT"
                    introspectable="0">
      <source-position filename="libsecret/secret-prompt.h" line="31"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PROMPT_CLASS"
                    c:identifier="SECRET_IS_PROMPT_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-prompt.h" line="32"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SERVICE"
                    c:identifier="SECRET_IS_SERVICE"
                    introspectable="0">
      <source-position filename="libsecret/secret-service.h" line="41"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SERVICE_CLASS"
                    c:identifier="SECRET_IS_SERVICE_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-service.h" line="42"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ITEM" c:identifier="SECRET_ITEM" introspectable="0">
      <source-position filename="libsecret/secret-item.h" line="41"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ITEM_CLASS"
                    c:identifier="SECRET_ITEM_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-item.h" line="42"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ITEM_GET_CLASS"
                    c:identifier="SECRET_ITEM_GET_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-item.h" line="45"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Item"
           c:symbol-prefix="item"
           c:type="SecretItem"
           stability="Stable"
           parent="Gio.DBusProxy"
           glib:type-name="SecretItem"
           glib:get-type="secret_item_get_type"
           glib:type-struct="ItemClass">
      <doc xml:space="preserve"
           filename="libsecret/secret-item.c"
           line="31">A secret item

#SecretItem represents a secret item stored in the Secret Service.

Each item has a value, represented by a [struct@Value], which can be
retrieved by [method@Item.get_secret] or set by [method@Item.set_secret].
The item is only available when the item is not locked.

Items can be locked or unlocked using the [method@Service.lock] or
[method@Service.unlock] functions. The Secret Service may not be able to
unlock individual items, and may unlock an entire collection when a single
item is unlocked.

Each item has a set of attributes, which are used to locate the item later.
These are not stored or transferred in a secure manner. Each attribute has
a string name and a string value. Use [method@Service.search] to search for
items based on their attributes, and [method@Item.set_attributes] to change
the attributes associated with an item.

Items can be created with [func@Item.create] or [method@Service.store].</doc>
      <source-position filename="libsecret/secret-item.h" line="62"/>
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.DBusInterface"/>
      <implements name="Gio.Initable"/>
      <implements name="Retrievable"/>
      <constructor name="new_for_dbus_path_finish"
                   c:identifier="secret_item_new_for_dbus_path_finish"
                   introspectable="0"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="202">Finish asynchronous operation to get a new item proxy for a secret
item in the secret service.</doc>
        <source-position filename="libsecret/secret-paths.h" line="75"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="212">the new item, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Item" c:type="SecretItem*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="204">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_dbus_path_sync"
                   c:identifier="secret_item_new_for_dbus_path_sync"
                   introspectable="0"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="233">Get a new item proxy for a secret item in the secret service.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-paths.h" line="78"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="251">the new item, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Item" c:type="SecretItem*"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="235">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="item_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="236">the D-Bus path of the item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="237">initialization flags for the new item</doc>
            <type name="ItemFlags" c:type="SecretItemFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="238">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="create"
                c:identifier="secret_item_create"
                glib:finish-func="create_finish"
                glib:sync-func="create_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="742">Create a new item in the secret service.

If the @flags contains %SECRET_ITEM_CREATE_REPLACE, then the secret
service will search for an item matching the @attributes, and update that item
instead of creating a new one.

This method may block indefinitely and should not be used in user interface
threads. The secret service may prompt the user. [method@Service.prompt]
will be used to handle any prompts that are required.</doc>
        <source-position filename="libsecret/secret-item.h" line="68"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="744">a secret collection to create this item in</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="745">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="746">attributes for the new item</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="747">label for the new item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="748">secret value for the new item</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="749">flags for the creation of the new item</doc>
            <type name="ItemCreateFlags" c:type="SecretItemCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="750">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="8">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="751">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="752">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="create_finish"
                c:identifier="secret_item_create_finish"
                throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="809">Finish operation to create a new item in the secret service.</doc>
        <source-position filename="libsecret/secret-item.h" line="78"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="816">the new item, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Item" c:type="SecretItem*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="811">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="create_sync"
                c:identifier="secret_item_create_sync"
                throws="1"
                glib:async-func="create">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="837">Create a new item in the secret service.

If the @flags contains %SECRET_ITEM_CREATE_REPLACE, then the secret
service will search for an item matching the @attributes, and update that item
instead of creating a new one.

This method may block indefinitely and should not be used in user interface
threads. The secret service may prompt the user. [method@Service.prompt]
will be used to handle any prompts that are required.</doc>
        <source-position filename="libsecret/secret-item.h" line="81"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="858">the new item, which should be unreferenced
  with [method@GObject.Object.unref]</doc>
          <type name="Item" c:type="SecretItem*"/>
        </return-value>
        <parameters>
          <parameter name="collection" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="839">a secret collection to create this item in</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="840">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="841">attributes for the new item</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="842">label for the new item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="843">secret value for the new item</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="844">flags for the creation of the new item</doc>
            <type name="ItemCreateFlags" c:type="SecretItemCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="845">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="load_secrets"
                c:identifier="secret_item_load_secrets"
                glib:finish-func="load_secrets_finish"
                glib:sync-func="load_secrets_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1414">Load the secret values for a secret item stored in the service.

The @items must all have the same [property@Item:service] property.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-item.h" line="122"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1416">the items to retrieve secrets for</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Item"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1417">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1418">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1419">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="load_secrets_finish"
                c:identifier="secret_item_load_secrets_finish"
                throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1483">Complete asynchronous operation to load the secret values for
secret items stored in the service.

Items that are locked will not have their secrets loaded.</doc>
        <source-position filename="libsecret/secret-item.h" line="127"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1493">whether the operation succeeded or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1485">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="load_secrets_sync"
                c:identifier="secret_item_load_secrets_sync"
                throws="1"
                glib:async-func="load_secrets">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1509">Load the secret values for a secret item stored in the service.

The @items must all have the same [property@Item:service] property.

This method may block indefinitely and should not be used in user interface
threads.

Items that are locked will not have their secrets loaded.</doc>
        <source-position filename="libsecret/secret-item.h" line="130"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1524">whether the operation succeeded or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1511">the items to retrieve secrets for</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Item"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1512">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_dbus_path"
                c:identifier="secret_item_new_for_dbus_path"
                introspectable="0"
                stability="Unstable"
                glib:finish-func="new_for_dbus_path_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="155">Get a new item proxy for a secret item in the secret service.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-paths.h" line="68"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="157">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </parameter>
          <parameter name="item_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="158">the D-Bus path of the collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="159">initialization flags for the new item</doc>
            <type name="ItemFlags" c:type="SecretItemFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="160">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="161">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="162">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="delete"
              c:identifier="secret_item_delete"
              glib:finish-func="delete_finish"
              glib:sync-func="delete_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="925">Delete this item.

This method returns immediately and completes asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that show up.</doc>
        <source-position filename="libsecret/secret-item.h" line="90"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="927">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="928">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="929">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="930">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_finish"
              c:identifier="secret_item_delete_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="961">Complete asynchronous operation to delete the secret item.</doc>
        <source-position filename="libsecret/secret-item.h" line="95"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="969">whether the item was successfully deleted or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="963">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="964">asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_sync"
              c:identifier="secret_item_delete_sync"
              throws="1"
              glib:async-func="delete">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="988">Delete this secret item.

This method may block indefinitely and should not be used in user
interface threads. The secret service may prompt the user.
[method@Service.prompt] will be used to handle any prompts that show up.</doc>
        <source-position filename="libsecret/secret-item.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1000">whether the item was successfully deleted or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="990">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="991">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attributes" c:identifier="secret_item_get_attributes">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1748">Set the attributes of this item.

The @attributes are a mapping of string keys to string values.
Attributes are used to search for items. Attributes are not stored
or transferred securely by the secret service.

Do not modify the attributes returned by this method. Use
[method@Item.set_attributes] instead.</doc>
        <source-position filename="libsecret/secret-item.h" line="151"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1761">a new reference
  to the attributes, which should not be modified, and
  released with [func@GLib.HashTable.unref]</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1750">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_created" c:identifier="secret_item_get_created">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="2019">Get the created date and time of the item.

The return value is the number of seconds since the unix epoch, January 1st
1970.</doc>
        <source-position filename="libsecret/secret-item.h" line="189"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="2028">the created date and time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="2021">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags"
              c:identifier="secret_item_get_flags"
              glib:get-property="flags">
        <attribute name="org.gtk.Method.get_property" value="flags"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1029">Get the flags representing what features of the #SecretItem proxy
have been initialized.

Use [method@Item.load_secret] to initialize further features
and change the flags.</doc>
        <source-position filename="libsecret/secret-item.h" line="103"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1039">the flags for features initialized</doc>
          <type name="ItemFlags" c:type="SecretItemFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1031">the secret item proxy</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_label" c:identifier="secret_item_get_label">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1888">Get the label of this item.</doc>
        <source-position filename="libsecret/secret-item.h" line="170"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1894">the label, which should be freed with [func@GLib.free]</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1890">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_locked"
              c:identifier="secret_item_get_locked"
              glib:get-property="locked">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1991">Get whether the item is locked or not.

Depending on the secret service an item may not be able to be locked
independently from the collection that it is in.</doc>
        <source-position filename="libsecret/secret-item.h" line="187"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="2000">whether the item is locked or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1993">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modified" c:identifier="secret_item_get_modified">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="2047">Get the modified date and time of the item.

The return value is the number of seconds since the unix epoch, January 1st
1970.</doc>
        <source-position filename="libsecret/secret-item.h" line="191"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="2056">the modified date and time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="2049">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_schema_name"
              c:identifier="secret_item_get_schema_name">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1722">Gets the name of the schema that this item was stored with. This is also
available at the `xdg:schema` attribute.</doc>
        <source-position filename="libsecret/secret-item.h" line="149"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1729">the schema name</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1724">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secret" c:identifier="secret_item_get_secret">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1075">Get the secret value of this item.

If this item is locked or the secret has not yet been loaded then this will
return %NULL.

To load the secret call the [method@Item.load_secret] method.</doc>
        <source-position filename="libsecret/secret-item.h" line="107"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1086">the secret value which should be
  released with [method@Value.unref], or %NULL</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1077">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_service"
              c:identifier="secret_item_get_service"
              glib:get-property="service">
        <attribute name="org.gtk.Method.get_property" value="service"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1059">Get the Secret Service object that this item was created with.</doc>
        <source-position filename="libsecret/secret-item.h" line="105"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1065">the Secret Service object</doc>
          <type name="Service" c:type="SecretService*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1061">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_secret"
              c:identifier="secret_item_load_secret"
              glib:finish-func="load_secret_finish"
              glib:sync-func="load_secret_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1172">Load the secret value of this item.

Each item has a single secret which might be a password or some
other secret binary value.

This function will fail if the secret item is locked.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-item.h" line="109"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1174">an item proxy</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1175">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1176">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1177">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_secret_finish"
              c:identifier="secret_item_load_secret_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1209">Complete asynchronous operation to load the secret value of this item.

The newly loaded secret value can be accessed by calling
[method@Item.get_secret].</doc>
        <source-position filename="libsecret/secret-item.h" line="114"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1220">whether the secret item successfully loaded or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1211">an item proxy</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1212">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_secret_sync"
              c:identifier="secret_item_load_secret_sync"
              throws="1"
              glib:async-func="load_secret">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1237">Load the secret value of this item.

Each item has a single secret which might be a password or some
other secret binary value.

This function may block indefinitely. Use the asynchronous version
in user interface threads.</doc>
        <source-position filename="libsecret/secret-item.h" line="118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1251">whether the secret item successfully loaded or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1239">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1240">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="refresh" c:identifier="secret_item_refresh">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="615">Refresh the properties on this item.

This fires off a request to refresh, and the properties will be updated
later.

Calling this method is not normally necessary, as the secret service
will notify the client when properties change.</doc>
        <source-position filename="libsecret/secret-item.h" line="66"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="617">the collection</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_attributes"
              c:identifier="secret_item_set_attributes"
              glib:finish-func="set_attributes_finish"
              glib:sync-func="set_attributes_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1782">Set the attributes of this item.

The @attributes are a mapping of string keys to string values.
Attributes are used to search for items. Attributes are not stored
or transferred securely by the secret service.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-item.h" line="153"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1784">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1785">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1786">a new set of attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1787">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1788">called when the asynchronous operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1789">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_finish"
              c:identifier="secret_item_set_attributes_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1824">Complete operation to set the attributes of this item.</doc>
        <source-position filename="libsecret/secret-item.h" line="160"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1832">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1826">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1827">asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes_sync"
              c:identifier="secret_item_set_attributes_sync"
              throws="1"
              glib:async-func="set_attributes">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1846">Set the attributes of this item.

The @attributes are a mapping of string keys to string values.
Attributes are used to search for items. Attributes are not stored
or transferred securely by the secret service.

This function may block indefinitely. Use the asynchronous version
in user interface threads.</doc>
        <source-position filename="libsecret/secret-item.h" line="164"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1863">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1848">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1849">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1850">a new set of attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1851">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label"
              c:identifier="secret_item_set_label"
              glib:finish-func="set_label_finish"
              glib:sync-func="set_label_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1913">Set the label of this item.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-item.h" line="172"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1915">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1916">a new label</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1917">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1918">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1919">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label_finish"
              c:identifier="secret_item_set_label_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1941">Complete asynchronous operation to set the label of this collection.</doc>
        <source-position filename="libsecret/secret-item.h" line="178"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1949">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1943">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1944">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_label_sync"
              c:identifier="secret_item_set_label_sync"
              throws="1"
              glib:async-func="set_label">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1963">Set the label of this item.

This function may block indefinitely. Use the asynchronous version
in user interface threads.</doc>
        <source-position filename="libsecret/secret-item.h" line="182"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1975">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1965">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1966">a new label</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1967">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_secret"
              c:identifier="secret_item_set_secret"
              glib:finish-func="set_secret_finish"
              glib:sync-func="set_secret_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1613">Set the secret value of this item.

Each item has a single secret which might be a password or some
other secret binary value.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-item.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1615">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1616">a new secret value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1617">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1618">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1619">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_secret_finish"
              c:identifier="secret_item_set_secret_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1652">Complete asynchronous operation to set the secret value of this item.</doc>
        <source-position filename="libsecret/secret-item.h" line="140"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1660">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1654">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1655">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_secret_sync"
              c:identifier="secret_item_set_secret_sync"
              throws="1"
              glib:async-func="set_secret">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="1677">Set the secret value of this item.

Each item has a single secret which might be a password or some
other secret binary value.

This function may block indefinitely. Use the asynchronous version
in user interface threads.</doc>
        <source-position filename="libsecret/secret-item.h" line="144"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-item.c"
               line="1692">whether the change was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1679">an item</doc>
            <type name="Item" c:type="SecretItem*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1680">a new secret value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-item.c"
                 line="1681">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="flags"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_flags"
                default-value="SECRET_ITEM_NONE">
        <attribute name="org.gtk.Property.get" value="secret_item_get_flags"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="341">A set of flags describing which parts of the secret item have
been initialized.</doc>
        <type name="ItemFlags"/>
      </property>
      <property name="locked"
                transfer-ownership="none"
                getter="get_locked"
                default-value="TRUE">
        <attribute name="org.gtk.Property.get" value="secret_item_get_locked"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="373">Whether the item is locked or not.

An item may not be independently lockable separate from other items in
its collection.

To lock or unlock a item use the [method@Service.lock] or
[method@Service.unlock] functions.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="service"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_service">
        <attribute name="org.gtk.Property.get"
                   value="secret_item_get_service"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="331">The [class@Service] object that this item is associated with and
uses to interact with the actual D-Bus Secret Service.</doc>
        <type name="Service"/>
      </property>
      <field name="parent_instance">
        <type name="Gio.DBusProxy" c:type="GDBusProxy"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="ItemPrivate" c:type="SecretItemPrivate*"/>
      </field>
    </class>
    <record name="ItemClass"
            c:type="SecretItemClass"
            glib:is-gtype-struct-for="Item">
      <doc xml:space="preserve"
           filename="libsecret/secret-item.c"
           line="58">The class for #SecretItem.</doc>
      <source-position filename="libsecret/secret-item.h" line="62"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="60">the parent class</doc>
        <type name="Gio.DBusProxyClass" c:type="GDBusProxyClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ItemCreateFlags"
              glib:type-name="SecretItemCreateFlags"
              glib:get-type="secret_item_create_flags_get_type"
              c:type="SecretItemCreateFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-item.c"
           line="73">Flags for [func@Item.create].</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_ITEM_CREATE_NONE"
              glib:nick="none"
              glib:name="SECRET_ITEM_CREATE_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="75">no flags</doc>
      </member>
      <member name="replace"
              value="2"
              c:identifier="SECRET_ITEM_CREATE_REPLACE"
              glib:nick="replace"
              glib:name="SECRET_ITEM_CREATE_REPLACE">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="76">replace an item with the same attributes.</doc>
      </member>
    </bitfield>
    <bitfield name="ItemFlags"
              glib:type-name="SecretItemFlags"
              glib:get-type="secret_item_flags_get_type"
              c:type="SecretItemFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-item.c"
           line="65">Flags which determine which parts of the #SecretItem proxy are initialized.</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_ITEM_NONE"
              glib:nick="none"
              glib:name="SECRET_ITEM_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="67">no flags</doc>
      </member>
      <member name="load_secret"
              value="2"
              c:identifier="SECRET_ITEM_LOAD_SECRET"
              glib:nick="load-secret"
              glib:name="SECRET_ITEM_LOAD_SECRET">
        <doc xml:space="preserve"
             filename="libsecret/secret-item.c"
             line="68">a secret has been (or should be) loaded for #SecretItem</doc>
      </member>
    </bitfield>
    <record name="ItemPrivate"
            c:type="SecretItemPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libsecret/secret-item.h" line="48"/>
    </record>
    <constant name="MAJOR_VERSION" value="0" c:type="SECRET_MAJOR_VERSION">
      <doc xml:space="preserve"
           filename="libsecret/secret-version.h"
           line="22">The major version of libsecret.</doc>
      <source-position filename="libsecret/secret-version.h" line="27"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="7" c:type="SECRET_MICRO_VERSION">
      <doc xml:space="preserve"
           filename="libsecret/secret-version.h"
           line="36">The micro version of libsecret.</doc>
      <source-position filename="libsecret/secret-version.h" line="41"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="21" c:type="SECRET_MINOR_VERSION">
      <doc xml:space="preserve"
           filename="libsecret/secret-version.h"
           line="29">The minor version of libsecret.</doc>
      <source-position filename="libsecret/secret-version.h" line="34"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PROMPT"
                    c:identifier="SECRET_PROMPT"
                    introspectable="0">
      <source-position filename="libsecret/secret-prompt.h" line="29"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PROMPT_CLASS"
                    c:identifier="SECRET_PROMPT_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-prompt.h" line="30"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PROMPT_GET_CLASS"
                    c:identifier="SECRET_PROMPT_GET_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-prompt.h" line="33"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Prompt"
           c:symbol-prefix="prompt"
           c:type="SecretPrompt"
           stability="Stable"
           parent="Gio.DBusProxy"
           glib:type-name="SecretPrompt"
           glib:get-type="secret_prompt_get_type"
           glib:type-struct="PromptClass">
      <doc xml:space="preserve"
           filename="libsecret/secret-prompt.c"
           line="24">A prompt in the Service

A proxy object representing a prompt that the Secret Service will display
to the user.

Certain actions on the Secret Service require user prompting to complete,
such as creating a collection, or unlocking a collection. When such a prompt
is necessary, then a #SecretPrompt object is created by this library, and
passed to the [method@Service.prompt] method. In this way it is handled
automatically.

In order to customize prompt handling, override the
[vfunc@Service.prompt_async] and [vfunc@Service.prompt_finish] virtual
methods of the [class@Service] class.</doc>
      <source-position filename="libsecret/secret-prompt.h" line="51"/>
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.DBusInterface"/>
      <implements name="Gio.Initable"/>
      <method name="perform"
              c:identifier="secret_prompt_perform"
              glib:finish-func="perform_finish"
              glib:sync-func="perform_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-prompt.c"
             line="398">Runs a prompt and performs the prompting.

Returns %TRUE if the prompt was completed and not dismissed.

If @window_id is non-null then it is used as an XWindow id on Linux. The API
expects this id to be converted to a string using the `%d` printf format. The
Secret Service can make its prompt transient for the window with this id. In
some Secret Service implementations this is not possible, so the behavior
depending on this should degrade gracefully.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-prompt.h" line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="400">a prompt</doc>
            <type name="Prompt" c:type="SecretPrompt*"/>
          </instance-parameter>
          <parameter name="window_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="401">string form of XWindow id for parent window to be transient for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="return_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="402">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="403">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="404">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="405">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="perform_finish"
              c:identifier="secret_prompt_perform_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-prompt.c"
             line="492">Complete asynchronous operation to run a prompt and perform the prompting.

Returns a variant result if the prompt was completed and not dismissed. The
type of result depends on the action the prompt is completing, and is
defined in the Secret Service DBus API specification.</doc>
        <source-position filename="libsecret/secret-prompt.h" line="74"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-prompt.c"
               line="504">%NULL if the prompt was dismissed or an error occurred,
  a variant result if the prompt was successful</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="494">a prompt</doc>
            <type name="Prompt" c:type="SecretPrompt*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="495">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="perform_sync"
              c:identifier="secret_prompt_perform_sync"
              throws="1"
              glib:async-func="perform">
        <doc xml:space="preserve"
             filename="libsecret/secret-prompt.c"
             line="175">Runs a prompt and performs the prompting.

Returns a variant result if the prompt was completed and not dismissed. The
type of result depends on the action the prompt is completing, and is defined
in the Secret Service DBus API specification.

If @window_id is non-null then it is used as an XWindow id on Linux. The API
expects this id to be converted to a string using the `%d` printf format. The
Secret Service can make its prompt transient for the window with this id. In
some Secret Service implementations this is not possible, so the behavior
depending on this should degrade gracefully.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-prompt.h" line="61"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-prompt.c"
               line="198">%NULL if the prompt was dismissed or an error occurred</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="177">a prompt</doc>
            <type name="Prompt" c:type="SecretPrompt*"/>
          </instance-parameter>
          <parameter name="window_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="178">string form of XWindow id for parent window to be transient for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="179">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="return_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="180">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="run" c:identifier="secret_prompt_run" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-prompt.c"
             line="114">Runs a prompt and performs the prompting.

Returns a variant result if the prompt was completed and not dismissed. The
type of result depends on the action the prompt is completing, and is defined
in the Secret Service DBus API specification.

If @window_id is non-null then it is used as an XWindow id on Linux. The API
expects this id to be converted to a string using the `%d` printf format. The
Secret Service can make its prompt transient for the window with this id. In
some Secret Service implementations this is not possible, so the behavior
depending on this should degrade gracefully.

This runs the dialog in a recursive mainloop. When run from a user interface
thread, this means the user interface will remain responsive. Care should be
taken that appropriate user interface actions are disabled while running the
prompt.</doc>
        <source-position filename="libsecret/secret-prompt.h" line="55"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-prompt.c"
               line="139">%NULL if the prompt was dismissed or an error occurred</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="116">a prompt</doc>
            <type name="Prompt" c:type="SecretPrompt*"/>
          </instance-parameter>
          <parameter name="window_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="117">string form of XWindow id for parent window to be transient for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="118">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="return_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-prompt.c"
                 line="119">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Gio.DBusProxy" c:type="GDBusProxy"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="PromptPrivate" c:type="SecretPromptPrivate*"/>
      </field>
    </class>
    <record name="PromptClass"
            c:type="SecretPromptClass"
            glib:is-gtype-struct-for="Prompt">
      <doc xml:space="preserve"
           filename="libsecret/secret-prompt.c"
           line="45">The class for #SecretPrompt.</doc>
      <source-position filename="libsecret/secret-prompt.h" line="51"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libsecret/secret-prompt.c"
             line="47">the parent class</doc>
        <type name="Gio.DBusProxyClass" c:type="GDBusProxyClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="PromptPrivate"
            c:type="SecretPromptPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libsecret/secret-prompt.h" line="37"/>
    </record>
    <interface name="Retrievable"
               c:symbol-prefix="retrievable"
               c:type="SecretRetrievable"
               version="0.19.0"
               stability="Stable"
               glib:type-name="SecretRetrievable"
               glib:get-type="secret_retrievable_get_type"
               glib:type-struct="RetrievableInterface">
      <doc xml:space="preserve"
           filename="libsecret/secret-retrievable.c"
           line="20">A read-only view of a secret item in the Secret Service.

#SecretRetrievable provides a read-only view of a secret item
stored in the Secret Service.

Each item has a value, represented by a [struct@Value], which can be
retrieved by [method@Retrievable.retrieve_secret] and
[method@Retrievable.retrieve_secret_finish].</doc>
      <source-position filename="libsecret/secret-retrievable.h" line="41"/>
      <virtual-method name="retrieve_secret"
                      invoker="retrieve_secret"
                      version="0.19.0"
                      glib:finish-func="retrieve_secret_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="105">Retrieve the secret value of this object.

Each retrievable object has a single secret which might be a
password or some other secret binary value.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="34"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="107">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="108">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="109">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="110">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="retrieve_secret_finish"
                      invoker="retrieve_secret_finish"
                      version="0.19.0"
                      throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="135">Complete asynchronous operation to retrieve the secret value of this object.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="38"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-retrievable.c"
               line="143">the secret value which should be
  released with [method@Value.unref], or %NULL</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="137">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="138">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_attributes"
              c:identifier="secret_retrievable_get_attributes"
              glib:get-property="attributes"
              version="0.19.0">
        <attribute name="org.gtk.Method.get_property" value="attributes"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="210">Get the attributes of this object.

The attributes are a mapping of string keys to string values.
Attributes are used to search for items. Attributes are not stored
or transferred securely by the secret service.

Do not modify the attribute returned by this method.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="56"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-retrievable.c"
               line="222">a new reference
  to the attributes, which should not be modified, and
  released with [func@GLib.HashTable.unref]</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="212">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_created"
              c:identifier="secret_retrievable_get_created"
              glib:get-property="created"
              version="0.19.0">
        <attribute name="org.gtk.Method.get_property" value="created"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="260">Get the created date and time of the object.

The return value is the number of seconds since the unix epoch, January 1st
1970.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="58"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-retrievable.c"
               line="269">the created date and time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="262">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_label"
              c:identifier="secret_retrievable_get_label"
              glib:get-property="label"
              version="0.19.0">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="239">Get the label of this item.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="57"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-retrievable.c"
               line="245">the label, which should be freed with [func@GLib.free]</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="241">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modified"
              c:identifier="secret_retrievable_get_modified"
              glib:get-property="modified"
              version="0.19.0">
        <attribute name="org.gtk.Method.get_property" value="modified"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="284">Get the modified date and time of the object.

The return value is the number of seconds since the unix epoch, January 1st
1970.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="59"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-retrievable.c"
               line="293">the modified date and time</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="286">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="retrieve_secret"
              c:identifier="secret_retrievable_retrieve_secret"
              version="0.19.0"
              glib:finish-func="retrieve_secret_finish"
              glib:sync-func="retrieve_secret_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="105">Retrieve the secret value of this object.

Each retrievable object has a single secret which might be a
password or some other secret binary value.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="43"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="107">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="108">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="109">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="110">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="retrieve_secret_finish"
              c:identifier="secret_retrievable_retrieve_secret_finish"
              version="0.19.0"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="135">Complete asynchronous operation to retrieve the secret value of this object.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="48"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-retrievable.c"
               line="143">the secret value which should be
  released with [method@Value.unref], or %NULL</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="137">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="138">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="retrieve_secret_sync"
              c:identifier="secret_retrievable_retrieve_secret_sync"
              version="0.19.0"
              throws="1"
              glib:async-func="retrieve_secret">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="161">Retrieve the secret value of this object synchronously.

Each retrievable object has a single secret which might be a
password or some other secret binary value.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-retrievable.h" line="52"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-retrievable.c"
               line="175">the secret value which should be
  released with [method@Value.unref], or %NULL</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="163">a retrievable object</doc>
            <type name="Retrievable" c:type="SecretRetrievable*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="164">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <property name="attributes"
                version="0.19.0"
                writable="1"
                transfer-ownership="full"
                getter="get_attributes">
        <attribute name="org.gtk.Property.get"
                   value="secret_retrievable_get_attributes"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="55">The attributes set on this item.

Attributes are used to locate an item. They are not guaranteed to be
stored or transferred securely.</doc>
        <type name="GLib.HashTable">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </property>
      <property name="created"
                version="0.19.0"
                writable="1"
                transfer-ownership="none"
                getter="get_created"
                default-value="0">
        <attribute name="org.gtk.Property.get"
                   value="secret_retrievable_get_created"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="80">The date and time (in seconds since the UNIX epoch) that this
item was created.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="label"
                version="0.19.0"
                writable="1"
                transfer-ownership="none"
                getter="get_label"
                default-value="NULL">
        <attribute name="org.gtk.Property.get"
                   value="secret_retrievable_get_label"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="69">The human readable label for the item.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="modified"
                version="0.19.0"
                writable="1"
                transfer-ownership="none"
                getter="get_modified"
                default-value="0">
        <attribute name="org.gtk.Property.get"
                   value="secret_retrievable_get_modified"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="92">The date and time (in seconds since the UNIX epoch) that this
item was last modified.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
    </interface>
    <record name="RetrievableInterface"
            c:type="SecretRetrievableInterface"
            glib:is-gtype-struct-for="Retrievable"
            version="0.19.0">
      <doc xml:space="preserve"
           filename="libsecret/secret-retrievable.c"
           line="37">The interface for #SecretRetrievable.</doc>
      <source-position filename="libsecret/secret-retrievable.h" line="41"/>
      <field name="parent_iface">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="39">the parent interface</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="retrieve_secret">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="40">implementation of [method@Retrievable.retrieve_secret],
  required</doc>
        <callback name="retrieve_secret">
          <source-position filename="libsecret/secret-retrievable.h"
                           line="34"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-retrievable.c"
                   line="107">a retrievable object</doc>
              <type name="Retrievable" c:type="SecretRetrievable*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="libsecret/secret-retrievable.c"
                   line="108">optional cancellation object</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="3">
              <doc xml:space="preserve"
                   filename="libsecret/secret-retrievable.c"
                   line="109">called when the operation completes</doc>
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <doc xml:space="preserve"
                   filename="libsecret/secret-retrievable.c"
                   line="110">data to pass to the callback</doc>
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="retrieve_secret_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-retrievable.c"
             line="42">implementation of
  [method@Retrievable.retrieve_secret_finish], required</doc>
        <callback name="retrieve_secret_finish" throws="1">
          <source-position filename="libsecret/secret-retrievable.h"
                           line="38"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-retrievable.c"
                 line="143">the secret value which should be
  released with [method@Value.unref], or %NULL</doc>
            <type name="Value" c:type="SecretValue*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-retrievable.c"
                   line="137">a retrievable object</doc>
              <type name="Retrievable" c:type="SecretRetrievable*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-retrievable.c"
                   line="138">asynchronous result passed to callback</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function-macro name="SERVICE"
                    c:identifier="SECRET_SERVICE"
                    introspectable="0">
      <source-position filename="libsecret/secret-service.h" line="39"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SERVICE_CLASS"
                    c:identifier="SECRET_SERVICE_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-service.h" line="40"/>
      <parameters>
        <parameter name="class">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SERVICE_GET_CLASS"
                    c:identifier="SECRET_SERVICE_GET_CLASS"
                    introspectable="0">
      <source-position filename="libsecret/secret-service.h" line="43"/>
      <parameters>
        <parameter name="inst">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Schema"
            c:type="SecretSchema"
            stability="Stable"
            glib:type-name="SecretSchema"
            glib:get-type="secret_schema_get_type"
            c:symbol-prefix="schema">
      <doc xml:space="preserve"
           filename="libsecret/secret-schema.c"
           line="25">Represents a set of attributes that are stored with an item.

These schemas are used for interoperability between various services storing
the same types of items.

Each schema has a name like `org.gnome.keyring.NetworkPassword`, and defines a
set of attributes, and types (string, integer, boolean) for those attributes.

Attributes are stored as strings in the Secret Service, and the attribute types
simply define standard ways to store integer and boolean values as strings.
Attributes are represented in libsecret via a [struct@GLib.HashTable] with
string keys and values. Even for values that defined as an integer or boolean in
the schema, the attribute values in the [struct@GLib.HashTable] are strings.
Boolean values are stored as the strings 'true' and 'false'. Integer values are
stored in decimal, with a preceding negative sign for negative integers.

Schemas are handled entirely on the client side by this library. The name of the
schema is automatically stored as an attribute on the item.

Normally when looking up passwords only those with matching schema names are
returned. If the schema @flags contain the `SECRET_SCHEMA_DONT_MATCH_NAME` flag,
then lookups will not check that the schema name matches that on the item, only
the schema's attributes are matched. This is useful when you are looking up
items that are not stored by the libsecret library. Other libraries such as
libgnome-keyring don't store the schema name.

Additional schemas can be defined via the [struct@Schema] structure like this:

```c
// in a header:

const SecretSchema * example_get_schema (void) G_GNUC_CONST;

#define EXAMPLE_SCHEMA  example_get_schema ()


// in a .c file

const SecretSchema *
example_get_schema (void)
{
    static const SecretSchema the_schema = {
        "org.example.Password", SECRET_SCHEMA_NONE,
        {
            {  "number", SECRET_SCHEMA_ATTRIBUTE_INTEGER },
            {  "string", SECRET_SCHEMA_ATTRIBUTE_STRING },
            {  "even", SECRET_SCHEMA_ATTRIBUTE_BOOLEAN },
            {  NULL, 0 },
        }
    };
    return &amp;the_schema;
}
```</doc>
      <source-position filename="libsecret/secret-schema.h" line="57"/>
      <field name="name" writable="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="27">the dotted name of the schema</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="28">flags for the schema</doc>
        <type name="SchemaFlags" c:type="SecretSchemaFlags"/>
      </field>
      <field name="attributes" writable="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="29">the attribute names and types of those attributes</doc>
        <array zero-terminated="0" fixed-size="32">
          <type name="SchemaAttribute" c:type="SecretSchemaAttribute"/>
        </array>
      </field>
      <field name="reserved" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="reserved1" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved6" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="reserved7" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <constructor name="new"
                   c:identifier="secret_schema_new"
                   shadowed-by="newv"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="224">Using this function is not normally necessary from C code.

A schema represents a set of attributes that are stored with an item. These
schemas are used for interoperability between various services storing the
same types of items.

Each schema has an @name like `org.gnome.keyring.NetworkPassword`, and
defines a set of attributes names, and types (string, integer, boolean) for
those attributes.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) integers from the
[enum@SchemaAttributeType] enumeration, representing the attribute type for
each attribute name. The list of attributes should be terminated with a %NULL.

Normally when looking up passwords only those with matching schema names are
returned. If the schema @flags contain the %SECRET_SCHEMA_DONT_MATCH_NAME flag,
then lookups will not check that the schema name matches that on the item, only
the schema's attributes are matched. This is useful when you are looking up items
that are not stored by the libsecret library. Other libraries such as libgnome-keyring
don't store the schema name.</doc>
        <source-position filename="libsecret/secret-schema.h" line="61"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-schema.c"
               line="252">the new schema, which should be unreferenced with
  [method@Schema.unref] when done</doc>
          <type name="Schema" c:type="SecretSchema*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="226">the dotted name of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="227">the flags for the schema</doc>
            <type name="SchemaFlags" c:type="SecretSchemaFlags"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="228">the attribute names and types, terminated with %NULL</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv" c:identifier="secret_schema_newv" shadows="new">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="140">Using this function is not normally necessary from C code. This is useful
for constructing #SecretSchema structures in bindings.

A schema represents a set of attributes that are stored with an item. These
schemas are used for interoperability between various services storing the
same types of items.

Each schema has an @name like `org.gnome.keyring.NetworkPassword`, and
defines a set of attributes names, and types (string, integer, boolean) for
those attributes.

Each key in the @attributes table should be a attribute name strings, and
the values in the table should be integers from the [enum@SchemaAttributeType]
enumeration, representing the attribute type for each attribute name.

Normally when looking up passwords only those with matching schema names are
returned. If the schema @flags contain the %SECRET_SCHEMA_DONT_MATCH_NAME flag,
then lookups will not check that the schema name matches that on the item, only
the schema's attributes are matched. This is useful when you are looking up items
that are not stored by the libsecret library. Other libraries such as libgnome-keyring
don't store the schema name.</doc>
        <source-position filename="libsecret/secret-schema.h" line="65"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-schema.c"
               line="168">the new schema, which should be unreferenced with
  [method@Schema.unref] when done</doc>
          <type name="Schema" c:type="SecretSchema*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="142">the dotted name of the schema</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="143">the flags for the schema</doc>
            <type name="SchemaFlags" c:type="SecretSchemaFlags"/>
          </parameter>
          <parameter name="attribute_names_and_types"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="144">the attribute names and types of those attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="SchemaAttributeType"/>
            </type>
          </parameter>
        </parameters>
      </constructor>
      <method name="ref" c:identifier="secret_schema_ref">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="285">Adds a reference to the #SecretSchema.

It is not normally necessary to call this function from C code, and is
mainly present for the sake of bindings. If the @schema was statically
allocated, then this function will copy the schema.</doc>
        <source-position filename="libsecret/secret-schema.h" line="69"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-schema.c"
               line="295">the referenced schema, which should be later
  unreferenced with [method@Schema.unref]</doc>
          <type name="Schema" c:type="SecretSchema*"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="287">the schema to reference</doc>
            <type name="Schema" c:type="SecretSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="secret_schema_unref">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="333">Releases a reference to the #SecretSchema.

If the last reference is released then the schema will be freed.

It is not normally necessary to call this function from C code, and is
mainly present for the sake of bindings. It is an error to call this for
a @schema that was statically allocated.</doc>
        <source-position filename="libsecret/secret-schema.h" line="71"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="schema" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-schema.c"
                 line="335">the schema to reference</doc>
            <type name="Schema" c:type="SecretSchema*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="SchemaAttribute"
            c:type="SecretSchemaAttribute"
            glib:type-name="SecretSchemaAttribute"
            glib:get-type="secret_schema_attribute_get_type"
            c:symbol-prefix="schema_attribute">
      <doc xml:space="preserve"
           filename="libsecret/secret-schema.c"
           line="97">An attribute in a #SecretSchema.</doc>
      <source-position filename="libsecret/secret-schema.h" line="36"/>
      <field name="name" writable="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="99">name of the attribute</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="type" writable="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="100">the type of the attribute</doc>
        <type name="SchemaAttributeType" c:type="SecretSchemaAttributeType"/>
      </field>
    </record>
    <enumeration name="SchemaAttributeType"
                 glib:type-name="SecretSchemaAttributeType"
                 glib:get-type="secret_schema_attribute_type_get_type"
                 c:type="SecretSchemaAttributeType">
      <doc xml:space="preserve"
           filename="libsecret/secret-schema.c"
           line="105">The type of an attribute in a [struct@SecretSchema].

Attributes are stored as strings in the Secret Service, and the attribute
types simply define standard ways to store integer and boolean values as
strings.</doc>
      <member name="string"
              value="0"
              c:identifier="SECRET_SCHEMA_ATTRIBUTE_STRING"
              glib:nick="string"
              glib:name="SECRET_SCHEMA_ATTRIBUTE_STRING">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="109">a utf-8 string attribute</doc>
      </member>
      <member name="integer"
              value="1"
              c:identifier="SECRET_SCHEMA_ATTRIBUTE_INTEGER"
              glib:nick="integer"
              glib:name="SECRET_SCHEMA_ATTRIBUTE_INTEGER">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="108">an integer attribute, stored as a decimal</doc>
      </member>
      <member name="boolean"
              value="2"
              c:identifier="SECRET_SCHEMA_ATTRIBUTE_BOOLEAN"
              glib:nick="boolean"
              glib:name="SECRET_SCHEMA_ATTRIBUTE_BOOLEAN">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="107">a boolean attribute, stored as 'true' or 'false'</doc>
      </member>
    </enumeration>
    <bitfield name="SchemaFlags"
              glib:type-name="SecretSchemaFlags"
              glib:get-type="secret_schema_flags_get_type"
              c:type="SecretSchemaFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-schema.c"
           line="88">Flags for a #SecretSchema definition.</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_SCHEMA_NONE"
              glib:nick="none"
              glib:name="SECRET_SCHEMA_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="90">no flags for the schema</doc>
      </member>
      <member name="dont_match_name"
              value="2"
              c:identifier="SECRET_SCHEMA_DONT_MATCH_NAME"
              glib:nick="dont-match-name"
              glib:name="SECRET_SCHEMA_DONT_MATCH_NAME">
        <doc xml:space="preserve"
             filename="libsecret/secret-schema.c"
             line="91">don't match the schema name when looking up or
  removing passwords</doc>
      </member>
    </bitfield>
    <enumeration name="SchemaType"
                 version="0.18.6"
                 glib:type-name="SecretSchemaType"
                 glib:get-type="secret_schema_type_get_type"
                 c:type="SecretSchemaType">
      <doc xml:space="preserve"
           filename="libsecret/secret-schemas.h"
           line="40">Different types of schemas for storing secrets, intended for use with
[func@get_schema].

## @SECRET_SCHEMA_NOTE

A predefined schema for personal passwords stored by the user in the
password manager. This schema has no attributes, and the items are not
meant to be used automatically by applications.

When used to search for items using this schema, it will only match
items that have the same schema. Items stored via libgnome-keyring with the
`GNOME_KEYRING_ITEM_NOTE` item type will match.

## @SECRET_SCHEMA_COMPAT_NETWORK

A predefined schema that is compatible with items stored via the
libgnome-keyring 'network password' functions. This is meant to be used by
applications migrating from libgnome-keyring which stored their secrets as
'network passwords'. It is not recommended that new code use this schema.

When used to search for items using this schema, it will only match
items that have the same schema. Items stored via libgnome-keyring with the
`GNOME_KEYRING_ITEM_NETWORK_PASSWORD` item type will match.

The following attributes exist in the schema:

### Attributes:

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;tt&gt;user&lt;/tt&gt;:&lt;/td&gt;
        &lt;td&gt;The user name (string).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;tt&gt;domain&lt;/tt&gt;:&lt;/td&gt;
        &lt;td&gt;The login domain or realm (string).&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;tt&gt;object&lt;/tt&gt;:&lt;/td&gt;
        &lt;td&gt;The object or path (string).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;tt&gt;protocol&lt;/tt&gt;:&lt;/td&gt;
        &lt;td&gt;The protocol (a string like 'http').&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;tt&gt;port&lt;/tt&gt;:&lt;/td&gt;
        &lt;td&gt;The network port (integer).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;tt&gt;server&lt;/tt&gt;:&lt;/td&gt;
        &lt;td&gt;The hostname or server (string).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;tt&gt;authtype&lt;/tt&gt;:&lt;/td&gt;
        &lt;td&gt;The authentication type (string).&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</doc>
      <member name="note"
              value="0"
              c:identifier="SECRET_SCHEMA_TYPE_NOTE"
              glib:nick="note"
              glib:name="SECRET_SCHEMA_TYPE_NOTE">
        <doc xml:space="preserve"
             filename="libsecret/secret-schemas.h"
             line="42">Personal passwords</doc>
      </member>
      <member name="compat_network"
              value="1"
              c:identifier="SECRET_SCHEMA_TYPE_COMPAT_NETWORK"
              glib:nick="compat-network"
              glib:name="SECRET_SCHEMA_TYPE_COMPAT_NETWORK">
        <doc xml:space="preserve"
             filename="libsecret/secret-schemas.h"
             line="43">Network passwords from older
   libgnome-keyring storage</doc>
      </member>
    </enumeration>
    <bitfield name="SearchFlags"
              glib:type-name="SecretSearchFlags"
              glib:get-type="secret_search_flags_get_type"
              c:type="SecretSearchFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-methods.c"
           line="29">Various flags to be used with [method@Service.search] and [method@Service.search_sync].</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_SEARCH_NONE"
              glib:nick="none"
              glib:name="SECRET_SEARCH_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="31">no flags</doc>
      </member>
      <member name="all"
              value="2"
              c:identifier="SECRET_SEARCH_ALL"
              glib:nick="all"
              glib:name="SECRET_SEARCH_ALL">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="32">all the items matching the search will be returned, instead of just the first one</doc>
      </member>
      <member name="unlock"
              value="4"
              c:identifier="SECRET_SEARCH_UNLOCK"
              glib:nick="unlock"
              glib:name="SECRET_SEARCH_UNLOCK">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="33">unlock locked items while searching</doc>
      </member>
      <member name="load_secrets"
              value="8"
              c:identifier="SECRET_SEARCH_LOAD_SECRETS"
              glib:nick="load-secrets"
              glib:name="SECRET_SEARCH_LOAD_SECRETS">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="34">while searching load secrets for items that are not locked</doc>
      </member>
    </bitfield>
    <class name="Service"
           c:symbol-prefix="service"
           c:type="SecretService"
           stability="Stable"
           parent="Gio.DBusProxy"
           glib:type-name="SecretService"
           glib:get-type="secret_service_get_type"
           glib:type-struct="ServiceClass">
      <doc xml:space="preserve"
           filename="libsecret/secret-service.c"
           line="32">A proxy object representing the Secret Service.

A #SecretService object either represents an implementation of the
[`org.freedesktop.Secret`](https://specifications.freedesktop.org/secret-service/latest/)
D-Bus service or a file that is encrypted using a master secret that was
provided by the
[secret portal](https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.Secret.html).

Normally a single #SecretService object can be shared between multiple
callers. The [func@Service.get] method is used to access this #SecretService
object. If a new independent #SecretService object is required, use
[func@Service.open].

In order to securely transfer secrets to the Sercret Service, a session
is established. This session can be established while initializing a
#SecretService object by passing the %SECRET_SERVICE_OPEN_SESSION flag
to the [func@Service.get] or [func@Service.open] functions. In order to
establish a session on an already existing #SecretService, use the
[method@Service.ensure_session] function.

To search for items, use the [method@Service.search] method.

Multiple collections can exist in the Secret Service, each of which contains
secret items. In order to instantiate [class@Collection] objects which
represent those collections while initializing a #SecretService then pass
the %SECRET_SERVICE_LOAD_COLLECTIONS flag to the [func@Service.get] or
[func@Service.open] functions. In order to establish a session on an already
existing #SecretService, use the [method@Service.load_collections] function.
To access the list of collections use [method@Service.get_collections].

Certain actions on the Secret Service require user prompting to complete,
such as creating a collection, or unlocking a collection. When such a prompt
is necessary, then a [class@Prompt] object is created by this library, and
passed to the [method@Service.prompt] method. In this way it is handled
automatically.

In order to customize prompt handling, override the
[vfunc@Service.prompt_async] and [vfunc@Service.prompt_finish] virtual
methods of the #SecretService class.</doc>
      <source-position filename="libsecret/secret-service.h" line="86"/>
      <implements name="Gio.AsyncInitable"/>
      <implements name="Gio.DBusInterface"/>
      <implements name="Gio.Initable"/>
      <implements name="Backend"/>
      <function name="disconnect" c:identifier="secret_service_disconnect">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1117">Disconnect the default #SecretService proxy returned by [func@Service.get]
and [func@Service.get_sync].

It is not necessary to call this function, but you may choose to do so at
program exit. It is useful for testing that memory is not leaked.

This function is safe to call at any time. But if other objects in this
library are still referenced, then this will not result in all memory
being freed.</doc>
        <source-position filename="libsecret/secret-service.h" line="106"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </function>
      <function name="get"
                c:identifier="secret_service_get"
                glib:finish-func="get_finish"
                glib:sync-func="get_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="972">Get a #SecretService proxy for the Secret Service.

If such a proxy object already exists, then the same proxy is returned.

If @flags contains any flags of which parts of the secret service to
ensure are initialized, then those will be initialized before completing.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="94"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="974">flags for which service functionality to ensure is initialized</doc>
            <type name="ServiceFlags" c:type="SecretServiceFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="975">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="976">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="977">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_finish"
                c:identifier="secret_service_get_finish"
                throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1022">Complete an asynchronous operation to get a #SecretService proxy for the
Secret Service.</doc>
        <source-position filename="libsecret/secret-service.h" line="99"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1030">a new reference to a #SecretService proxy, which
  should be released with [method@GObject.Object.unref].</doc>
          <type name="Service" c:type="SecretService*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1024">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_sync"
                c:identifier="secret_service_get_sync"
                throws="1"
                glib:async-func="get">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1071">Get a #SecretService proxy for the Secret Service.

If such a proxy object already exists, then the same proxy is returned.

If @flags contains any flags of which parts of the secret service to
ensure are initialized, then those will be initialized before returning.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="102"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1087">a new reference to a #SecretService proxy, which
  should be released with [method@GObject.Object.unref].</doc>
          <type name="Service" c:type="SecretService*"/>
        </return-value>
        <parameters>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1073">flags for which service functionality to ensure is initialized</doc>
            <type name="ServiceFlags" c:type="SecretServiceFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1074">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open"
                c:identifier="secret_service_open"
                glib:finish-func="open_finish"
                glib:sync-func="open_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1136">Create a new #SecretService proxy for the Secret Service.

This function is rarely used, see [func@Service.get] instead.

The @service_gtype argument should be set to %SECRET_TYPE_SERVICE or a the type
of a derived class.

If @flags contains any flags of which parts of the secret service to
ensure are initialized, then those will be initialized before returning.

If @service_bus_name is %NULL then the default is used.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="108"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="service_gtype" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1138">the GType of the new secret service</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="service_bus_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1139">the D-Bus service name of the secret service</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1140">flags for which service functionality to ensure is initialized</doc>
            <type name="ServiceFlags" c:type="SecretServiceFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1141">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1142">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1143">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_finish"
                c:identifier="secret_service_open_finish"
                throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1176">Complete an asynchronous operation to create a new #SecretService proxy for
the Secret Service.</doc>
        <source-position filename="libsecret/secret-service.h" line="115"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1184">a new reference to a #SecretService proxy, which
  should be released with [method@GObject.Object.unref].</doc>
          <type name="Service" c:type="SecretService*"/>
        </return-value>
        <parameters>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1178">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open_sync"
                c:identifier="secret_service_open_sync"
                throws="1"
                glib:async-func="open">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1208">Create a new #SecretService proxy for the Secret Service.

This function is rarely used, see [func@Service.get_sync] instead.

The @service_gtype argument should be set to %SECRET_TYPE_SERVICE or a the
type of a derived class.

If @flags contains any flags of which parts of the secret service to
ensure are initialized, then those will be initialized before returning.

If @service_bus_name is %NULL then the default is used.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="118"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1231">a new reference to a #SecretService proxy, which
  should be released with [method@GObject.Object.unref].</doc>
          <type name="Service" c:type="SecretService*"/>
        </return-value>
        <parameters>
          <parameter name="service_gtype" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1210">the GType of the new secret service</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="service_bus_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1211">the D-Bus service name of the secret service</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1212">flags for which service functionality to ensure is initialized</doc>
            <type name="ServiceFlags" c:type="SecretServiceFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1213">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </function>
      <virtual-method name="get_collection_gtype"
                      invoker="get_collection_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1944">Get the GObject type for collections instantiated by this service.

This will always be either [class@Collection] or derived from it.</doc>
        <source-position filename="libsecret/secret-service.h" line="80"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1952">the gobject type for collections</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1946">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_item_gtype" invoker="get_item_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1973">Get the GObject type for items instantiated by this service.

This will always be either [class@Item] or derived from it.</doc>
        <source-position filename="libsecret/secret-service.h" line="82"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1981">the gobject type for items</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1975">the service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prompt_async" glib:finish-func="prompt_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="85">called to perform asynchronous prompting when necessary</doc>
        <source-position filename="libsecret/secret-service.h" line="69"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="prompt" transfer-ownership="none">
            <type name="Prompt" c:type="SecretPrompt*"/>
          </parameter>
          <parameter name="return_type" transfer-ownership="none">
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="4">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prompt_finish" invoker="prompt_finish" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1912">Complete asynchronous operation to perform prompting for a [class@Prompt].

Returns a variant result if the prompt was completed and not dismissed. The
type of result depends on the action the prompt is completing, and is defined
in the Secret Service DBus API specification.</doc>
        <source-position filename="libsecret/secret-service.h" line="76"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1924">%NULL if the prompt was dismissed or an error occurred,
  a variant result if the prompt was successful</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1914">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1915">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prompt_sync" invoker="prompt_sync" throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1829">Perform prompting for a [class@Prompt].

Runs a prompt and performs the prompting. Returns a variant result if the
prompt was completed and not dismissed. The type of result depends on the
action the prompt is completing, and is defined in the Secret Service DBus
API specification.

This function is called by other parts of this library to handle prompts
for the various actions that can require prompting.

Override the #SecretServiceClass [vfunc@Service.prompt_sync] virtual method
to change the behavior of the prompting. The default behavior is to simply
run [method@Prompt.perform_sync] on the prompt with a %NULL `window_id`.</doc>
        <source-position filename="libsecret/secret-service.h" line="63"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1851">%NULL if the prompt was dismissed or an error occurred,
  a variant result if the prompt was successful</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1831">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1832">the prompt</doc>
            <type name="Prompt" c:type="SecretPrompt*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1833">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="return_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1834">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="clear"
              c:identifier="secret_service_clear"
              glib:finish-func="clear_finish"
              glib:sync-func="clear_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1666">Remove unlocked items which match the attributes from the secret service.

The @attributes should be a set of key and value string pairs.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="266"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1668">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1669">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1670">the attribute keys and values</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1671">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1672">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1673">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_finish"
              c:identifier="secret_service_clear_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1730">Finish asynchronous operation to remove items from the secret
service.</doc>
        <source-position filename="libsecret/secret-service.h" line="273"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1739">whether items were removed or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1732">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1733">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_sync"
              c:identifier="secret_service_clear_sync"
              throws="1"
              glib:async-func="clear">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1758">Remove unlocked items which match the attributes from the secret service.

The @attributes should be a set of key and value string pairs.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="277"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1776">whether items were removed or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1760">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1761">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1762">the attribute keys and values</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1763">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_collection_dbus_path"
              c:identifier="secret_service_create_collection_dbus_path"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="create_collection_dbus_path_finish"
              glib:sync-func="create_collection_dbus_path_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1701">Create a new collection in the secret service, and return its path.

Using this method requires that you setup a correct hash table of D-Bus
properties for the new collection. You may prefer to use
[func@Collection.create] which does handles this for you.

An @alias is a well-known tag for a collection, such as 'default' (ie: the
default collection to store items in). This allows other applications to
easily identify and share a collection. If a collection with the @alias
already exists, then instead of creating a new collection, the existing
collection will be returned. If no collection with this alias exists, then a
new collection will be created and this alias will be assigned to it.

@properties is a set of properties for the new collection. The keys in the
hash table should be interface.property strings like
`org.freedesktop.Secret.Collection.Label`. The values
in the hash table should be [struct@GLib.Variant] values of the properties.

If you wish to have a

This method will return immediately and complete asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that are required.</doc>
        <source-position filename="libsecret/secret-paths.h" line="203"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1703">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1704">hash table of properties for
  the new collection</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.Variant"/>
            </type>
          </parameter>
          <parameter name="alias"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1706">an alias to check for before creating the new
  collection, or to assign to the new collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1708">not currently used</doc>
            <type name="CollectionCreateFlags"
                  c:type="SecretCollectionCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1709">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1710">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1711">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_collection_dbus_path_finish"
              c:identifier="secret_service_create_collection_dbus_path_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1783">Finish asynchronous operation to create a new collection in the secret
service.</doc>
        <source-position filename="libsecret/secret-paths.h" line="211"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1794">a new string containing the D-Bus object path
  of the collection</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1785">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1786">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_collection_dbus_path_sync"
              c:identifier="secret_service_create_collection_dbus_path_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="create_collection_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1818">Create a new collection in the secret service and return its path.

Using this method requires that you setup a correct hash table of D-Bus
properties for the new collection. You may prefer to use
[func@Collection.create] which does handles this for you.

An @alias is a well-known tag for a collection, such as 'default' (ie: the
default collection to store items in). This allows other applications to
easily identify and share a collection. If a collection with the @alias
already exists, then instead of creating a new collection, the existing
collection will be returned. If no collection with this alias exists, then
a new collection will be created and this alias will be assigned to it.

@properties is a set of properties for the new collection. The keys in the
hash table should be interface.property strings like
`org.freedesktop.Secret.Collection.Label`. The values
in the hash table should be [struct@GLib.Variant] values of the properties.

This method may block indefinitely and should not be used in user interface
threads. The secret service may prompt the user. [method@Service.prompt]
will be used to handle any prompts that are required.</doc>
        <source-position filename="libsecret/secret-paths.h" line="215"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1853">a new string containing the D-Bus object path
  of the collection</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1820">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1821">hash table of D-Bus properties
  for the new collection</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.Variant"/>
            </type>
          </parameter>
          <parameter name="alias"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1823">an alias to check for before creating the new
  collection, or to assign to the new collection</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1825">not currently used</doc>
            <type name="CollectionCreateFlags"
                  c:type="SecretCollectionCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1826">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_item_dbus_path"
              c:identifier="secret_service_create_item_dbus_path"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="create_item_dbus_path_finish"
              glib:sync-func="create_item_dbus_path_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2004">Create a new item in a secret service collection and return its D-Bus
object path.

It is often easier to use [func@password_store] or [func@Item.create]
rather than using this function. Using this method requires that you setup
a correct hash table of D-Bus @properties for the new collection.

If the @flags contains %SECRET_ITEM_CREATE_REPLACE, then the secret
service will search for an item matching the @attributes, and update that item
instead of creating a new one.

@properties is a set of properties for the new collection. The keys in the
hash table should be interface.property strings like
`org.freedesktop.Secret.Item.Label`. The values
in the hash table should be [struct@GLib.Variant] values of the properties.

This method will return immediately and complete asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that are required.</doc>
        <source-position filename="libsecret/secret-paths.h" line="222"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2006">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="collection_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2007">the D-Bus object path of the collection in which to create item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2008">hash table of D-Bus properties
  for the new collection</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.Variant"/>
            </type>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2010">the secret value to store in the item</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2011">flags for the creation of the new item</doc>
            <type name="ItemCreateFlags" c:type="SecretItemCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2012">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="6">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2013">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2014">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_item_dbus_path_finish"
              c:identifier="secret_service_create_item_dbus_path_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2074">Finish asynchronous operation to create a new item in the secret
service.</doc>
        <source-position filename="libsecret/secret-paths.h" line="231"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2085">a new string containing the D-Bus object path
  of the item</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2076">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2077">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_item_dbus_path_sync"
              c:identifier="secret_service_create_item_dbus_path_sync"
              stability="Unstable"
              throws="1"
              glib:async-func="create_item_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2126">Create a new item in a secret service collection and return its D-Bus
object path.

It is often easier to use [func@password_store_sync] or [func@Item.create_sync]
rather than using this function. Using this method requires that you setup
a correct hash table of D-Bus @properties for the new collection.

If the @flags contains %SECRET_ITEM_CREATE_REPLACE, then the secret
service will search for an item matching the @attributes, and update that item
instead of creating a new one.

@properties is a set of properties for the new collection. The keys in the
hash table should be interface.property strings like
`org.freedesktop.Secret.Item.Label`. The values
in the hash table should be [struct@GLib.Variant] values of the properties.

This method may block indefinitely and should not be used in user interface
threads. The secret service may prompt the user. [method@Service.prompt]
will be used to handle any prompts that are required.</doc>
        <source-position filename="libsecret/secret-paths.h" line="235"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2159">a new string containing the D-Bus object path
  of the item</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2128">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="collection_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2129">the D-Bus path of the collection in which to create item</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="properties" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2130">hash table of D-Bus properties
  for the new collection</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GLib.Variant"/>
            </type>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2132">the secret value to store in the item</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2133">flags for the creation of the new item</doc>
            <type name="ItemCreateFlags" c:type="SecretItemCreateFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2134">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="decode_dbus_secret"
              c:identifier="secret_service_decode_dbus_secret">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2591">Decode a [struct@Value] into [struct@GLib.Variant] received with the Secret Service
DBus API.

The [struct@GLib.Variant] should have a `(oayays)` signature.

A session must have already been established by the [class@Service], and
the encoded secret must be valid for that session.</doc>
        <source-position filename="libsecret/secret-paths.h" line="278"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2604">the decoded secret value</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2593">the service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2594">the encoded secret</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_item_dbus_path"
              c:identifier="secret_service_delete_item_dbus_path"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="delete_item_dbus_path_finish"
              glib:sync-func="delete_item_dbus_path_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1530">Delete a secret item from the secret service.

The item is represented by its D-Bus object path. If you already have a
[class@Item] proxy objects, use use [method@Item.delete] instead.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-paths.h" line="188"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1532">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="item_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1533">the D-Bus path of item to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1534">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1535">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1536">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_item_dbus_path_finish"
              c:identifier="secret_service_delete_item_dbus_path_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1561">Complete an asynchronous operation to delete a secret item from the secret
service.</doc>
        <source-position filename="libsecret/secret-paths.h" line="194"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1572">whether the deletion was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1563">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1564">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="delete_item_dbus_path_sync"
              c:identifier="secret_service_delete_item_dbus_path_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="delete_item_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1582">Delete a secret item from the secret service.

The item is represented by its D-Bus object path. If you already have a
[class@Item] proxy objects, use use [method@Item.delete_sync] instead.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-paths.h" line="198"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1599">whether the deletion was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1584">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="item_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1585">the D-Bus path of item to delete</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1586">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="encode_dbus_secret"
              c:identifier="secret_service_encode_dbus_secret">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2562">Encodes a [struct@Value] into [struct@GLib.Variant] for use with the Secret
Service DBus API.

The resulting [struct@GLib.Variant] will have a `(oayays)` signature.

A session must have already been established by the [class@Service].</doc>
        <source-position filename="libsecret/secret-paths.h" line="275"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2574">the encoded secret</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2564">the service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2565">the secret value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_session"
              c:identifier="secret_service_ensure_session"
              glib:finish-func="ensure_session_finish"
              glib:sync-func="ensure_session_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1446">Ensure that the #SecretService proxy has established a session with the
Secret Service.

This session is used to transfer secrets.

It is not normally necessary to call this method, as the session is
established as necessary. You can also pass the %SECRET_SERVICE_OPEN_SESSION
to [func@Service.get] in order to ensure that a session has been established
by the time you get the #SecretService proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="130"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1448">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1449">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1450">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1451">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_session_finish"
              c:identifier="secret_service_ensure_session_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1492">Finish an asynchronous operation to ensure that the #SecretService proxy
has established a session with the Secret Service.</doc>
        <source-position filename="libsecret/secret-service.h" line="135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1501">whether a session is established or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1494">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1495">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ensure_session_sync"
              c:identifier="secret_service_ensure_session_sync"
              throws="1"
              glib:async-func="ensure_session">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1521">Ensure that the #SecretService proxy has established a session with the
Secret Service.

This session is used to transfer secrets.

It is not normally necessary to call this method, as the session is
established as necessary. You can also pass the %SECRET_SERVICE_OPEN_SESSION
to [func@Service.get_sync] in order to ensure that a session has been
established by the time you get the #SecretService proxy.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="139"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1540">whether a session is established or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1523">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1524">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_collection_gtype"
              c:identifier="secret_service_get_collection_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1944">Get the GObject type for collections instantiated by this service.

This will always be either [class@Collection] or derived from it.</doc>
        <source-position filename="libsecret/secret-service.h" line="90"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1952">the gobject type for collections</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1946">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_collections"
              c:identifier="secret_service_get_collections">
        <attribute name="org.gtk.Method.get_property" value="collections"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1280">Get a list of [class@Collection] objects representing all the collections
in the secret service.

If the %SECRET_SERVICE_LOAD_COLLECTIONS flag was not specified when
initializing #SecretService proxy object, then this method will return
%NULL. Use [method@Service.load_collections] to load the collections.</doc>
        <source-position filename="libsecret/secret-service.h" line="128"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1291">a
  list of the collections in the secret service</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Collection"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1282">the secret service proxy</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flags" c:identifier="secret_service_get_flags">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1249">Get the flags representing what features of the #SecretService proxy
have been initialized.

Use [method@Service.ensure_session] or [method@Service.load_collections]
to initialize further features and change the flags.</doc>
        <source-position filename="libsecret/secret-service.h" line="124"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1259">the flags for features initialized</doc>
          <type name="ServiceFlags" c:type="SecretServiceFlags"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1251">the secret service proxy</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_item_gtype"
              c:identifier="secret_service_get_item_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1973">Get the GObject type for items instantiated by this service.

This will always be either [class@Item] or derived from it.</doc>
        <source-position filename="libsecret/secret-service.h" line="92"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1981">the gobject type for items</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1975">the service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_secret_for_dbus_path"
              c:identifier="secret_service_get_secret_for_dbus_path"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="get_secret_for_dbus_path_finish"
              glib:sync-func="get_secret_for_dbus_path_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="719">Get the secret value for a secret item stored in the service.

The item is represented by its D-Bus object path. If you already have a
[class@Item] proxy object, use use [method@Item.get_secret] to more simply
get its secret value.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-paths.h" line="107"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="721">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="item_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="722">the D-Bus path to item to retrieve secret for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="723">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="724">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="725">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secret_for_dbus_path_finish"
              c:identifier="secret_service_get_secret_for_dbus_path_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="764">Complete asynchronous operation to get the secret value for an
secret item stored in the service.

Will return %NULL if the item is locked.</doc>
        <source-position filename="libsecret/secret-paths.h" line="113"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="777">the newly allocated secret value
  for the item, which should be released with [method@Value.unref]</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="766">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="767">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secret_for_dbus_path_sync"
              c:identifier="secret_service_get_secret_for_dbus_path_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="get_secret_for_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="805">Get the secret value for a secret item stored in the service.

The item is represented by its D-Bus object path. If you already have a
[class@Item] proxy object, use use [method@Item.load_secret_sync] to more simply
get its secret value.

This method may block indefinitely and should not be used in user interface
threads.

Will return %NULL if the item is locked.</doc>
        <source-position filename="libsecret/secret-paths.h" line="117"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="825">the newly allocated secret value
  the item, which should be released with [method@Value.unref]</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="807">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="item_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="808">the D-Bus path to item to retrieve secret for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="809">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets_for_dbus_paths"
              c:identifier="secret_service_get_secrets_for_dbus_paths"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="get_secrets_for_dbus_paths_finish"
              glib:sync-func="get_secrets_for_dbus_paths_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="858">Get the secret values for a secret item stored in the service.

The items are represented by their D-Bus object paths. If you already have
[class@Item] proxy objects, use use [func@Item.load_secrets] to more simply
get their secret values.

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-paths.h" line="122"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="860">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="item_paths" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="861">the D-Bus paths to items to retrieve secrets for</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="862">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="863">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="864">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets_for_dbus_paths_finish"
              c:identifier="secret_service_get_secrets_for_dbus_paths_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="903">Complete asynchronous operation to get the secret values for an
secret items stored in the service.

Items that are locked will not be included the results.</doc>
        <source-position filename="libsecret/secret-paths.h" line="128"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="916">a newly
  allocated hash table of item path keys to [struct@Value]
  values.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="905">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="906">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_secrets_for_dbus_paths_sync"
              c:identifier="secret_service_get_secrets_for_dbus_paths_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="get_secrets_for_dbus_paths">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="945">Get the secret values for a secret item stored in the service.

The items are represented by their D-Bus object paths. If you already have
[class@Item] proxy objects, use use [func@Item.load_secrets_sync] to more
simply get their secret values.

This method may block indefinitely and should not be used in user interface
threads.

Items that are locked will not be included the results.</doc>
        <source-position filename="libsecret/secret-paths.h" line="132"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="965">a newly
  allocated hash table of item_path keys to [struct@Value]
  values.</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="Value"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="947">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="item_paths" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="948">the D-Bus paths to items to retrieve secrets for</doc>
            <type name="utf8" c:type="const gchar**"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="949">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_session_algorithms"
              c:identifier="secret_service_get_session_algorithms">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1386">Get the set of algorithms being used to transfer secrets between this
secret service proxy and the Secret Service itself.

This will be %NULL if no session has been established. Use
[method@Service.ensure_session] to establish a session.</doc>
        <source-position filename="libsecret/secret-service.h" line="126"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1396">a string representing the algorithms for transferring
  secrets</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1388">the secret service proxy</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_session_dbus_path"
              c:identifier="secret_service_get_session_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1416">Get the D-Bus object path of the session object being used to transfer
secrets between this secret service proxy and the Secret Service itself.

This will be %NULL if no session has been established. Use
[method@Service.ensure_session] to establish a session.</doc>
        <source-position filename="libsecret/secret-paths.h" line="84"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1426">a string representing the D-Bus object path of the
  session</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1418">the secret service proxy</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_collections"
              c:identifier="secret_service_load_collections"
              glib:finish-func="load_collections_finish"
              glib:sync-func="load_collections_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1663">Ensure that the #SecretService proxy has loaded all the collections present
in the Secret Service.

This affects the result of [method@Service.get_collections].

You can also pass the %SECRET_SERVICE_LOAD_COLLECTIONS to
[func@Service.get_sync] in order to ensure that the collections have been
loaded by the time you get the #SecretService proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="143"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1665">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1666">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1667">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1668">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_collections_finish"
              c:identifier="secret_service_load_collections_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1732">Complete an asynchronous operation to ensure that the #SecretService proxy
has loaded all the collections present in the Secret Service.</doc>
        <source-position filename="libsecret/secret-service.h" line="148"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1741">whether the load was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1734">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1735">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_collections_sync"
              c:identifier="secret_service_load_collections_sync"
              throws="1"
              glib:async-func="load_collections">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1762">Ensure that the #SecretService proxy has loaded all the collections present
in the Secret Service.

This affects the result of [method@Service.get_collections].

You can also pass the %SECRET_SERVICE_LOAD_COLLECTIONS to
[func@Service.get_sync] in order to ensure that the collections have been
loaded by the time you get the #SecretService proxy.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="152"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1780">whether the load was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1764">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1765">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lock"
              c:identifier="secret_service_lock"
              glib:finish-func="lock_finish"
              glib:sync-func="lock_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="727">Lock items or collections in the secret service.

The secret service may not be able to lock items individually, and may
lock an entire collection instead.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

This method returns immediately and completes asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that show up.</doc>
        <source-position filename="libsecret/secret-service.h" line="192"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="729">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="objects" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="730">the items or collections to lock</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="731">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="732">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="733">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lock_dbus_paths"
              c:identifier="secret_service_lock_dbus_paths"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="lock_dbus_paths_finish"
              glib:sync-func="lock_dbus_paths_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1205">Lock items or collections in the secret service.

The items or collections are represented by their D-Bus object paths. If you
already have [class@Item] and [class@Collection] proxy objects, use use
[method@Service.lock] instead.

The secret service may not be able to lock items individually, and may
lock an entire collection instead.

This method returns immediately and completes asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that show up.</doc>
        <source-position filename="libsecret/secret-paths.h" line="143"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1207">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1208">the D-Bus paths for items or collections to lock</doc>
            <array c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1209">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1210">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1211">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lock_dbus_paths_finish"
              c:identifier="secret_service_lock_dbus_paths_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1243">Complete asynchronous operation to lock items or collections in the secret
service.

The secret service may not be able to lock items individually, and may
lock an entire collection instead.</doc>
        <source-position filename="libsecret/secret-paths.h" line="149"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1260">the number of items or collections that were locked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1245">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1246">asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="locked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1247">
  location to place array of D-Bus paths of items or collections
  that were locked</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="lock_dbus_paths_sync"
              c:identifier="secret_service_lock_dbus_paths_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="lock_dbus_paths">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1146">Lock items or collections in the secret service.

The items or collections are represented by their D-Bus object paths. If you
already have [class@Item] and [class@Collection] proxy objects, use use
[method@Service.lock_sync] instead.

The secret service may not be able to lock items individually, and may
lock an entire collection instead.

This method may block indefinitely and should not be used in user
interface threads. The secret service may prompt the user.
[method@Service.prompt] will be used to handle any prompts that show up.</doc>
        <source-position filename="libsecret/secret-paths.h" line="137"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1171">the number of items or collections that were locked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1148">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1149">the D-Bus object paths of the items or collections to lock</doc>
            <array c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1150">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="locked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1151">
  location to place array of D-Bus paths of items or collections
  that were locked</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="lock_finish"
              c:identifier="secret_service_lock_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="760">Complete asynchronous operation to lock items or collections in the secret
service.

The secret service may not be able to lock items individually, and may
lock an entire collection instead.</doc>
        <source-position filename="libsecret/secret-service.h" line="198"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="774">the number of items or collections that were locked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="762">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="763">asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="locked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="764">
  location to place list of items or collections that were locked</doc>
            <type name="GLib.List" c:type="GList**">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="lock_sync"
              c:identifier="secret_service_lock_sync"
              throws="1"
              glib:async-func="lock">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="788">Lock items or collections in the secret service.

The secret service may not be able to lock items individually, and may
lock an entire collection instead.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user
interface threads. The secret service may prompt the user.
[method@Service.prompt] will be used to handle any prompts that show up.</doc>
        <source-position filename="libsecret/secret-service.h" line="203"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="809">the number of items or collections that were locked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="790">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="objects" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="791">the items or collections to lock</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="792">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="locked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="793">
  location to place list of items or collections that were locked</doc>
            <type name="GLib.List" c:type="GList**">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="lookup"
              c:identifier="secret_service_lookup"
              glib:finish-func="lookup_finish"
              glib:sync-func="lookup_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1419">Lookup a secret value in the secret service.

The @attributes should be a set of key and value string pairs.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="249"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1421">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1422">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1423">the attribute keys and values</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1424">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1425">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1426">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_finish"
              c:identifier="secret_service_lookup_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1480">Finish asynchronous operation to lookup a secret value in the secret service.

If no secret is found then %NULL is returned.</doc>
        <source-position filename="libsecret/secret-service.h" line="256"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1490">a newly allocated [struct@Value], which should be
  released with [method@Value.unref], or %NULL if no secret found</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1482">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1483">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lookup_sync"
              c:identifier="secret_service_lookup_sync"
              throws="1"
              glib:async-func="lookup">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1513">Lookup a secret value in the secret service.

The @attributes should be a set of key and value string pairs.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="260"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1531">a newly allocated [struct@Value], which should be
  released with [method@Value.unref], or %NULL if no secret found</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1515">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1516">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1517">the attribute keys and values</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1518">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prompt"
              c:identifier="secret_service_prompt"
              glib:finish-func="prompt_finish"
              glib:sync-func="prompt_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1874">Perform prompting for a [class@Prompt].

This function is called by other parts of this library to handle prompts
for the various actions that can require prompting.

Override the #SecretServiceClass [vfunc@Service.prompt_async] virtual method
to change the behavior of the prompting. The default behavior is to simply
run [method@Prompt.perform] on the prompt.</doc>
        <source-position filename="libsecret/secret-service.h" line="162"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1876">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1877">the prompt</doc>
            <type name="Prompt" c:type="SecretPrompt*"/>
          </parameter>
          <parameter name="return_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1878">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1879">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1880">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1881">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prompt_at_dbus_path"
              c:identifier="secret_service_prompt_at_dbus_path"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="prompt_at_dbus_path_finish"
              glib:sync-func="prompt_at_dbus_path_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2494">Perform prompting for a [class@Prompt].

This function is called by other parts of this library to handle prompts
for the various actions that can require prompting.

Override the #SecretServiceClass [vfunc@Service.prompt_async] virtual method
to change the behavior of the propmting. The default behavior is to simply
run [method@Prompt.perform] on the prompt.</doc>
        <source-position filename="libsecret/secret-paths.h" line="177"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2496">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="prompt_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2497">the D-Bus object path of the prompt</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="return_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2498">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2499">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2500">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2501">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="prompt_at_dbus_path_finish"
              c:identifier="secret_service_prompt_at_dbus_path_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2533">Complete asynchronous operation to perform prompting for a [class@Prompt].

Returns a variant result if the prompt was completed and not dismissed. The
type of result depends on the action the prompt is completing, and is defined
in the Secret Service DBus API specification.</doc>
        <source-position filename="libsecret/secret-paths.h" line="184"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2547">%NULL if the prompt was dismissed or an
  error occurred, a variant result if the prompt was successful</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2535">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2536">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prompt_at_dbus_path_sync"
              c:identifier="secret_service_prompt_at_dbus_path_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="prompt_at_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2447">Perform prompting for a [class@Prompt].

Override the #SecretServiceClass [vfunc@Service.prompt_async] virtual method
to change the behavior of the propmting. The default behavior is to simply
run [method@Prompt.perform] on the prompt.

Returns a variant result if the prompt was completed and not dismissed. The
type of result depends on the action the prompt is completing, and is defined
in the Secret Service DBus API specification.

This method may block and should not be used in user interface threads.</doc>
        <source-position filename="libsecret/secret-paths.h" line="171"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2469">%NULL if the prompt was dismissed or an
  error occurred, a variant result if the prompt was successful</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2449">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="prompt_path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2450">the D-Bus object path of the prompt</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2451">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="return_type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2452">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prompt_finish"
              c:identifier="secret_service_prompt_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1912">Complete asynchronous operation to perform prompting for a [class@Prompt].

Returns a variant result if the prompt was completed and not dismissed. The
type of result depends on the action the prompt is completing, and is defined
in the Secret Service DBus API specification.</doc>
        <source-position filename="libsecret/secret-service.h" line="169"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1924">%NULL if the prompt was dismissed or an error occurred,
  a variant result if the prompt was successful</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1914">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1915">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prompt_sync"
              c:identifier="secret_service_prompt_sync"
              throws="1"
              glib:async-func="prompt">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="1829">Perform prompting for a [class@Prompt].

Runs a prompt and performs the prompting. Returns a variant result if the
prompt was completed and not dismissed. The type of result depends on the
action the prompt is completing, and is defined in the Secret Service DBus
API specification.

This function is called by other parts of this library to handle prompts
for the various actions that can require prompting.

Override the #SecretServiceClass [vfunc@Service.prompt_sync] virtual method
to change the behavior of the prompting. The default behavior is to simply
run [method@Prompt.perform_sync] on the prompt with a %NULL `window_id`.</doc>
        <source-position filename="libsecret/secret-service.h" line="156"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-service.c"
               line="1851">%NULL if the prompt was dismissed or an error occurred,
  a variant result if the prompt was successful</doc>
          <type name="GLib.Variant" c:type="GVariant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1831">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="prompt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1832">the prompt</doc>
            <type name="Prompt" c:type="SecretPrompt*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1833">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="return_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1834">the variant type of the prompt result</doc>
            <type name="GLib.VariantType" c:type="const GVariantType*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_alias_dbus_path"
              c:identifier="secret_service_read_alias_dbus_path"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="read_alias_dbus_path_finish"
              glib:sync-func="read_alias_dbus_path_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2196">Lookup which collection is assigned to this alias.

Aliases help determine well known collections, such as 'default'. This method
looks up the dbus object path of the well known collection.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-paths.h" line="243"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2198">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2199">the alias to lookup</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2200">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2201">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2202">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_alias_dbus_path_finish"
              c:identifier="secret_service_read_alias_dbus_path_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2230">Finish an asynchronous operation to lookup which collection is assigned
to an alias.

This method returns the DBus object path of the collection</doc>
        <source-position filename="libsecret/secret-paths.h" line="249"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2243">the collection dbus object path,
  or %NULL if none assigned to the alias</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2232">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2233">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_alias_dbus_path_sync"
              c:identifier="secret_service_read_alias_dbus_path_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="read_alias_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2271">Lookup which collection is assigned to this alias.

Aliases help determine well known collections, such as 'default'. This method
returns the dbus object path of the collection.

This method may block and should not be used in user interface threads.</doc>
        <source-position filename="libsecret/secret-paths.h" line="253"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2287">the collection dbus object path,
         or %NULL if none assigned to the alias</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2273">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2274">the alias to lookup</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2275">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search"
              c:identifier="secret_service_search"
              glib:finish-func="search_finish"
              glib:sync-func="search_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="260">Search for items matching the @attributes.

All collections are searched. The @attributes should be a table of string
keys and string values.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

If %SECRET_SEARCH_ALL is set in @flags, then all the items matching the
search will be returned. Otherwise only the first item will be returned.
This is almost always the unlocked item that was most recently stored.

If %SECRET_SEARCH_UNLOCK is set in @flags, then items will be unlocked
if necessary. In either case, locked and unlocked items will match the
search and be returned. If the unlock fails, the search does not fail.

If %SECRET_SEARCH_LOAD_SECRETS is set in @flags, then the items will have
their secret values loaded and available via [method@Item.get_secret].

This function returns immediately and completes asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="173"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="262">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="263">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="264">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="265">search option flags</doc>
            <type name="SearchFlags" c:type="SecretSearchFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="266">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="5">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="267">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="268">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_finish"
              c:identifier="secret_service_search_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="338">Complete asynchronous operation to search for items.</doc>
        <source-position filename="libsecret/secret-service.h" line="181"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="346">
  a list of items that matched the search</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Item"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="340">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="341">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_for_dbus_paths"
              c:identifier="secret_service_search_for_dbus_paths"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="search_for_dbus_paths_finish"
              glib:sync-func="search_for_dbus_paths_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="459">Search for items matching the @attributes, and return their D-Bus object paths.

All collections are searched. The @attributes should be a table of string keys
and string values.

This function returns immediately and completes asynchronously.

When your callback is called use [method@Service.search_for_dbus_paths_finish]
to get the results of this function. Only the D-Bus object paths of the
items will be returned. If you would like [class@Item] objects to be returned
instead, then use the [method@Service.search] function.</doc>
        <source-position filename="libsecret/secret-paths.h" line="86"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="461">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="462">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="463">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="464">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="465">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="466">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="search_for_dbus_paths_finish"
              c:identifier="secret_service_search_for_dbus_paths_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="531">Complete asynchronous operation to search for items, and return their
D-Bus object paths.

Matching items that are locked or unlocked, have their D-Bus paths placed
in the @locked or @unlocked arrays respectively.

D-Bus object paths of the items will be returned in the @unlocked or
@locked arrays. If you would to have [class@Item] objects to be returned
instead, then us the [method@Service.search] and
[method@Service.search_finish] functions.</doc>
        <source-position filename="libsecret/secret-paths.h" line="93"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="556">whether the search was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="533">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="534">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="unlocked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="535">
  location to place an array of D-Bus object paths for matching
  items which were locked.</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
          <parameter name="locked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="538">
  location to place an array of D-Bus object paths for matching
  items which were locked.</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="search_for_dbus_paths_sync"
              c:identifier="secret_service_search_for_dbus_paths_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="search_for_dbus_paths">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="593">Search for items matching the @attributes, and return their D-Bus object
paths.

All collections are searched. The @attributes should be a table of string
keys and string values.

This function may block indefinitely. Use the asynchronous version
in user interface threads.

Matching items that are locked or unlocked, have their D-Bus paths placed
in the @locked or @unlocked arrays respectively.

D-Bus object paths of the items will be returned in the @unlocked or
@locked arrays. If you would to have [class@Item] objects to be returned
instead, then use the [method@Service.search_sync] function.</doc>
        <source-position filename="libsecret/secret-paths.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="625">whether the search was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="595">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="596">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="597">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="598">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="unlocked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="599">
  location to place an array of D-Bus object paths for matching
  items which were locked.</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
          <parameter name="locked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="602">
  location to place an array of D-Bus object paths for matching
  items which were locked.</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="search_sync"
              c:identifier="secret_service_search_sync"
              throws="1"
              glib:async-func="search">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="403">Search for items matching the @attributes.

All collections are searched. The @attributes should be a table of string
keys and string values.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

If %SECRET_SEARCH_ALL is set in @flags, then all the items matching the
search will be returned. Otherwise only the first item will be returned.
This is almost always the unlocked item that was most recently stored.

If %SECRET_SEARCH_UNLOCK is set in @flags, then items will be unlocked
if necessary. In either case, locked and unlocked items will match the
search and be returned. If the unlock fails, the search does not fail.

If %SECRET_SEARCH_LOAD_SECRETS is set in @flags, then the items' secret
values will be loaded for any unlocked items. Loaded item secret values
are available via [method@Item.get_secret]. If the load of a secret values
fail, then the

This function may block indefinitely. Use the asynchronous version
in user interface threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="185"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="436">
  a list of items that matched the search</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Item"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="405">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="406">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="407">search for items matching these attributes</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="408">search option flags</doc>
            <type name="SearchFlags" c:type="SecretSearchFlags"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="409">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alias"
              c:identifier="secret_service_set_alias"
              glib:finish-func="set_alias_finish"
              glib:sync-func="set_alias_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1871">Assign a collection to this alias.

Aliases help determine well known collections, such as 'default'.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="283"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1873">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1874">the alias to assign the collection to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="collection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1875">the collection to assign to the alias</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1876">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1877">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1878">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alias_finish"
              c:identifier="secret_service_set_alias_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1935">Finish an asynchronous operation to assign a collection to an alias.</doc>
        <source-position filename="libsecret/secret-service.h" line="290"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1943">%TRUE if successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1937">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1938">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alias_sync"
              c:identifier="secret_service_set_alias_sync"
              throws="1"
              glib:async-func="set_alias">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1962">Assign a collection to this alias. Aliases help determine
well known collections, such as 'default'.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block and should not be used in user interface threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="294"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1978">%TRUE if successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1964">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1965">the alias to assign the collection to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="collection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1966">the collection to assign to the alias</doc>
            <type name="Collection" c:type="SecretCollection*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1967">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alias_to_dbus_path"
              c:identifier="secret_service_set_alias_to_dbus_path"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="set_alias_to_dbus_path_finish"
              glib:sync-func="set_alias_to_dbus_path_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2319">Assign a collection to this alias. Aliases help determine
well known collections, such as 'default'. This method takes the dbus object
path of the collection to assign to the alias.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-paths.h" line="258"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2321">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2322">the alias to assign the collection to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="collection_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2323">the dbus object path of the collection to assign to the alias</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2324">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="4">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2325">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2326">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alias_to_dbus_path_finish"
              c:identifier="secret_service_set_alias_to_dbus_path_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2359">Finish an asynchronous operation to assign a collection to an alias.</doc>
        <source-position filename="libsecret/secret-paths.h" line="265"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2369">%TRUE if successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2361">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2362">asynchronous result passed to callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alias_to_dbus_path_sync"
              c:identifier="secret_service_set_alias_to_dbus_path_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="set_alias_to_dbus_path">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="2391">Assign a collection to this alias.

Aliases help determine well known collections, such as 'default'. This method
takes the dbus object path of the collection to assign to the alias.

This method may block and should not be used in user interface threads.</doc>
        <source-position filename="libsecret/secret-paths.h" line="269"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="2409">%TRUE if successful</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2393">a secret service object</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="alias" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2394">the alias to assign the collection to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="collection_path"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2395">the D-Bus object path of the collection to
  assign to the alias</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="2397">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="store"
              c:identifier="secret_service_store"
              glib:finish-func="store_finish"
              glib:sync-func="store_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1116">Store a secret value in the secret service.

The @attributes should be a set of key and value string pairs.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

If @collection is not specified, then the default collection will be
used. Use [const@COLLECTION_SESSION] to store the password in the session
collection, which doesn't get stored across login sessions.

This method will return immediately and complete asynchronously.</doc>
        <source-position filename="libsecret/secret-service.h" line="226"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1118">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1119">the schema to use to check attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1120">the attribute keys and values</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="collection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1121">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1123">label for the secret</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1124">the secret value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1125">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="7">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1126">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1127">data to be passed to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="store_finish"
              c:identifier="secret_service_store_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1209">Finish asynchronous operation to store a secret value in the secret service.</doc>
        <source-position filename="libsecret/secret-service.h" line="236"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1217">whether the storage was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1211">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1212">the asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
        </parameters>
      </method>
      <method name="store_sync"
              c:identifier="secret_service_store_sync"
              throws="1"
              glib:async-func="store">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="1236">Store a secret value in the secret service.

The @attributes should be a set of key and value string pairs.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use [const@COLLECTION_SESSION] to store the password in the session
collection, which doesn't get stored across login sessions.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user interface
threads.</doc>
        <source-position filename="libsecret/secret-service.h" line="240"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="1265">whether the storage was successful or not</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1238">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="schema"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1239">the schema for the attributes</doc>
            <type name="Schema" c:type="const SecretSchema*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1240">the attribute keys and values</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="utf8"/>
            </type>
          </parameter>
          <parameter name="collection"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1241">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="label" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1243">label for the secret</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1244">the secret value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="1245">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlock"
              c:identifier="secret_service_unlock"
              glib:finish-func="unlock_finish"
              glib:sync-func="unlock_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="841">Unlock items or collections in the secret service.

The secret service may not be able to unlock items individually, and may
unlock an entire collection instead.

If @service is %NULL, then [func@Service.get] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user
interface threads. The secret service may prompt the user.
[method@Service.prompt] will be used to handle any prompts that show up.</doc>
        <source-position filename="libsecret/secret-service.h" line="209"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="843">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="objects" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="844">the items or collections to unlock</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="845">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="846">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="847">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlock_dbus_paths"
              c:identifier="secret_service_unlock_dbus_paths"
              introspectable="0"
              stability="Unstable"
              glib:finish-func="unlock_dbus_paths_finish"
              glib:sync-func="unlock_dbus_paths_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1335">Unlock items or collections in the secret service.

The items or collections are represented by their D-Bus object paths. If you
already have [class@Item] and [class@Collection] proxy objects, use use
[method@Service.unlock] instead.

The secret service may not be able to unlock items individually, and may
unlock an entire collection instead.

This method returns immediately and completes asynchronously. The secret
service may prompt the user. [method@Service.prompt] will be used to handle
any prompts that show up.</doc>
        <source-position filename="libsecret/secret-paths.h" line="160"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1337">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1338">the D-Bus paths for items or
  collections to unlock</doc>
            <array c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1340">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1341">called when the operation completes</doc>
            <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1342">data to pass to the callback</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlock_dbus_paths_finish"
              c:identifier="secret_service_unlock_dbus_paths_finish"
              introspectable="0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1375">Complete asynchronous operation to unlock items or collections in the secret
service.

The secret service may not be able to unlock items individually, and may
unlock an entire collection instead.</doc>
        <source-position filename="libsecret/secret-paths.h" line="166"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1392">the number of items or collections that were unlocked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1377">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1378">asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="unlocked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1379">
  location to place array of D-Bus paths of items or collections
  that were unlocked</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="unlock_dbus_paths_sync"
              c:identifier="secret_service_unlock_dbus_paths_sync"
              introspectable="0"
              stability="Unstable"
              throws="1"
              glib:async-func="unlock_dbus_paths">
        <doc xml:space="preserve"
             filename="libsecret/secret-paths.c"
             line="1275">Unlock items or collections in the secret service.

The items or collections are represented by their D-Bus object paths. If you
already have [class@Item] and [class@Collection] proxy objects, use use
[method@Service.unlock_sync] instead.

The secret service may not be able to unlock items individually, and may
unlock an entire collection instead.

This method may block indefinitely and should not be used in user
interface threads. The secret service may prompt the user.
[method@Service.prompt] will be used to handle any prompts that show up.</doc>
        <source-position filename="libsecret/secret-paths.h" line="154"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-paths.c"
               line="1301">the number of items or collections that were unlocked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1277">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="paths" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1278">the D-Bus object paths of the items or
  collections to unlock</doc>
            <array c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1280">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="unlocked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-paths.c"
                 line="1281">
  location to place array of D-Bus paths of items or collections
  that were unlocked</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="unlock_finish"
              c:identifier="secret_service_unlock_finish"
              throws="1">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="874">Complete asynchronous operation to unlock items or collections in the secret
service.

The secret service may not be able to unlock items individually, and may
unlock an entire collection instead.</doc>
        <source-position filename="libsecret/secret-service.h" line="215"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="888">the number of items or collections that were unlocked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="876">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="877">asynchronous result passed to the callback</doc>
            <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
          </parameter>
          <parameter name="unlocked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="878">
  location to place list of items or collections that were unlocked</doc>
            <type name="GLib.List" c:type="GList**">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="unlock_sync"
              c:identifier="secret_service_unlock_sync"
              throws="1"
              glib:async-func="unlock">
        <doc xml:space="preserve"
             filename="libsecret/secret-methods.c"
             line="902">Unlock items or collections in the secret service.

The secret service may not be able to unlock items individually, and may
unlock an entire collection instead.

If @service is %NULL, then [func@Service.get_sync] will be called to get
the default [class@Service] proxy.

This method may block indefinitely and should not be used in user
interface threads. The secret service may prompt the user.
[method@Service.prompt] will be used to handle any prompts that show up.</doc>
        <source-position filename="libsecret/secret-service.h" line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-methods.c"
               line="923">the number of items or collections that were unlocked</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="service"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="904">the secret service</doc>
            <type name="Service" c:type="SecretService*"/>
          </instance-parameter>
          <parameter name="objects" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="905">the items or collections to unlock</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
          <parameter name="cancellable"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="906">optional cancellation object</doc>
            <type name="Gio.Cancellable" c:type="GCancellable*"/>
          </parameter>
          <parameter name="unlocked"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libsecret/secret-methods.c"
                 line="907">
  location to place list of items or collections that were unlocked</doc>
            <type name="GLib.List" c:type="GList**">
              <type name="Gio.DBusProxy"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="collections"
                introspectable="0"
                transfer-ownership="none">
        <attribute name="org.gtk.Property.get"
                   value="secret_service_get_collections"/>
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="588">A list of [class@Collection] objects representing the collections in
the Secret Service.

This list may be %NULL if the collections have not been loaded.

To load the collections, specify the %SECRET_SERVICE_LOAD_COLLECTIONS
initialization flag when calling the [func@Service.get] or
[func@Service.open] functions. Or call the [method@Service.load_collections]
method.</doc>
        <type/>
      </property>
      <field name="parent">
        <type name="Gio.DBusProxy" c:type="GDBusProxy"/>
      </field>
      <field name="pv" readable="0" private="1">
        <type name="ServicePrivate" c:type="SecretServicePrivate*"/>
      </field>
    </class>
    <record name="ServiceClass"
            c:type="SecretServiceClass"
            glib:is-gtype-struct-for="Service">
      <doc xml:space="preserve"
           filename="libsecret/secret-service.c"
           line="78">The class for #SecretService.</doc>
      <source-position filename="libsecret/secret-service.h" line="86"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="80">the parent class</doc>
        <type name="Gio.DBusProxyClass" c:type="GDBusProxyClass"/>
      </field>
      <field name="collection_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="81">the [alias@GObject.Type] of the [class@Collection] objects
  instantiated by the #SecretService proxy</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="item_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="83">the [alias@GObject.Type] of the [class@Item] objects
  instantiated by the #SecretService proxy</doc>
        <type name="GType" c:type="GType"/>
      </field>
      <field name="prompt_sync">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="87">called to perform synchronous prompting when necessary</doc>
        <callback name="prompt_sync" throws="1">
          <source-position filename="libsecret/secret-service.h" line="63"/>
          <return-value transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1851">%NULL if the prompt was dismissed or an error occurred,
  a variant result if the prompt was successful</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1831">the secret service</doc>
              <type name="Service" c:type="SecretService*"/>
            </parameter>
            <parameter name="prompt" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1832">the prompt</doc>
              <type name="Prompt" c:type="SecretPrompt*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1833">optional cancellation object</doc>
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="return_type" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1834">the variant type of the prompt result</doc>
              <type name="GLib.VariantType" c:type="const GVariantType*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prompt_async">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="85">called to perform asynchronous prompting when necessary</doc>
        <callback name="prompt_async">
          <source-position filename="libsecret/secret-service.h" line="69"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Service" c:type="SecretService*"/>
            </parameter>
            <parameter name="prompt" transfer-ownership="none">
              <type name="Prompt" c:type="SecretPrompt*"/>
            </parameter>
            <parameter name="return_type" transfer-ownership="none">
              <type name="GLib.VariantType" c:type="const GVariantType*"/>
            </parameter>
            <parameter name="cancellable"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gio.Cancellable" c:type="GCancellable*"/>
            </parameter>
            <parameter name="callback"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       scope="async"
                       closure="5">
              <type name="Gio.AsyncReadyCallback"
                    c:type="GAsyncReadyCallback"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="5">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prompt_finish">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="86">called to complete an asynchronous prompt operation</doc>
        <callback name="prompt_finish" throws="1">
          <source-position filename="libsecret/secret-service.h" line="76"/>
          <return-value transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1924">%NULL if the prompt was dismissed or an error occurred,
  a variant result if the prompt was successful</doc>
            <type name="GLib.Variant" c:type="GVariant*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1914">the secret service</doc>
              <type name="Service" c:type="SecretService*"/>
            </parameter>
            <parameter name="result" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1915">the asynchronous result passed to the callback</doc>
              <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_collection_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="88">called to get the GObject type for collections
  instantiated by the #SecretService proxy</doc>
        <callback name="get_collection_gtype">
          <source-position filename="libsecret/secret-service.h" line="80"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1952">the gobject type for collections</doc>
            <type name="GType" c:type="GType"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1946">the secret service</doc>
              <type name="Service" c:type="SecretService*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_item_gtype">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="90">called to get the GObject type for collections
  instantiated by the #SecretService proxy</doc>
        <callback name="get_item_gtype">
          <source-position filename="libsecret/secret-service.h" line="82"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-service.c"
                 line="1981">the gobject type for items</doc>
            <type name="GType" c:type="GType"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libsecret/secret-service.c"
                   line="1975">the service</doc>
              <type name="Service" c:type="SecretService*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="14">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="ServiceFlags"
              glib:type-name="SecretServiceFlags"
              glib:get-type="secret_service_flags_get_type"
              c:type="SecretServiceFlags">
      <doc xml:space="preserve"
           filename="libsecret/secret-service.c"
           line="96">Flags which determine which parts of the #SecretService proxy are initialized
during a [func@Service.get] or [func@Service.open] operation.</doc>
      <member name="none"
              value="0"
              c:identifier="SECRET_SERVICE_NONE"
              glib:nick="none"
              glib:name="SECRET_SERVICE_NONE">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="98">no flags for initializing the #SecretService</doc>
      </member>
      <member name="open_session"
              value="2"
              c:identifier="SECRET_SERVICE_OPEN_SESSION"
              glib:nick="open-session"
              glib:name="SECRET_SERVICE_OPEN_SESSION">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="99">establish a session for transfer of secrets
  while initializing the #SecretService</doc>
      </member>
      <member name="load_collections"
              value="4"
              c:identifier="SECRET_SERVICE_LOAD_COLLECTIONS"
              glib:nick="load-collections"
              glib:name="SECRET_SERVICE_LOAD_COLLECTIONS">
        <doc xml:space="preserve"
             filename="libsecret/secret-service.c"
             line="101">load collections while initializing the
  #SecretService</doc>
      </member>
    </bitfield>
    <record name="ServicePrivate"
            c:type="SecretServicePrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libsecret/secret-service.h" line="48"/>
    </record>
    <record name="Value"
            c:type="SecretValue"
            opaque="1"
            stability="Stable"
            glib:type-name="SecretValue"
            glib:get-type="secret_value_get_type"
            c:symbol-prefix="value">
      <doc xml:space="preserve"
           filename="libsecret/secret-value.c"
           line="24">A value containing a secret

A #SecretValue contains a password or other secret value.

Use [method@Value.get] to get the actual secret data, such as a password.
The secret data is not necessarily null-terminated, unless the content type
is "text/plain".

Each #SecretValue has a content type. For passwords, this is `text/plain`.
Use [method@Value.get_content_type] to look at the content type.

#SecretValue is reference counted and immutable. The secret data is only
freed when all references have been released via [method@Value.unref].</doc>
      <source-position filename="libsecret/secret-value.h" line="28"/>
      <constructor name="new" c:identifier="secret_value_new">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="72">Create a #SecretValue for the secret data passed in.

The secret data is copied into non-pageable 'secure' memory.

If the length is less than zero, then @secret is assumed to be
null-terminated.</doc>
        <source-position filename="libsecret/secret-value.h" line="34"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-value.c"
               line="85">the new #SecretValue</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <parameter name="secret" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="74">the secret data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="75">the length of the data</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="76">the content type of the data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full" c:identifier="secret_value_new_full">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="107">Create a #SecretValue for the secret data passed in.

The secret data is not copied, and will later be freed with the @destroy
function.

If the length is less than zero, then @secret is assumed to be
null-terminated.</doc>
        <source-position filename="libsecret/secret-value.h" line="38"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-value.c"
               line="122">the new #SecretValue</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <parameter name="secret" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="109">the secret data</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="110">the length of the data</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
          <parameter name="content_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="111">the content type of the data</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="112">function to call to free the secret data</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get" c:identifier="secret_value_get">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="147">Get the secret data in the #SecretValue.

The value is not necessarily null-terminated unless it was created with
[ctor@Value.new] or a null-terminated string was passed to
[ctor@Value.new_full].</doc>
        <source-position filename="libsecret/secret-value.h" line="43"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-value.c"
               line="158">the secret data</doc>
          <array length="0" zero-terminated="0" c:type="const gchar*">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="149">the value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="150">the length of the secret</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_content_type"
              c:identifier="secret_value_get_content_type">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="192">Get the content type of the secret value, such as
`text/plain`.</doc>
        <source-position filename="libsecret/secret-value.h" line="48"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-value.c"
               line="199">the content type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="194">the value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_text" c:identifier="secret_value_get_text">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="170">Get the secret data in the #SecretValue if it contains a textual
value.

The content type must be `text/plain`.</doc>
        <source-position filename="libsecret/secret-value.h" line="46"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-value.c"
               line="179">the value</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="172">the value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="secret_value_ref">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="208">Add another reference to the #SecretValue.

For each reference [method@Value.unref] should be called to unreference the
value.</doc>
        <source-position filename="libsecret/secret-value.h" line="50"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-value.c"
               line="217">the value</doc>
          <type name="Value" c:type="SecretValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="210">value to reference</doc>
            <type name="Value" c:type="SecretValue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="secret_value_unref">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="227">Unreference a #SecretValue.

When the last reference is gone, then the value will be freed.</doc>
        <source-position filename="libsecret/secret-value.h" line="52"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="229">value to unreference</doc>
            <type name="Value" c:type="gpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref_to_password"
              c:identifier="secret_value_unref_to_password"
              version="0.19.0">
        <doc xml:space="preserve"
             filename="libsecret/secret-value.c"
             line="263">Unreference a #SecretValue and steal the secret data in
#SecretValue as nonpageable memory.</doc>
        <source-position filename="libsecret/secret-value.h" line="54"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-value.c"
               line="271">a new password string stored in nonpageable memory
  which must be freed with [func@password_free] when done</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="265">the value</doc>
            <type name="Value" c:type="SecretValue*"/>
          </instance-parameter>
          <parameter name="length"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libsecret/secret-value.c"
                 line="266">the length of the secret</doc>
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function name="attributes_build"
              c:identifier="secret_attributes_build"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-attributes.c"
           line="64">Build up a hash table of attribute values.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.</doc>
      <source-position filename="libsecret/secret-attributes.h" line="29"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-attributes.c"
             line="76">a new table of
  attributes, to be released with [func@GLib.HashTable.unref]</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-attributes.c"
               line="66">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-attributes.c"
               line="67">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="attributes_buildv"
              c:identifier="secret_attributes_buildv"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-attributes.c"
           line="93">Build up a hash table of attribute values.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.</doc>
      <source-position filename="libsecret/secret-attributes.h" line="32"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-attributes.c"
             line="105">a new table of
  attributes, to be released with [func@GLib.HashTable.unref]</doc>
        <type name="GLib.HashTable" c:type="GHashTable*">
          <type name="utf8"/>
          <type name="utf8"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-attributes.c"
               line="95">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="va" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-attributes.c"
               line="96">the attribute keys and values, terminated with %NULL</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="attributes_validate"
              c:identifier="secret_attributes_validate"
              version="0.21.2"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-attributes.c"
           line="182">Check if attributes are valid according to the provided schema.

Verifies schema name if available, attribute names and parsing
of attribute values.</doc>
      <source-position filename="libsecret/secret-attributes.h" line="35"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-attributes.c"
             line="193">whether or not the given attributes table is valid</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-attributes.c"
               line="184">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-attributes.c"
               line="185">the attributes to be validated</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="gpointer" c:type="gpointer"/>
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="backend_get"
              c:identifier="secret_backend_get"
              moved-to="Backend.get"
              version="0.19.0">
      <doc xml:space="preserve"
           filename="libsecret/secret-backend.c"
           line="202">Get a #SecretBackend instance.

If such a backend already exists, then the same backend is returned.

If @flags contains any flags of which parts of the secret backend to
ensure are initialized, then those will be initialized before completing.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-backend.h" line="103"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-backend.c"
               line="204">flags for which service functionality to ensure is initialized</doc>
          <type name="BackendFlags" c:type="SecretBackendFlags"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-backend.c"
               line="205">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:space="preserve"
               filename="libsecret/secret-backend.c"
               line="206">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-backend.c"
               line="207">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="backend_get_finish"
              c:identifier="secret_backend_get_finish"
              moved-to="Backend.get_finish"
              version="0.19.0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-backend.c"
           line="258">Complete an asynchronous operation to get a #SecretBackend.</doc>
      <source-position filename="libsecret/secret-backend.h" line="108"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-backend.c"
             line="265">a new reference to a #SecretBackend proxy, which
  should be released with [method@GObject.Object.unref].</doc>
        <type name="Backend" c:type="SecretBackend*"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-backend.c"
               line="260">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_get_quark"
              c:identifier="secret_error_get_quark"
              moved-to="Error.get_quark">
      <doc xml:space="preserve"
           filename="libsecret/secret-util.c"
           line="105">Get the error quark.</doc>
      <source-position filename="libsecret/secret-types.h" line="28"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-util.c"
             line="110">the quark</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="get_schema"
              c:identifier="secret_get_schema"
              version="0.18.6">
      <doc xml:space="preserve"
           filename="libsecret/secret-schemas.c"
           line="47">Get a secret storage schema of the given @type.

C code may access the schemas (such as %SECRET_SCHEMA_NOTE) directly, but
language bindings cannot, and must use this accessor.</doc>
      <source-position filename="libsecret/secret-schemas.h" line="112"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-schemas.c"
             line="56">schema type</doc>
        <type name="Schema" c:type="const SecretSchema*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-schemas.c"
               line="49">type of schema to get</doc>
          <type name="SchemaType" c:type="SecretSchemaType"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_clear"
              c:identifier="secret_password_clear"
              shadowed-by="password_clearv"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1138">Clear unlocked matching passwords from the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.

All unlocked items that match the attributes will be deleted.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="149"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1140">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1141">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1142">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1143">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1144">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_clear_finish"
              c:identifier="secret_password_clear_finish"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1295">Finish an asynchronous operation to remove passwords from the secret
service.</doc>
      <source-position filename="libsecret/secret-password.h" line="161"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1303">whether any passwords were removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1297">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_clear_sync"
              c:identifier="secret_password_clear_sync"
              shadowed-by="password_clearv_sync"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1315">Remove unlocked matching passwords from the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.

All unlocked items that match the attributes will be deleted.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="164"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1334">whether the any passwords were removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1317">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1318">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1319">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1320">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_clearv"
              c:identifier="secret_password_clearv"
              shadows="password_clear">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1251">Remove unlocked matching passwords from the secret service.

The @attributes should be a set of key and value string pairs.

All unlocked items that match the attributes will be deleted.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="155"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1253">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1254">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1255">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="4">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1256">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1257">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_clearv_sync"
              c:identifier="secret_password_clearv_sync"
              shadows="password_clear_sync"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1366">Remove unlocked matching passwords from the secret service.

The @attributes should be a set of key and value string pairs.

All unlocked items that match the attributes will be deleted.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="169"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1382">whether any passwords were removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1368">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1369">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1370">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_free"
              c:identifier="secret_password_free"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1721">Clear the memory used by a password, and then free it.

This function must be used to free nonpageable memory returned by
[func@password_lookup_nonpageable_finish],
[func@password_lookup_nonpageable_sync] or
[func@password_lookupv_nonpageable_sync].</doc>
      <source-position filename="libsecret/secret-password.h" line="203"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="password"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1723">password to free</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup"
              c:identifier="secret_password_lookup"
              shadowed-by="password_lookupv"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="594">Lookup a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.

If no secret is found then %NULL is returned.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="101"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="596">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="597">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="3">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="598">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="599">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="600">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_binary_finish"
              c:identifier="secret_password_lookup_binary_finish"
              version="0.19.0"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="779">Finish an asynchronous operation to lookup a password in the secret service.</doc>
      <source-position filename="libsecret/secret-password.h" line="118"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="786">a newly allocated [struct@Value], which should be
  released with [method@Value.unref], or %NULL if no secret found</doc>
        <type name="Value" c:type="SecretValue*"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="781">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_binary_sync"
              c:identifier="secret_password_lookup_binary_sync"
              version="0.19.0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="983">Lookup a password in the secret service.

This is similar to [func@password_lookup_sync], but returns a
[struct@Value] instead of a null-terminated password.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="130"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="998">a newly allocated [struct@Value], which should be
  released with [method@Value.unref], or %NULL if no secret found</doc>
        <type name="Value" c:type="SecretValue*"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="985">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="986">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="987">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="988">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_finish"
              c:identifier="secret_password_lookup_finish"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="801">Finish an asynchronous operation to lookup a password in the secret service.</doc>
      <source-position filename="libsecret/secret-password.h" line="113"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="808">a new password string which should be freed with
  [func@password_free] or may be freed with [func@GLib.free] when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="803">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_nonpageable_finish"
              c:identifier="secret_password_lookup_nonpageable_finish"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="753">Finish an asynchronous operation to lookup a password in the secret service.</doc>
      <source-position filename="libsecret/secret-password.h" line="116"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="760">a new password string stored in nonpageable memory
  which must be freed with [func@password_free] when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="755">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_nonpageable_sync"
              c:identifier="secret_password_lookup_nonpageable_sync"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="879">Lookup a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="126"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="898">a new password string stored in nonpageable memory
  which must be freed with [func@password_free] when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="881">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="882">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="883">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="884">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookup_sync"
              c:identifier="secret_password_lookup_sync"
              shadowed-by="password_lookupv_sync"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="827">Lookup a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="121"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="846">a new password string which should be freed with
  [func@password_free] or may be freed with [func@GLib.free] when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="829">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="830">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="831">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="832">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookupv"
              c:identifier="secret_password_lookupv"
              shadows="password_lookup">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="709">Lookup a password in the secret service.

The @attributes should be a set of key and value string pairs.

If no secret is found then %NULL is returned.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="107"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="711">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="712">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="713">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="4">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="714">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="715">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookupv_binary_sync"
              c:identifier="secret_password_lookupv_binary_sync"
              version="0.19.0"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1033">Lookup a password in the secret service.

This is similar to [func@password_lookupv_sync], but returns a
[struct@Value] instead of a null-terminated password.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="144"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1048">a newly allocated [struct@Value], which should be
  released with [method@Value.unref], or %NULL if no secret found</doc>
        <type name="Value" c:type="SecretValue*"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1035">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1036">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1037">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookupv_nonpageable_sync"
              c:identifier="secret_password_lookupv_nonpageable_sync"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="931">Lookup a password in the secret service.

The @attributes should be a set of key and value string pairs.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="140"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="947">a new password string stored in non pageable memory
  which should be freed with [func@password_free] when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="933">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="934">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="935">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_lookupv_sync"
              c:identifier="secret_password_lookupv_sync"
              shadows="password_lookup_sync"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1086">Lookup a password in the secret service.

The @attributes should be a set of key and value string pairs.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="135"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1102">a new password string which should be freed with
  [func@password_free] or may be freed with [func@GLib.free] when done</doc>
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1088">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1089">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1090">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_search"
              c:identifier="secret_password_search"
              shadowed-by="password_searchv"
              version="0.19.0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1417">Search for items in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="174"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1419">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1420">search option flags</doc>
          <type name="SearchFlags" c:type="SecretSearchFlags"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1421">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="4">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1422">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1423">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1424">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_search_finish"
              c:identifier="secret_password_search_finish"
              version="0.19.0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1587">Finish an asynchronous operation to search for items in the secret service.</doc>
      <source-position filename="libsecret/secret-password.h" line="200"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1594">a list of
  [iface@Retrievable] containing attributes of the matched items</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Retrievable"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1589">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_search_sync"
              c:identifier="secret_password_search_sync"
              shadowed-by="password_searchv_sync"
              version="0.19.0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1609">Search for items in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the password
@schema. The list of attributes should be terminated with a %NULL.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="188"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1629">a list of
  [iface@Retrievable] containing attributes of the matched items</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Retrievable"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1611">the schema for the attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1612">search option flags</doc>
          <type name="SearchFlags" c:type="SecretSearchFlags"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1613">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1614">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1615">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_searchv"
              c:identifier="secret_password_searchv"
              shadows="password_search"
              version="0.19.0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1540">Search for items in the secret service.

The @attributes should be a set of key and value string pairs.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="181"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1542">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1543">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1544">search option flags</doc>
          <type name="SearchFlags" c:type="SecretSearchFlags"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1545">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="5">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1546">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1547">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_searchv_sync"
              c:identifier="secret_password_searchv_sync"
              shadows="password_search_sync"
              version="0.19.0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1665">Search for items in the secret service.

The @attributes should be a set of key and value string pairs.

If no secret is found then %NULL is returned.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="194"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="1682">a list of
  [iface@Retrievable] containing attributes of the matched items</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Retrievable"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1667">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1668">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1669">search option flags</doc>
          <type name="SearchFlags" c:type="SecretSearchFlags"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1670">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_store"
              c:identifier="secret_password_store"
              shadowed-by="password_storev"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="26">Store a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the @schema.
The list of attributes should be terminated with a %NULL.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use [const@COLLECTION_SESSION] to store the password in the session
collection, which doesn't get stored across login sessions.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="30"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="28">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="29">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="31">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="32">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="33">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="6">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="34">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="35">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="36">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_store_binary"
              c:identifier="secret_password_store_binary"
              shadowed-by="password_storev_binary"
              version="0.19.0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="218">Store a password in the secret service.

This is similar to [func@password_store], but takes a
[struct@Value] as the argument instead of a null-terminated password.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="48"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="220">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="221">a collection alias, or D-Bus object path of the
   collection where to store the secret</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="223">label for the secret</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="224">a [struct@Value]</doc>
          <type name="Value" c:type="SecretValue*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="225">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="6">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="226">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="227">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="228">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_store_binary_sync"
              c:identifier="secret_password_store_binary_sync"
              shadowed-by="password_storev_binary_sync"
              version="0.19.0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="476">Store a password in the secret service.

This is similar to [func@password_store_sync], but takes a
[struct@Value] as the argument instead of a null terminated password.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="85"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="495">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="478">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="479">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="481">label for the secret</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="482">a [struct@Value]</doc>
          <type name="Value" c:type="SecretValue*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="483">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="484">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="485">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_store_finish"
              c:identifier="secret_password_store_finish"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="328">Finish asynchronous operation to store a password in the secret service.</doc>
      <source-position filename="libsecret/secret-password.h" line="66"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="335">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="330">the asynchronous result passed to the callback</doc>
          <type name="Gio.AsyncResult" c:type="GAsyncResult*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_store_sync"
              c:identifier="secret_password_store_sync"
              shadowed-by="password_storev_sync"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="347">Store a password in the secret service.

The variable argument list should contain pairs of a) The attribute name as
a null-terminated string, followed by b) attribute value, either a character
string, an int number, or a gboolean value, as defined in the @schema.
The list of attributes should be terminated with a %NULL.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use [const@COLLECTION_SESSION] to store the password in the session
collection, which doesn't get stored across login sessions.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="69"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="375">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="349">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="350">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="352">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="353">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="354">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="355">location to place an error on failure</doc>
          <type name="GLib.Error" c:type="GError**"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="356">the attribute keys and values, terminated with %NULL</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="password_storev"
              c:identifier="secret_password_storev"
              shadows="password_store">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="157">Store a password in the secret service.

The @attributes should be a set of key and value string pairs.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use [const@COLLECTION_SESSION] to store the password in the session
collection, which doesn't get stored across login sessions.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="39"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="159">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="160">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="161">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="163">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="164">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="165">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="7">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="166">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="167">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_storev_binary"
              c:identifier="secret_password_storev_binary"
              shadows="password_store_binary"
              version="0.19.0">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="271">Store a password in the secret service.

This is similar to [func@password_storev], but takes a
[struct@Value] as the argument instead of a null-terminated password.

This method will return immediately and complete asynchronously.</doc>
      <source-position filename="libsecret/secret-password.h" line="57"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="273">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="274">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="275">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="277">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="278">a [struct@Value]</doc>
          <type name="Value" c:type="SecretValue*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="279">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   scope="async"
                   closure="7">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="280">called when the operation completes</doc>
          <type name="Gio.AsyncReadyCallback" c:type="GAsyncReadyCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="281">data to be passed to the callback</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_storev_binary_sync"
              c:identifier="secret_password_storev_binary_sync"
              shadows="password_store_binary_sync"
              version="0.19.0"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="533">Store a password in the secret service.

This is similar to [func@password_storev_sync], but takes a [struct@Value] as
the argument instead of a null-terminated passwords.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="93"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="552">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="535">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="536">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="537">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="539">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="540">a [struct@Value]</doc>
          <type name="Value" c:type="SecretValue*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="541">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_storev_sync"
              c:identifier="secret_password_storev_sync"
              shadows="password_store_sync"
              throws="1">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="411">Store a password in the secret service.

The @attributes should be a set of key and value string pairs.

If the attributes match a secret item already stored in the collection, then
the item will be updated with these new values.

If @collection is %NULL, then the default collection will be
used. Use [const@COLLECTION_SESSION] to store the password in the session
collection, which doesn't get stored across login sessions.

This method may block indefinitely and should not be used in user interface
threads.</doc>
      <source-position filename="libsecret/secret-password.h" line="77"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libsecret/secret-password.c"
             line="436">whether the storage was successful or not</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="schema"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="413">the schema for attributes</doc>
          <type name="Schema" c:type="const SecretSchema*"/>
        </parameter>
        <parameter name="attributes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="414">the attribute keys and values</doc>
          <type name="GLib.HashTable" c:type="GHashTable*">
            <type name="utf8"/>
            <type name="utf8"/>
          </type>
        </parameter>
        <parameter name="collection"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="415">a collection alias, or D-Bus object path of the
  collection where to store the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="label" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="417">label for the secret</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="password" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="418">the null-terminated password to store</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="cancellable"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="419">optional cancellation object</doc>
          <type name="Gio.Cancellable" c:type="GCancellable*"/>
        </parameter>
      </parameters>
    </function>
    <function name="password_wipe" c:identifier="secret_password_wipe">
      <doc xml:space="preserve"
           filename="libsecret/secret-password.c"
           line="1741">Clear the memory used by a password.</doc>
      <source-position filename="libsecret/secret-password.h" line="205"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="password"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libsecret/secret-password.c"
               line="1743">password to clear</doc>
          <type name="utf8" c:type="gchar*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
