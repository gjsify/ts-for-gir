/**
 * TelepathyGLib-0.12
 */

import "node"
import type { Gio } from './Gio-2.0';
import type { GObject } from './GObject-2.0';
import type { GLib } from './GLib-2.0';

export declare namespace TelepathyGLib {

export enum AccessControlType {
    WHITELIST,
    PUBLISH_LIST,
    GROUP,
    OPEN,
    SUBSCRIBE_OR_PUBLISH_LIST,
    CLOSED,
    NOT_UNDERSTOOD,
}
export enum CMInfoSource {
    NONE,
    FILE,
    LIVE,
}
export enum CallContentDisposition {
    NONE,
    INITIAL,
}
export enum CallContentPacketizationType {
    RTP,
    RAW,
    MSN_WEBCAM,
}
export enum CallState {
    UNKNOWN,
    PENDING_INITIATOR,
    INITIALISING,
    INITIALISED,
    ACCEPTED,
    ACTIVE,
    ENDED,
}
export enum CallStateChangeReason {
    UNKNOWN,
    PROGRESS_MADE,
    USER_REQUESTED,
    FORWARDED,
    REJECTED,
    NO_ANSWER,
    INVALID_CONTACT,
    PERMISSION_DENIED,
    BUSY,
    INTERNAL_ERROR,
    SERVICE_ERROR,
    NETWORK_ERROR,
    MEDIA_ERROR,
    CONNECTIVITY_ERROR,
}
export enum CallStreamCandidateType {
    NONE,
    HOST,
    SERVER_REFLEXIVE,
    PEER_REFLEXIVE,
    RELAY,
    MULTICAST,
}
export enum CaptchaCancelReason {
    USER_CANCELLED,
    NOT_SUPPORTED,
    SERVICE_CONFUSED,
}
export enum CaptchaStatus {
    LOCAL_PENDING,
    REMOTE_PENDING,
    SUCCEEDED,
    TRY_AGAIN,
    FAILED,
}
export enum ChannelChatState {
    GONE,
    INACTIVE,
    ACTIVE,
    PAUSED,
    COMPOSING,
}
export enum ChannelContactSearchState {
    NOT_STARTED,
    IN_PROGRESS,
    MORE_AVAILABLE,
    COMPLETED,
    FAILED,
}
export enum ChannelGroupChangeReason {
    NONE,
    OFFLINE,
    KICKED,
    BUSY,
    INVITED,
    BANNED,
    ERROR,
    INVALID_CONTACT,
    NO_ANSWER,
    RENAMED,
    PERMISSION_DENIED,
    SEPARATED,
}
export enum ChannelTextMessageType {
    NORMAL,
    ACTION,
    NOTICE,
    AUTO_REPLY,
    DELIVERY_REPORT,
}
export enum ChannelTextSendError {
    UNKNOWN,
    OFFLINE,
    INVALID_CONTACT,
    PERMISSION_DENIED,
    TOO_LONG,
    NOT_IMPLEMENTED,
}
export enum ConnectionPresenceType {
    UNSET,
    OFFLINE,
    AVAILABLE,
    AWAY,
    EXTENDED_AWAY,
    HIDDEN,
    BUSY,
    UNKNOWN,
    ERROR,
}
export enum ConnectionStatus {
    CONNECTED,
    CONNECTING,
    DISCONNECTED,
}
export enum ConnectionStatusReason {
    NONE_SPECIFIED,
    REQUESTED,
    NETWORK_ERROR,
    AUTHENTICATION_FAILED,
    ENCRYPTION_ERROR,
    NAME_IN_USE,
    CERT_NOT_PROVIDED,
    CERT_UNTRUSTED,
    CERT_EXPIRED,
    CERT_NOT_ACTIVATED,
    CERT_HOSTNAME_MISMATCH,
    CERT_FINGERPRINT_MISMATCH,
    CERT_SELF_SIGNED,
    CERT_OTHER_ERROR,
    CERT_REVOKED,
    CERT_INSECURE,
    CERT_LIMIT_EXCEEDED,
}
export enum ContactFeature {
    ALIAS,
    AVATAR_TOKEN,
    PRESENCE,
    LOCATION,
    CAPABILITIES,
    AVATAR_DATA,
    CONTACT_INFO,
    CLIENT_TYPES,
    SUBSCRIPTION_STATES,
    CONTACT_GROUPS,
    CONTACT_BLOCKING,
}
export enum ContactListState {
    NONE,
    WAITING,
    FAILURE,
    SUCCESS,
}
export enum ContactMetadataStorageType {
    NONE,
    SUBSCRIBED_OR_PENDING,
    SUBSCRIBED,
    ANYONE,
}
export enum DBusError {
    UNKNOWN_REMOTE_ERROR,
    PROXY_UNREFERENCED,
    NO_INTERFACE,
    NAME_OWNER_LOST,
    INVALID_BUS_NAME,
    INVALID_INTERFACE_NAME,
    INVALID_OBJECT_PATH,
    INVALID_MEMBER_NAME,
    OBJECT_REMOVED,
    CANCELLED,
    INCONSISTENT,
}
export enum DTMFEvent {
    DIGIT_0,
    DIGIT_1,
    DIGIT_2,
    DIGIT_3,
    DIGIT_4,
    DIGIT_5,
    DIGIT_6,
    DIGIT_7,
    DIGIT_8,
    DIGIT_9,
    ASTERISK,
    HASH,
    LETTER_A,
    LETTER_B,
    LETTER_C,
    LETTER_D,
}
export enum DebugLevel {
    ERROR,
    CRITICAL,
    WARNING,
    MESSAGE,
    INFO,
    DEBUG,
}
export enum DeliveryStatus {
    UNKNOWN,
    DELIVERED,
    TEMPORARILY_FAILED,
    PERMANENTLY_FAILED,
    ACCEPTED,
    READ,
    DELETED,
}
export enum Error {
    NETWORK_ERROR,
    NOT_IMPLEMENTED,
    INVALID_ARGUMENT,
    NOT_AVAILABLE,
    PERMISSION_DENIED,
    DISCONNECTED,
    INVALID_HANDLE,
    CHANNEL_BANNED,
    CHANNEL_FULL,
    CHANNEL_INVITE_ONLY,
    NOT_YOURS,
    CANCELLED,
    AUTHENTICATION_FAILED,
    ENCRYPTION_NOT_AVAILABLE,
    ENCRYPTION_ERROR,
    CERT_NOT_PROVIDED,
    CERT_UNTRUSTED,
    CERT_EXPIRED,
    CERT_NOT_ACTIVATED,
    CERT_FINGERPRINT_MISMATCH,
    CERT_HOSTNAME_MISMATCH,
    CERT_SELF_SIGNED,
    CERT_INVALID,
    NOT_CAPABLE,
    OFFLINE,
    CHANNEL_KICKED,
    BUSY,
    NO_ANSWER,
    DOES_NOT_EXIST,
    TERMINATED,
    CONNECTION_REFUSED,
    CONNECTION_FAILED,
    CONNECTION_LOST,
    ALREADY_CONNECTED,
    CONNECTION_REPLACED,
    REGISTRATION_EXISTS,
    SERVICE_BUSY,
    RESOURCE_UNAVAILABLE,
    WOULD_BREAK_ANONYMITY,
    CERT_REVOKED,
    CERT_INSECURE,
    CERT_LIMIT_EXCEEDED,
    NOT_YET,
    REJECTED,
    PICKED_UP_ELSEWHERE,
    CONFUSED,
    SERVICE_CONFUSED,
    EMERGENCY_CALLS_NOT_SUPPORTED,
    SOFTWARE_UPGRADE_REQUIRED,
    INSUFFICIENT_BALANCE,
    MEDIA_CODECS_INCOMPATIBLE,
    MEDIA_UNSUPPORTED_TYPE,
    MEDIA_STREAMING_ERROR,
    CAPTCHA_NOT_SUPPORTED,
}
export enum FileHashType {
    NONE,
    MD5,
    SHA1,
    SHA256,
}
export enum FileTransferState {
    NONE,
    PENDING,
    ACCEPTED,
    OPEN,
    COMPLETED,
    CANCELLED,
}
export enum FileTransferStateChangeReason {
    NONE,
    REQUESTED,
    LOCAL_STOPPED,
    REMOTE_STOPPED,
    LOCAL_ERROR,
    REMOTE_ERROR,
}
export enum HTTPMethod {
    GET,
    POST,
}
export enum HandleType {
    NONE,
    CONTACT,
    ROOM,
    LIST,
    GROUP,
}
export enum LocalHoldState {
    UNHELD,
    HELD,
    PENDING_HOLD,
    PENDING_UNHOLD,
}
export enum LocalHoldStateReason {
    NONE,
    REQUESTED,
    RESOURCE_NOT_AVAILABLE,
}
export enum MediaStreamBaseProto {
    UDP,
    TCP,
}
export enum MediaStreamDirection {
    NONE,
    SEND,
    RECEIVE,
    BIDIRECTIONAL,
}
export enum MediaStreamError {
    UNKNOWN,
    EOS,
    CODEC_NEGOTIATION_FAILED,
    CONNECTION_FAILED,
    NETWORK_ERROR,
    NO_CODECS,
    INVALID_CM_BEHAVIOR,
    MEDIA_ERROR,
}
export enum MediaStreamState {
    DISCONNECTED,
    CONNECTING,
    CONNECTED,
}
export enum MediaStreamTransportType {
    LOCAL,
    DERIVED,
    RELAY,
}
export enum MediaStreamType {
    AUDIO,
    VIDEO,
}
export enum RCPTXRRTTMode {
    ALL,
    SENDER,
}
export enum RichPresenceAccessControlType {
    WHITELIST,
    PUBLISH_LIST,
    GROUP,
    OPEN,
}
export enum SASLAbortReason {
    INVALID_CHALLENGE,
    USER_ABORT,
}
export enum SASLStatus {
    NOT_STARTED,
    IN_PROGRESS,
    SERVER_SUCCEEDED,
    CLIENT_ACCEPTED,
    SUCCEEDED,
    SERVER_FAILED,
    CLIENT_FAILED,
}
export enum SendingState {
    NONE,
    PENDING_SEND,
    SENDING,
    PENDING_STOP_SENDING,
}
export enum ServicePointType {
    NONE,
    EMERGENCY,
    COUNSELING,
}
export enum SocketAccessControl {
    LOCALHOST,
    PORT,
    NETMASK,
    CREDENTIALS,
}
export enum SocketAddressType {
    UNIX,
    ABSTRACT_UNIX,
    IPV4,
    IPV6,
}
export enum StreamComponent {
    UNKNOWN,
    DATA,
    CONTROL,
}
export enum StreamEndpointState {
    CONNECTING,
    PROVISIONALLY_CONNECTED,
    FULLY_CONNECTED,
    EXHAUSTED_CANDIDATES,
    FAILED,
}
export enum StreamFlowState {
    STOPPED,
    PENDING_START,
    PENDING_STOP,
    STARTED,
}
export enum StreamTransportType {
    UNKNOWN,
    RAW_UDP,
    ICE,
    GTALK_P2P,
    WLM_2009,
    SHM,
    MULTICAST,
}
export enum SubscriptionState {
    UNKNOWN,
    NO,
    REMOVED_REMOTELY,
    ASK,
    YES,
}
export enum TLSCertificateRejectReason {
    UNKNOWN,
    UNTRUSTED,
    EXPIRED,
    NOT_ACTIVATED,
    FINGERPRINT_MISMATCH,
    HOSTNAME_MISMATCH,
    SELF_SIGNED,
    REVOKED,
    INSECURE,
    LIMIT_EXCEEDED,
}
export enum TLSCertificateState {
    PENDING,
    ACCEPTED,
    REJECTED,
}
export enum TubeChannelState {
    LOCAL_PENDING,
    REMOTE_PENDING,
    OPEN,
    NOT_OFFERED,
}
export enum TubeState {
    LOCAL_PENDING,
    REMOTE_PENDING,
    OPEN,
}
export enum TubeType {
    DBUS,
    STREAM,
}
export enum AnonymityModeFlags {
    CLIENT_INFO,
    SHOW_CLIENT_INFO,
    NETWORK_INFO,
}
export enum CallFlags {
    LOCALLY_HELD,
    LOCALLY_RINGING,
    LOCALLY_QUEUED,
    FORWARDED,
    CLEARING,
}
export enum CallMemberFlags {
    RINGING,
    HELD,
    CONFERENCE_HOST,
}
export enum CaptchaFlags {
    CAPTCHA_FLAGS_REQUIRED,
}
export enum ChannelCallStateFlags {
    RINGING,
    QUEUED,
    HELD,
    FORWARDED,
    IN_PROGRESS,
    CONFERENCE_HOST,
}
export enum ChannelGroupFlags {
    CAN_ADD,
    CAN_REMOVE,
    CAN_RESCIND,
    MESSAGE_ADD,
    MESSAGE_REMOVE,
    MESSAGE_ACCEPT,
    MESSAGE_REJECT,
    MESSAGE_RESCIND,
    CHANNEL_SPECIFIC_HANDLES,
    ONLY_ONE_GROUP,
    HANDLE_OWNERS_NOT_AVAILABLE,
    PROPERTIES,
    MEMBERS_CHANGED_DETAILED,
    MESSAGE_DEPART,
}
export enum ChannelMediaCapabilities {
    AUDIO,
    VIDEO,
    NAT_TRAVERSAL_STUN,
    NAT_TRAVERSAL_GTALK_P2P,
    NAT_TRAVERSAL_ICE_UDP,
    IMMUTABLE_STREAMS,
}
export enum ChannelPasswordFlags {
    PROVIDE,
    HINT,
}
export enum ChannelTextMessageFlags {
    TRUNCATED,
    NON_TEXT_CONTENT,
    SCROLLBACK,
    RESCUED,
}
export enum ConnMgrParamFlags {
    REQUIRED,
    REGISTER,
    HAS_DEFAULT,
    SECRET,
    DBUS_PROPERTY,
}
export enum ConnectionAliasFlags {
    CONNECTION_ALIAS_FLAG_USER_SET,
}
export enum ConnectionCapabilityFlags {
    CREATE,
    INVITE,
}
export enum ContactBlockingCapabilities {
    CONTACT_BLOCKING_CAPABILITY_CAN_REPORT_ABUSIVE,
}
export enum ContactInfoFieldFlags {
    PARAMETERS_EXACT,
    OVERWRITTEN_BY_NICKNAME,
}
export enum ContactInfoFlags {
    CAN_SET,
    PUSH,
}
export enum DBusNameType {
    UNIQUE,
    WELL_KNOWN,
    BUS_DAEMON,
    NOT_BUS_DAEMON,
    ANY,
}
export enum DBusPropertiesMixinFlags {
    READ,
    WRITE,
    EMITS_CHANGED,
    EMITS_INVALIDATED,
}
export enum DeliveryReportingSupportFlags {
    FAILURES,
    SUCCESSES,
    READ,
    DELETED,
}
export enum LocationFeatures {
    LOCATION_FEATURE_CAN_SET,
}
export enum MailNotificationFlags {
    SUPPORTS_UNREAD_MAIL_COUNT,
    SUPPORTS_UNREAD_MAILS,
    EMITS_MAILS_RECEIVED,
    SUPPORTS_REQUEST_INBOX_URL,
    SUPPORTS_REQUEST_MAIL_URL,
    THREAD_BASED,
}
export enum MediaStreamPendingSend {
    LOCAL_SEND,
    REMOTE_SEND,
}
export enum MessagePartSupportFlags {
    ONE_ATTACHMENT,
    MULTIPLE_ATTACHMENTS,
}
export enum MessageSendingFlags {
    DELIVERY,
    READ,
    DELETED,
}
export enum PropertyFlags {
    READ,
    WRITE,
}
export enum RTCPXRStatisticsFlags {
    LOSS,
    DUPLICATE,
    JITTER,
    TTL,
    HL,
}
export enum StorageRestrictionFlags {
    PARAMETERS,
    ENABLED,
    PRESENCE,
    SERVICE,
}
export const ACCOUNT_MANAGER_BUS_NAME: string
export const ACCOUNT_MANAGER_OBJECT_PATH: string
export const ACCOUNT_OBJECT_PATH_BASE: string
export const CHANNEL_DISPATCHER_BUS_NAME: string
export const CHANNEL_DISPATCHER_OBJECT_PATH: string
export const CLIENT_BUS_NAME_BASE: string
export const CLIENT_OBJECT_PATH_BASE: string
export const CM_BUS_NAME_BASE: string
export const CM_OBJECT_PATH_BASE: string
export const CONN_BUS_NAME_BASE: string
export const CONN_OBJECT_PATH_BASE: string
export const DEBUG_OBJECT_PATH: string
export const ERROR_PREFIX: string
export const IFACE_ACCOUNT: string
export const IFACE_ACCOUNT_INTERFACE_ADDRESSING: string
export const IFACE_ACCOUNT_INTERFACE_AVATAR: string
export const IFACE_ACCOUNT_INTERFACE_STORAGE: string
export const IFACE_ACCOUNT_MANAGER: string
export const IFACE_AUTHENTICATION_TLS_CERTIFICATE: string
export const IFACE_CALL_CONTENT: string
export const IFACE_CALL_CONTENT_INTERFACE_AUDIO_CONTROL: string
export const IFACE_CALL_CONTENT_INTERFACE_DTMF: string
export const IFACE_CALL_CONTENT_INTERFACE_MEDIA: string
export const IFACE_CALL_CONTENT_INTERFACE_VIDEO_CONTROL: string
export const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION: string
export const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS: string
export const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK: string
export const IFACE_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS: string
export const IFACE_CALL_STREAM: string
export const IFACE_CALL_STREAM_ENDPOINT: string
export const IFACE_CALL_STREAM_INTERFACE_MEDIA: string
export const IFACE_CHANNEL: string
export const IFACE_CHANNEL_DISPATCHER: string
export const IFACE_CHANNEL_DISPATCHER_INTERFACE_MESSAGES1: string
export const IFACE_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST: string
export const IFACE_CHANNEL_DISPATCH_OPERATION: string
export const IFACE_CHANNEL_INTERFACE_ANONYMITY: string
export const IFACE_CHANNEL_INTERFACE_CALL_STATE: string
export const IFACE_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION: string
export const IFACE_CHANNEL_INTERFACE_CHAT_STATE: string
export const IFACE_CHANNEL_INTERFACE_CONFERENCE: string
export const IFACE_CHANNEL_INTERFACE_DESTROYABLE: string
export const IFACE_CHANNEL_INTERFACE_DTMF: string
export const IFACE_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA: string
export const IFACE_CHANNEL_INTERFACE_GROUP: string
export const IFACE_CHANNEL_INTERFACE_HOLD: string
export const IFACE_CHANNEL_INTERFACE_MEDIA_SIGNALLING: string
export const IFACE_CHANNEL_INTERFACE_MESSAGES: string
export const IFACE_CHANNEL_INTERFACE_PASSWORD: string
export const IFACE_CHANNEL_INTERFACE_ROOM: string
export const IFACE_CHANNEL_INTERFACE_ROOM_CONFIG: string
export const IFACE_CHANNEL_INTERFACE_SASL_AUTHENTICATION: string
export const IFACE_CHANNEL_INTERFACE_SECURABLE: string
export const IFACE_CHANNEL_INTERFACE_SERVICE_POINT: string
export const IFACE_CHANNEL_INTERFACE_SMS: string
export const IFACE_CHANNEL_INTERFACE_SUBJECT: string
export const IFACE_CHANNEL_INTERFACE_TUBE: string
export const IFACE_CHANNEL_REQUEST: string
export const IFACE_CHANNEL_TYPE_CALL: string
export const IFACE_CHANNEL_TYPE_CONTACT_LIST: string
export const IFACE_CHANNEL_TYPE_CONTACT_SEARCH: string
export const IFACE_CHANNEL_TYPE_DBUS_TUBE: string
export const IFACE_CHANNEL_TYPE_FILE_TRANSFER: string
export const IFACE_CHANNEL_TYPE_ROOM_LIST: string
export const IFACE_CHANNEL_TYPE_SERVER_AUTHENTICATION: string
export const IFACE_CHANNEL_TYPE_SERVER_TLS_CONNECTION: string
export const IFACE_CHANNEL_TYPE_STREAMED_MEDIA: string
export const IFACE_CHANNEL_TYPE_STREAM_TUBE: string
export const IFACE_CHANNEL_TYPE_TEXT: string
export const IFACE_CHANNEL_TYPE_TUBES: string
export const IFACE_CLIENT: string
export const IFACE_CLIENT_APPROVER: string
export const IFACE_CLIENT_HANDLER: string
export const IFACE_CLIENT_INTERFACE_REQUESTS: string
export const IFACE_CLIENT_OBSERVER: string
export const IFACE_CONNECTION: string
export const IFACE_CONNECTION_INTERFACE_ADDRESSING: string
export const IFACE_CONNECTION_INTERFACE_ALIASING: string
export const IFACE_CONNECTION_INTERFACE_ANONYMITY: string
export const IFACE_CONNECTION_INTERFACE_AVATARS: string
export const IFACE_CONNECTION_INTERFACE_BALANCE: string
export const IFACE_CONNECTION_INTERFACE_CAPABILITIES: string
export const IFACE_CONNECTION_INTERFACE_CELLULAR: string
export const IFACE_CONNECTION_INTERFACE_CLIENT_TYPES: string
export const IFACE_CONNECTION_INTERFACE_CONTACTS: string
export const IFACE_CONNECTION_INTERFACE_CONTACT_BLOCKING: string
export const IFACE_CONNECTION_INTERFACE_CONTACT_CAPABILITIES: string
export const IFACE_CONNECTION_INTERFACE_CONTACT_GROUPS: string
export const IFACE_CONNECTION_INTERFACE_CONTACT_INFO: string
export const IFACE_CONNECTION_INTERFACE_CONTACT_LIST: string
export const IFACE_CONNECTION_INTERFACE_LOCATION: string
export const IFACE_CONNECTION_INTERFACE_MAIL_NOTIFICATION: string
export const IFACE_CONNECTION_INTERFACE_POWER_SAVING: string
export const IFACE_CONNECTION_INTERFACE_PRESENCE: string
export const IFACE_CONNECTION_INTERFACE_RENAMING: string
export const IFACE_CONNECTION_INTERFACE_REQUESTS: string
export const IFACE_CONNECTION_INTERFACE_SERVICE_POINT: string
export const IFACE_CONNECTION_INTERFACE_SIDECARS1: string
export const IFACE_CONNECTION_INTERFACE_SIMPLE_PRESENCE: string
export const IFACE_CONNECTION_MANAGER: string
export const IFACE_DBUS_DAEMON: string
export const IFACE_DBUS_INTROSPECTABLE: string
export const IFACE_DBUS_PEER: string
export const IFACE_DBUS_PROPERTIES: string
export const IFACE_DEBUG: string
export const IFACE_MEDIA_SESSION_HANDLER: string
export const IFACE_MEDIA_STREAM_HANDLER: string
export const IFACE_PROPERTIES_INTERFACE: string
export const IFACE_PROTOCOL: string
export const IFACE_PROTOCOL_INTERFACE_ADDRESSING: string
export const IFACE_PROTOCOL_INTERFACE_AVATARS: string
export const IFACE_PROTOCOL_INTERFACE_PRESENCE: string
export const NUM_ACCESS_CONTROL_TYPES: number
export const NUM_CALL_CONTENT_DISPOSITIONS: number
export const NUM_CALL_CONTENT_PACKETIZATION_TYPES: number
export const NUM_CALL_STATES: number
export const NUM_CALL_STATE_CHANGE_REASONS: number
export const NUM_CALL_STREAM_CANDIDATE_TYPES: number
export const NUM_CAPTCHA_CANCEL_REASONS: number
export const NUM_CAPTCHA_STATUSES: number
export const NUM_CHANNEL_CHAT_STATES: number
export const NUM_CHANNEL_CONTACT_SEARCH_STATES: number
export const NUM_CHANNEL_GROUP_CHANGE_REASONS: number
export const NUM_CHANNEL_TEXT_MESSAGE_TYPES: number
export const NUM_CHANNEL_TEXT_SEND_ERRORS: number
export const NUM_CONNECTION_PRESENCE_TYPES: number
export const NUM_CONNECTION_STATUSES: number
export const NUM_CONNECTION_STATUS_REASONS: number
export const NUM_CONTACT_FEATURES: number
export const NUM_CONTACT_LIST_STATES: number
export const NUM_CONTACT_METADATA_STORAGE_TYPES: number
export const NUM_DBUS_ERRORS: number
export const NUM_DEBUG_LEVELS: number
export const NUM_DELIVERY_STATUSES: number
export const NUM_DTMF_EVENTS: number
export const NUM_FILE_HASH_TYPES: number
export const NUM_FILE_TRANSFER_STATES: number
export const NUM_FILE_TRANSFER_STATE_CHANGE_REASONS: number
export const NUM_HANDLE_TYPES: number
export const NUM_HTTP_METHODS: number
export const NUM_LOCAL_HOLD_STATES: number
export const NUM_LOCAL_HOLD_STATE_REASONS: number
export const NUM_MEDIA_STREAM_BASE_PROTOS: number
export const NUM_MEDIA_STREAM_DIRECTIONS: number
export const NUM_MEDIA_STREAM_ERRORS: number
export const NUM_MEDIA_STREAM_STATES: number
export const NUM_MEDIA_STREAM_TRANSPORT_TYPES: number
export const NUM_MEDIA_STREAM_TYPES: number
export const NUM_RCPT_XR_RTT_MODES: number
export const NUM_RICH_PRESENCE_ACCESS_CONTROL_TYPES: number
export const NUM_SASL_ABORT_REASONS: number
export const NUM_SASL_STATUSES: number
export const NUM_SENDING_STATES: number
export const NUM_SERVICE_POINT_TYPES: number
export const NUM_SOCKET_ACCESS_CONTROLS: number
export const NUM_SOCKET_ADDRESS_TYPES: number
export const NUM_STREAM_COMPONENTS: number
export const NUM_STREAM_ENDPOINT_STATES: number
export const NUM_STREAM_FLOW_STATES: number
export const NUM_STREAM_TRANSPORT_TYPES: number
export const NUM_SUBSCRIPTION_STATES: number
export const NUM_TLS_CERTIFICATE_REJECT_REASONS: number
export const NUM_TLS_CERTIFICATE_STATES: number
export const NUM_TUBE_CHANNEL_STATES: number
export const NUM_TUBE_STATES: number
export const NUM_TUBE_TYPES: number
export const PROP_ACCOUNT_AUTOMATIC_PRESENCE: string
export const PROP_ACCOUNT_CHANGING_PRESENCE: string
export const PROP_ACCOUNT_CONNECTION: string
export const PROP_ACCOUNT_CONNECTION_ERROR: string
export const PROP_ACCOUNT_CONNECTION_ERROR_DETAILS: string
export const PROP_ACCOUNT_CONNECTION_STATUS: string
export const PROP_ACCOUNT_CONNECTION_STATUS_REASON: string
export const PROP_ACCOUNT_CONNECT_AUTOMATICALLY: string
export const PROP_ACCOUNT_CURRENT_PRESENCE: string
export const PROP_ACCOUNT_DISPLAY_NAME: string
export const PROP_ACCOUNT_ENABLED: string
export const PROP_ACCOUNT_HAS_BEEN_ONLINE: string
export const PROP_ACCOUNT_ICON: string
export const PROP_ACCOUNT_INTERFACES: string
export const PROP_ACCOUNT_INTERFACE_ADDRESSING_URI_SCHEMES: string
export const PROP_ACCOUNT_INTERFACE_AVATAR_AVATAR: string
export const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_IDENTIFIER: string
export const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_PROVIDER: string
export const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_RESTRICTIONS: string
export const PROP_ACCOUNT_INTERFACE_STORAGE_STORAGE_SPECIFIC_INFORMATION: string
export const PROP_ACCOUNT_MANAGER_INTERFACES: string
export const PROP_ACCOUNT_MANAGER_INVALID_ACCOUNTS: string
export const PROP_ACCOUNT_MANAGER_SUPPORTED_ACCOUNT_PROPERTIES: string
export const PROP_ACCOUNT_MANAGER_VALID_ACCOUNTS: string
export const PROP_ACCOUNT_NICKNAME: string
export const PROP_ACCOUNT_NORMALIZED_NAME: string
export const PROP_ACCOUNT_PARAMETERS: string
export const PROP_ACCOUNT_REQUESTED_PRESENCE: string
export const PROP_ACCOUNT_SERVICE: string
export const PROP_ACCOUNT_SUPERSEDES: string
export const PROP_ACCOUNT_VALID: string
export const PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_CHAIN_DATA: string
export const PROP_AUTHENTICATION_TLS_CERTIFICATE_CERTIFICATE_TYPE: string
export const PROP_AUTHENTICATION_TLS_CERTIFICATE_REJECTIONS: string
export const PROP_AUTHENTICATION_TLS_CERTIFICATE_STATE: string
export const PROP_CALL_CONTENT_DISPOSITION: string
export const PROP_CALL_CONTENT_INTERFACES: string
export const PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_INPUT_VOLUME: string
export const PROP_CALL_CONTENT_INTERFACE_AUDIO_CONTROL_REQUESTED_OUTPUT_VOLUME: string
export const PROP_CALL_CONTENT_INTERFACE_DTMF_CURRENTLY_SENDING_TONES: string
export const PROP_CALL_CONTENT_INTERFACE_DTMF_DEFERRED_TONES: string
export const PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_EVENT: string
export const PROP_CALL_CONTENT_INTERFACE_MEDIA_CURRENT_DTMF_STATE: string
export const PROP_CALL_CONTENT_INTERFACE_MEDIA_LOCAL_MEDIA_DESCRIPTIONS: string
export const PROP_CALL_CONTENT_INTERFACE_MEDIA_MEDIA_DESCRIPTION_OFFER: string
export const PROP_CALL_CONTENT_INTERFACE_MEDIA_PACKETIZATION: string
export const PROP_CALL_CONTENT_INTERFACE_MEDIA_REMOTE_MEDIA_DESCRIPTIONS: string
export const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_BITRATE: string
export const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_FRAMERATE: string
export const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MANUAL_KEY_FRAMES: string
export const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_MTU: string
export const PROP_CALL_CONTENT_INTERFACE_VIDEO_CONTROL_VIDEO_RESOLUTION: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_CODECS: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_FURTHER_NEGOTIATION_REQUIRED: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_HAS_REMOTE_INFORMATION: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACES: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DLRR_MAX_SIZE: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_DUPLICATE_RLE_MAX_SIZE: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_ENABLE_METRICS: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_LOSS_RLE_MAX_SIZE: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_PACKET_RECEIPT_TIMES_MAX_SIZE: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_RTT_MODE: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_EXTENDED_REPORTS_STATISTICS_FLAGS: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_DOES_AVPF: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTCP_FEEDBACK_FEEDBACK_MESSAGES: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_INTERFACE_RTP_HEADER_EXTENSIONS_HEADER_EXTENSIONS: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_REMOTE_CONTACT: string
export const PROP_CALL_CONTENT_MEDIA_DESCRIPTION_SSRCS: string
export const PROP_CALL_CONTENT_NAME: string
export const PROP_CALL_CONTENT_STREAMS: string
export const PROP_CALL_CONTENT_TYPE: string
export const PROP_CALL_STREAM_CAN_REQUEST_RECEIVING: string
export const PROP_CALL_STREAM_ENDPOINT_CONTROLLING: string
export const PROP_CALL_STREAM_ENDPOINT_ENDPOINT_STATE: string
export const PROP_CALL_STREAM_ENDPOINT_IS_ICE_LITE: string
export const PROP_CALL_STREAM_ENDPOINT_REMOTE_CANDIDATES: string
export const PROP_CALL_STREAM_ENDPOINT_REMOTE_CREDENTIALS: string
export const PROP_CALL_STREAM_ENDPOINT_SELECTED_CANDIDATE_PAIRS: string
export const PROP_CALL_STREAM_ENDPOINT_TRANSPORT: string
export const PROP_CALL_STREAM_INTERFACES: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_ENDPOINTS: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_HAS_SERVER_INFO: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_ICE_RESTART_PENDING: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CANDIDATES: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_LOCAL_CREDENTIALS: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_RECEIVING_STATE: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_RELAY_INFO: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_SENDING_STATE: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_STUN_SERVERS: string
export const PROP_CALL_STREAM_INTERFACE_MEDIA_TRANSPORT: string
export const PROP_CALL_STREAM_LOCAL_SENDING_STATE: string
export const PROP_CALL_STREAM_REMOTE_MEMBERS: string
export const PROP_CALL_STREAM_REMOTE_MEMBER_IDENTIFIERS: string
export const PROP_CHANNEL_CHANNEL_TYPE: string
export const PROP_CHANNEL_DISPATCHER_INTERFACES: string
export const PROP_CHANNEL_DISPATCHER_INTERFACE_OPERATION_LIST_DISPATCH_OPERATIONS: string
export const PROP_CHANNEL_DISPATCHER_SUPPORTS_REQUEST_HINTS: string
export const PROP_CHANNEL_DISPATCH_OPERATION_ACCOUNT: string
export const PROP_CHANNEL_DISPATCH_OPERATION_CHANNELS: string
export const PROP_CHANNEL_DISPATCH_OPERATION_CONNECTION: string
export const PROP_CHANNEL_DISPATCH_OPERATION_INTERFACES: string
export const PROP_CHANNEL_DISPATCH_OPERATION_POSSIBLE_HANDLERS: string
export const PROP_CHANNEL_INITIATOR_HANDLE: string
export const PROP_CHANNEL_INITIATOR_ID: string
export const PROP_CHANNEL_INTERFACES: string
export const PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY: string
export const PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMITY_MODES: string
export const PROP_CHANNEL_INTERFACE_ANONYMITY_ANONYMOUS_ID: string
export const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAN_RETRY_CAPTCHA: string
export const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR: string
export const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_ERROR_DETAILS: string
export const PROP_CHANNEL_INTERFACE_CAPTCHA_AUTHENTICATION_CAPTCHA_STATUS: string
export const PROP_CHANNEL_INTERFACE_CHAT_STATE_CHAT_STATES: string
export const PROP_CHANNEL_INTERFACE_CONFERENCE_CHANNELS: string
export const PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_CHANNELS: string
export const PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_HANDLES: string
export const PROP_CHANNEL_INTERFACE_CONFERENCE_INITIAL_INVITEE_IDS: string
export const PROP_CHANNEL_INTERFACE_CONFERENCE_INVITATION_MESSAGE: string
export const PROP_CHANNEL_INTERFACE_CONFERENCE_ORIGINAL_CHANNELS: string
export const PROP_CHANNEL_INTERFACE_DTMF_CURRENTLY_SENDING_TONES: string
export const PROP_CHANNEL_INTERFACE_DTMF_DEFERRED_TONES: string
export const PROP_CHANNEL_INTERFACE_DTMF_INITIAL_TONES: string
export const PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_METADATA: string
export const PROP_CHANNEL_INTERFACE_FILE_TRANSFER_METADATA_SERVICE_NAME: string
export const PROP_CHANNEL_INTERFACE_GROUP_GROUP_FLAGS: string
export const PROP_CHANNEL_INTERFACE_GROUP_HANDLE_OWNERS: string
export const PROP_CHANNEL_INTERFACE_GROUP_LOCAL_PENDING_MEMBERS: string
export const PROP_CHANNEL_INTERFACE_GROUP_MEMBERS: string
export const PROP_CHANNEL_INTERFACE_GROUP_MEMBER_IDENTIFIERS: string
export const PROP_CHANNEL_INTERFACE_GROUP_REMOTE_PENDING_MEMBERS: string
export const PROP_CHANNEL_INTERFACE_GROUP_SELF_HANDLE: string
export const PROP_CHANNEL_INTERFACE_MESSAGES_DELIVERY_REPORTING_SUPPORT: string
export const PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_PART_SUPPORT_FLAGS: string
export const PROP_CHANNEL_INTERFACE_MESSAGES_MESSAGE_TYPES: string
export const PROP_CHANNEL_INTERFACE_MESSAGES_PENDING_MESSAGES: string
export const PROP_CHANNEL_INTERFACE_MESSAGES_SUPPORTED_CONTENT_TYPES: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_ANONYMOUS: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CAN_UPDATE_CONFIGURATION: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_CONFIGURATION_RETRIEVED: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_DESCRIPTION: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_INVITEONLY: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_LIMIT: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MODERATED: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_MUTABLE_PROPERTIES: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_HINT: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PASSWORD_PROTECTED: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PERSISTENT: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_PRIVATE: string
export const PROP_CHANNEL_INTERFACE_ROOM_CONFIG_TITLE: string
export const PROP_CHANNEL_INTERFACE_ROOM_CREATION_TIMESTAMP: string
export const PROP_CHANNEL_INTERFACE_ROOM_CREATOR: string
export const PROP_CHANNEL_INTERFACE_ROOM_CREATOR_HANDLE: string
export const PROP_CHANNEL_INTERFACE_ROOM_ROOM_NAME: string
export const PROP_CHANNEL_INTERFACE_ROOM_SERVER: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AUTHORIZATION_IDENTITY: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_AVAILABLE_MECHANISMS: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_CAN_TRY_AGAIN: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_REALM: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_DEFAULT_USERNAME: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_HAS_INITIAL_DATA: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_MAY_SAVE_RESPONSE: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_ERROR_DETAILS: string
export const PROP_CHANNEL_INTERFACE_SASL_AUTHENTICATION_SASL_STATUS: string
export const PROP_CHANNEL_INTERFACE_SECURABLE_ENCRYPTED: string
export const PROP_CHANNEL_INTERFACE_SECURABLE_VERIFIED: string
export const PROP_CHANNEL_INTERFACE_SERVICE_POINT_CURRENT_SERVICE_POINT: string
export const PROP_CHANNEL_INTERFACE_SERVICE_POINT_INITIAL_SERVICE_POINT: string
export const PROP_CHANNEL_INTERFACE_SMS_FLASH: string
export const PROP_CHANNEL_INTERFACE_SMS_SMS_CHANNEL: string
export const PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR: string
export const PROP_CHANNEL_INTERFACE_SUBJECT_ACTOR_HANDLE: string
export const PROP_CHANNEL_INTERFACE_SUBJECT_CAN_SET: string
export const PROP_CHANNEL_INTERFACE_SUBJECT_SUBJECT: string
export const PROP_CHANNEL_INTERFACE_SUBJECT_TIMESTAMP: string
export const PROP_CHANNEL_INTERFACE_TUBE_PARAMETERS: string
export const PROP_CHANNEL_INTERFACE_TUBE_STATE: string
export const PROP_CHANNEL_REQUESTED: string
export const PROP_CHANNEL_REQUEST_ACCOUNT: string
export const PROP_CHANNEL_REQUEST_HINTS: string
export const PROP_CHANNEL_REQUEST_INTERFACES: string
export const PROP_CHANNEL_REQUEST_PREFERRED_HANDLER: string
export const PROP_CHANNEL_REQUEST_REQUESTS: string
export const PROP_CHANNEL_REQUEST_USER_ACTION_TIME: string
export const PROP_CHANNEL_TARGET_HANDLE: string
export const PROP_CHANNEL_TARGET_HANDLE_TYPE: string
export const PROP_CHANNEL_TARGET_ID: string
export const PROP_CHANNEL_TYPE_CALL_CALL_FLAGS: string
export const PROP_CHANNEL_TYPE_CALL_CALL_MEMBERS: string
export const PROP_CHANNEL_TYPE_CALL_CALL_STATE: string
export const PROP_CHANNEL_TYPE_CALL_CALL_STATE_DETAILS: string
export const PROP_CHANNEL_TYPE_CALL_CALL_STATE_REASON: string
export const PROP_CHANNEL_TYPE_CALL_CONTENTS: string
export const PROP_CHANNEL_TYPE_CALL_HARDWARE_STREAMING: string
export const PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO: string
export const PROP_CHANNEL_TYPE_CALL_INITIAL_AUDIO_NAME: string
export const PROP_CHANNEL_TYPE_CALL_INITIAL_TRANSPORT: string
export const PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO: string
export const PROP_CHANNEL_TYPE_CALL_INITIAL_VIDEO_NAME: string
export const PROP_CHANNEL_TYPE_CALL_MEMBER_IDENTIFIERS: string
export const PROP_CHANNEL_TYPE_CALL_MUTABLE_CONTENTS: string
export const PROP_CHANNEL_TYPE_CONTACT_SEARCH_AVAILABLE_SEARCH_KEYS: string
export const PROP_CHANNEL_TYPE_CONTACT_SEARCH_LIMIT: string
export const PROP_CHANNEL_TYPE_CONTACT_SEARCH_SEARCH_STATE: string
export const PROP_CHANNEL_TYPE_CONTACT_SEARCH_SERVER: string
export const PROP_CHANNEL_TYPE_DBUS_TUBE_DBUS_NAMES: string
export const PROP_CHANNEL_TYPE_DBUS_TUBE_SERVICE_NAME: string
export const PROP_CHANNEL_TYPE_DBUS_TUBE_SUPPORTED_ACCESS_CONTROLS: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_AVAILABLE_SOCKET_TYPES: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_HASH_TYPE: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_CONTENT_TYPE: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_DATE: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_DESCRIPTION: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_FILENAME: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_FILE_COLLECTION: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_INITIAL_OFFSET: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_SIZE: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_STATE: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_TRANSFERRED_BYTES: string
export const PROP_CHANNEL_TYPE_FILE_TRANSFER_URI: string
export const PROP_CHANNEL_TYPE_ROOM_LIST_SERVER: string
export const PROP_CHANNEL_TYPE_SERVER_AUTHENTICATION_AUTHENTICATION_METHOD: string
export const PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_HOSTNAME: string
export const PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_REFERENCE_IDENTITIES: string
export const PROP_CHANNEL_TYPE_SERVER_TLS_CONNECTION_SERVER_CERTIFICATE: string
export const PROP_CHANNEL_TYPE_STREAMED_MEDIA_IMMUTABLE_STREAMS: string
export const PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_AUDIO: string
export const PROP_CHANNEL_TYPE_STREAMED_MEDIA_INITIAL_VIDEO: string
export const PROP_CHANNEL_TYPE_STREAM_TUBE_SERVICE: string
export const PROP_CHANNEL_TYPE_STREAM_TUBE_SUPPORTED_SOCKET_TYPES: string
export const PROP_CLIENT_APPROVER_APPROVER_CHANNEL_FILTER: string
export const PROP_CLIENT_HANDLER_BYPASS_APPROVAL: string
export const PROP_CLIENT_HANDLER_CAPABILITIES: string
export const PROP_CLIENT_HANDLER_HANDLED_CHANNELS: string
export const PROP_CLIENT_HANDLER_HANDLER_CHANNEL_FILTER: string
export const PROP_CLIENT_INTERFACES: string
export const PROP_CLIENT_OBSERVER_DELAY_APPROVERS: string
export const PROP_CLIENT_OBSERVER_OBSERVER_CHANNEL_FILTER: string
export const PROP_CLIENT_OBSERVER_RECOVER: string
export const PROP_CONNECTION_HAS_IMMORTAL_HANDLES: string
export const PROP_CONNECTION_INTERFACES: string
export const PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MANDATORY: string
export const PROP_CONNECTION_INTERFACE_ANONYMITY_ANONYMITY_MODES: string
export const PROP_CONNECTION_INTERFACE_ANONYMITY_SUPPORTED_ANONYMITY_MODES: string
export const PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES: string
export const PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT: string
export const PROP_CONNECTION_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH: string
export const PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT: string
export const PROP_CONNECTION_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH: string
export const PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT: string
export const PROP_CONNECTION_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH: string
export const PROP_CONNECTION_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES: string
export const PROP_CONNECTION_INTERFACE_BALANCE_ACCOUNT_BALANCE: string
export const PROP_CONNECTION_INTERFACE_BALANCE_MANAGE_CREDIT_URI: string
export const PROP_CONNECTION_INTERFACE_CELLULAR_IMSI: string
export const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_NATIONAL_CHARACTER_SET: string
export const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_REDUCED_CHARACTER_SET: string
export const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_SERVICE_CENTRE: string
export const PROP_CONNECTION_INTERFACE_CELLULAR_MESSAGE_VALIDITY_PERIOD: string
export const PROP_CONNECTION_INTERFACE_CELLULAR_OVERRIDE_MESSAGE_SERVICE_CENTRE: string
export const PROP_CONNECTION_INTERFACE_CONTACTS_CONTACT_ATTRIBUTE_INTERFACES: string
export const PROP_CONNECTION_INTERFACE_CONTACT_BLOCKING_CONTACT_BLOCKING_CAPABILITIES: string
export const PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_DISJOINT_GROUPS: string
export const PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS: string
export const PROP_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUP_STORAGE: string
export const PROP_CONNECTION_INTERFACE_CONTACT_INFO_CONTACT_INFO_FLAGS: string
export const PROP_CONNECTION_INTERFACE_CONTACT_INFO_SUPPORTED_FIELDS: string
export const PROP_CONNECTION_INTERFACE_CONTACT_LIST_CAN_CHANGE_CONTACT_LIST: string
export const PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_PERSISTS: string
export const PROP_CONNECTION_INTERFACE_CONTACT_LIST_CONTACT_LIST_STATE: string
export const PROP_CONNECTION_INTERFACE_CONTACT_LIST_DOWNLOAD_AT_CONNECTION: string
export const PROP_CONNECTION_INTERFACE_CONTACT_LIST_REQUEST_USES_MESSAGE: string
export const PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL: string
export const PROP_CONNECTION_INTERFACE_LOCATION_LOCATION_ACCESS_CONTROL_TYPES: string
export const PROP_CONNECTION_INTERFACE_LOCATION_SUPPORTED_LOCATION_FEATURES: string
export const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_ADDRESS: string
export const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_MAIL_NOTIFICATION_FLAGS: string
export const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAILS: string
export const PROP_CONNECTION_INTERFACE_MAIL_NOTIFICATION_UNREAD_MAIL_COUNT: string
export const PROP_CONNECTION_INTERFACE_POWER_SAVING_POWER_SAVING_ACTIVE: string
export const PROP_CONNECTION_INTERFACE_REQUESTS_CHANNELS: string
export const PROP_CONNECTION_INTERFACE_REQUESTS_REQUESTABLE_CHANNEL_CLASSES: string
export const PROP_CONNECTION_INTERFACE_SERVICE_POINT_KNOWN_SERVICE_POINTS: string
export const PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_MAXIMUM_STATUS_MESSAGE_LENGTH: string
export const PROP_CONNECTION_INTERFACE_SIMPLE_PRESENCE_STATUSES: string
export const PROP_CONNECTION_MANAGER_INTERFACES: string
export const PROP_CONNECTION_MANAGER_PROTOCOLS: string
export const PROP_CONNECTION_SELF_HANDLE: string
export const PROP_CONNECTION_SELF_ID: string
export const PROP_CONNECTION_STATUS: string
export const PROP_DEBUG_ENABLED: string
export const PROP_MEDIA_STREAM_HANDLER_CREATED_LOCALLY: string
export const PROP_MEDIA_STREAM_HANDLER_NAT_TRAVERSAL: string
export const PROP_MEDIA_STREAM_HANDLER_RELAY_INFO: string
export const PROP_MEDIA_STREAM_HANDLER_STUN_SERVERS: string
export const PROP_PROTOCOL_AUTHENTICATION_TYPES: string
export const PROP_PROTOCOL_CONNECTION_INTERFACES: string
export const PROP_PROTOCOL_ENGLISH_NAME: string
export const PROP_PROTOCOL_ICON: string
export const PROP_PROTOCOL_INTERFACES: string
export const PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_URI_SCHEMES: string
export const PROP_PROTOCOL_INTERFACE_ADDRESSING_ADDRESSABLE_VCARD_FIELDS: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_BYTES: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_HEIGHT: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_MAXIMUM_AVATAR_WIDTH: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_HEIGHT: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_MINIMUM_AVATAR_WIDTH: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_HEIGHT: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_RECOMMENDED_AVATAR_WIDTH: string
export const PROP_PROTOCOL_INTERFACE_AVATARS_SUPPORTED_AVATAR_MIME_TYPES: string
export const PROP_PROTOCOL_INTERFACE_PRESENCE_STATUSES: string
export const PROP_PROTOCOL_PARAMETERS: string
export const PROP_PROTOCOL_REQUESTABLE_CHANNEL_CLASSES: string
export const PROP_PROTOCOL_VCARD_FIELD: string
export const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_GTALK_P2P: string
export const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_ICE_UDP: string
export const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_2009: string
export const TOKEN_CHANNEL_INTERFACE_MEDIA_SIGNALLING_WLM_8_5: string
export const TOKEN_CHANNEL_TYPE_CALL_AUDIO: string
export const TOKEN_CHANNEL_TYPE_CALL_GTALK_P2P: string
export const TOKEN_CHANNEL_TYPE_CALL_ICE: string
export const TOKEN_CHANNEL_TYPE_CALL_SHM: string
export const TOKEN_CHANNEL_TYPE_CALL_VIDEO: string
export const TOKEN_CHANNEL_TYPE_CALL_WLM_2009: string
export const TOKEN_CONNECTION_CONTACT_ID: string
export const TOKEN_CONNECTION_INTERFACE_ADDRESSING_ADDRESSES: string
export const TOKEN_CONNECTION_INTERFACE_ADDRESSING_URIS: string
export const TOKEN_CONNECTION_INTERFACE_ALIASING_ALIAS: string
export const TOKEN_CONNECTION_INTERFACE_AVATARS_TOKEN: string
export const TOKEN_CONNECTION_INTERFACE_CAPABILITIES_CAPS: string
export const TOKEN_CONNECTION_INTERFACE_CLIENT_TYPES_CLIENT_TYPES: string
export const TOKEN_CONNECTION_INTERFACE_CONTACT_BLOCKING_BLOCKED: string
export const TOKEN_CONNECTION_INTERFACE_CONTACT_CAPABILITIES_CAPABILITIES: string
export const TOKEN_CONNECTION_INTERFACE_CONTACT_GROUPS_GROUPS: string
export const TOKEN_CONNECTION_INTERFACE_CONTACT_INFO_INFO: string
export const TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH: string
export const TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_PUBLISH_REQUEST: string
export const TOKEN_CONNECTION_INTERFACE_CONTACT_LIST_SUBSCRIBE: string
export const TOKEN_CONNECTION_INTERFACE_LOCATION_LOCATION: string
export const TOKEN_CONNECTION_INTERFACE_SIMPLE_PRESENCE_PRESENCE: string
export const UNKNOWN_CONNECTION_STATUS: ConnectionStatus
export const UNKNOWN_HANDLE_TYPE: HandleType
export const USER_ACTION_TIME_NOT_USER_ACTION: number
export function asvGetBoolean(asv: GLib.HashTable, key: string): { returnType: boolean, valid: boolean }
export function asvGetBoxed(asv: GLib.HashTable, key: string, type: GObject.Type): object | null
export function asvGetBytes(asv: GLib.HashTable, key: string): any[] | null
export function asvGetDouble(asv: GLib.HashTable, key: string): { returnType: number, valid: boolean }
export function asvGetInt32(asv: GLib.HashTable, key: string): { returnType: number, valid: boolean }
export function asvGetInt64(asv: GLib.HashTable, key: string): { returnType: number, valid: boolean }
export function asvGetObjectPath(asv: GLib.HashTable, key: string): string | null
export function asvGetString(asv: GLib.HashTable, key: string): string | null
export function asvGetStrv(asv: GLib.HashTable, key: string): string[] | null
export function asvGetUint32(asv: GLib.HashTable, key: string): { returnType: number, valid: boolean }
export function asvGetUint64(asv: GLib.HashTable, key: string): { returnType: number, valid: boolean }
export function dbusCheckValidBusName(name: string, allowTypes: DBusNameType): boolean
export function dbusCheckValidInterfaceName(name: string): boolean
export function dbusCheckValidMemberName(name: string): boolean
export function dbusCheckValidObjectPath(path: string): boolean
export function dbusErrorsQuark(): GLib.Quark
export function dbusPropertiesMixinClassInit(cls: GObject.ObjectClass, offset: number): void
export function dbusPropertiesMixinDupAll(self: GObject.Object, interfaceName: string): GLib.HashTable
export function dbusPropertiesMixinEmitPropertiesChanged(object: GObject.Object, interfaceName: string, properties?: string | null): void
export function dbusPropertiesMixinGet(self: GObject.Object, interfaceName: string, propertyName: string, value: any): boolean
export function dbusPropertiesMixinGetterGobjectProperties(object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, getterData?: object | null): void
export function dbusPropertiesMixinIfaceInit(gIface?: object | null, ifaceData?: object | null): void
export function dbusPropertiesMixinSet(self: GObject.Object, interfaceName: string, propertyName: string, value: any): boolean
export function dbusPropertiesMixinSetterGobjectProperties(object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, setterData?: object | null): boolean
export function debugDivertMessages(filename: string): void
export function debugSetFlags(flagsString: string): void
export function debugSetPersistent(persistent: boolean): void
export function debugTimestampedLogHandler(logDomain: string, logLevel: GLib.LogLevelFlags, message: string, ignored?: object | null): void
export function errorGetDbusName(error: Error): string
export function errorQuark(): GLib.Quark
export function errorsDisconnectedQuark(): GLib.Quark
export function errorsRemovedFromGroupQuark(): GLib.Quark
export function escapeAsIdentifier(name: string): string
export function handleEnsure(self: HandleRepoIface, id: string, context?: object | null): Handle
export function handleTypeIsValid(type: HandleType): boolean
export function handleTypeToString(type: HandleType): string
export function ifaceQuarkAccount(): GLib.Quark
export function ifaceQuarkAccountInterfaceAddressing(): GLib.Quark
export function ifaceQuarkAccountInterfaceAvatar(): GLib.Quark
export function ifaceQuarkAccountInterfaceStorage(): GLib.Quark
export function ifaceQuarkAccountManager(): GLib.Quark
export function ifaceQuarkAuthenticationTlsCertificate(): GLib.Quark
export function ifaceQuarkCallContent(): GLib.Quark
export function ifaceQuarkCallContentInterfaceAudioControl(): GLib.Quark
export function ifaceQuarkCallContentInterfaceDtmf(): GLib.Quark
export function ifaceQuarkCallContentInterfaceMedia(): GLib.Quark
export function ifaceQuarkCallContentInterfaceVideoControl(): GLib.Quark
export function ifaceQuarkCallContentMediaDescription(): GLib.Quark
export function ifaceQuarkCallContentMediaDescriptionInterfaceRtcpExtendedReports(): GLib.Quark
export function ifaceQuarkCallContentMediaDescriptionInterfaceRtcpFeedback(): GLib.Quark
export function ifaceQuarkCallContentMediaDescriptionInterfaceRtpHeaderExtensions(): GLib.Quark
export function ifaceQuarkCallStream(): GLib.Quark
export function ifaceQuarkCallStreamEndpoint(): GLib.Quark
export function ifaceQuarkCallStreamInterfaceMedia(): GLib.Quark
export function ifaceQuarkChannel(): GLib.Quark
export function ifaceQuarkChannelDispatchOperation(): GLib.Quark
export function ifaceQuarkChannelDispatcher(): GLib.Quark
export function ifaceQuarkChannelDispatcherInterfaceMessages1(): GLib.Quark
export function ifaceQuarkChannelDispatcherInterfaceOperationList(): GLib.Quark
export function ifaceQuarkChannelInterfaceAnonymity(): GLib.Quark
export function ifaceQuarkChannelInterfaceCallState(): GLib.Quark
export function ifaceQuarkChannelInterfaceCaptchaAuthentication(): GLib.Quark
export function ifaceQuarkChannelInterfaceChatState(): GLib.Quark
export function ifaceQuarkChannelInterfaceConference(): GLib.Quark
export function ifaceQuarkChannelInterfaceDestroyable(): GLib.Quark
export function ifaceQuarkChannelInterfaceDtmf(): GLib.Quark
export function ifaceQuarkChannelInterfaceFileTransferMetadata(): GLib.Quark
export function ifaceQuarkChannelInterfaceGroup(): GLib.Quark
export function ifaceQuarkChannelInterfaceHold(): GLib.Quark
export function ifaceQuarkChannelInterfaceMediaSignalling(): GLib.Quark
export function ifaceQuarkChannelInterfaceMessages(): GLib.Quark
export function ifaceQuarkChannelInterfacePassword(): GLib.Quark
export function ifaceQuarkChannelInterfaceRoom(): GLib.Quark
export function ifaceQuarkChannelInterfaceRoomConfig(): GLib.Quark
export function ifaceQuarkChannelInterfaceSaslAuthentication(): GLib.Quark
export function ifaceQuarkChannelInterfaceSecurable(): GLib.Quark
export function ifaceQuarkChannelInterfaceServicePoint(): GLib.Quark
export function ifaceQuarkChannelInterfaceSms(): GLib.Quark
export function ifaceQuarkChannelInterfaceSubject(): GLib.Quark
export function ifaceQuarkChannelInterfaceTube(): GLib.Quark
export function ifaceQuarkChannelRequest(): GLib.Quark
export function ifaceQuarkChannelTypeCall(): GLib.Quark
export function ifaceQuarkChannelTypeContactList(): GLib.Quark
export function ifaceQuarkChannelTypeContactSearch(): GLib.Quark
export function ifaceQuarkChannelTypeDbusTube(): GLib.Quark
export function ifaceQuarkChannelTypeFileTransfer(): GLib.Quark
export function ifaceQuarkChannelTypeRoomList(): GLib.Quark
export function ifaceQuarkChannelTypeServerAuthentication(): GLib.Quark
export function ifaceQuarkChannelTypeServerTlsConnection(): GLib.Quark
export function ifaceQuarkChannelTypeStreamTube(): GLib.Quark
export function ifaceQuarkChannelTypeStreamedMedia(): GLib.Quark
export function ifaceQuarkChannelTypeText(): GLib.Quark
export function ifaceQuarkChannelTypeTubes(): GLib.Quark
export function ifaceQuarkClient(): GLib.Quark
export function ifaceQuarkClientApprover(): GLib.Quark
export function ifaceQuarkClientHandler(): GLib.Quark
export function ifaceQuarkClientInterfaceRequests(): GLib.Quark
export function ifaceQuarkClientObserver(): GLib.Quark
export function ifaceQuarkConnection(): GLib.Quark
export function ifaceQuarkConnectionInterfaceAddressing(): GLib.Quark
export function ifaceQuarkConnectionInterfaceAliasing(): GLib.Quark
export function ifaceQuarkConnectionInterfaceAnonymity(): GLib.Quark
export function ifaceQuarkConnectionInterfaceAvatars(): GLib.Quark
export function ifaceQuarkConnectionInterfaceBalance(): GLib.Quark
export function ifaceQuarkConnectionInterfaceCapabilities(): GLib.Quark
export function ifaceQuarkConnectionInterfaceCellular(): GLib.Quark
export function ifaceQuarkConnectionInterfaceClientTypes(): GLib.Quark
export function ifaceQuarkConnectionInterfaceContactBlocking(): GLib.Quark
export function ifaceQuarkConnectionInterfaceContactCapabilities(): GLib.Quark
export function ifaceQuarkConnectionInterfaceContactGroups(): GLib.Quark
export function ifaceQuarkConnectionInterfaceContactInfo(): GLib.Quark
export function ifaceQuarkConnectionInterfaceContactList(): GLib.Quark
export function ifaceQuarkConnectionInterfaceContacts(): GLib.Quark
export function ifaceQuarkConnectionInterfaceLocation(): GLib.Quark
export function ifaceQuarkConnectionInterfaceMailNotification(): GLib.Quark
export function ifaceQuarkConnectionInterfacePowerSaving(): GLib.Quark
export function ifaceQuarkConnectionInterfacePresence(): GLib.Quark
export function ifaceQuarkConnectionInterfaceRenaming(): GLib.Quark
export function ifaceQuarkConnectionInterfaceRequests(): GLib.Quark
export function ifaceQuarkConnectionInterfaceServicePoint(): GLib.Quark
export function ifaceQuarkConnectionInterfaceSidecars1(): GLib.Quark
export function ifaceQuarkConnectionInterfaceSimplePresence(): GLib.Quark
export function ifaceQuarkConnectionManager(): GLib.Quark
export function ifaceQuarkDbusDaemon(): GLib.Quark
export function ifaceQuarkDbusIntrospectable(): GLib.Quark
export function ifaceQuarkDbusPeer(): GLib.Quark
export function ifaceQuarkDbusProperties(): GLib.Quark
export function ifaceQuarkDebug(): GLib.Quark
export function ifaceQuarkMediaSessionHandler(): GLib.Quark
export function ifaceQuarkMediaStreamHandler(): GLib.Quark
export function ifaceQuarkPropertiesInterface(): GLib.Quark
export function ifaceQuarkProtocol(): GLib.Quark
export function ifaceQuarkProtocolInterfaceAddressing(): GLib.Quark
export function ifaceQuarkProtocolInterfaceAvatars(): GLib.Quark
export function ifaceQuarkProtocolInterfacePresence(): GLib.Quark
export function intsetFromArray(array: number[]): Intset
export function listConnectionManagers(busDaemon: DBusDaemon, callback: ConnectionManagerListCb, weakObject?: GObject.Object | null): void
export function listConnectionManagersAsync(dbusDaemon?: DBusDaemon | null, callback?: Gio.AsyncReadyCallback | null): void
export function listConnectionManagersFinish(result: Gio.AsyncResult): ConnectionManager[]
export function listConnectionNames(busDaemon: DBusDaemon, callback: ConnectionNameListCb, weakObject?: GObject.Object | null): void
export function simpleAsyncReportSuccessInIdle(source?: GObject.Object | null, callback?: Gio.AsyncReadyCallback | null, sourceTag?: object | null): void
export function svcInterfaceSetDbusPropertiesInfo(gInterface: GObject.Type, info: DBusPropertiesMixinIfaceInfo): void
export function userActionTimeFromX11(x11Time: number): number
export function userActionTimeShouldPresent(userActionTime: number): { returnType: boolean, x11Time: number | null }
export function utf8MakeValid(name: string): string
export function valueArrayFree(va: GObject.ValueArray): void
export interface AccountChannelRequestDelegatedChannelCb {
    (request: AccountChannelRequest, channel: Channel): void
}
export interface BaseClientClassAddDispatchOperationImpl {
    (client: BaseClient, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation, context: AddDispatchOperationContext): void
}
export interface BaseClientClassHandleChannelsImpl {
    (client: BaseClient, account: Account, connection: Connection, channels: Channel[], requestsSatisfied: ChannelRequest[], userActionTime: number, context: HandleChannelsContext): void
}
export interface BaseClientClassObserveChannelsImpl {
    (client: BaseClient, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation | null, requests: ChannelRequest[], context: ObserveChannelsContext): void
}
export interface BaseClientDelegatedChannelsCb {
    (client: BaseClient, channels: Channel[]): void
}
export interface BaseConnectionGetUniqueConnectionNameImpl {
    (self: BaseConnection): string
}
export interface BaseConnectionProc {
    (self: BaseConnection): void
}
export interface BaseConnectionStartConnectingImpl {
    (self: BaseConnection): boolean
}
export interface ChannelWhenReadyCb {
    (channel: Channel, error: GLib.Error): void
}
export interface ConnectionContactsByHandleCb {
    (connection: Connection, contacts: Contact[], failed: Handle[], error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionContactsByIdCb {
    (connection: Connection, contacts: Contact[], requestedIds: string[], failedIdErrors: GLib.HashTable, error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionHoldHandlesCb {
    (connection: Connection, handleType: HandleType, nHandles: number, handles: Handle, error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionManagerListCb {
    (cms: ConnectionManager[], nCms: number, error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionManagerWhenReadyCb {
    (cm: ConnectionManager, error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionNameListCb {
    (names: string[], n: number, cms: string[], protocols: string[], error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionRequestHandlesCb {
    (connection: Connection, handleType: HandleType, handles: number[], ids: string[], error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionUpgradeContactsCb {
    (connection: Connection, contacts: Contact[], error: GLib.Error, weakObject: GObject.Object): void
}
export interface ConnectionWhenReadyCb {
    (connection: Connection, error: GLib.Error): void
}
export interface DBusDaemonListNamesCb {
    (busDaemon: DBusDaemon, names: string, error: GLib.Error, weakObject: GObject.Object): void
}
export interface DBusDaemonNameOwnerChangedCb {
    (busDaemon: DBusDaemon, name: string, newOwner: string): void
}
export interface DBusPropertiesMixinGetter {
    (object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, getterData?: object | null): void
}
export interface DBusPropertiesMixinSetter {
    (object: GObject.Object, iface: GLib.Quark, name: GLib.Quark, value: any, setterData?: object | null): boolean
}
export interface GroupMixinAddMemberFunc {
    (obj: GObject.Object, handle: Handle, message: string): boolean
}
export interface GroupMixinRemMemberFunc {
    (obj: GObject.Object, handle: Handle, message: string): boolean
}
export interface GroupMixinRemMemberWithReasonFunc {
    (obj: GObject.Object, handle: Handle, message: string, reason: number): boolean
}
export interface IntFunc {
    (i: number, userdata?: object | null): void
}
export interface PresenceMixinGetMaximumStatusMessageLengthFunc {
    (obj: GObject.Object): number
}
export interface PresenceMixinSetOwnStatusFunc {
    (obj: GObject.Object, status: PresenceStatus): boolean
}
export interface PresenceMixinStatusAvailableFunc {
    (obj: GObject.Object, which: number): boolean
}
export interface ProxyPrepareAsync {
    (proxy: Proxy, feature: ProxyFeature, callback?: Gio.AsyncReadyCallback | null): void
}
export interface SimpleApproverAddDispatchOperationImpl {
    (approver: SimpleApprover, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation | null, context: AddDispatchOperationContext): void
}
export interface SimpleHandlerHandleChannelsImpl {
    (handler: SimpleHandler, account: Account, connection: Connection, channels: Channel[], requestsSatisfied: ChannelRequest[], userActionTime: number, context: HandleChannelsContext): void
}
export interface SimpleObserverObserveChannelsImpl {
    (observer: SimpleObserver, account: Account, connection: Connection, channels: Channel[], dispatchOperation: ChannelDispatchOperation | null, requests: ChannelRequest[], context: ObserveChannelsContext): void
}
export class ClientChannelFactory {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactory */
    createChannel(conn: Connection, path: string, properties: GLib.HashTable): Channel
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    static name: string
}
export class HandleRepoIface {
    static name: string
}
export interface Account_ConstructProps extends Proxy_ConstructProps {
}
export class Account {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Account */
    readonly automaticPresenceType: number
    readonly automaticStatus: string
    readonly automaticStatusMessage: string
    readonly changingPresence: boolean
    readonly cmName: string
    readonly connectAutomatically: boolean
    readonly connection: Connection
    readonly connectionError: string
    readonly connectionErrorDetails: GLib.HashTable
    readonly connectionManager: string
    readonly connectionStatus: number
    readonly connectionStatusReason: number
    readonly currentPresenceType: number
    readonly currentStatus: string
    readonly currentStatusMessage: string
    readonly displayName: string
    readonly enabled: boolean
    readonly hasBeenOnline: boolean
    readonly iconName: string
    readonly nickname: string
    readonly normalizedName: string
    readonly protocol: string
    readonly protocolName: string
    readonly requestedPresenceType: number
    readonly requestedStatus: string
    readonly requestedStatusMessage: string
    readonly service: string
    readonly storageIdentifier: any
    readonly storageIdentifierVariant: GLib.Variant
    readonly storageProvider: string
    readonly storageRestrictions: number
    readonly supersedes: string[]
    readonly uriSchemes: string[]
    readonly valid: boolean
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Account */
    associatedWithUriScheme(scheme: string): boolean
    bindConnectionStatusToProperty(target: object | null, targetProperty: string, invert: boolean): GObject.Binding
    dupDetailedErrorVardict(): { returnType: string | null, details: GLib.Variant | null }
    dupParametersVardict(): GLib.Variant
    dupStorageIdentifierVariant(): GLib.Variant
    dupStorageSpecificInformationVardictAsync(callback?: Gio.AsyncReadyCallback | null): void
    dupStorageSpecificInformationVardictFinish(result: Gio.AsyncResult): GLib.Variant
    ensureConnection(path: string): Connection
    getAutomaticPresence(): { returnType: ConnectionPresenceType, status: string, statusMessage: string }
    getAvatarAsync(callback?: Gio.AsyncReadyCallback | null): void
    getAvatarFinish(result: Gio.AsyncResult): any[]
    getChangingPresence(): boolean
    getCmName(): string
    getConnectAutomatically(): boolean
    getConnection(): Connection
    getConnectionManager(): string
    getConnectionStatus(): { returnType: ConnectionStatus, reason: ConnectionStatusReason }
    getCurrentPresence(): { returnType: ConnectionPresenceType, status: string, statusMessage: string }
    getDisplayName(): string
    getHasBeenOnline(): boolean
    getIconName(): string
    getNickname(): string
    getNormalizedName(): string
    getParameters(): GLib.HashTable
    getPathSuffix(): string
    getProtocol(): string
    getProtocolName(): string
    getRequestedPresence(): { returnType: ConnectionPresenceType, status: string, statusMessage: string }
    getService(): string
    getStorageIdentifier(): any
    getStorageProvider(): string
    getStorageRestrictions(): StorageRestrictionFlags
    getStorageSpecificInformationAsync(callback?: Gio.AsyncReadyCallback | null): void
    getStorageSpecificInformationFinish(result: Gio.AsyncResult): GLib.HashTable
    getSupersedes(): string[]
    getUriSchemes(): string[]
    isEnabled(): boolean
    isValid(): boolean
    reconnectAsync(callback?: Gio.AsyncReadyCallback | null): void
    reconnectFinish(result: Gio.AsyncResult): boolean
    removeAsync(callback?: Gio.AsyncReadyCallback | null): void
    removeFinish(result: Gio.AsyncResult): boolean
    requestPresenceAsync(type: ConnectionPresenceType, status: string, message: string, callback?: Gio.AsyncReadyCallback | null): void
    requestPresenceFinish(result: Gio.AsyncResult): boolean
    setAutomaticPresenceAsync(type: ConnectionPresenceType, status: string, message: string, callback?: Gio.AsyncReadyCallback | null): void
    setAutomaticPresenceFinish(result: Gio.AsyncResult): boolean
    setAvatarAsync(avatar: any[] | null, mimeType?: string | null, callback?: Gio.AsyncReadyCallback | null): void
    setAvatarFinish(result: Gio.AsyncResult): boolean
    setConnectAutomaticallyAsync(connectAutomatically: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setConnectAutomaticallyFinish(result: Gio.AsyncResult): boolean
    setDisplayNameAsync(displayName: string, callback?: Gio.AsyncReadyCallback | null): void
    setDisplayNameFinish(result: Gio.AsyncResult): boolean
    setEnabledAsync(enabled: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setEnabledFinish(result: Gio.AsyncResult): boolean
    setIconNameAsync(iconName: string, callback?: Gio.AsyncReadyCallback | null): void
    setIconNameFinish(result: Gio.AsyncResult): boolean
    setNicknameAsync(nickname: string, callback?: Gio.AsyncReadyCallback | null): void
    setNicknameFinish(result: Gio.AsyncResult): boolean
    setServiceAsync(service: string, callback?: Gio.AsyncReadyCallback | null): void
    setServiceFinish(result: Gio.AsyncResult): boolean
    setUriSchemeAssociationAsync(scheme: string, associate: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setUriSchemeAssociationFinish(result: Gio.AsyncResult): boolean
    updateParametersAsync(parameters: GLib.HashTable, unsetParameters: string, callback?: Gio.AsyncReadyCallback | null): void
    updateParametersFinish(result: Gio.AsyncResult): { returnType: boolean, reconnectRequired: string[] }
    updateParametersVardictAsync(parameters: GLib.Variant, unsetParameters: string[], callback?: Gio.AsyncReadyCallback | null): void
    updateParametersVardictFinish(result: Gio.AsyncResult): { returnType: boolean, reconnectRequired: string[] }
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Account */
    connect(sigName: "avatar-changed", callback: (($obj: Account) => void)): number
    on(sigName: "avatar-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "avatar-changed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "avatar-changed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "avatar-changed"): void
    connect(sigName: "presence-changed", callback: (($obj: Account, presence: number, status: string, statusMessage: string) => void)): number
    on(sigName: "presence-changed", callback: (presence: number, status: string, statusMessage: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "presence-changed", callback: (presence: number, status: string, statusMessage: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "presence-changed", callback: (presence: number, status: string, statusMessage: string) => void): NodeJS.EventEmitter
    emit(sigName: "presence-changed", presence: number, status: string, statusMessage: string): void
    connect(sigName: "status-changed", callback: (($obj: Account, oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void)): number
    on(sigName: "status-changed", callback: (oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "status-changed", callback: (oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "status-changed", callback: (oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "status-changed", oldStatus: number, newStatus: number, reason: number, dbusErrorName: string | null, details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: Account, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: Account, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::automatic-presence-type", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-presence-type", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status-message", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status-message", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::changing-presence", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::changing-presence", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::changing-presence", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::changing-presence", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::changing-presence", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cm-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cm-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connect-automatically", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connect-automatically", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-error", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-error", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-error", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-error-details", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-error-details", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-error-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-error-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-error-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-manager", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-manager", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-status-reason", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-status-reason", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::current-presence-type", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-presence-type", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::current-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::current-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::current-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::current-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::current-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::current-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::current-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::current-status-message", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::current-status-message", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::current-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::current-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::current-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::display-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::display-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::display-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::display-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::display-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::has-been-online", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-been-online", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-been-online", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-been-online", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-been-online", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::nickname", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nickname", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::normalized-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::normalized-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::normalized-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::normalized-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::normalized-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-name", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-presence-type", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-presence-type", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status-message", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status-message", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-identifier", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-identifier", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-identifier-variant", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-identifier-variant", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-identifier-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-identifier-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-identifier-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-provider", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-provider", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-restrictions", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-restrictions", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-restrictions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-restrictions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-restrictions", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::supersedes", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supersedes", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::uri-schemes", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::uri-schemes", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::valid", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::valid", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::valid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::valid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::valid", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: Account, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Account_ConstructProps)
    _init (config?: Account_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon, objectPath: string): Account
    static getFeatureQuarkAddressing(): GLib.Quark
    static getFeatureQuarkConnection(): GLib.Quark
    static getFeatureQuarkCore(): GLib.Quark
    static getFeatureQuarkStorage(): GLib.Quark
    static initKnownInterfaces(): void
    static parseObjectPath(objectPath: string): { returnType: boolean, cm: string, protocol: string, accountId: string }
    static $gtype: GObject.Type
}
export interface AccountChannelRequest_ConstructProps extends GObject.Object_ConstructProps {
    account?: Account
    requestVardict?: GLib.Variant
    userActionTime?: number
}
export class AccountChannelRequest {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.AccountChannelRequest */
    readonly channelRequest: ChannelRequest
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AccountChannelRequest */
    createAndHandleChannelAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    createAndHandleChannelFinish(result: Gio.AsyncResult): { returnType: Channel | null, context: HandleChannelsContext | null }
    createAndObserveChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    createAndObserveChannelFinish(result: Gio.AsyncResult): Channel
    createChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    createChannelFinish(result: Gio.AsyncResult): boolean
    dupRequest(): GLib.Variant
    ensureAndHandleChannelAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    ensureAndHandleChannelFinish(result: Gio.AsyncResult): { returnType: Channel | null, context: HandleChannelsContext | null }
    ensureAndObserveChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    ensureAndObserveChannelFinish(result: Gio.AsyncResult): Channel
    ensureChannelAsync(preferredHandler: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    ensureChannelFinish(result: Gio.AsyncResult): boolean
    getAccount(): Account
    getChannelRequest(): ChannelRequest
    getRequest(): GLib.HashTable
    getUserActionTime(): number
    setChannelFactory(factory: ClientChannelFactory): void
    setConferenceInitialChannels(channels: string): void
    setDelegateToPreferredHandler(delegate: boolean): void
    setDelegatedChannelCallback(callback: AccountChannelRequestDelegatedChannelCb): void
    setFileTransferDescription(description: string): void
    setFileTransferHash(hashType: FileHashType, hash: string): void
    setFileTransferInitialOffset(offset: number): void
    setFileTransferTimestamp(timestamp: number): void
    setFileTransferUri(uri: string): void
    setHint(key: string, value: GLib.Variant): void
    setHints(hints: GLib.HashTable): void
    setInitialInviteeIds(ids: string): void
    setInitialInvitees(contacts: Contact[]): void
    setRequestProperty(name: string, value: GLib.Variant): void
    setSmsChannel(isSmsChannel: boolean): void
    setTargetContact(contact: Contact): void
    setTargetId(handleType: HandleType, identifier: string): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.AccountChannelRequest */
    connect(sigName: "re-handled", callback: (($obj: AccountChannelRequest, channel: Channel, userActionTime: number, context: HandleChannelsContext) => void)): number
    on(sigName: "re-handled", callback: (channel: Channel, userActionTime: number, context: HandleChannelsContext) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "re-handled", callback: (channel: Channel, userActionTime: number, context: HandleChannelsContext) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "re-handled", callback: (channel: Channel, userActionTime: number, context: HandleChannelsContext) => void): NodeJS.EventEmitter
    emit(sigName: "re-handled", channel: Channel, userActionTime: number, context: HandleChannelsContext): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: AccountChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel-request", callback: (($obj: AccountChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-request", callback: (($obj: AccountChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AccountChannelRequest_ConstructProps)
    _init (config?: AccountChannelRequest_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(account: Account, request: GLib.HashTable, userActionTime: number): AccountChannelRequest
    static newAudioCall(account: Account, userActionTime: number): AccountChannelRequest
    static newAudioVideoCall(account: Account, userActionTime: number): AccountChannelRequest
    static newDbusTube(account: Account, serviceName: string, userActionTime: number): AccountChannelRequest
    static newFileTransfer(account: Account, filename: string, mimeType: string | null, size: number, userActionTime: number): AccountChannelRequest
    static newStreamTube(account: Account, service: string, userActionTime: number): AccountChannelRequest
    static newText(account: Account, userActionTime: number): AccountChannelRequest
    static newVardict(account: Account, request: GLib.Variant, userActionTime: number): AccountChannelRequest
    static $gtype: GObject.Type
}
export interface AccountManager_ConstructProps extends Proxy_ConstructProps {
}
export class AccountManager {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AccountManager */
    createAccountAsync(connectionManager: string, protocol: string, displayName: string, parameters: GLib.HashTable, properties: GLib.HashTable, callback?: Gio.AsyncReadyCallback | null): void
    createAccountFinish(result: Gio.AsyncResult): Account
    dupValidAccounts(): Account[]
    enableRestart(): void
    ensureAccount(path: string): Account
    getMostAvailablePresence(): { returnType: ConnectionPresenceType, status: string, message: string }
    getValidAccounts(): Account[]
    setAllRequestedPresences(type: ConnectionPresenceType, status: string, message: string): void
    setDefault(): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.AccountManager */
    connect(sigName: "account-disabled", callback: (($obj: AccountManager, account: Account) => void)): number
    on(sigName: "account-disabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-disabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-disabled", callback: (account: Account) => void): NodeJS.EventEmitter
    emit(sigName: "account-disabled", account: Account): void
    connect(sigName: "account-enabled", callback: (($obj: AccountManager, account: Account) => void)): number
    on(sigName: "account-enabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-enabled", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-enabled", callback: (account: Account) => void): NodeJS.EventEmitter
    emit(sigName: "account-enabled", account: Account): void
    connect(sigName: "account-removed", callback: (($obj: AccountManager, account: Account) => void)): number
    on(sigName: "account-removed", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-removed", callback: (account: Account) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-removed", callback: (account: Account) => void): NodeJS.EventEmitter
    emit(sigName: "account-removed", account: Account): void
    connect(sigName: "account-validity-changed", callback: (($obj: AccountManager, account: Account, valid: boolean) => void)): number
    on(sigName: "account-validity-changed", callback: (account: Account, valid: boolean) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "account-validity-changed", callback: (account: Account, valid: boolean) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "account-validity-changed", callback: (account: Account, valid: boolean) => void): NodeJS.EventEmitter
    emit(sigName: "account-validity-changed", account: Account, valid: boolean): void
    connect(sigName: "most-available-presence-changed", callback: (($obj: AccountManager, presence: number, status: string, message: string) => void)): number
    on(sigName: "most-available-presence-changed", callback: (presence: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "most-available-presence-changed", callback: (presence: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "most-available-presence-changed", callback: (presence: number, status: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "most-available-presence-changed", presence: number, status: string, message: string): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: AccountManager, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: AccountManager, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: AccountManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: (($obj: AccountManager, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: AccountManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AccountManager_ConstructProps)
    _init (config?: AccountManager_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon): AccountManager
    static newWithFactory(factory: SimpleClientFactory): AccountManager
    static canSetDefault(): boolean
    static dup(): AccountManager
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface AccountRequest_ConstructProps extends GObject.Object_ConstructProps {
    accountManager?: AccountManager
    connectionManager?: string
    displayName?: string
    protocol?: string
}
export class AccountRequest {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.AccountRequest */
    readonly automaticPresenceType: number
    readonly automaticStatus: string
    readonly automaticStatusMessage: string
    readonly avatar: object[]
    readonly avatarMimeType: string
    readonly connectAutomatically: boolean
    readonly enabled: boolean
    readonly iconName: string
    readonly nickname: string
    readonly parameters: GLib.Variant
    readonly properties: GLib.Variant
    readonly requestedPresenceType: number
    readonly requestedStatus: string
    readonly requestedStatusMessage: string
    readonly service: string
    readonly storageProvider: string
    readonly supersedes: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AccountRequest */
    addSupersedes(supersededPath: string): void
    createAccountAsync(callback?: Gio.AsyncReadyCallback | null): void
    createAccountFinish(result: Gio.AsyncResult): Account
    setAutomaticPresence(presence: ConnectionPresenceType, status: string, message: string): void
    setAvatar(avatar: any[] | null, mimeType?: string | null): void
    setConnectAutomatically(connectAutomatically: boolean): void
    setDisplayName(name: string): void
    setEnabled(enabled: boolean): void
    setIconName(icon: string): void
    setNickname(nickname: string): void
    setParameter(key: string, value: GLib.Variant): void
    setRequestedPresence(presence: ConnectionPresenceType, status: string, message: string): void
    setService(service: string): void
    setStorageProvider(provider: string): void
    unsetParameter(key: string): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::automatic-presence-type", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-presence-type", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::automatic-status-message", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::automatic-status-message", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::automatic-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-mime-type", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-mime-type", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connect-automatically", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connect-automatically", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connect-automatically", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::enabled", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon-name", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon-name", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::nickname", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::nickname", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::nickname", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::parameters", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameters", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parameters", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parameters", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parameters", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::properties", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::properties", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::properties", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-presence-type", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-presence-type", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested-status-message", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested-status-message", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested-status-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::storage-provider", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::storage-provider", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::storage-provider", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::supersedes", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supersedes", callback: (($obj: AccountRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::supersedes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AccountRequest_ConstructProps)
    _init (config?: AccountRequest_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(accountManager: AccountManager, manager: string, protocol: string, displayName: string): AccountRequest
    static newFromProtocol(accountManager: AccountManager, protocol: Protocol, displayName: string): AccountRequest
    static $gtype: GObject.Type
}
export interface AddDispatchOperationContext_ConstructProps extends GObject.Object_ConstructProps {
    account?: Account
    channels?: object[]
    connection?: Connection
    dispatchOperation?: ChannelDispatchOperation
}
export class AddDispatchOperationContext {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.AddDispatchOperationContext */
    accept(): void
    delay(): void
    fail(error: GLib.Error): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: AddDispatchOperationContext, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AddDispatchOperationContext_ConstructProps)
    _init (config?: AddDispatchOperationContext_ConstructProps): void
    static $gtype: GObject.Type
}
export interface AutomaticClientFactory_ConstructProps extends SimpleClientFactory_ConstructProps {
}
export class AutomaticClientFactory {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.SimpleClientFactory */
    addAccountFeatures(features?: GLib.Quark[] | null): void
    addChannelFeatures(features?: GLib.Quark[] | null): void
    addConnectionFeatures(features?: GLib.Quark[] | null): void
    addContactFeatures(features?: ContactFeature[] | null): void
    dupAccountFeatures(account: Account): GLib.Quark[]
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    dupConnectionFeatures(connection: Connection): GLib.Quark[]
    dupContactFeatures(connection: Connection): ContactFeature[]
    ensureAccount(objectPath: string, immutableProperties: GLib.HashTable): Account
    ensureChannel(connection: Connection, objectPath: string, immutableProperties: GLib.HashTable): Channel
    ensureConnection(objectPath: string, immutableProperties: GLib.HashTable): Connection
    ensureContact(connection: Connection, handle: Handle, identifier: string): Contact
    ensureContactByIdAsync(connection: Connection, identifier: string, callback?: Gio.AsyncReadyCallback | null): void
    ensureContactByIdFinish(result: Gio.AsyncResult): Contact
    getDbusDaemon(): DBusDaemon
    upgradeContactsAsync(connection: Connection, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    upgradeContactsFinish(result: Gio.AsyncResult): { returnType: boolean, contacts: Contact[] | null }
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: AutomaticClientFactory, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AutomaticClientFactory_ConstructProps)
    _init (config?: AutomaticClientFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus?: DBusDaemon | null): AutomaticClientFactory
    static $gtype: GObject.Type
}
export interface AutomaticProxyFactory_ConstructProps extends GObject.Object_ConstructProps {
}
export class AutomaticProxyFactory {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactory */
    createChannel(conn: Connection, path: string, properties: GLib.HashTable): Channel
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: AutomaticProxyFactory, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: AutomaticProxyFactory_ConstructProps)
    _init (config?: AutomaticProxyFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): AutomaticProxyFactory
    static dup(): AutomaticProxyFactory
    static $gtype: GObject.Type
}
export interface BaseClient_ConstructProps extends GObject.Object_ConstructProps {
    accountManager?: AccountManager
    channelFactory?: GObject.Object
    dbusDaemon?: DBusDaemon
    factory?: SimpleClientFactory
    name?: string
    uniquifyName?: boolean
}
export class BaseClient {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): { returnType: boolean, delegated: Channel[], notDelegated: GLib.HashTable }
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: (($obj: BaseClient, account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: (($obj: BaseClient, request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: BaseClient, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BaseClient_ConstructProps)
    _init (config?: BaseClient_ConstructProps): void
    static $gtype: GObject.Type
}
export interface BaseConnection_ConstructProps extends GObject.Object_ConstructProps {
    accountPathSuffix?: string
}
export class BaseConnection {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.BaseConnection */
    readonly hasImmortalHandles: boolean
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseConnection */
    addClientInterest(uniqueName: string, token: string, onlyIfUninterested: boolean): void
    addPossibleClientInterest(token: GLib.Quark): void
    changeStatus(status: ConnectionStatus, reason: ConnectionStatusReason): void
    checkConnected(): boolean
    getAccountPathSuffix(): string
    getBusName(): string | null
    getHandles(handleType: HandleType): HandleRepoIface
    getObjectPath(): string | null
    getStatus(): ConnectionStatus
    isDestroyed(): boolean
    register(cmName: string): { returnType: boolean, busName: string, objectPath: string }
    setSelfHandle(selfHandle: Handle): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseConnection */
    connect(sigName: "clients-interested", callback: (($obj: BaseConnection, token: string) => void)): number
    on(sigName: "clients-interested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "clients-interested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "clients-interested", callback: (token: string) => void): NodeJS.EventEmitter
    emit(sigName: "clients-interested", token: string): void
    connect(sigName: "clients-uninterested", callback: (($obj: BaseConnection, token: string) => void)): number
    on(sigName: "clients-uninterested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "clients-uninterested", callback: (token: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "clients-uninterested", callback: (token: string) => void): NodeJS.EventEmitter
    emit(sigName: "clients-uninterested", token: string): void
    connect(sigName: "shutdown-finished", callback: (($obj: BaseConnection) => void)): number
    on(sigName: "shutdown-finished", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "shutdown-finished", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "shutdown-finished", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "shutdown-finished"): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: BaseConnection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::has-immortal-handles", callback: (($obj: BaseConnection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::has-immortal-handles", callback: (($obj: BaseConnection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::has-immortal-handles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::has-immortal-handles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::has-immortal-handles", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BaseConnection_ConstructProps)
    _init (config?: BaseConnection_ConstructProps): void
    static $gtype: GObject.Type
}
export interface BasicProxyFactory_ConstructProps extends GObject.Object_ConstructProps {
}
export class BasicProxyFactory {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactory */
    createChannel(conn: Connection, path: string, properties: GLib.HashTable): Channel
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: BasicProxyFactory, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: BasicProxyFactory_ConstructProps)
    _init (config?: BasicProxyFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): BasicProxyFactory
    static dup(): BasicProxyFactory
    static $gtype: GObject.Type
}
export interface CallChannel_ConstructProps extends Channel_ConstructProps {
}
export class CallChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.CallChannel */
    readonly contents: object[]
    readonly flags: number
    readonly hardwareStreaming: boolean
    readonly holdState: number
    readonly holdStateReason: number
    readonly initialAudio: boolean
    readonly initialAudioName: string
    readonly initialVideo: boolean
    readonly initialVideoName: string
    readonly mutableContents: boolean
    readonly state: number
    readonly stateDetails: GLib.HashTable
    readonly stateReason: CallStateReason
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.CallChannel */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): boolean
    addContentAsync(name: string, type: MediaStreamType, initialDirection: MediaStreamDirection, callback?: Gio.AsyncReadyCallback | null): void
    addContentFinish(result: Gio.AsyncResult): CallContent
    getContents(): CallContent[]
    getMembers(): GLib.HashTable
    getState(): { returnType: CallState, flags: CallFlags | null, details: GLib.HashTable | null, reason: CallStateReason | null }
    hangupAsync(reason: CallStateChangeReason, detailedReason: string, message: string, callback?: Gio.AsyncReadyCallback | null): void
    hangupFinish(result: Gio.AsyncResult): boolean
    hasDtmf(): boolean
    hasHardwareStreaming(): boolean
    hasHold(): boolean
    hasInitialAudio(): { returnType: boolean, initialAudioName: string | null }
    hasInitialVideo(): { returnType: boolean, initialVideoName: string | null }
    hasMutableContents(): boolean
    requestHoldAsync(hold: boolean, callback?: Gio.AsyncReadyCallback | null): void
    requestHoldFinish(result: Gio.AsyncResult): boolean
    sendTonesAsync(tones: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    sendTonesFinish(result: Gio.AsyncResult): boolean
    setQueuedAsync(callback?: Gio.AsyncReadyCallback | null): void
    setQueuedFinish(result: Gio.AsyncResult): boolean
    setRingingAsync(callback?: Gio.AsyncReadyCallback | null): void
    setRingingFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): { returnType: Handle, handleType: HandleType }
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): { returnType: boolean, actor: Contact | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetLocalPendingInfo(localPending: Handle): { returnType: boolean, actor: Handle | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.CallChannel */
    connect(sigName: "content-added", callback: (($obj: CallChannel, content: GObject.Object) => void)): number
    on(sigName: "content-added", callback: (content: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "content-added", callback: (content: GObject.Object) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "content-added", callback: (content: GObject.Object) => void): NodeJS.EventEmitter
    emit(sigName: "content-added", content: GObject.Object): void
    connect(sigName: "content-removed", callback: (($obj: CallChannel, content: GObject.Object, reason: CallStateReason) => void)): number
    on(sigName: "content-removed", callback: (content: GObject.Object, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "content-removed", callback: (content: GObject.Object, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "content-removed", callback: (content: GObject.Object, reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "content-removed", content: GObject.Object, reason: CallStateReason): void
    connect(sigName: "members-changed", callback: (($obj: CallChannel, updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void)): number
    on(sigName: "members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "members-changed", updates: GLib.HashTable, removed: Contact[], reason: CallStateReason): void
    connect(sigName: "state-changed", callback: (($obj: CallChannel, state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void)): number
    on(sigName: "state-changed", callback: (state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "state-changed", callback: (state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "state-changed", callback: (state: number, flags: number, reason: CallStateReason, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "state-changed", state: number, flags: number, reason: CallStateReason, details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: (($obj: CallChannel, contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: (($obj: CallChannel, added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: (($obj: CallChannel, added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: (($obj: CallChannel, message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: (($obj: CallChannel, added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: CallChannel, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: CallChannel, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::contents", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contents", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::flags", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::flags", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hardware-streaming", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hardware-streaming", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hardware-streaming", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hardware-streaming", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hardware-streaming", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hold-state", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hold-state", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hold-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hold-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hold-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hold-state-reason", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hold-state-reason", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hold-state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hold-state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hold-state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-audio", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-audio", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-audio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-audio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-audio", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-audio-name", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-audio-name", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-audio-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-audio-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-audio-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-video", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-video", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-video", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-video", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-video", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-video-name", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-video-name", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-video-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-video-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-video-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mutable-contents", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mutable-contents", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mutable-contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mutable-contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mutable-contents", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state-details", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-details", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state-details", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state-reason", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state-reason", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: CallChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CallChannel_ConstructProps)
    _init (config?: CallChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getFeatureQuarkCore(): GLib.Quark
    static $gtype: GObject.Type
}
export interface CallContent_ConstructProps extends Proxy_ConstructProps {
    channel?: CallChannel
    connection?: Connection
}
export class CallContent {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.CallContent */
    readonly disposition: number
    readonly mediaType: number
    readonly name: string
    readonly streams: object[]
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.CallContent */
    getDisposition(): CallContentDisposition
    getMediaType(): MediaStreamType
    getName(): string
    getStreams(): CallStream[]
    removeAsync(callback?: Gio.AsyncReadyCallback | null): void
    removeFinish(result: Gio.AsyncResult): boolean
    sendTonesAsync(tones: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    sendTonesFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.CallContent */
    connect(sigName: "removed", callback: (($obj: CallContent) => void)): number
    on(sigName: "removed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "removed", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "removed", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "removed"): void
    connect(sigName: "streams-added", callback: (($obj: CallContent, streams: CallStream[]) => void)): number
    on(sigName: "streams-added", callback: (streams: CallStream[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "streams-added", callback: (streams: CallStream[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "streams-added", callback: (streams: CallStream[]) => void): NodeJS.EventEmitter
    emit(sigName: "streams-added", streams: CallStream[]): void
    connect(sigName: "streams-removed", callback: (($obj: CallContent, streams: CallStream[], reason: CallStateReason) => void)): number
    on(sigName: "streams-removed", callback: (streams: CallStream[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "streams-removed", callback: (streams: CallStream[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "streams-removed", callback: (streams: CallStream[], reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "streams-removed", streams: CallStream[], reason: CallStateReason): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: CallContent, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: CallContent, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::disposition", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::disposition", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::disposition", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::disposition", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::disposition", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::media-type", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::media-type", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::media-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::media-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::media-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::name", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::name", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::streams", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::streams", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::streams", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::streams", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::streams", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: CallContent, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CallContent_ConstructProps)
    _init (config?: CallContent_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface CallStream_ConstructProps extends Proxy_ConstructProps {
    connection?: Connection
    content?: CallContent
}
export class CallStream {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.CallStream */
    readonly canRequestReceiving: boolean
    readonly localSendingState: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.CallStream */
    getLocalSendingState(): SendingState
    getRemoteMembers(): GLib.HashTable
    requestReceivingAsync(contact: Contact, receive: boolean, callback?: Gio.AsyncReadyCallback | null): void
    requestReceivingFinish(result: Gio.AsyncResult): boolean
    setSendingAsync(send: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setSendingFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.CallStream */
    connect(sigName: "local-sending-state-changed", callback: (($obj: CallStream, state: number, reason: CallStateReason) => void)): number
    on(sigName: "local-sending-state-changed", callback: (state: number, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "local-sending-state-changed", callback: (state: number, reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "local-sending-state-changed", callback: (state: number, reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "local-sending-state-changed", state: number, reason: CallStateReason): void
    connect(sigName: "remote-members-changed", callback: (($obj: CallStream, updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void)): number
    on(sigName: "remote-members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "remote-members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "remote-members-changed", callback: (updates: GLib.HashTable, removed: Contact[], reason: CallStateReason) => void): NodeJS.EventEmitter
    emit(sigName: "remote-members-changed", updates: GLib.HashTable, removed: Contact[], reason: CallStateReason): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: CallStream, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: CallStream, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: CallStream, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::can-request-receiving", callback: (($obj: CallStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-request-receiving", callback: (($obj: CallStream, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::can-request-receiving", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::can-request-receiving", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::can-request-receiving", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::local-sending-state", callback: (($obj: CallStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::local-sending-state", callback: (($obj: CallStream, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::local-sending-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::local-sending-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::local-sending-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: CallStream, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: CallStream, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: CallStream_ConstructProps)
    _init (config?: CallStream_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface Capabilities_ConstructProps extends GObject.Object_ConstructProps {
    contactSpecific?: boolean
}
export class Capabilities {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Capabilities */
    readonly channelClassesVariant: GLib.Variant
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Capabilities */
    dupChannelClassesVariant(): GLib.Variant
    getChannelClasses(): GLib.HashTable[]
    isSpecificToContact(): boolean
    supportsAudioCall(handleType: HandleType): boolean
    supportsAudioVideoCall(handleType: HandleType): boolean
    supportsContactSearch(): { returnType: boolean, withLimit: boolean, withServer: boolean }
    supportsDbusTubes(handleType: HandleType, serviceName: string): boolean
    supportsFileTransfer(): boolean
    supportsFileTransferDescription(): boolean
    supportsFileTransferInitialOffset(): boolean
    supportsFileTransferTimestamp(): boolean
    supportsFileTransferUri(): boolean
    supportsRoomList(): { returnType: boolean, withServer: boolean }
    supportsSms(): boolean
    supportsStreamTubes(handleType: HandleType, service: string): boolean
    supportsTextChatrooms(): boolean
    supportsTextChats(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Capabilities, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel-classes-variant", callback: (($obj: Capabilities, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-classes-variant", callback: (($obj: Capabilities, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-classes-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-classes-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-classes-variant", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Capabilities_ConstructProps)
    _init (config?: Capabilities_ConstructProps): void
    static $gtype: GObject.Type
}
export interface Channel_ConstructProps extends Proxy_ConstructProps {
    connection?: Connection
}
export class Channel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): { returnType: Handle, handleType: HandleType }
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): { returnType: boolean, actor: Contact | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetLocalPendingInfo(localPending: Handle): { returnType: boolean, actor: Handle | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: (($obj: Channel, contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: (($obj: Channel, added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: (($obj: Channel, added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: (($obj: Channel, message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: (($obj: Channel, added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: Channel, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: Channel, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::channel-ready", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: Channel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Channel_ConstructProps)
    _init (config?: Channel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): Channel
    static newFromProperties(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): Channel
    static getFeatureQuarkChatStates(): GLib.Quark
    static getFeatureQuarkContacts(): GLib.Quark
    static getFeatureQuarkCore(): GLib.Quark
    static getFeatureQuarkGroup(): GLib.Quark
    static getFeatureQuarkPassword(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface ChannelDispatchOperation_ConstructProps extends Proxy_ConstructProps {
    account?: Account
    channels?: object[]
    connection?: Connection
}
export class ChannelDispatchOperation {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatchOperation */
    readonly possibleHandlers: string[]
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatchOperation */
    claimAsync(callback?: Gio.AsyncReadyCallback | null): void
    claimFinish(result: Gio.AsyncResult): boolean
    claimWithAsync(client: BaseClient, callback?: Gio.AsyncReadyCallback | null): void
    claimWithFinish(result: Gio.AsyncResult): boolean
    closeChannelsAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeChannelsFinish(result: Gio.AsyncResult): boolean
    destroyChannelsAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyChannelsFinish(result: Gio.AsyncResult): boolean
    getChannels(): Channel[]
    handleWithAsync(handler?: string | null, callback?: Gio.AsyncReadyCallback | null): void
    handleWithFinish(result: Gio.AsyncResult): boolean
    handleWithTimeAsync(handler: string | null, userActionTime: number, callback?: Gio.AsyncReadyCallback | null): void
    handleWithTimeFinish(result: Gio.AsyncResult): boolean
    leaveChannelsAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveChannelsFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatchOperation */
    connect(sigName: "channel-lost", callback: (($obj: ChannelDispatchOperation, channel: Channel, domain: number, code: number, message: string) => void)): number
    on(sigName: "channel-lost", callback: (channel: Channel, domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "channel-lost", callback: (channel: Channel, domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "channel-lost", callback: (channel: Channel, domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "channel-lost", channel: Channel, domain: number, code: number, message: string): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: ChannelDispatchOperation, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: ChannelDispatchOperation, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ChannelDispatchOperation, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::possible-handlers", callback: (($obj: ChannelDispatchOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::possible-handlers", callback: (($obj: ChannelDispatchOperation, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::possible-handlers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::possible-handlers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::possible-handlers", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: ChannelDispatchOperation, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: ChannelDispatchOperation, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ChannelDispatchOperation_ConstructProps)
    _init (config?: ChannelDispatchOperation_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon, objectPath: string, immutableProperties: GLib.HashTable): ChannelDispatchOperation
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface ChannelDispatcher_ConstructProps extends Proxy_ConstructProps {
}
export class ChannelDispatcher {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ChannelDispatcher */
    presentChannelAsync(channel: Channel, userActionTime: number, callback?: Gio.AsyncReadyCallback | null): void
    presentChannelFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: ChannelDispatcher, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: ChannelDispatcher, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ChannelDispatcher, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: (($obj: ChannelDispatcher, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: ChannelDispatcher, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ChannelDispatcher_ConstructProps)
    _init (config?: ChannelDispatcher_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon): ChannelDispatcher
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface ChannelRequest_ConstructProps extends Proxy_ConstructProps {
    channelFactory?: GObject.Object
}
export class ChannelRequest {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ChannelRequest */
    readonly account: Account
    channelFactory: GObject.Object
    readonly hintsVardict: GLib.Variant
    readonly immutablePropertiesVardict: GLib.Variant
    readonly preferredHandler: string
    readonly userActionTime: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ChannelRequest */
    dupHints(): GLib.Variant
    dupImmutableProperties(): GLib.Variant
    getAccount(): Account
    getHints(): GLib.HashTable
    getImmutableProperties(): GLib.HashTable
    getPreferredHandler(): string
    getUserActionTime(): number
    setChannelFactory(factory: ClientChannelFactory): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ChannelRequest */
    connect(sigName: "succeeded", callback: (($obj: ChannelRequest) => void)): number
    on(sigName: "succeeded", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "succeeded", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "succeeded", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "succeeded"): void
    connect(sigName: "succeeded-with-channel", callback: (($obj: ChannelRequest, connection: Connection, channel: Channel) => void)): number
    on(sigName: "succeeded-with-channel", callback: (connection: Connection, channel: Channel) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "succeeded-with-channel", callback: (connection: Connection, channel: Channel) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "succeeded-with-channel", callback: (connection: Connection, channel: Channel) => void): NodeJS.EventEmitter
    emit(sigName: "succeeded-with-channel", connection: Connection, channel: Channel): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: ChannelRequest, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: ChannelRequest, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::account", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::account", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::account", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::account", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::account", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-factory", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-factory", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-factory", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-factory", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-factory", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::hints-vardict", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::hints-vardict", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::hints-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::hints-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::hints-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::immutable-properties-vardict", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::immutable-properties-vardict", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::immutable-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::immutable-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::immutable-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::preferred-handler", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::preferred-handler", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::preferred-handler", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::preferred-handler", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::preferred-handler", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::user-action-time", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::user-action-time", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::user-action-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::user-action-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::user-action-time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: ChannelRequest, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ChannelRequest_ConstructProps)
    _init (config?: ChannelRequest_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(busDaemon: DBusDaemon, objectPath: string, immutableProperties: GLib.HashTable): ChannelRequest
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface ClientMessage_ConstructProps extends Message_ConstructProps {
}
export class ClientMessage {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Message */
    appendPart(): number
    countParts(): number
    deleteKey(part: number, key: string): boolean
    deletePart(part: number): void
    destroy(): void
    dupPart(part: number): GLib.Variant
    getMessageType(): ChannelTextMessageType
    getPendingMessageId(): { returnType: number, valid: boolean }
    getReceivedTimestamp(): number
    getSentTimestamp(): number
    getSpecificToInterface(): string
    getSupersedes(): string
    getToken(): string
    isDeliveryReport(): boolean
    isMutable(): boolean
    isRescued(): boolean
    isScrollback(): boolean
    peek(part: number): GLib.HashTable
    refHandle(handleType: HandleType, handle: Handle): void
    set(part: number, key: string, source: any): void
    setBoolean(part: number, key: string, b: boolean): void
    setBytes(part: number, key: string, len: number, bytes?: object | null): void
    setHandle(part: number, key: string, handleType: HandleType, handleOr0: Handle): void
    setInt32(part: number, key: string, i: number): void
    setInt64(part: number, key: string, i: number): void
    setString(part: number, key: string, s: string): void
    setUint32(part: number, key: string, u: number): void
    setUint64(part: number, key: string, u: number): void
    setVariant(part: number, key: string, value: GLib.Variant): void
    takeMessage(part: number, key: string, message: Message): void
    toText(): { returnType: string, outFlags: ChannelTextMessageFlags }
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ClientMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ClientMessage_ConstructProps)
    _init (config?: ClientMessage_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(): ClientMessage
    static newText(type: ChannelTextMessageType, text: string): ClientMessage
    static $gtype: GObject.Type
}
export interface Connection_ConstructProps extends Proxy_ConstructProps {
}
export class Connection {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Connection */
    readonly balance: number
    readonly balanceCurrency: string
    readonly balanceScale: number
    readonly balanceUri: string
    readonly blockedContacts: object[]
    readonly canChangeContactList: boolean
    readonly canReportAbusive: boolean
    readonly capabilities: Capabilities
    readonly cmName: string
    readonly connectionManagerName: string
    readonly connectionReady: boolean
    readonly contactGroups: string[]
    readonly contactListPersists: boolean
    readonly contactListState: number
    readonly disjointGroups: boolean
    readonly groupStorage: number
    readonly protocolName: string
    readonly requestUsesMessage: boolean
    readonly selfContact: Contact
    readonly selfHandle: number
    readonly status: number
    readonly statusReason: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Connection */
    addClientInterest(interestedIn: string): void
    addToGroupAsync(group: string, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    addToGroupFinish(result: Gio.AsyncResult): boolean
    authorizePublicationAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    authorizePublicationFinish(result: Gio.AsyncResult): boolean
    bindConnectionStatusToProperty(target: object | null, targetProperty: string, invert: boolean): GObject.Binding
    blockContactsAsync(contacts: Contact[], reportAbusive: boolean, callback?: Gio.AsyncReadyCallback | null): void
    blockContactsFinish(result: Gio.AsyncResult): boolean
    canSetContactAlias(): boolean
    disconnectAsync(callback?: Gio.AsyncReadyCallback | null): void
    disconnectFinish(result: Gio.AsyncResult): boolean
    dupContactByIdAsync(id: string, features?: ContactFeature[] | null, callback?: Gio.AsyncReadyCallback | null): void
    dupContactByIdFinish(result: Gio.AsyncResult): Contact
    dupContactIfPossible(handle: Handle, identifier: string): Contact
    dupContactInfoSupportedFields(): ContactInfoFieldSpec[]
    dupContactList(): Contact[]
    dupDetailedErrorVardict(): { returnType: string | null, details: GLib.Variant | null }
    getAccount(): Account
    getAvatarRequirements(): AvatarRequirements
    getBalance(): { returnType: boolean, balance: number, scale: number, currency: string }
    getBalanceUri(): string
    getBlockedContacts(): Contact[]
    getCanChangeContactList(): boolean
    getCapabilities(): Capabilities
    getCmName(): string
    getConnectionManagerName(): string
    getContactAttributes(timeoutMs: number, handles: Handle[], interfaces: string, hold: boolean, callback: GObject.Callback, weakObject: GObject.Object): void
    getContactGroups(): string[]
    getContactInfoFlags(): ContactInfoFlags
    getContactInfoSupportedFields(): ContactInfoFieldSpec[]
    getContactListAttributes(timeoutMs: number, interfaces: string, hold: boolean, callback: GObject.Callback, weakObject: GObject.Object): void
    getContactListPersists(): boolean
    getContactListState(): ContactListState
    getContactsByHandle(handles: number[], features: number[] | null, callback: ConnectionContactsByHandleCb, weakObject?: GObject.Object | null): void
    getContactsById(ids: string[], features: ContactFeature[] | null, callback: ConnectionContactsByIdCb, weakObject?: GObject.Object | null): void
    getDetailedError(): { returnType: string | null, details: GLib.HashTable | null }
    getDisjointGroups(): boolean
    getGroupStorage(): ContactMetadataStorageType
    getProtocolName(): string
    getRequestUsesMessage(): boolean
    getSelfContact(): Contact
    getSelfHandle(): Handle
    getStatus(): { returnType: ConnectionStatus, reason: ConnectionStatusReason }
    hasImmortalHandles(): boolean
    holdHandles(timeoutMs: number, handleType: HandleType, handles: Handle[], callback: ConnectionHoldHandlesCb, weakObject: GObject.Object): void
    parseObjectPath(): { returnType: boolean, protocol: string, cmName: string }
    refreshContactInfo(contacts: Contact[]): void
    removeContactsAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    removeContactsFinish(result: Gio.AsyncResult): boolean
    removeFromGroupAsync(group: string, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    removeFromGroupFinish(result: Gio.AsyncResult): boolean
    removeGroupAsync(group: string, callback?: Gio.AsyncReadyCallback | null): void
    removeGroupFinish(result: Gio.AsyncResult): boolean
    renameGroupAsync(oldName: string, newName: string, callback?: Gio.AsyncReadyCallback | null): void
    renameGroupFinish(result: Gio.AsyncResult): boolean
    requestHandles(timeoutMs: number, handleType: HandleType, ids: string[], callback: ConnectionRequestHandlesCb, weakObject: GObject.Object): void
    requestSubscriptionAsync(contacts: Contact[], message: string, callback?: Gio.AsyncReadyCallback | null): void
    requestSubscriptionFinish(result: Gio.AsyncResult): boolean
    setContactInfoAsync(info: ContactInfoField[], callback?: Gio.AsyncReadyCallback | null): void
    setContactInfoFinish(result: Gio.AsyncResult): boolean
    setGroupMembersAsync(group: string, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    setGroupMembersFinish(result: Gio.AsyncResult): boolean
    unblockContactsAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    unblockContactsFinish(result: Gio.AsyncResult): boolean
    unpublishAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    unpublishFinish(result: Gio.AsyncResult): boolean
    unrefHandles(handleType: HandleType, handles: Handle[]): void
    unsubscribeAsync(contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    unsubscribeFinish(result: Gio.AsyncResult): boolean
    upgradeContacts(contacts: Contact[], features: ContactFeature[], callback: ConnectionUpgradeContactsCb, weakObject?: GObject.Object | null): void
    upgradeContactsAsync(contacts: Contact[], features: ContactFeature[], callback?: Gio.AsyncReadyCallback | null): void
    upgradeContactsFinish(result: Gio.AsyncResult): { returnType: boolean, contacts: Contact[] | null }
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Connection */
    connect(sigName: "balance-changed", callback: (($obj: Connection, balance: number, balanceScale: number, balanceCurrency: string) => void)): number
    on(sigName: "balance-changed", callback: (balance: number, balanceScale: number, balanceCurrency: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "balance-changed", callback: (balance: number, balanceScale: number, balanceCurrency: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "balance-changed", callback: (balance: number, balanceScale: number, balanceCurrency: string) => void): NodeJS.EventEmitter
    emit(sigName: "balance-changed", balance: number, balanceScale: number, balanceCurrency: string): void
    connect(sigName: "blocked-contacts-changed", callback: (($obj: Connection, added: Contact[], removed: Contact[]) => void)): number
    on(sigName: "blocked-contacts-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "blocked-contacts-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "blocked-contacts-changed", callback: (added: Contact[], removed: Contact[]) => void): NodeJS.EventEmitter
    emit(sigName: "blocked-contacts-changed", added: Contact[], removed: Contact[]): void
    connect(sigName: "contact-list-changed", callback: (($obj: Connection, added: Contact[], removed: Contact[]) => void)): number
    on(sigName: "contact-list-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "contact-list-changed", callback: (added: Contact[], removed: Contact[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "contact-list-changed", callback: (added: Contact[], removed: Contact[]) => void): NodeJS.EventEmitter
    emit(sigName: "contact-list-changed", added: Contact[], removed: Contact[]): void
    connect(sigName: "group-renamed", callback: (($obj: Connection, oldName: string, newName: string) => void)): number
    on(sigName: "group-renamed", callback: (oldName: string, newName: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-renamed", callback: (oldName: string, newName: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-renamed", callback: (oldName: string, newName: string) => void): NodeJS.EventEmitter
    emit(sigName: "group-renamed", oldName: string, newName: string): void
    connect(sigName: "groups-created", callback: (($obj: Connection, added: string[]) => void)): number
    on(sigName: "groups-created", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "groups-created", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "groups-created", callback: (added: string[]) => void): NodeJS.EventEmitter
    emit(sigName: "groups-created", added: string[]): void
    connect(sigName: "groups-removed", callback: (($obj: Connection, added: string[]) => void)): number
    on(sigName: "groups-removed", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "groups-removed", callback: (added: string[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "groups-removed", callback: (added: string[]) => void): NodeJS.EventEmitter
    emit(sigName: "groups-removed", added: string[]): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: Connection, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: Connection, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::balance", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::balance-currency", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance-currency", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance-currency", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance-currency", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance-currency", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::balance-scale", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance-scale", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance-scale", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance-scale", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance-scale", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::balance-uri", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::balance-uri", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::balance-uri", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::balance-uri", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::balance-uri", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::blocked-contacts", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::blocked-contacts", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::blocked-contacts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::blocked-contacts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::blocked-contacts", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::can-change-contact-list", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-change-contact-list", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::can-change-contact-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::can-change-contact-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::can-change-contact-list", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::can-report-abusive", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::can-report-abusive", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::can-report-abusive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::can-report-abusive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::can-report-abusive", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::capabilities", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cm-name", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cm-name", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-manager-name", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-manager-name", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-manager-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-manager-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-manager-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-ready", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-ready", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-groups", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-groups", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-list-persists", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-list-persists", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-list-persists", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-list-persists", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-list-persists", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-list-state", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-list-state", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-list-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-list-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-list-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::disjoint-groups", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::disjoint-groups", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::disjoint-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::disjoint-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::disjoint-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-storage", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-storage", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-storage", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol-name", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-name", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::request-uses-message", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::request-uses-message", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::request-uses-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::request-uses-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::request-uses-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::self-contact", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::self-contact", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::self-handle", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::self-handle", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::status", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::status", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::status-reason", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::status-reason", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::status-reason", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: Connection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Connection_ConstructProps)
    _init (config?: Connection_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, busName?: string | null, objectPath?: string | null): Connection
    static getFeatureQuarkAliasing(): GLib.Quark
    static getFeatureQuarkAvatarRequirements(): GLib.Quark
    static getFeatureQuarkBalance(): GLib.Quark
    static getFeatureQuarkCapabilities(): GLib.Quark
    static getFeatureQuarkConnected(): GLib.Quark
    static getFeatureQuarkContactBlocking(): GLib.Quark
    static getFeatureQuarkContactGroups(): GLib.Quark
    static getFeatureQuarkContactInfo(): GLib.Quark
    static getFeatureQuarkContactList(): GLib.Quark
    static getFeatureQuarkContactListProperties(): GLib.Quark
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static presenceTypeCmpAvailability(p1: ConnectionPresenceType, p2: ConnectionPresenceType): number
    static $gtype: GObject.Type
}
export interface ConnectionManager_ConstructProps extends Proxy_ConstructProps {
    alwaysIntrospect?: boolean
    managerFile?: string
}
export class ConnectionManager {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ConnectionManager */
    alwaysIntrospect: boolean
    readonly cmName: string
    readonly connectionManager: string
    readonly infoSource: number
    managerFile: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ConnectionManager */
    dupProtocolNames(): string[]
    dupProtocols(): Protocol[]
    getInfoSource(): CMInfoSource
    getName(): string
    getProtocol(protocol: string): ConnectionManagerProtocol
    getProtocolObject(protocol: string): Protocol
    hasProtocol(protocol: string): boolean
    isRunning(): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ConnectionManager */
    connect(sigName: "activated", callback: (($obj: ConnectionManager) => void)): number
    on(sigName: "activated", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "activated", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "activated", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "activated"): void
    connect(sigName: "exited", callback: (($obj: ConnectionManager) => void)): number
    on(sigName: "exited", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "exited", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "exited", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "exited"): void
    connect(sigName: "got-info", callback: (($obj: ConnectionManager, source: number) => void)): number
    on(sigName: "got-info", callback: (source: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "got-info", callback: (source: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "got-info", callback: (source: number) => void): NodeJS.EventEmitter
    emit(sigName: "got-info", source: number): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: ConnectionManager, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: ConnectionManager, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::always-introspect", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::always-introspect", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::always-introspect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::always-introspect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::always-introspect", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cm-name", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cm-name", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cm-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection-manager", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection-manager", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection-manager", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::info-source", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::info-source", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::info-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::info-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::info-source", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::manager-file", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::manager-file", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::manager-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::manager-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::manager-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: ConnectionManager, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ConnectionManager_ConstructProps)
    _init (config?: ConnectionManager_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, name: string, managerFilename?: string | null): ConnectionManager
    static checkValidName(name: string): boolean
    static checkValidProtocolName(name: string): boolean
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface Contact_ConstructProps extends GObject.Object_ConstructProps {
}
export class Contact {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Contact */
    readonly alias: string
    readonly avatarFile: Gio.File
    readonly avatarMimeType: string
    readonly avatarToken: string
    readonly capabilities: Capabilities
    readonly clientTypes: string[]
    readonly connection: Connection
    readonly contactGroups: string[]
    readonly contactInfo: any
    readonly handle: number
    readonly identifier: string
    readonly isBlocked: boolean
    readonly locationVardict: GLib.Variant
    readonly presenceMessage: string
    readonly presenceStatus: string
    readonly presenceType: number
    readonly publishRequest: string
    readonly publishState: number
    readonly subscribeState: number
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Contact */
    addToGroupAsync(group: string, callback?: Gio.AsyncReadyCallback | null): void
    addToGroupFinish(result: Gio.AsyncResult): boolean
    authorizePublicationAsync(callback?: Gio.AsyncReadyCallback | null): void
    authorizePublicationFinish(result: Gio.AsyncResult): boolean
    blockAsync(reportAbusive: boolean, callback?: Gio.AsyncReadyCallback | null): void
    blockFinish(result: Gio.AsyncResult): boolean
    dupContactInfo(): ContactInfoField[]
    dupLocation(): GLib.Variant
    getAccount(): Account
    getAlias(): string
    getAvatarFile(): Gio.File
    getAvatarMimeType(): string
    getAvatarToken(): string
    getCapabilities(): Capabilities
    getClientTypes(): string[]
    getConnection(): Connection
    getContactGroups(): string[]
    getContactInfo(): ContactInfoField[]
    getHandle(): Handle
    getIdentifier(): string
    getLocation(): GLib.HashTable
    getPresenceMessage(): string
    getPresenceStatus(): string
    getPresenceType(): ConnectionPresenceType
    getPublishRequest(): string
    getPublishState(): SubscriptionState
    getSubscribeState(): SubscriptionState
    hasFeature(feature: ContactFeature): boolean
    removeAsync(callback?: Gio.AsyncReadyCallback | null): void
    removeFinish(result: Gio.AsyncResult): boolean
    removeFromGroupAsync(group: string, callback?: Gio.AsyncReadyCallback | null): void
    removeFromGroupFinish(result: Gio.AsyncResult): boolean
    requestContactInfoAsync(cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    requestContactInfoFinish(result: Gio.AsyncResult): boolean
    requestSubscriptionAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    requestSubscriptionFinish(result: Gio.AsyncResult): boolean
    setContactGroupsAsync(groups?: string[] | null, callback?: Gio.AsyncReadyCallback | null): void
    setContactGroupsFinish(result: Gio.AsyncResult): boolean
    unblockAsync(callback?: Gio.AsyncReadyCallback | null): void
    unblockFinish(result: Gio.AsyncResult): boolean
    unpublishAsync(callback?: Gio.AsyncReadyCallback | null): void
    unpublishFinish(result: Gio.AsyncResult): boolean
    unsubscribeAsync(callback?: Gio.AsyncReadyCallback | null): void
    unsubscribeFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Contact */
    connect(sigName: "contact-groups-changed", callback: (($obj: Contact, added: string[], removed: string[]) => void)): number
    on(sigName: "contact-groups-changed", callback: (added: string[], removed: string[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "contact-groups-changed", callback: (added: string[], removed: string[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "contact-groups-changed", callback: (added: string[], removed: string[]) => void): NodeJS.EventEmitter
    emit(sigName: "contact-groups-changed", added: string[], removed: string[]): void
    connect(sigName: "presence-changed", callback: (($obj: Contact, type: number, status: string, message: string) => void)): number
    on(sigName: "presence-changed", callback: (type: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "presence-changed", callback: (type: number, status: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "presence-changed", callback: (type: number, status: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "presence-changed", type: number, status: string, message: string): void
    connect(sigName: "subscription-states-changed", callback: (($obj: Contact, subscribe: number, publish: number, publishRequest: string) => void)): number
    on(sigName: "subscription-states-changed", callback: (subscribe: number, publish: number, publishRequest: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "subscription-states-changed", callback: (subscribe: number, publish: number, publishRequest: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "subscription-states-changed", callback: (subscribe: number, publish: number, publishRequest: string) => void): NodeJS.EventEmitter
    emit(sigName: "subscription-states-changed", subscribe: number, publish: number, publishRequest: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::alias", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::alias", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::alias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::alias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::alias", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-file", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-file", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-mime-type", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-mime-type", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-token", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-token", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-token", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-token", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-token", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::capabilities", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::client-types", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::client-types", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::client-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::client-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::client-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::connection", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::connection", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::connection", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-groups", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-groups", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-groups", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::contact-info", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::contact-info", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::contact-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::contact-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::contact-info", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::handle", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::handle", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::is-blocked", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-blocked", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::is-blocked", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::is-blocked", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::is-blocked", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::location-vardict", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::location-vardict", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::location-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::location-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::location-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::presence-message", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::presence-message", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::presence-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::presence-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::presence-message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::presence-status", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::presence-status", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::presence-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::presence-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::presence-status", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::presence-type", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::presence-type", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::presence-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::publish-request", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::publish-request", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::publish-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::publish-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::publish-request", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::publish-state", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::publish-state", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::publish-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::publish-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::publish-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::subscribe-state", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::subscribe-state", callback: (($obj: Contact, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::subscribe-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::subscribe-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::subscribe-state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Contact_ConstructProps)
    _init (config?: Contact_ConstructProps): void
    static $gtype: GObject.Type
}
export interface ContactSearch_ConstructProps extends GObject.Object_ConstructProps {
    account?: Account
    limit?: number
    server?: string
}
export class ContactSearch {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.ContactSearch */
    limit: number
    readonly state: number
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ContactSearch */
    getAccount(): Account
    getLimit(): number
    getSearchKeys(): string[]
    getServer(): string
    resetAsync(server: string, limit: number, callback?: Gio.AsyncReadyCallback | null): void
    resetFinish(result: Gio.AsyncResult): string[]
    start(criteria: GLib.HashTable): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    initAsync(ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    initFinish(res: Gio.AsyncResult): boolean
    newFinish(res: Gio.AsyncResult): GObject.Object
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.ContactSearch */
    connect(sigName: "search-results-received", callback: (($obj: ContactSearch, results: ContactSearchResult[]) => void)): number
    on(sigName: "search-results-received", callback: (results: ContactSearchResult[]) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "search-results-received", callback: (results: ContactSearchResult[]) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "search-results-received", callback: (results: ContactSearchResult[]) => void): NodeJS.EventEmitter
    emit(sigName: "search-results-received", results: ContactSearchResult[]): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ContactSearch, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::limit", callback: (($obj: ContactSearch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::limit", callback: (($obj: ContactSearch, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::limit", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::limit", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::limit", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: (($obj: ContactSearch, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: ContactSearch, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ContactSearch_ConstructProps)
    _init (config?: ContactSearch_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newFinish(result: Gio.AsyncResult): ContactSearch
    static newAsync(account: Account, server: string, limit: number, callback?: Gio.AsyncReadyCallback | null): void
    static newvAsync(objectType: GObject.Type, nParameters: number, parameters: GObject.Parameter, ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    static $gtype: GObject.Type
}
export interface ContactSearchResult_ConstructProps extends GObject.Object_ConstructProps {
    identifier?: string
}
export class ContactSearchResult {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ContactSearchResult */
    dupFields(): ContactInfoField[]
    getField(field: string): ContactInfoField
    getFields(): ContactInfoField[]
    getIdentifier(): string
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ContactSearchResult, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ContactSearchResult_ConstructProps)
    _init (config?: ContactSearchResult_ConstructProps): void
    static $gtype: GObject.Type
}
export interface DBusDaemon_ConstructProps extends Proxy_ConstructProps {
}
export class DBusDaemon {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DBusDaemon */
    getUniqueName(): string
    listActivatableNames(timeoutMs: number, callback: DBusDaemonListNamesCb, weakObject: GObject.Object): void
    listNames(timeoutMs: number, callback: DBusDaemonListNamesCb, weakObject: GObject.Object): void
    registerObject(objectPath: string, object: GObject.Object): void
    releaseName(wellKnownName: string): boolean
    requestName(wellKnownName: string, idempotent: boolean): boolean
    unregisterObject(object: GObject.Object): void
    watchNameOwner(name: string, callback: DBusDaemonNameOwnerChangedCb): void
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: DBusDaemon, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: DBusDaemon, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: DBusDaemon, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: (($obj: DBusDaemon, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: DBusDaemon, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DBusDaemon_ConstructProps)
    _init (config?: DBusDaemon_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static dup(): DBusDaemon
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface DBusTubeChannel_ConstructProps extends Channel_ConstructProps {
}
export class DBusTubeChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.DBusTubeChannel */
    readonly parametersVardict: GLib.Variant
    readonly serviceName: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DBusTubeChannel */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): Gio.DBusConnection
    dupParametersVardict(): GLib.Variant
    getServiceName(): string
    offerAsync(params?: GLib.HashTable | null, callback?: Gio.AsyncReadyCallback | null): void
    offerFinish(result: Gio.AsyncResult): Gio.DBusConnection
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): { returnType: Handle, handleType: HandleType }
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): { returnType: boolean, actor: Contact | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetLocalPendingInfo(localPending: Handle): { returnType: boolean, actor: Handle | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: (($obj: DBusTubeChannel, contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: (($obj: DBusTubeChannel, added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: (($obj: DBusTubeChannel, added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: (($obj: DBusTubeChannel, message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: (($obj: DBusTubeChannel, added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: DBusTubeChannel, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: DBusTubeChannel, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parameters-vardict", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameters-vardict", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service-name", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service-name", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: DBusTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DBusTubeChannel_ConstructProps)
    _init (config?: DBusTubeChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static featureQuarkCore(): GLib.Quark
    static $gtype: GObject.Type
}
export interface DebugClient_ConstructProps extends Proxy_ConstructProps {
}
export class DebugClient {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.DebugClient */
    readonly enabled: boolean
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DebugClient */
    getMessagesAsync(callback?: Gio.AsyncReadyCallback | null): void
    getMessagesFinish(result: Gio.AsyncResult): DebugMessage[]
    isEnabled(): boolean
    setEnabledAsync(enabled: boolean, callback?: Gio.AsyncReadyCallback | null): void
    setEnabledFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.DebugClient */
    connect(sigName: "new-debug-message", callback: (($obj: DebugClient, message: DebugMessage) => void)): number
    on(sigName: "new-debug-message", callback: (message: DebugMessage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "new-debug-message", callback: (message: DebugMessage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "new-debug-message", callback: (message: DebugMessage) => void): NodeJS.EventEmitter
    emit(sigName: "new-debug-message", message: DebugMessage): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: DebugClient, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: DebugClient, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: DebugClient, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::enabled", callback: (($obj: DebugClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::enabled", callback: (($obj: DebugClient, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::enabled", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: DebugClient, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: DebugClient, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DebugClient_ConstructProps)
    _init (config?: DebugClient_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, uniqueName: string): DebugClient
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface DebugMessage_ConstructProps extends GObject.Object_ConstructProps {
}
export class DebugMessage {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.DebugMessage */
    readonly category: string
    readonly domain: string
    readonly level: number
    readonly message: string
    readonly time: GLib.DateTime
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.DebugMessage */
    getCategory(): string
    getDomain(): string
    getLevel(): GLib.LogLevelFlags
    getMessage(): string
    getTime(): GLib.DateTime
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::category", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::category", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::category", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::domain", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::domain", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::domain", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::level", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::level", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::level", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::message", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::message", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::time", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::time", callback: (($obj: DebugMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::time", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: DebugMessage_ConstructProps)
    _init (config?: DebugMessage_ConstructProps): void
    static $gtype: GObject.Type
}
export interface FileTransferChannel_ConstructProps extends Channel_ConstructProps {
}
export class FileTransferChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.FileTransferChannel */
    readonly date: GLib.DateTime
    readonly description: string
    readonly file: Gio.File
    readonly filename: string
    readonly initialOffset: number
    readonly mimeType: string
    readonly serviceName: string
    readonly size: number
    readonly state: number
    readonly transferredBytes: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.FileTransferChannel */
    acceptFileAsync(file: Gio.File, offset: number, callback?: Gio.AsyncReadyCallback | null): void
    acceptFileFinish(result: Gio.AsyncResult): boolean
    getDate(): GLib.DateTime
    getDescription(): string
    getFilename(): string
    getMetadata(): GLib.HashTable
    getMimeType(): string
    getServiceName(): string
    getSize(): number
    getState(): { returnType: FileTransferState, reason: FileTransferStateChangeReason }
    getTransferredBytes(): number
    provideFileAsync(file: Gio.File, callback?: Gio.AsyncReadyCallback | null): void
    provideFileFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): { returnType: Handle, handleType: HandleType }
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): { returnType: boolean, actor: Contact | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetLocalPendingInfo(localPending: Handle): { returnType: boolean, actor: Handle | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: (($obj: FileTransferChannel, contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: (($obj: FileTransferChannel, added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: (($obj: FileTransferChannel, added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: (($obj: FileTransferChannel, message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: (($obj: FileTransferChannel, added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: FileTransferChannel, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: FileTransferChannel, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::date", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::date", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::date", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::date", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::date", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::description", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::description", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::description", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::file", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::file", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::file", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::filename", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::filename", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::filename", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initial-offset", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initial-offset", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initial-offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initial-offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initial-offset", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::mime-type", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::mime-type", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::mime-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service-name", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service-name", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::size", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::size", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::size", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::transferred-bytes", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::transferred-bytes", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::transferred-bytes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::transferred-bytes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::transferred-bytes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: FileTransferChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: FileTransferChannel_ConstructProps)
    _init (config?: FileTransferChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): FileTransferChannel
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): FileTransferChannel
    static getFeatureQuarkCore(): GLib.Quark
    static $gtype: GObject.Type
}
export interface HandleChannelsContext_ConstructProps extends GObject.Object_ConstructProps {
    account?: Account
    channels?: object[]
    connection?: Connection
    requestsSatisfied?: object[]
    userActionTime?: number
}
export class HandleChannelsContext {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.HandleChannelsContext */
    accept(): void
    delay(): void
    fail(error: GLib.Error): void
    getHandlerInfo(): GLib.HashTable
    getRequests(): ChannelRequest[]
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.HandleChannelsContext */
    connect(sigName: "done", callback: (($obj: HandleChannelsContext) => void)): number
    on(sigName: "done", callback: () => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "done", callback: () => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "done", callback: () => void): NodeJS.EventEmitter
    emit(sigName: "done"): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: HandleChannelsContext, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: HandleChannelsContext_ConstructProps)
    _init (config?: HandleChannelsContext_ConstructProps): void
    static $gtype: GObject.Type
}
export interface Message_ConstructProps extends GObject.Object_ConstructProps {
}
export class Message {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Message */
    appendPart(): number
    countParts(): number
    deleteKey(part: number, key: string): boolean
    deletePart(part: number): void
    destroy(): void
    dupPart(part: number): GLib.Variant
    getMessageType(): ChannelTextMessageType
    getPendingMessageId(): { returnType: number, valid: boolean }
    getReceivedTimestamp(): number
    getSentTimestamp(): number
    getSpecificToInterface(): string
    getSupersedes(): string
    getToken(): string
    isDeliveryReport(): boolean
    isMutable(): boolean
    isRescued(): boolean
    isScrollback(): boolean
    peek(part: number): GLib.HashTable
    refHandle(handleType: HandleType, handle: Handle): void
    set(part: number, key: string, source: any): void
    setBoolean(part: number, key: string, b: boolean): void
    setBytes(part: number, key: string, len: number, bytes?: object | null): void
    setHandle(part: number, key: string, handleType: HandleType, handleOr0: Handle): void
    setInt32(part: number, key: string, i: number): void
    setInt64(part: number, key: string, i: number): void
    setString(part: number, key: string, s: string): void
    setUint32(part: number, key: string, u: number): void
    setUint64(part: number, key: string, u: number): void
    setVariant(part: number, key: string, value: GLib.Variant): void
    takeMessage(part: number, key: string, message: Message): void
    toText(): { returnType: string, outFlags: ChannelTextMessageFlags }
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Message, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Message_ConstructProps)
    _init (config?: Message_ConstructProps): void
    static $gtype: GObject.Type
}
export interface ObserveChannelsContext_ConstructProps extends GObject.Object_ConstructProps {
    account?: Account
    channels?: object[]
    connection?: Connection
    dispatchOperation?: ChannelDispatchOperation
    requests?: object[]
}
export class ObserveChannelsContext {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ObserveChannelsContext */
    accept(): void
    delay(): void
    fail(error: GLib.Error): void
    getRequests(): ChannelRequest[]
    isRecovering(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: ObserveChannelsContext, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: ObserveChannelsContext_ConstructProps)
    _init (config?: ObserveChannelsContext_ConstructProps): void
    static $gtype: GObject.Type
}
export interface Protocol_ConstructProps extends Proxy_ConstructProps {
    cmName?: string
    protocolName?: string
}
export class Protocol {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Protocol */
    readonly addressableUriSchemes: string[]
    readonly addressableVcardFields: string[]
    readonly authenticationTypes: string[]
    readonly avatarRequirements: object
    readonly capabilities: Capabilities
    readonly englishName: string
    readonly iconName: string
    readonly paramNames: string[]
    readonly protocolPropertiesVardict: GLib.Variant
    readonly vcardField: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Protocol */
    canRegister(): boolean
    dupImmutableProperties(): GLib.Variant
    dupParam(param: string): ConnectionManagerParam
    dupParamNames(): string[]
    dupParams(): ConnectionManagerParam[]
    dupPresenceStatuses(): PresenceStatusSpec[]
    getAddressableUriSchemes(): string[]
    getAddressableVcardFields(): string[]
    getAuthenticationTypes(): string[]
    getAvatarRequirements(): AvatarRequirements
    getCapabilities(): Capabilities
    getCmName(): string
    getEnglishName(): string
    getIconName(): string
    getName(): string
    getParam(param: string): ConnectionManagerParam
    getVcardField(): string
    hasParam(param: string): boolean
    identifyAccountAsync(vardict: GLib.Variant, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    identifyAccountFinish(result: Gio.AsyncResult): string
    normalizeContactAsync(contact: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    normalizeContactFinish(result: Gio.AsyncResult): string
    normalizeContactUriAsync(uri: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    normalizeContactUriFinish(result: Gio.AsyncResult): string
    normalizeVcardAddressAsync(field: string, value: string, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    normalizeVcardAddressFinish(result: Gio.AsyncResult): string
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: Protocol, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: Protocol, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::addressable-uri-schemes", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addressable-uri-schemes", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::addressable-uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::addressable-uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::addressable-uri-schemes", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::addressable-vcard-fields", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::addressable-vcard-fields", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::addressable-vcard-fields", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::addressable-vcard-fields", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::addressable-vcard-fields", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::authentication-types", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::authentication-types", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::authentication-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::authentication-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::authentication-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::avatar-requirements", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::avatar-requirements", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::avatar-requirements", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::avatar-requirements", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::avatar-requirements", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::capabilities", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::capabilities", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::capabilities", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::english-name", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::english-name", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::english-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::english-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::english-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::icon-name", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::icon-name", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::icon-name", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::param-names", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::param-names", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::param-names", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::param-names", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::param-names", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::protocol-properties-vardict", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::protocol-properties-vardict", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::protocol-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::protocol-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::protocol-properties-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::vcard-field", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::vcard-field", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::vcard-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::vcard-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::vcard-field", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: Protocol, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Protocol_ConstructProps)
    _init (config?: Protocol_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, cmName: string, protocolName: string, immutableProperties: GLib.HashTable): Protocol
    static newVardict(dbus: DBusDaemon, cmName: string, protocolName: string, immutableProperties: GLib.Variant): Protocol
    static getFeatureQuarkCore(): GLib.Quark
    static getFeatureQuarkParameters(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface Proxy_ConstructProps extends GObject.Object_ConstructProps {
    busName?: string
    dbusDaemon?: DBusDaemon
    factory?: SimpleClientFactory
    objectPath?: string
}
export class Proxy {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: Proxy, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: Proxy, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: Proxy, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::interfaces", callback: (($obj: Proxy, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: Proxy, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: Proxy_ConstructProps)
    _init (config?: Proxy_ConstructProps): void
    static $gtype: GObject.Type
}
export interface RoomInfo_ConstructProps extends GObject.Object_ConstructProps {
}
export class RoomInfo {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.RoomInfo */
    getChannelType(): string
    getDescription(): string
    getHandle(): Handle
    getHandleName(): string
    getInviteOnly(known: boolean): boolean
    getMembersCount(known: boolean): number
    getName(): string
    getRequiresPassword(known: boolean): boolean
    getRoomId(): string
    getServer(): string
    getSubject(): string
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: RoomInfo, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: RoomInfo_ConstructProps)
    _init (config?: RoomInfo_ConstructProps): void
    static $gtype: GObject.Type
}
export interface RoomList_ConstructProps extends GObject.Object_ConstructProps {
    account?: Account
    server?: string
}
export class RoomList {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.RoomList */
    readonly listing: boolean
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.RoomList */
    getAccount(): Account
    getServer(): string
    isListing(): boolean
    start(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Methods of Gio-2.0.Gio.AsyncInitable */
    initAsync(ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    initFinish(res: Gio.AsyncResult): boolean
    newFinish(res: Gio.AsyncResult): GObject.Object
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.RoomList */
    connect(sigName: "failed", callback: (($obj: RoomList, error: GLib.Error) => void)): number
    on(sigName: "failed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "failed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "failed", callback: (error: GLib.Error) => void): NodeJS.EventEmitter
    emit(sigName: "failed", error: GLib.Error): void
    connect(sigName: "got-room", callback: (($obj: RoomList, room: RoomInfo) => void)): number
    on(sigName: "got-room", callback: (room: RoomInfo) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "got-room", callback: (room: RoomInfo) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "got-room", callback: (room: RoomInfo) => void): NodeJS.EventEmitter
    emit(sigName: "got-room", room: RoomInfo): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: RoomList, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::listing", callback: (($obj: RoomList, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::listing", callback: (($obj: RoomList, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::listing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::listing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::listing", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: RoomList_ConstructProps)
    _init (config?: RoomList_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static newFinish(result: Gio.AsyncResult): RoomList
    static newAsync(account: Account, server: string, callback?: Gio.AsyncReadyCallback | null): void
    static newvAsync(objectType: GObject.Type, nParameters: number, parameters: GObject.Parameter, ioPriority: number, cancellable?: Gio.Cancellable | null, callback?: Gio.AsyncReadyCallback | null): void
    static $gtype: GObject.Type
}
export interface SignalledMessage_ConstructProps extends Message_ConstructProps {
    sender?: Contact
}
export class SignalledMessage {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Message */
    appendPart(): number
    countParts(): number
    deleteKey(part: number, key: string): boolean
    deletePart(part: number): void
    destroy(): void
    dupPart(part: number): GLib.Variant
    getMessageType(): ChannelTextMessageType
    getPendingMessageId(): { returnType: number, valid: boolean }
    getReceivedTimestamp(): number
    getSentTimestamp(): number
    getSpecificToInterface(): string
    getSupersedes(): string
    getToken(): string
    isDeliveryReport(): boolean
    isMutable(): boolean
    isRescued(): boolean
    isScrollback(): boolean
    peek(part: number): GLib.HashTable
    refHandle(handleType: HandleType, handle: Handle): void
    set(part: number, key: string, source: any): void
    setBoolean(part: number, key: string, b: boolean): void
    setBytes(part: number, key: string, len: number, bytes?: object | null): void
    setHandle(part: number, key: string, handleType: HandleType, handleOr0: Handle): void
    setInt32(part: number, key: string, i: number): void
    setInt64(part: number, key: string, i: number): void
    setString(part: number, key: string, s: string): void
    setUint32(part: number, key: string, u: number): void
    setUint64(part: number, key: string, u: number): void
    setVariant(part: number, key: string, value: GLib.Variant): void
    takeMessage(part: number, key: string, message: Message): void
    toText(): { returnType: string, outFlags: ChannelTextMessageFlags }
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: SignalledMessage, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SignalledMessage_ConstructProps)
    _init (config?: SignalledMessage_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static getSender(message: Message): Contact
    static $gtype: GObject.Type
}
export interface SimpleApprover_ConstructProps extends BaseClient_ConstructProps {
    callback?: object
    destroy?: object
    userData?: object
}
export class SimpleApprover {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): { returnType: boolean, delegated: Channel[], notDelegated: GLib.HashTable }
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: (($obj: SimpleApprover, account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: (($obj: SimpleApprover, request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: SimpleApprover, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleApprover_ConstructProps)
    _init (config?: SimpleApprover_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, name: string, uniquify: boolean, callback: SimpleApproverAddDispatchOperationImpl): SimpleApprover
    static newWithAm(accountManager: AccountManager, name: string, uniquify: boolean, callback: SimpleApproverAddDispatchOperationImpl): SimpleApprover
    static newWithFactory(factory: SimpleClientFactory, name: string, uniquify: boolean, callback: SimpleApproverAddDispatchOperationImpl): SimpleApprover
    static $gtype: GObject.Type
}
export interface SimpleClientFactory_ConstructProps extends GObject.Object_ConstructProps {
    dbusDaemon?: DBusDaemon
}
export class SimpleClientFactory {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.SimpleClientFactory */
    addAccountFeatures(features?: GLib.Quark[] | null): void
    addChannelFeatures(features?: GLib.Quark[] | null): void
    addConnectionFeatures(features?: GLib.Quark[] | null): void
    addContactFeatures(features?: ContactFeature[] | null): void
    dupAccountFeatures(account: Account): GLib.Quark[]
    dupChannelFeatures(channel: Channel): GLib.Quark[]
    dupConnectionFeatures(connection: Connection): GLib.Quark[]
    dupContactFeatures(connection: Connection): ContactFeature[]
    ensureAccount(objectPath: string, immutableProperties: GLib.HashTable): Account
    ensureChannel(connection: Connection, objectPath: string, immutableProperties: GLib.HashTable): Channel
    ensureConnection(objectPath: string, immutableProperties: GLib.HashTable): Connection
    ensureContact(connection: Connection, handle: Handle, identifier: string): Contact
    ensureContactByIdAsync(connection: Connection, identifier: string, callback?: Gio.AsyncReadyCallback | null): void
    ensureContactByIdFinish(result: Gio.AsyncResult): Contact
    getDbusDaemon(): DBusDaemon
    upgradeContactsAsync(connection: Connection, contacts: Contact[], callback?: Gio.AsyncReadyCallback | null): void
    upgradeContactsFinish(result: Gio.AsyncResult): { returnType: boolean, contacts: Contact[] | null }
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: SimpleClientFactory, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleClientFactory_ConstructProps)
    _init (config?: SimpleClientFactory_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus?: DBusDaemon | null): SimpleClientFactory
    static $gtype: GObject.Type
}
export interface SimpleHandler_ConstructProps extends BaseClient_ConstructProps {
    bypassApproval?: boolean
    callback?: object
    destroy?: object
    requests?: boolean
    userData?: object
}
export class SimpleHandler {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): { returnType: boolean, delegated: Channel[], notDelegated: GLib.HashTable }
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: (($obj: SimpleHandler, account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: (($obj: SimpleHandler, request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: SimpleHandler, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleHandler_ConstructProps)
    _init (config?: SimpleHandler_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, bypassApproval: boolean, requests: boolean, name: string, uniquify: boolean, callback: SimpleHandlerHandleChannelsImpl): SimpleHandler
    static newWithAm(accountManager: AccountManager, bypassApproval: boolean, requests: boolean, name: string, uniquify: boolean, callback: SimpleHandlerHandleChannelsImpl): SimpleHandler
    static newWithFactory(factory: SimpleClientFactory, bypassApproval: boolean, requests: boolean, name: string, uniquify: boolean, callback: SimpleHandlerHandleChannelsImpl): SimpleHandler
    static $gtype: GObject.Type
}
export interface SimpleObserver_ConstructProps extends BaseClient_ConstructProps {
    callback?: object
    destroy?: object
    recover?: boolean
    userData?: object
}
export class SimpleObserver {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    addAccountFeatures(features: GLib.Quark[]): void
    addApproverFilter(filter: GLib.HashTable): void
    addApproverFilterVardict(filter: GLib.Variant): void
    addChannelFeatures(features: GLib.Quark[]): void
    addConnectionFeatures(features: GLib.Quark[]): void
    addHandlerCapabilities(tokens: string[]): void
    addHandlerCapability(token: string): void
    addHandlerFilter(filter: GLib.HashTable): void
    addHandlerFilterVardict(filter: GLib.Variant): void
    addObserverFilter(filter: GLib.HashTable): void
    addObserverFilterVardict(filter: GLib.Variant): void
    beAHandler(): void
    delegateChannelsAsync(channels: Channel[], userActionTime: number, preferredHandler: string, callback?: Gio.AsyncReadyCallback | null): void
    delegateChannelsFinish(result: Gio.AsyncResult): { returnType: boolean, delegated: Channel[], notDelegated: GLib.HashTable }
    dupHandledChannels(): Channel[]
    dupPendingRequests(): ChannelRequest[]
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getHandledChannels(): Channel[]
    getName(): string
    getObjectPath(): string
    getPendingRequests(): ChannelRequest[]
    getUniquifyName(): boolean
    isHandlingChannel(channel: Channel): boolean
    register(): boolean
    setChannelFactory(factory: ClientChannelFactory): void
    setDelegatedChannelsCallback(callback: BaseClientDelegatedChannelsCb): void
    setHandlerBypassApproval(bypassApproval: boolean): void
    setHandlerRequestNotification(): void
    setObserverDelayApprovers(delay: boolean): void
    setObserverRecover(recover: boolean): void
    unregister(): void
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.BaseClient */
    connect(sigName: "request-added", callback: (($obj: SimpleObserver, account: Account, request: ChannelRequest) => void)): number
    on(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-added", callback: (account: Account, request: ChannelRequest) => void): NodeJS.EventEmitter
    emit(sigName: "request-added", account: Account, request: ChannelRequest): void
    connect(sigName: "request-removed", callback: (($obj: SimpleObserver, request: ChannelRequest, error: string, message: string) => void)): number
    on(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "request-removed", callback: (request: ChannelRequest, error: string, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "request-removed", request: ChannelRequest, error: string, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: SimpleObserver, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: SimpleObserver_ConstructProps)
    _init (config?: SimpleObserver_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(dbus: DBusDaemon, recover: boolean, name: string, uniquify: boolean, callback: SimpleObserverObserveChannelsImpl): SimpleObserver
    static newWithAm(accountManager: AccountManager, recover: boolean, name: string, uniquify: boolean, callback: SimpleObserverObserveChannelsImpl): SimpleObserver
    static newWithFactory(factory: SimpleClientFactory, recover: boolean, name: string, uniquify: boolean, callback: SimpleObserverObserveChannelsImpl): SimpleObserver
    static $gtype: GObject.Type
}
export interface StreamTubeChannel_ConstructProps extends Channel_ConstructProps {
}
export class StreamTubeChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.StreamTubeChannel */
    readonly parametersVardict: GLib.Variant
    readonly service: string
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.StreamTubeChannel */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): StreamTubeConnection
    dupParametersVardict(): GLib.Variant
    getService(): string
    offerAsync(params?: GLib.HashTable | null, callback?: Gio.AsyncReadyCallback | null): void
    offerFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): { returnType: Handle, handleType: HandleType }
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): { returnType: boolean, actor: Contact | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetLocalPendingInfo(localPending: Handle): { returnType: boolean, actor: Handle | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.StreamTubeChannel */
    connect(sigName: "incoming", callback: (($obj: StreamTubeChannel, tubeConnection: StreamTubeConnection) => void)): number
    on(sigName: "incoming", callback: (tubeConnection: StreamTubeConnection) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "incoming", callback: (tubeConnection: StreamTubeConnection) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "incoming", callback: (tubeConnection: StreamTubeConnection) => void): NodeJS.EventEmitter
    emit(sigName: "incoming", tubeConnection: StreamTubeConnection): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: (($obj: StreamTubeChannel, contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: (($obj: StreamTubeChannel, added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: (($obj: StreamTubeChannel, added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: (($obj: StreamTubeChannel, message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: (($obj: StreamTubeChannel, added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: StreamTubeChannel, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: StreamTubeChannel, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::parameters-vardict", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::parameters-vardict", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::parameters-vardict", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::service", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::service", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::service", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: StreamTubeChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: StreamTubeChannel_ConstructProps)
    _init (config?: StreamTubeChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): StreamTubeChannel
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): StreamTubeChannel
    static $gtype: GObject.Type
}
export interface StreamTubeConnection_ConstructProps extends GObject.Object_ConstructProps {
    channel?: StreamTubeChannel
    contact?: Contact
    socketConnection?: Gio.SocketConnection
}
export class StreamTubeConnection {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.StreamTubeConnection */
    getChannel(): StreamTubeChannel
    getContact(): Contact
    getSocketConnection(): Gio.SocketConnection
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.StreamTubeConnection */
    connect(sigName: "closed", callback: (($obj: StreamTubeConnection, error: GLib.Error) => void)): number
    on(sigName: "closed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "closed", callback: (error: GLib.Error) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "closed", callback: (error: GLib.Error) => void): NodeJS.EventEmitter
    emit(sigName: "closed", error: GLib.Error): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: StreamTubeConnection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: StreamTubeConnection_ConstructProps)
    _init (config?: StreamTubeConnection_ConstructProps): void
    static $gtype: GObject.Type
}
export interface TLSCertificate_ConstructProps extends Proxy_ConstructProps {
    parent?: Proxy
}
export class TLSCertificate {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.TLSCertificate */
    readonly certData: object[]
    readonly certType: string
    readonly state: number
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.TLSCertificate */
    acceptAsync(callback?: Gio.AsyncReadyCallback | null): void
    acceptFinish(result: Gio.AsyncResult): boolean
    addRejection(reason: TLSCertificateRejectReason, dbusError: string, details?: GLib.Variant | null): void
    getCertData(): any[]
    getCertType(): string
    getNthRejection(n: number): TLSCertificateRejection | null
    getRejection(): TLSCertificateRejection | null
    getState(): TLSCertificateState
    rejectAsync(callback?: Gio.AsyncReadyCallback | null): void
    rejectFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: TLSCertificate, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: TLSCertificate, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::cert-data", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cert-data", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cert-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cert-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cert-data", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::cert-type", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::cert-type", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::cert-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::cert-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::cert-type", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::state", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::state", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::state", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: TLSCertificate, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TLSCertificate_ConstructProps)
    _init (config?: TLSCertificate_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(connOrChan: Proxy, objectPath: string): TLSCertificate
    static getFeatureQuarkCore(): GLib.Quark
    static initKnownInterfaces(): void
    static $gtype: GObject.Type
}
export interface TLSCertificateRejection_ConstructProps extends GObject.Object_ConstructProps {
    dbusError?: string
    details?: GLib.Variant
    error?: GLib.Error
    reason?: number
}
export class TLSCertificateRejection {
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.TLSCertificateRejection */
    getDbusError(): string
    getDetails(): GLib.Variant
    getError(): GLib.Error
    getReason(): TLSCertificateRejectReason
    raiseError(): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: TLSCertificateRejection, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TLSCertificateRejection_ConstructProps)
    _init (config?: TLSCertificateRejection_ConstructProps): void
    static $gtype: GObject.Type
}
export interface TextChannel_ConstructProps extends Channel_ConstructProps {
}
export class TextChannel {
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.TextChannel */
    readonly deliveryReportingSupport: number
    readonly isSmsChannel: boolean
    readonly messagePartSupportFlags: number
    readonly smsFlash: boolean
    readonly supportedContentTypes: string[]
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Channel */
    readonly channelReady: boolean
    readonly groupFlags: number
    readonly groupSelfContact: Contact
    readonly groupSelfHandle: number
    readonly identifier: string
    readonly initiatorContact: Contact
    readonly initiatorHandle: number
    readonly initiatorIdentifier: string
    readonly passwordNeeded: boolean
    readonly requested: boolean
    readonly targetContact: Contact
    /* Properties of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    readonly interfaces: string[]
    /* Fields of GObject-2.0.GObject.Object */
    gTypeInstance: GObject.TypeInstance
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.TextChannel */
    ackAllPendingMessagesAsync(callback?: Gio.AsyncReadyCallback | null): void
    ackAllPendingMessagesFinish(result: Gio.AsyncResult): boolean
    ackMessageAsync(message: Message, callback?: Gio.AsyncReadyCallback | null): void
    ackMessageFinish(result: Gio.AsyncResult): boolean
    ackMessagesAsync(messages: SignalledMessage[], callback?: Gio.AsyncReadyCallback | null): void
    ackMessagesFinish(result: Gio.AsyncResult): boolean
    dupPendingMessages(): SignalledMessage[]
    getChatState(contact: Contact): ChannelChatState
    getDeliveryReportingSupport(): DeliveryReportingSupportFlags
    getMessagePartSupportFlags(): MessagePartSupportFlags
    getMessageTypes(): ChannelTextMessageType[]
    getPendingMessages(): SignalledMessage[]
    getSmsFlash(): boolean
    getSmsLengthAsync(message: Message, callback?: Gio.AsyncReadyCallback | null): void
    getSmsLengthFinish(result: Gio.AsyncResult): { returnType: boolean, chunksRequired: number, remainingCharacters: number, estimatedCost: number }
    getSupportedContentTypes(): string[]
    sendMessageAsync(message: Message, flags: MessageSendingFlags, callback?: Gio.AsyncReadyCallback | null): void
    sendMessageFinish(result: Gio.AsyncResult): { returnType: boolean, token: string }
    setChatStateAsync(state: ChannelChatState, callback?: Gio.AsyncReadyCallback | null): void
    setChatStateFinish(result: Gio.AsyncResult): boolean
    supportsMessageType(messageType: ChannelTextMessageType): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Channel */
    borrowConnection(): Connection
    borrowImmutableProperties(): GLib.HashTable
    closeAsync(callback?: Gio.AsyncReadyCallback | null): void
    closeFinish(result: Gio.AsyncResult): boolean
    destroyAsync(callback?: Gio.AsyncReadyCallback | null): void
    destroyFinish(result: Gio.AsyncResult): boolean
    dupImmutableProperties(): GLib.Variant
    getChannelType(): string
    getChannelTypeId(): GLib.Quark
    getChatState(contact: Handle): ChannelChatState
    getConnection(): Connection
    getHandle(): { returnType: Handle, handleType: HandleType }
    getIdentifier(): string
    getInitiatorContact(): Contact
    getRequested(): boolean
    getTargetContact(): Contact
    groupDupLocalPendingContacts(): Contact[]
    groupDupMembersContacts(): Contact[]
    groupDupRemotePendingContacts(): Contact[]
    groupGetContactOwner(contact: Contact): Contact
    groupGetFlags(): ChannelGroupFlags
    groupGetHandleOwner(handle: Handle): Handle
    groupGetLocalPending(): Intset
    groupGetLocalPendingContactInfo(localPending: Contact): { returnType: boolean, actor: Contact | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetLocalPendingInfo(localPending: Handle): { returnType: boolean, actor: Handle | null, reason: ChannelGroupChangeReason | null, message: string | null }
    groupGetMembers(): Intset
    groupGetRemotePending(): Intset
    groupGetSelfContact(): Contact
    groupGetSelfHandle(): Handle
    joinAsync(message: string, callback?: Gio.AsyncReadyCallback | null): void
    joinFinish(result: Gio.AsyncResult): boolean
    leaveAsync(reason: ChannelGroupChangeReason, message: string, callback?: Gio.AsyncReadyCallback | null): void
    leaveFinish(result: Gio.AsyncResult): boolean
    providePasswordAsync(password: string, callback?: Gio.AsyncReadyCallback | null): void
    providePasswordFinish(result: Gio.AsyncResult): boolean
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    dbusErrorToGerror(dbusError: string, debugMessage: string): void
    getBusName(): string
    getDbusDaemon(): DBusDaemon
    getFactory(): SimpleClientFactory
    getInvalidated(): GLib.Error
    getObjectPath(): string
    hasInterface(iface: string): boolean
    hasInterfaceById(iface: GLib.Quark): boolean
    isPrepared(feature: GLib.Quark): boolean
    prepareAsync(features?: GLib.Quark[] | null, callback?: Gio.AsyncReadyCallback | null): void
    prepareFinish(result: Gio.AsyncResult): boolean
    /* Methods of GObject-2.0.GObject.Object */
    bindProperty(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags): GObject.Binding
    bindPropertyFull(sourceProperty: string, target: GObject.Object, targetProperty: string, flags: GObject.BindingFlags, transformTo: Function, transformFrom: Function): GObject.Binding
    forceFloating(): void
    freezeNotify(): void
    getData(key: string): object | null
    getProperty(propertyName: string, value: any): void
    getQdata(quark: GLib.Quark): object | null
    getv(names: string[], values: any[]): void
    isFloating(): boolean
    notify(propertyName: string): void
    notifyByPspec(pspec: GObject.ParamSpec): void
    ref(): GObject.Object
    refSink(): GObject.Object
    runDispose(): void
    setData(key: string, data?: object | null): void
    setProperty(propertyName: string, value: any): void
    stealData(key: string): object | null
    stealQdata(quark: GLib.Quark): object | null
    thawNotify(): void
    unref(): void
    watchClosure(closure: Function): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.TextChannel */
    connect(sigName: "contact-chat-state-changed", callback: (($obj: TextChannel, contact: Contact, state: number) => void)): number
    on(sigName: "contact-chat-state-changed", callback: (contact: Contact, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "contact-chat-state-changed", callback: (contact: Contact, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "contact-chat-state-changed", callback: (contact: Contact, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "contact-chat-state-changed", contact: Contact, state: number): void
    connect(sigName: "message-received", callback: (($obj: TextChannel, message: SignalledMessage) => void)): number
    on(sigName: "message-received", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "message-received", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "message-received", callback: (message: SignalledMessage) => void): NodeJS.EventEmitter
    emit(sigName: "message-received", message: SignalledMessage): void
    connect(sigName: "message-sent", callback: (($obj: TextChannel, message: SignalledMessage, flags: number, token: string) => void)): number
    on(sigName: "message-sent", callback: (message: SignalledMessage, flags: number, token: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "message-sent", callback: (message: SignalledMessage, flags: number, token: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "message-sent", callback: (message: SignalledMessage, flags: number, token: string) => void): NodeJS.EventEmitter
    emit(sigName: "message-sent", message: SignalledMessage, flags: number, token: string): void
    connect(sigName: "pending-message-removed", callback: (($obj: TextChannel, message: SignalledMessage) => void)): number
    on(sigName: "pending-message-removed", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "pending-message-removed", callback: (message: SignalledMessage) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "pending-message-removed", callback: (message: SignalledMessage) => void): NodeJS.EventEmitter
    emit(sigName: "pending-message-removed", message: SignalledMessage): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Channel */
    connect(sigName: "chat-state-changed", callback: (($obj: TextChannel, contact: number, state: number) => void)): number
    on(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "chat-state-changed", callback: (contact: number, state: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "chat-state-changed", callback: (contact: number, state: number) => void): NodeJS.EventEmitter
    emit(sigName: "chat-state-changed", contact: number, state: number): void
    connect(sigName: "group-contacts-changed", callback: (($obj: TextChannel, added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void)): number
    on(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-contacts-changed", callback: (added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-contacts-changed", added: Contact[], removed: Contact[], localPending: Contact[], remotePending: Contact[], actor: Contact, details: GLib.HashTable): void
    connect(sigName: "group-flags-changed", callback: (($obj: TextChannel, added: number, removed: number) => void)): number
    on(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-flags-changed", callback: (added: number, removed: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-flags-changed", callback: (added: number, removed: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-flags-changed", added: number, removed: number): void
    connect(sigName: "group-members-changed", callback: (($obj: TextChannel, message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void)): number
    on(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed", callback: (message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed", message: string, added: any, removed: any, localPending: any, remotePending: any, actor: number, reason: number): void
    connect(sigName: "group-members-changed-detailed", callback: (($obj: TextChannel, added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void)): number
    on(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "group-members-changed-detailed", callback: (added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable) => void): NodeJS.EventEmitter
    emit(sigName: "group-members-changed-detailed", added: number[], removed: number[], localPending: number[], remotePending: number[], details: GLib.HashTable): void
    /* Signals of TelepathyGLib-0.12.TelepathyGLib.Proxy */
    connect(sigName: "interface-added", callback: (($obj: TextChannel, id: number, proxy: any) => void)): number
    on(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "interface-added", callback: (id: number, proxy: any) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "interface-added", callback: (id: number, proxy: any) => void): NodeJS.EventEmitter
    emit(sigName: "interface-added", id: number, proxy: any): void
    connect(sigName: "invalidated", callback: (($obj: TextChannel, domain: number, code: number, message: string) => void)): number
    on(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "invalidated", callback: (domain: number, code: number, message: string) => void): NodeJS.EventEmitter
    emit(sigName: "invalidated", domain: number, code: number, message: string): void
    /* Signals of GObject-2.0.GObject.Object */
    connect(sigName: "notify", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    once(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void, after?: boolean): NodeJS.EventEmitter
    off(sigName: "notify", callback: (pspec: GObject.ParamSpec) => void): NodeJS.EventEmitter
    emit(sigName: "notify", pspec: GObject.ParamSpec): void
    connect(sigName: "notify::delivery-reporting-support", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::delivery-reporting-support", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::delivery-reporting-support", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::delivery-reporting-support", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::delivery-reporting-support", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::is-sms-channel", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::is-sms-channel", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::is-sms-channel", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::is-sms-channel", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::is-sms-channel", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::message-part-support-flags", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::message-part-support-flags", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::message-part-support-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::message-part-support-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::message-part-support-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::sms-flash", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::sms-flash", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::sms-flash", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::sms-flash", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::sms-flash", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::supported-content-types", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::supported-content-types", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::supported-content-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::supported-content-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::supported-content-types", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::channel-ready", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::channel-ready", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::channel-ready", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-flags", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-flags", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-flags", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-contact", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-contact", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::group-self-handle", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::group-self-handle", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::group-self-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::identifier", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::identifier", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-contact", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-contact", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-handle", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-handle", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-handle", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::initiator-identifier", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::initiator-identifier", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::initiator-identifier", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::password-needed", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::password-needed", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::password-needed", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::requested", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::requested", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::requested", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::target-contact", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::target-contact", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::target-contact", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: "notify::interfaces", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    connect_after(sigName: "notify::interfaces", callback: (($obj: TextChannel, pspec: GObject.ParamSpec) => void)): number
    on(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    once(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    off(sigName: "notify::interfaces", callback: (...args: any[]) => void): NodeJS.EventEmitter
    connect(sigName: string, callback: any): number
    connect_after(sigName: string, callback: any): number
    emit(sigName: string, ...args: any[]): void
    disconnect(id: number): void
    on(sigName: string, callback: any): NodeJS.EventEmitter
    once(sigName: string, callback: any): NodeJS.EventEmitter
    off(sigName: string, callback: any): NodeJS.EventEmitter
    static name: string
    constructor (config?: TextChannel_ConstructProps)
    _init (config?: TextChannel_ConstructProps): void
    /* Static methods and pseudo-constructors */
    static new(conn: Connection, objectPath: string, immutableProperties: GLib.HashTable): TextChannel
    static new(conn: Connection, objectPath: string, optionalChannelType: string, optionalHandleType: HandleType, optionalHandle: Handle): TextChannel
    static getFeatureQuarkChatStates(): GLib.Quark
    static getFeatureQuarkIncomingMessages(): GLib.Quark
    static getFeatureQuarkSms(): GLib.Quark
    static $gtype: GObject.Type
}
export abstract class AccountChannelRequestClass {
    static name: string
}
export class AccountChannelRequestPrivate {
    static name: string
}
export abstract class AccountClass {
    static name: string
}
export class AccountClassPrivate {
    static name: string
}
export abstract class AccountManagerClass {
    static name: string
}
export class AccountManagerClassPrivate {
    static name: string
}
export class AccountManagerPrivate {
    static name: string
}
export class AccountPrivate {
    static name: string
}
export abstract class AccountRequestClass {
    static name: string
}
export class AccountRequestPrivate {
    static name: string
}
export abstract class AddDispatchOperationContextClass {
    static name: string
}
export class AddDispatchOperationContextPrivate {
    static name: string
}
export abstract class AutomaticClientFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.AutomaticClientFactoryClass */
    parentClass: SimpleClientFactoryClass
    static name: string
}
export abstract class AutomaticProxyFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.AutomaticProxyFactoryClass */
    parentClass: GObject.ObjectClass
    static name: string
}
export class AvatarRequirements {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.AvatarRequirements */
    supportedMimeTypes: string[]
    minimumWidth: number
    minimumHeight: number
    recommendedWidth: number
    recommendedHeight: number
    maximumWidth: number
    maximumHeight: number
    maximumBytes: number
    static name: string
    static new(supportedMimeTypes: string[], minimumWidth: number, minimumHeight: number, recommendedWidth: number, recommendedHeight: number, maximumWidth: number, maximumHeight: number, maximumBytes: number): AvatarRequirements
    constructor(supportedMimeTypes: string[], minimumWidth: number, minimumHeight: number, recommendedWidth: number, recommendedHeight: number, maximumWidth: number, maximumHeight: number, maximumBytes: number)
    /* Static methods and pseudo-constructors */
    static new(supportedMimeTypes: string[], minimumWidth: number, minimumHeight: number, recommendedWidth: number, recommendedHeight: number, maximumWidth: number, maximumHeight: number, maximumBytes: number): AvatarRequirements
}
export abstract class BaseClientClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.BaseClientClass */
    parentClass: GObject.ObjectClass
    observeChannels: BaseClientClassObserveChannelsImpl
    addDispatchOperation: BaseClientClassAddDispatchOperationImpl
    handleChannels: BaseClientClassHandleChannelsImpl
    static name: string
}
export class BaseClientClassPrivate {
    static name: string
}
export class BaseClientPrivate {
    static name: string
}
export abstract class BaseConnectionClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.BaseConnectionClass */
    parentClass: GObject.ObjectClass
    getUniqueConnectionName: BaseConnectionGetUniqueConnectionNameImpl
    connecting: BaseConnectionProc
    connected: BaseConnectionProc
    disconnected: BaseConnectionProc
    shutDown: BaseConnectionProc
    startConnecting: BaseConnectionStartConnectingImpl
    static name: string
}
export class BaseConnectionPrivate {
    static name: string
}
export abstract class BasicProxyFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.BasicProxyFactoryClass */
    parentClass: GObject.ObjectClass
    static name: string
}
export abstract class CallChannelClass {
    static name: string
}
export class CallChannelPrivate {
    static name: string
}
export abstract class CallContentClass {
    static name: string
}
export class CallContentPrivate {
    static name: string
}
export class CallStateReason {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.CallStateReason */
    actor: Handle
    reason: CallStateChangeReason
    dbusReason: string
    message: string
    static name: string
}
export abstract class CallStreamClass {
    static name: string
}
export class CallStreamPrivate {
    static name: string
}
export abstract class CapabilitiesClass {
    static name: string
}
export class CapabilitiesPrivate {
    static name: string
}
export abstract class ChannelClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ChannelClass */
    parentClass: ProxyClass
    static name: string
}
export abstract class ChannelDispatchOperationClass {
    static name: string
}
export class ChannelDispatchOperationClassPrivate {
    static name: string
}
export class ChannelDispatchOperationPrivate {
    static name: string
}
export abstract class ChannelDispatcherClass {
    static name: string
}
export class ChannelDispatcherClassPrivate {
    static name: string
}
export class ChannelDispatcherPrivate {
    static name: string
}
export class ChannelManagerIter {
    static name: string
}
export class ChannelPrivate {
    static name: string
}
export abstract class ChannelRequestClass {
    static name: string
}
export class ChannelRequestClassPrivate {
    static name: string
}
export class ChannelRequestPrivate {
    static name: string
}
export abstract class ClientChannelFactoryInterface {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ClientChannelFactoryInterface */
    parent: GObject.TypeInterface
    static name: string
}
export abstract class ClientMessageClass {
    static name: string
}
export abstract class ConnectionClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ConnectionClass */
    parentClass: ProxyClass
    static name: string
}
export abstract class ConnectionManagerClass {
    static name: string
}
export class ConnectionManagerParam {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ConnectionManagerParam */
    copy(): ConnectionManagerParam
    dupDefaultVariant(): GLib.Variant
    dupVariantType(): GLib.VariantType
    free(): void
    getDbusSignature(): string
    getDefault(value: any): boolean
    getName(): string
    isDbusProperty(): boolean
    isRequired(): boolean
    isRequiredForRegistration(): boolean
    isSecret(): boolean
    static name: string
}
export class ConnectionManagerPrivate {
    static name: string
}
export class ConnectionManagerProtocol {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ConnectionManagerProtocol */
    name: string
    params: ConnectionManagerParam
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ConnectionManagerProtocol */
    canRegister(): boolean
    copy(): ConnectionManagerProtocol
    dupParamNames(): string[]
    free(): void
    getParam(param: string): ConnectionManagerParam
    hasParam(param: string): boolean
    static name: string
}
export class ConnectionPrivate {
    static name: string
}
export abstract class ContactClass {
    static name: string
}
export class ContactInfoField {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ContactInfoField */
    fieldName: string
    parameters: string[]
    fieldValue: string[]
    static name: string
    static new(fieldName: string, parameters: string[], fieldValue: string[]): ContactInfoField
    constructor(fieldName: string, parameters: string[], fieldValue: string[])
    /* Static methods and pseudo-constructors */
    static new(fieldName: string, parameters: string[], fieldValue: string[]): ContactInfoField
}
export class ContactInfoFieldSpec {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ContactInfoFieldSpec */
    name: string
    parameters: string[]
    flags: ContactInfoFieldFlags
    max: number
    static name: string
}
export class ContactPrivate {
    static name: string
}
export abstract class ContactSearchClass {
    static name: string
}
export class ContactSearchPrivate {
    static name: string
}
export abstract class ContactSearchResultClass {
    static name: string
}
export class ContactSearchResultPrivate {
    static name: string
}
export class ContactsMixin {
    static name: string
}
export class ContactsMixinClass {
    static name: string
}
export class ContactsMixinClassPrivate {
    static name: string
}
export class ContactsMixinPrivate {
    static name: string
}
export abstract class DBusDaemonClass {
    static name: string
}
export class DBusDaemonPrivate {
    static name: string
}
export class DBusPropertiesMixinClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinClass */
    interfaces: DBusPropertiesMixinIfaceImpl
    static name: string
    /* Static methods and pseudo-constructors */
    static init(cls: GObject.ObjectClass, offset: number): void
}
export class DBusPropertiesMixinIfaceImpl {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinIfaceImpl */
    name: string
    getter: DBusPropertiesMixinGetter
    setter: DBusPropertiesMixinSetter
    props: DBusPropertiesMixinPropImpl
    static name: string
}
export class DBusPropertiesMixinIfaceInfo {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinIfaceInfo */
    dbusInterface: GLib.Quark
    props: DBusPropertiesMixinPropInfo
    static name: string
}
export class DBusPropertiesMixinPropImpl {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinPropImpl */
    name: string
    getterData: object
    setterData: object
    static name: string
}
export class DBusPropertiesMixinPropInfo {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.DBusPropertiesMixinPropInfo */
    name: GLib.Quark
    flags: DBusPropertiesMixinFlags
    dbusSignature: string
    type: GObject.Type
    static name: string
}
export abstract class DBusTubeChannelClass {
    static name: string
}
export class DBusTubeChannelPrivate {
    static name: string
}
export abstract class DebugClientClass {
    static name: string
}
export class DebugClientPrivate {
    static name: string
}
export abstract class DebugMessageClass {
    static name: string
}
export class DebugMessagePriv {
    static name: string
}
export abstract class FileTransferChannelClass {
    static name: string
}
export class FileTransferChannelPrivate {
    static name: string
}
export class GroupMixin {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.GroupMixin */
    handleRepo: HandleRepoIface
    selfHandle: Handle
    groupFlags: ChannelGroupFlags
    members: HandleSet
    localPending: HandleSet
    remotePending: HandleSet
    priv: GroupMixinPrivate
    static name: string
}
export class GroupMixinClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.GroupMixinClass */
    addMember: GroupMixinAddMemberFunc
    removeMember: GroupMixinRemMemberFunc
    priv: GroupMixinClassPrivate
    static name: string
}
export class GroupMixinClassPrivate {
    static name: string
}
export class GroupMixinPrivate {
    static name: string
}
export abstract class HandleChannelsContextClass {
    static name: string
}
export class HandleChannelsContextPrivate {
    static name: string
}
export class HandleRepoIfaceClass {
    static name: string
}
export class HandleSet {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.HandleSet */
    dump(): string
    toIdentifierMap(): GLib.HashTable
    static name: string
}
export class Intset {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.Intset */
    add(element: number): void
    clear(): void
    copy(): Intset
    destroy(): void
    difference(right: Intset): Intset
    differenceUpdate(other: Intset): void
    dump(): string
    foreach(func: IntFunc): void
    intersection(right: Intset): Intset
    isEmpty(): boolean
    isEqual(right: Intset): boolean
    isMember(element: number): boolean
    remove(element: number): boolean
    size(): number
    symmetricDifference(right: Intset): Intset
    toArray(): number[]
    union(right: Intset): Intset
    unionUpdate(other: Intset): void
    static name: string
    static new(): Intset
    constructor()
    /* Static methods and pseudo-constructors */
    static new(): Intset
    static newContaining(element: number): Intset
    static sizedNew(size: number): Intset
    static fromArray(array: number[]): Intset
}
export class IntsetFastIter {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.IntsetFastIter */
    init(set: Intset): void
    next(output: number): boolean
    static name: string
}
export class IntsetIter {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.IntsetIter */
    set: Intset
    element: number
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.IntsetIter */
    init(set: Intset): void
    next(): boolean
    reset(): void
    static name: string
}
export abstract class MessageClass {
    static name: string
}
export abstract class ObserveChannelsContextClass {
    static name: string
}
export class ObserveChannelsContextPrivate {
    static name: string
}
export class PresenceMixin {
    static name: string
}
export class PresenceMixinClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceMixinClass */
    statusAvailable: PresenceMixinStatusAvailableFunc
    setOwnStatus: PresenceMixinSetOwnStatusFunc
    statuses: PresenceStatusSpec
    getMaximumStatusMessageLength: PresenceMixinGetMaximumStatusMessageLengthFunc
    static name: string
}
export class PresenceMixinClassPrivate {
    static name: string
}
export class PresenceMixinPrivate {
    static name: string
}
export class PresenceStatus {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceStatus */
    index: number
    optionalArguments: GLib.HashTable
    static name: string
}
export class PresenceStatusOptionalArgumentSpec {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceStatusOptionalArgumentSpec */
    name: string
    dtype: string
    static name: string
}
export class PresenceStatusSpec {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.PresenceStatusSpec */
    name: string
    presenceType: ConnectionPresenceType
    self: boolean
    optionalArguments: PresenceStatusOptionalArgumentSpec
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.PresenceStatusSpec */
    canSetOnSelf(): boolean
    copy(): PresenceStatusSpec
    free(): void
    getName(): string
    getPresenceType(): ConnectionPresenceType
    hasMessage(): boolean
    static name: string
    static new(name: string, type: ConnectionPresenceType, canSetOnSelf: boolean, hasMessage: boolean): PresenceStatusSpec
    constructor(name: string, type: ConnectionPresenceType, canSetOnSelf: boolean, hasMessage: boolean)
    /* Static methods and pseudo-constructors */
    static new(name: string, type: ConnectionPresenceType, canSetOnSelf: boolean, hasMessage: boolean): PresenceStatusSpec
}
export class PresenceStatusSpecPrivate {
    static name: string
}
export abstract class ProtocolClass {
    static name: string
}
export class ProtocolClassPrivate {
    static name: string
}
export class ProtocolPrivate {
    static name: string
}
export abstract class ProxyClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ProxyClass */
    parentClass: GObject.ObjectClass
    interface: GLib.Quark
    mustHaveUniqueName: number
    static name: string
}
export class ProxyFeature {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.ProxyFeature */
    name: GLib.Quark
    core: boolean
    prepareAsync: ProxyPrepareAsync
    prepareBeforeSignallingConnectedAsync: ProxyPrepareAsync
    interfacesNeeded: GLib.Quark
    dependsOn: GLib.Quark
    canRetry: boolean
    static name: string
}
export class ProxyFeaturePrivate {
    static name: string
}
export class ProxyPendingCall {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ProxyPendingCall */
    cancel(): void
    static name: string
}
export class ProxyPrivate {
    static name: string
}
export class ProxySignalConnection {
    /* Methods of TelepathyGLib-0.12.TelepathyGLib.ProxySignalConnection */
    disconnect(): void
    static name: string
}
export abstract class RoomInfoClass {
    static name: string
}
export class RoomInfoPriv {
    static name: string
}
export abstract class RoomListClass {
    static name: string
}
export class RoomListPrivate {
    static name: string
}
export abstract class SignalledMessageClass {
    static name: string
}
export abstract class SimpleApproverClass {
    static name: string
}
export class SimpleApproverPrivate {
    static name: string
}
export abstract class SimpleClientFactoryClass {
    /* Fields of TelepathyGLib-0.12.TelepathyGLib.SimpleClientFactoryClass */
    parentClass: GObject.ObjectClass
    dupAccountFeatures: (self: SimpleClientFactory, account: Account) => GLib.Quark[]
    dupConnectionFeatures: (self: SimpleClientFactory, connection: Connection) => GLib.Quark[]
    dupChannelFeatures: (self: SimpleClientFactory, channel: Channel) => GLib.Quark[]
    dupContactFeatures: (self: SimpleClientFactory, connection: Connection) => ContactFeature[]
    static name: string
}
export class SimpleClientFactoryPrivate {
    static name: string
}
export abstract class SimpleHandlerClass {
    static name: string
}
export class SimpleHandlerPrivate {
    static name: string
}
export abstract class SimpleObserverClass {
    static name: string
}
export class SimpleObserverPrivate {
    static name: string
}
export abstract class StreamTubeChannelClass {
    static name: string
}
export class StreamTubeChannelPrivate {
    static name: string
}
export abstract class StreamTubeConnectionClass {
    static name: string
}
export class StreamTubeConnectionPrivate {
    static name: string
}
export abstract class TLSCertificateClass {
    static name: string
}
export class TLSCertificateClassPrivate {
    static name: string
}
export class TLSCertificatePrivate {
    static name: string
}
export abstract class TLSCertificateRejectionClass {
    static name: string
}
export class TLSCertificateRejectionPriv {
    static name: string
}
export abstract class TextChannelClass {
    static name: string
}
export class TextChannelPrivate {
    static name: string
}
export class WeakRef {
    static name: string
}
export type Handle = number
}