<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="Babl" version="0.1"/>
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <package name="gegl-0.4"/>
  <c:include name="gegl.h"/>
  <namespace name="Gegl"
             version="0.4"
             shared-library="libgegl-0.4.so.0"
             c:identifier-prefixes="Gegl"
             c:symbol-prefixes="gegl">
    <function-macro name="AUDIO_FRAGMENT"
                    c:identifier="GEGL_AUDIO_FRAGMENT"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="27"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AUDIO_FRAGMENT_CLASS"
                    c:identifier="GEGL_AUDIO_FRAGMENT_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="28"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AUDIO_FRAGMENT_GET_CLASS"
                    c:identifier="GEGL_AUDIO_FRAGMENT_GET_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="31"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="AUTO_ROWSTRIDE" value="0" c:type="GEGL_AUTO_ROWSTRIDE">
      <source-position filename="gegl/gegl-types.h" line="29"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="AbyssPolicy"
                 glib:type-name="GeglAbyssPolicy"
                 glib:get-type="gegl_abyss_policy_get_type"
                 c:type="GeglAbyssPolicy">
      <member name="none"
              value="0"
              c:identifier="None"
              glib:nick="none"
              glib:name="None">
      </member>
      <member name="clamp"
              value="1"
              c:identifier="Clamp"
              glib:nick="clamp"
              glib:name="Clamp">
      </member>
      <member name="loop"
              value="2"
              c:identifier="Loop"
              glib:nick="loop"
              glib:name="Loop">
      </member>
      <member name="black"
              value="3"
              c:identifier="Black"
              glib:nick="black"
              glib:name="Black">
      </member>
      <member name="white"
              value="4"
              c:identifier="White"
              glib:nick="white"
              glib:name="White">
      </member>
    </enumeration>
    <bitfield name="AccessMode"
              glib:type-name="GeglAccessMode"
              glib:get-type="gegl_access_mode_get_type"
              c:type="GeglAccessMode">
      <member name="read"
              value="1"
              c:identifier="GEGL_ACCESS_READ"
              glib:nick="read"
              glib:name="Read">
      </member>
      <member name="write"
              value="2"
              c:identifier="GEGL_ACCESS_WRITE"
              glib:nick="write"
              glib:name="Write">
      </member>
      <member name="readwrite"
              value="3"
              c:identifier="GEGL_ACCESS_READWRITE"
              glib:nick="readwrite"
              glib:name="Read/Write">
      </member>
    </bitfield>
    <class name="AudioFragment"
           c:symbol-prefix="audio_fragment"
           c:type="GeglAudioFragment"
           parent="GObject.Object"
           glib:type-name="GeglAudioFragment"
           glib:get-type="gegl_audio_fragment_get_type"
           glib:type-struct="AudioFragmentClass">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="108"/>
      <constructor name="new" c:identifier="gegl_audio_fragment_new">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="112"/>
        <return-value transfer-ownership="full">
          <type name="AudioFragment" c:type="GeglAudioFragment*"/>
        </return-value>
        <parameters>
          <parameter name="sample_rate" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="channel_layout" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_samples" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_channel_layout"
              c:identifier="gegl_audio_fragment_get_channel_layout">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="126"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channels"
              c:identifier="gegl_audio_fragment_get_channels">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="123"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_samples"
              c:identifier="gegl_audio_fragment_get_max_samples">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="121"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pos" c:identifier="gegl_audio_fragment_get_pos">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="125"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sample_count"
              c:identifier="gegl_audio_fragment_get_sample_count">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="124"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sample_rate"
              c:identifier="gegl_audio_fragment_get_sample_rate">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="122"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_channel_layout"
              c:identifier="gegl_audio_fragment_set_channel_layout">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="117"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="channel_layout" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_channels"
              c:identifier="gegl_audio_fragment_set_channels">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="116"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="channels" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_samples"
              c:identifier="gegl_audio_fragment_set_max_samples">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="114"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="max_samples" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos" c:identifier="gegl_audio_fragment_set_pos">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="119"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample_count"
              c:identifier="gegl_audio_fragment_set_sample_count">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="118"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="sample_count" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample_rate"
              c:identifier="gegl_audio_fragment_set_sample_rate">
        <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                         line="115"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="sample_rate" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="string" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="data">
        <array zero-terminated="0" fixed-size="8">
          <type name="gfloat" c:type="float*"/>
        </array>
      </field>
      <field name="priv">
        <type name="AudioFragmentPrivate" c:type="GeglAudioFragmentPrivate*"/>
      </field>
    </class>
    <record name="AudioFragmentClass"
            c:type="GeglAudioFragmentClass"
            glib:is-gtype-struct-for="AudioFragment">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="108"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="AudioFragmentPrivate"
            c:type="GeglAudioFragmentPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="34"/>
    </record>
    <function-macro name="BUFFER"
                    c:identifier="GEGL_BUFFER"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-buffer.h" line="778"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="BablVariant"
                 glib:type-name="GeglBablVariant"
                 glib:get-type="gegl_babl_variant_get_type"
                 c:type="GeglBablVariant">
      <member name="float"
              value="0"
              c:identifier="Float"
              glib:nick="float"
              glib:name="Float">
      </member>
      <member name="linear"
              value="1"
              c:identifier="Linear"
              glib:nick="linear"
              glib:name="Linear">
      </member>
      <member name="non_linear"
              value="2"
              c:identifier="Non-linear"
              glib:nick="non-linear"
              glib:name="Non-linear">
      </member>
      <member name="perceptual"
              value="3"
              c:identifier="Perceptual"
              glib:nick="perceptual"
              glib:name="Perceptual">
      </member>
      <member name="linear_premultiplied"
              value="4"
              c:identifier="Linear-premultiplied"
              glib:nick="linear-premultiplied"
              glib:name="Linear-premultiplied">
      </member>
      <member name="perceptual_premultiplied"
              value="5"
              c:identifier="Perceptual-premultiplied"
              glib:nick="perceptual-premultiplied"
              glib:name="Perceptual-premultiplied">
      </member>
      <member name="linear_premultiplied_if_alpha"
              value="6"
              c:identifier="Linear-premultiplied-if-alpha"
              glib:nick="linear-premultiplied-if-alpha"
              glib:name="Linear-premultiplied-if-alpha">
      </member>
      <member name="perceptual_premultiplied_if_alpha"
              value="7"
              c:identifier="Perceptual-premultiplied-if-alpha"
              glib:nick="perceptual-premultiplied-if-alpha"
              glib:name="Perceptual-premultiplied-if-alpha">
      </member>
      <member name="add_alpha"
              value="8"
              c:identifier="add-alpha"
              glib:nick="add-alpha"
              glib:name="add-alpha">
      </member>
    </enumeration>
    <bitfield name="BlitFlags" c:type="GeglBlitFlags">
      <source-position filename="gegl/gegl-types.h" line="42"/>
      <member name="default" value="0" c:identifier="GEGL_BLIT_DEFAULT">
      </member>
      <member name="cache" value="1" c:identifier="GEGL_BLIT_CACHE">
      </member>
      <member name="dirty" value="2" c:identifier="GEGL_BLIT_DIRTY">
      </member>
    </bitfield>
    <class name="Buffer"
           c:symbol-prefix="buffer"
           c:type="GeglBuffer"
           parent="TileHandler"
           glib:type-name="GeglBuffer"
           glib:get-type="gegl_buffer_get_type">
      <constructor name="introspectable_new"
                   c:identifier="gegl_buffer_introspectable_new"
                   shadows="new">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="104">Create a new GeglBuffer with the given format and dimensions.</doc>
        <source-position filename="gegl/gegl-introspection-support.h"
                         line="114"/>
        <return-value transfer-ownership="full">
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="format_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="106">The Babl format name for this buffer, e.g. "RGBA float"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="107">x origin of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="108">y origin of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="109">width of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="110">height of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="linear_new"
                   c:identifier="gegl_buffer_linear_new"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="619">Creates a GeglBuffer backed by a linear memory buffer, of the given
@extent in the specified @format. babl_format ("R'G'B'A u8") for instance
to make a normal 8bit buffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="630"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="628">a GeglBuffer that can be used as any other GeglBuffer.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="621">dimensions of buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="622">desired pixel format.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="linear_new_from_data"
                   c:identifier="gegl_buffer_linear_new_from_data"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="633">Creates a GeglBuffer backed by a linear memory buffer that already exists,
of the given @extent in the specified @format. babl_format ("R'G'B'A u8")
for instance to make a normal 8bit buffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="651"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="649">a GeglBuffer that can be used as any other GeglBuffer.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="635">a pointer to a linear buffer in memory.</doc>
            <type name="gpointer" c:type="const gpointer"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="636">the format of the data in memory</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="637">the dimensions (and upper left coordinates) of linear buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="638">the number of bytes between rowstarts in memory (or 0 to
            autodetect)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="destroy_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="640">function to call to free data or NULL if memory should not be
             freed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="destroy_fn_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="642">extra argument to be passed to void destroy(ptr, data) type
             function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new"
                   c:identifier="gegl_buffer_new"
                   shadowed-by="introspectable_new"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="57">Create a new GeglBuffer of a given format with a given extent. It is
possible to pass in NULL for both extent and format, a NULL extent creates
an empty buffer and a NULL format makes the buffer default to "RGBA float".</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="68"/>
        <return-value transfer-ownership="full">
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="59">the geometry of the buffer (origin, width and height) a
GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="61">the Babl pixel format to be used, create one with babl_format("RGBA
u8") and similar.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_backend"
                   c:identifier="gegl_buffer_new_for_backend">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="71">Create a new GeglBuffer from a backend, if NULL is passed in the extent of
the buffer will be inherited from the extent of the backend.

returns a GeglBuffer, that holds a reference to the provided backend.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="82"/>
        <return-value transfer-ownership="full">
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="73">the geometry of the buffer (origin, width and height) a
GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="75">an instance of a GeglTileBackend subclass.</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="load" c:identifier="gegl_buffer_load">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="130">Loads an existing GeglBuffer from disk, if it has previously been saved with
gegl_buffer_save it should be possible to open through any GIO transport, buffers
that have been used as swap needs random access to be opened.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="140"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="138">a #GeglBuffer object.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="132">the path to a gegl buffer on disk.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open" c:identifier="gegl_buffer_open">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="105">Open an existing on-disk GeglBuffer, this buffer is opened in a monitored
state so multiple instances of gegl can share the same buffer. Sets on
one buffer are reflected in the other.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="115"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="113">a GeglBuffer object.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="107">the path to a gegl buffer on disk.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="swap_create_file"
                c:identifier="gegl_buffer_swap_create_file">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-swap.h"
             line="26">Generates a unique filename in the GEGL swap directory, suitable for
using as swap space.  When the file is no longer needed, it may be
removed with gegl_buffer_swap_remove_file(); otherwise, it will be
removed when gegl_exit() is called.</doc>
        <source-position filename="gegl/buffer/gegl-buffer-swap.h" line="40"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer-swap.h"
               line="36">a string containing the full
file path, or %NULL is the swap is disabled.  The returned string
should be freed with g_free() when no longer needed.</doc>
          <type name="filename" c:type="gchar*"/>
        </return-value>
        <parameters>
          <parameter name="suffix"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-swap.h"
                 line="28">a string to suffix the filename with, for
         identification purposes, or %NULL.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="swap_has_file" c:identifier="gegl_buffer_swap_has_file">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-swap.h"
             line="52">Tests if @path is a swap file, that is, if it has been created
with gegl_buffer_swap_create_file(), and hasn't been removed
yet.</doc>
        <source-position filename="gegl/buffer/gegl-buffer-swap.h" line="60"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-swap.h"
                 line="54">a filename</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="swap_remove_file"
                c:identifier="gegl_buffer_swap_remove_file">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-swap.h"
             line="42">Removes a swap file, generated using gegl_buffer_swap_create_file(),
unlinking the file, if exists.</doc>
        <source-position filename="gegl/buffer/gegl-buffer-swap.h" line="50"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-swap.h"
                 line="44">the swap file to remove, as returned by
       gegl_buffer_swap_create_file()</doc>
            <type name="filename" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_handler" c:identifier="gegl_buffer_add_handler">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="85">Add a new tile handler in the existing chain of tile handler of a GeglBuffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="92"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="87">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="88">a #GeglTileHandler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gegl_buffer_clear">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="368">Clears the provided rectangular region by setting all the associated memory
to 0.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="376"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="370">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="371">a rectangular region</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gegl_buffer_copy">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="380">Copy a region from source buffer to destination buffer.

If the babl_formats of the buffers are the same, and the tile boundaries
align, this will create copy-on-write tiles in the destination buffer.

This function never does any scaling. When src_rect and dst_rect do not have
the same width and height, the size of src_rect is used.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="396"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="382">source buffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="src_rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="383">source rectangle (or NULL to copy entire source buffer)</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="384">the abyss policy to be using if src_rect is outside src's extent.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
          <parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="385">destination buffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="dst_rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="386">position of upper left destination pixel (or NULL to match @src_rect)</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_sub_buffer"
              c:identifier="gegl_buffer_create_sub_buffer">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="152">Create a new sub GeglBuffer, that is a view on a larger buffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="161"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="159">the new sub buffer</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="154">parent buffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="155">coordinates of new buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="gegl_buffer_dup">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="404">Duplicate a buffer (internally uses gegl_buffer_copy). Aligned tiles
will create copy-on-write clones in the new buffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="413"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="411">the new buffer</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="406">the GeglBuffer to duplicate.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gegl_buffer_flush">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="142">Flushes all unsaved data to disk, this is not necessary for shared
geglbuffers opened with gegl_buffer_open since they auto-sync on writes.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="149"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="144">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush_ext" c:identifier="gegl_buffer_flush_ext">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="756">Invokes the external flush function, if any is set on the provided buffer -
this ensures that data pending - in the current implementation only OpenCL -
externally to be synchronized with the buffer. Multi threaded code should
call such a synchronization before branching out to avoid each of the
threads having an implicit synchronization of its own.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="768"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="758">a GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="759">rectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="freeze_changed" c:identifier="gegl_buffer_freeze_changed">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="733">Blocks emission of the "changed" signal for @buffer.

While the signal is blocked, changes to @buffer are accumulated, and will
be emitted once the signal is unblocked, using gegl_buffer_thaw_changed().</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="742"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="735">a GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get"
              c:identifier="gegl_buffer_get"
              shadowed-by="introspectable_get"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="243">Fetch a rectangular linear buffer of pixel data from the GeglBuffer, the
data is converted to the desired BablFormat, if the BablFormat stored and
fetched is the same this amounts to a series of memcpy's aligned to demux
the tile structure into a linear buffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="271"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="245">the buffer to retrieve data from.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="246">the coordinates we want to retrieve data from, and width/height of
destination buffer, if NULL equal to the extent of the buffer. The
coordinates and dimensions are after scale has been applied.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="249">sampling scale, 1.0 = pixel for pixel 2.0 = magnify, 0.5 scale down.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="250">the BablFormat to store in the linear buffer @dest.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="251">the memory destination for a linear buffer for the pixels, the size needed
depends on the requested BablFormat.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="253">rowstride in bytes, or GEGL_AUTO_ROWSTRIDE to compute the
rowstride based on the width and bytes per pixel for the specified format.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="255">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle)
this argument also takes a GEGL_BUFFER_FILTER value or'ed into it, allowing
to specify trade-off of performance/quality, valid values are:
GEGL_BUFFER_FILTER_NEAREST, GEGL_BUFFER_FILTER_BILINEAR,
GEGL_BUFFER_FILTER_BOX and GEGL_BUFFER_FILTER_AUTO.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_abyss" c:identifier="gegl_buffer_get_abyss">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="690">Return the abyss extent of a buffer, this expands out to the parents extent in
subbuffers.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="697"/>
        <return-value transfer-ownership="none">
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="692">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extent" c:identifier="gegl_buffer_get_extent">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="164">Returns a pointer to a GeglRectangle structure defining the geometry of a
specific GeglBuffer, this is also the default width/height of buffers passed
in to gegl_buffer_set and gegl_buffer_get (with a scale of 1.0 at least).</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="172"/>
        <return-value transfer-ownership="none">
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="166">the buffer to operate on.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format"
              c:identifier="gegl_buffer_get_format"
              glib:get-property="format"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="337">Get the babl format of the buffer, this might not be the format the buffer
was originally created with, you need to use gegl_buffer_set_format (buf,
NULL); to retrieve the original format (potentially having saved away the
original format of the buffer to re-set it.)</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="349"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="346">the babl format used for storing pixels in the buffer.</doc>
          <type name="Babl.Object" c:type="const Babl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="339">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile"
              c:identifier="gegl_buffer_get_tile"
              introspectable="0">
        <source-position filename="gegl/buffer/gegl-tile-source.h" line="110"/>
        <return-value>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="introspectable_get"
              c:identifier="gegl_buffer_introspectable_get"
              shadows="get">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="120">Fetch a rectangular linear buffer of pixel data from the GeglBuffer.</doc>
        <source-position filename="gegl/gegl-introspection-support.h"
                         line="137"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-introspection-support.h"
               line="135">A copy of the requested data</doc>
          <array length="4" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="122">the buffer to retrieve data from.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="123">the coordinates we want to retrieve data from.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="124">sampling scale, 1.0 = pixel for pixel 2.0 = magnify, 0.5 scale down.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="125">the format to store data in, if NULL the format of the buffer is used.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="126">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
          <parameter name="data_length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="131">The length of the returned buffer</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="introspectable_set"
              c:identifier="gegl_buffer_introspectable_set"
              shadows="set">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="145">Store a linear raster buffer into the GeglBuffer.</doc>
        <source-position filename="gegl/gegl-introspection-support.h"
                         line="155"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="147">the buffer to modify.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="148">the rectangle to write.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="149">the format of the input data.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="150">pixel data to write to @buffer.</doc>
            <array length="3" zero-terminated="0" c:type="const guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="src_length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="151">the lenght of src in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterator_new"
              c:identifier="gegl_buffer_iterator_new"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-iterator.h"
             line="61">Create a new buffer iterator, this buffer will be iterated through
in linear chunks, some chunks might be full tiles the coordinates, see
the documentation of gegl_buffer_iterator_next for how to use it and
destroy it.</doc>
        <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                         line="79"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer-iterator.h"
               line="76">a new buffer iterator that can be used to iterate through the
buffers pixels.</doc>
          <type name="BufferIterator" c:type="GeglBufferIterator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="63">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="64">the rectangle to iterate over</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="65">the level at which we are iterating, the roi will indicate the
extent at 1:1, x,y,width and height are/(2^level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="67">the format we want to process this buffers data in, pass 0 to use the buffers format.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="access_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="68">whether we need reading or writing to this buffer one of GEGL_BUFFER_READ, GEGL_BUFFER_WRITE and GEGL_BUFFER_READWRITE.</doc>
            <type name="AccessMode" c:type="GeglAccessMode"/>
          </parameter>
          <parameter name="abyss_policy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="69">how request outside the buffer extent are handled.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
          <parameter name="max_slots" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="linear_close" c:identifier="gegl_buffer_linear_close">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="676">This function makes sure GeglBuffer and underlying code is aware of changes
being made to the linear buffer. If the request was not a compatible one
it is written back to the buffer. Multiple concurrent users can be handed
the same buffer (both raw access and converted).</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="686"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="678">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="linear"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="679">a previously returned buffer.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="linear_open"
              c:identifier="gegl_buffer_linear_open"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="658">Raw direct random access to the full data of a buffer in linear memory.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="671"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="667">a pointer to a linear memory region describing the buffer, if the
request is compatible with the underlying data storage direct access
to the underlying data is provided. Otherwise, it returns a copy of the data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="660">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="661">region to open, pass NULL for entire buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="662">return location for rowstride.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="663">desired format or NULL to use buffers format.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_handler" c:identifier="gegl_buffer_remove_handler">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="95">Remove the provided tile handler in the existing chain of tile handler of a GeglBuffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="102"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="97">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="98">a #GeglTileHandler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sample"
              c:identifier="gegl_buffer_sample"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="454">Query interpolate pixel values at a given coordinate using a specified form
of interpolation.

If you intend to take multiple samples, consider using
gegl_buffer_sampler_new() to create a sampler object instead, which is more
efficient.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="480"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="456">the GeglBuffer to sample from</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="457">x coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="458">y coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="459">a matrix that indicates scaling factors, see
gegl_sampler_compute_scale the same.</doc>
            <type name="BufferMatrix2" c:type="GeglBufferMatrix2*"/>
          </parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="461">buffer capable of storing one pixel in @format.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="462">the format to store the sampled color in.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="463">the sampler type to use,
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="467">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="sample_at_level"
              c:identifier="gegl_buffer_sample_at_level"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="416">Query interpolate pixel values at a given coordinate using a specified form
of interpolation.

If you intend to take multiple samples, consider using
gegl_buffer_sampler_new_at_level() to create a sampler object instead, which
is more efficient.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="444"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="418">the GeglBuffer to sample from</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="419">x coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="420">y coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="421">a matrix that indicates scaling factors, see
gegl_sampler_compute_scale the same.</doc>
            <type name="BufferMatrix2" c:type="GeglBufferMatrix2*"/>
          </parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="423">buffer capable of storing one pixel in @format.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="424">the format to store the sampled color in.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="425">mipmap level to sample from (@x and @y are level 0 coordinates)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="426">the sampler type to use,
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="430">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="sample_cleanup"
              c:identifier="gegl_buffer_sample_cleanup"
              deprecated="1"
              deprecated-version="0.4.2">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="491">Clean up resources used by sampling framework of buffer.</doc>
        <doc-deprecated xml:space="preserve">This function has no effect. It is not necessary to call
it after using gegl_buffer_sample() or gegl_buffer_sample_at_level().</doc-deprecated>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="501"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="493">the GeglBuffer to sample from</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sampler_new"
              c:identifier="gegl_buffer_sampler_new"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="519">Create a new sampler, when you are done with the sampler, g_object_unref
it.

Samplers only hold weak references to buffers, so if its buffer is freed
the sampler will become invalid.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="534"/>
        <return-value>
          <type name="Sampler" c:type="GeglSampler*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="521">buffer to create a new sampler for</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="522">format we want data back in</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="523">the sampler type to use,
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
        </parameters>
      </method>
      <method name="sampler_new_at_level"
              c:identifier="gegl_buffer_sampler_new_at_level"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="538">Create a new sampler, when you are done with the sampler, g_object_unref
it.

Samplers only hold weak references to buffers, so if its buffer is freed
the sampler will become invalid.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="554"/>
        <return-value>
          <type name="Sampler" c:type="GeglSampler*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="540">buffer to create a new sampler for</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="541">format we want data back in</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="542">the sampler type to use,</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="543">the mipmap level to create a sampler for
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="gegl_buffer_save">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="117">Write a GeglBuffer to a file.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="126"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="119">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="120">the path where the gegl buffer will be saved, any writable GIO uri is valid.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="121">the region of interest to write, this is the tiles that will be collected and
written to disk.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set"
              c:identifier="gegl_buffer_set"
              shadowed-by="introspectable_set"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="279">Store a linear raster buffer into the GeglBuffer.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="294"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="281">the buffer to modify.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="282">the coordinates we want to change the data of and the width/height of
the linear buffer being set.
the data when setting.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="mipmap_level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="285">the scale level being set, 0 = 1:1 = default = base mipmap level,
1 = 1:2, 2=1:4, 3=1:8 ..</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="287">the babl_format the linear buffer @src.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="src"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="288">linear buffer of image data to be stored in @buffer.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="289">rowstride in bytes, or GEGL_AUTO_ROWSTRIDE to compute the
rowstride based on the width and bytes per pixel for the specified format.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_abyss" c:identifier="gegl_buffer_set_abyss">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="189">Changes the size and position of the abyss rectangle of a buffer.

Returns TRUE if the change of abyss was successful.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="198"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="191">the buffer to operate on.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="abyss" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="192">new abyss.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color" c:identifier="gegl_buffer_set_color">
        <doc xml:space="preserve"
             filename="gegl/gegl-utils.h"
             line="110">Sets the region covered by rect to the specified color.</doc>
        <source-position filename="gegl/gegl-utils.h" line="118"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-utils.h"
                 line="112">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-utils.h"
                 line="113">a rectangular region to fill with a color.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-utils.h"
                 line="114">the GeglColor to fill with.</doc>
            <type name="Color" c:type="GeglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_from_pixel"
              c:identifier="gegl_buffer_set_color_from_pixel">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="303">Sets the region covered by rect to the the provided pixel.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="313"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="305">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="306">a rectangular region to fill with a color.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="pixel"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="307">pointer to the data of a single pixel</doc>
            <type name="gpointer" c:type="gconstpointer"/>
          </parameter>
          <parameter name="pixel_format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="308">the babl format of the pixel, if missing - the soft format of dst.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_extent" c:identifier="gegl_buffer_set_extent">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="175">Changes the size and position that is considered active in a buffer, this
operation is valid on any buffer, reads on subbuffers outside the master
buffer's extent are at the moment undefined.

Returns TRUE if the change of extent was successful.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="186"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="177">the buffer to operate on.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="178">new extent.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_format"
              c:identifier="gegl_buffer_set_format"
              glib:set-property="format"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="352">Set the babl format of the buffer, setting the babl format of the buffer
requires the new format to have exactly the same bytes per pixel as the
original format. If NULL is passed in the format of the buffer is reset to
the original format.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="365"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="362">the new babl format or NULL if the passed-in buffer was
incompatible (then the original format is still used).</doc>
          <type name="Babl.Object" c:type="const Babl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="354">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="355">the new babl format, must have same bpp as original format.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pattern" c:identifier="gegl_buffer_set_pattern">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="319">Fill a region with a repeating pattern. Offsets parameters are
relative to the origin (0, 0) and not to the rectangle. So be carefull
about the origin of @pattern and @buffer extents.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="331"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="321">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="322">the region of @buffer to fill</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="323">a #GeglBuffer to be repeated as a pattern</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="x_offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="324">where the pattern starts horizontally</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y_offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="325">where the pattern starts vertical</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="share_storage" c:identifier="gegl_buffer_share_storage">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="700">Checks if a pair of buffers share the same underlying tile storage.

Returns TRUE if @buffer1 and @buffer2 share the same storage.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="709"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="702">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="buffer2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="703">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="signal_connect" c:identifier="gegl_buffer_signal_connect">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="713">This function should be used instead of g_signal_connect when connecting to
the GeglBuffer::changed signal handler, GeglBuffer contains additional
machinery to avoid the overhead of changes when no signal handler have been
connected, if regular g_signal_connect is used; then no signals will be
emitted.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="728"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="726">an handle like g_signal_connect.</doc>
          <type name="glong" c:type="glong"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="715">a GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="716">only "changed" expected for now</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="c_handler"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="717">c function callback</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="718">user data:</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="thaw_changed" c:identifier="gegl_buffer_thaw_changed">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="744">Unblocks emission of the "changed" signal for @buffer.

Once all calls to gegl_buffer_freeze_changed() are matched by corresponding
calls to gegl_buffer_freeze_changed(), all accumulated changes are emitted.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="753"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="746">a GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="abyss-height"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="abyss-width"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="abyss-x"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="abyss-y"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="backend"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="TileBackend"/>
      </property>
      <property name="format"
                writable="1"
                construct="1"
                transfer-ownership="none"
                setter="set_format"
                getter="get_format">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="height"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="initialized"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="TRUE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="path"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="NULL">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pixels" transfer-ownership="none" default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="px-size" transfer-ownership="none" default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="shift-x"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="shift-y"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-height"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="128">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-width"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="128">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="width"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="x"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="y"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <glib:signal name="changed" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Rectangle"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BufferIterator" c:type="GeglBufferIterator">
      <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                       line="50"/>
      <field name="length" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="priv" writable="1">
        <type name="BufferIteratorPriv" c:type="GeglBufferIteratorPriv*"/>
      </field>
      <field name="items" writable="1">
        <array zero-terminated="0">
          <type name="BufferIteratorItem" c:type="GeglBufferIteratorItem"/>
        </array>
      </field>
      <method name="add"
              c:identifier="gegl_buffer_iterator_add"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-iterator.h"
             line="89">Adds an additional buffer iterator that will be processed in sync with
the original one, if the buffer doesn't align with the other for tile access
the corresponding scans and regions will be serialized automatically using
gegl_buffer_get.

If the buffer shares its tiles with a previously-added buffer (in
particular, if the same buffer is added more than once), and at least one of
the buffers is accessed for writing, the corresponding iterated-over areas
should either completely overlap, or not overlap at all, in the coordinate-
system of the underlying tile storage (that is, after shifting each area by
the corresponding buffer's shift-x and shift-y properties).  If the areas
overlap, at most one of the buffers may be accessed for writing, and the
data pointers of the corresponding iterator items may refer to the same
data.</doc>
        <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                         line="118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer-iterator.h"
               line="115">an integer handle refering to the indice in the iterator structure
of the added buffer.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="iterator" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="91">a #GeglBufferIterator</doc>
            <type name="BufferIterator" c:type="GeglBufferIterator*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="92">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="93">the rectangle to iterate over</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="94">the level at which we are iterating, the roi will indicate the
extent at 1:1, x,y,width and height are/(2^level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="96">the format we want to process this buffers data in, pass 0 to use the buffers format.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="access_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="97">whether we need reading or writing to this buffer.</doc>
            <type name="AccessMode" c:type="GeglAccessMode"/>
          </parameter>
          <parameter name="abyss_policy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="98">how request outside the buffer extent are handled.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="next"
              c:identifier="gegl_buffer_iterator_next"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-iterator.h"
             line="135">Do an iteration, this causes a new set of iterator-&gt;data[] to become
available if there is more data to process. Changed data from a previous
iteration step will also be saved now. When there is no more data to
be processed FALSE will be returned (and the iterator handle is no longer
valid).</doc>
        <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                         line="147"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer-iterator.h"
               line="145">TRUE if there is more work FALSE if iteration is complete.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iterator" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="137">a #GeglBufferIterator</doc>
            <type name="BufferIterator" c:type="GeglBufferIterator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop"
              c:identifier="gegl_buffer_iterator_stop"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-iterator.h"
             line="126">Cancels the current iteration, freeing up any temporary resources. The
iterator handle is no longer valid after invoking this function.</doc>
        <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                         line="133"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iterator" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer-iterator.h"
                 line="128">a GeglBufferIterator</doc>
            <type name="BufferIterator" c:type="GeglBufferIterator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="empty_new"
                c:identifier="gegl_buffer_iterator_empty_new"
                introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-iterator.h"
             line="53">Create a new buffer iterator without adding any buffers.</doc>
        <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                         line="59"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer-iterator.h"
               line="57">a new buffer iterator.</doc>
          <type name="BufferIterator" c:type="GeglBufferIterator*"/>
        </return-value>
        <parameters>
          <parameter name="max_slots" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="BufferIteratorItem" c:type="GeglBufferIteratorItem">
      <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                       line="43"/>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="roi" writable="1">
        <type name="Rectangle" c:type="GeglRectangle"/>
      </field>
    </record>
    <record name="BufferIteratorPriv"
            c:type="GeglBufferIteratorPriv"
            disguised="1"
            opaque="1">
      <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                       line="29"/>
    </record>
    <record name="BufferMatrix2" c:type="GeglBufferMatrix2">
      <source-position filename="gegl/buffer/gegl-buffer-matrix2.h" line="33"/>
      <field name="coeff" writable="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gdouble" c:type="gdouble"/>
        </array>
      </field>
      <method name="determinant"
              c:identifier="gegl_buffer_matrix2_determinant">
        <source-position filename="gegl/buffer/gegl-buffer-matrix2.h"
                         line="61"/>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <type name="BufferMatrix2" c:type="GeglBufferMatrix2*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_identity"
              c:identifier="gegl_buffer_matrix2_is_identity">
        <source-position filename="gegl/buffer/gegl-buffer-matrix2.h"
                         line="43"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <type name="BufferMatrix2" c:type="GeglBufferMatrix2*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_scale" c:identifier="gegl_buffer_matrix2_is_scale">
        <source-position filename="gegl/buffer/gegl-buffer-matrix2.h"
                         line="53"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <type name="BufferMatrix2" c:type="GeglBufferMatrix2*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <constant name="CH_BACK_CENTER" value="256" c:type="GEGL_CH_BACK_CENTER">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="50"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_BACK_LEFT" value="16" c:type="GEGL_CH_BACK_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="46"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_BACK_RIGHT" value="32" c:type="GEGL_CH_BACK_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="47"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_CENTER" value="4" c:type="GEGL_CH_FRONT_CENTER">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="44"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_LEFT" value="1" c:type="GEGL_CH_FRONT_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="42"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_LEFT_OF_CENTER"
              value="64"
              c:type="GEGL_CH_FRONT_LEFT_OF_CENTER">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="48"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_RIGHT" value="2" c:type="GEGL_CH_FRONT_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="43"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_RIGHT_OF_CENTER"
              value="128"
              c:type="GEGL_CH_FRONT_RIGHT_OF_CENTER">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="49"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_2POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_2POINT1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="71"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_2_1" value="0" c:type="GEGL_CH_LAYOUT_2_1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="72"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_2_2" value="0" c:type="GEGL_CH_LAYOUT_2_2">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="77"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_3POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_3POINT1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="74"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_4POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_4POINT0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="75"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_4POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_4POINT1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="76"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="79"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT0_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT0_BACK">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="81"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="80"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT1_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT1_BACK">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="82"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="83"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT0_FRONT"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT0_FRONT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="84"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="86"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT1_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT1_BACK">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="87"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT1_FRONT"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT1_FRONT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="88"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="89"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT0_FRONT"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT0_FRONT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="90"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT1">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="91"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT1_WIDE"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT1_WIDE">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="92"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT1_WIDE_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT1_WIDE_BACK">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="93"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_HEXADECAGONAL"
              value="0"
              c:type="GEGL_CH_LAYOUT_HEXADECAGONAL">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="95"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_HEXAGONAL"
              value="0"
              c:type="GEGL_CH_LAYOUT_HEXAGONAL">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="85"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_NATIVE"
              value="9223372036854775808"
              c:type="GEGL_CH_LAYOUT_NATIVE">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="68"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_OCTAGONAL"
              value="0"
              c:type="GEGL_CH_LAYOUT_OCTAGONAL">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="94"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_QUAD" value="0" c:type="GEGL_CH_LAYOUT_QUAD">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="78"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_STEREO" value="0" c:type="GEGL_CH_LAYOUT_STEREO">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="70"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_STEREO_DOWNMIX"
              value="0"
              c:type="GEGL_CH_LAYOUT_STEREO_DOWNMIX">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="96"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_SURROUND"
              value="0"
              c:type="GEGL_CH_LAYOUT_SURROUND">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="73"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LOW_FREQUENCY" value="8" c:type="GEGL_CH_LOW_FREQUENCY">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="45"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LOW_FREQUENCY_2"
              value="34359738368"
              c:type="GEGL_CH_LOW_FREQUENCY_2">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="66"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SIDE_LEFT" value="512" c:type="GEGL_CH_SIDE_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="51"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SIDE_RIGHT" value="1024" c:type="GEGL_CH_SIDE_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="52"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_STEREO_LEFT"
              value="536870912"
              c:type="GEGL_CH_STEREO_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="60"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_STEREO_RIGHT"
              value="1073741824"
              c:type="GEGL_CH_STEREO_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="61"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SURROUND_DIRECT_LEFT"
              value="8589934592"
              c:type="GEGL_CH_SURROUND_DIRECT_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="64"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SURROUND_DIRECT_RIGHT"
              value="17179869184"
              c:type="GEGL_CH_SURROUND_DIRECT_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="65"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_BACK_CENTER"
              value="65536"
              c:type="GEGL_CH_TOP_BACK_CENTER">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="58"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_BACK_LEFT"
              value="32768"
              c:type="GEGL_CH_TOP_BACK_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="57"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_BACK_RIGHT"
              value="131072"
              c:type="GEGL_CH_TOP_BACK_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="59"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_CENTER" value="2048" c:type="GEGL_CH_TOP_CENTER">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="53"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_FRONT_CENTER"
              value="8192"
              c:type="GEGL_CH_TOP_FRONT_CENTER">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="55"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_FRONT_LEFT"
              value="4096"
              c:type="GEGL_CH_TOP_FRONT_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="54"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_FRONT_RIGHT"
              value="16384"
              c:type="GEGL_CH_TOP_FRONT_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="56"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_WIDE_LEFT"
              value="2147483648"
              c:type="GEGL_CH_WIDE_LEFT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="62"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_WIDE_RIGHT"
              value="4294967296"
              c:type="GEGL_CH_WIDE_RIGHT">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="63"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="COLOR" c:identifier="GEGL_COLOR" introspectable="0">
      <source-position filename="gegl/property-types/gegl-color.h" line="27"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLOR_CLASS"
                    c:identifier="GEGL_COLOR_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-color.h" line="28"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLOR_GET_CLASS"
                    c:identifier="GEGL_COLOR_GET_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-color.h" line="31"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CONFIG"
                    c:identifier="GEGL_CONFIG"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CURVE" c:identifier="GEGL_CURVE" introspectable="0">
      <source-position filename="gegl/property-types/gegl-curve.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CURVE_CLASS"
                    c:identifier="GEGL_CURVE_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-curve.h" line="36"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="CURVE_GET_CLASS"
                    c:identifier="GEGL_CURVE_GET_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-curve.h" line="39"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="CachePolicy"
                 glib:type-name="GeglCachePolicy"
                 glib:get-type="gegl_cache_policy_get_type"
                 c:type="GeglCachePolicy">
      <member name="auto"
              value="0"
              c:identifier="GEGL_CACHE_POLICY_AUTO"
              glib:nick="auto"
              glib:name="Auto">
      </member>
      <member name="never"
              value="1"
              c:identifier="GEGL_CACHE_POLICY_NEVER"
              glib:nick="never"
              glib:name="Never">
      </member>
      <member name="always"
              value="2"
              c:identifier="GEGL_CACHE_POLICY_ALWAYS"
              glib:nick="always"
              glib:name="Always">
      </member>
    </enumeration>
    <class name="Color"
           c:symbol-prefix="color"
           c:type="GeglColor"
           parent="GObject.Object"
           glib:type-name="GeglColor"
           glib:get-type="gegl_color_get_type"
           glib:type-struct="ColorClass">
      <source-position filename="gegl/property-types/gegl-color.h" line="45"/>
      <constructor name="new" c:identifier="gegl_color_new">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="67">Creates a new #GeglColor.

Returns the newly created #GeglColor.</doc>
        <source-position filename="gegl/property-types/gegl-color.h"
                         line="75"/>
        <return-value transfer-ownership="full">
          <type name="Color" c:type="GeglColor*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="69">a string describing the color to be created.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="duplicate" c:identifier="gegl_color_duplicate">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="77">Creates a copy of @color.</doc>
        <source-position filename="gegl/property-types/gegl-color.h"
                         line="85"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="83">A new copy of @color.</doc>
          <type name="Color" c:type="GeglColor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="79">the color to duplicate.</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_components" c:identifier="gegl_color_get_components">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="55">Get the component values of the color in @format.</doc>
        <source-position filename="gegl/gegl-introspection-support.h"
                         line="67"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-introspection-support.h"
               line="63">The color components
If value format not supported return NULL and components_length set to 0.</doc>
          <array length="1" zero-terminated="0" c:type="gdouble*">
            <type name="gdouble" c:type="gdouble"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="57">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="58">A Babl pointer</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="components_length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="59">The length of the returned buffer</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="gegl_color_get_format">
        <source-position filename="gegl/property-types/gegl-color.h"
                         line="204"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="201">the pixel format encoding of the set color.</doc>
          <type name="Babl.Object" c:type="const Babl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="199">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pixel"
              c:identifier="gegl_color_get_pixel"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="130">Store the color in a pixel in the given format.</doc>
        <source-position filename="gegl/property-types/gegl-color.h"
                         line="138"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="132">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="133">a babl pixel format</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="pixel"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="134">pointer to a pixel</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_rgba" c:identifier="gegl_color_get_rgba">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="87">Retrieves the current set color as linear light non premultipled RGBA data,
any of the return pointers can be omitted.</doc>
        <source-position filename="gegl/property-types/gegl-color.h"
                         line="98"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="89">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="red"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="90">red return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="green"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="91">green return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="blue"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="92">blue return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="alpha"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="93">alpha return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_components" c:identifier="gegl_color_set_components">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="69">Set the color using the component values as @format.</doc>
        <source-position filename="gegl/gegl-introspection-support.h"
                         line="79"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="71">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="72">A Babl pointer</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="73">The color components.</doc>
            <array length="2" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
          <parameter name="components_length" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="74">The length of the components array</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pixel"
              c:identifier="gegl_color_set_pixel"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="119">Set a GeglColor from a pointer to a pixel and it's babl format.</doc>
        <source-position filename="gegl/property-types/gegl-color.h"
                         line="127"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="121">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="122">a babl pixel format</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="pixel"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="123">pointer to a pixel</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rgba" c:identifier="gegl_color_set_rgba">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="104">Set color as linear light non premultipled RGBA data</doc>
        <source-position filename="gegl/property-types/gegl-color.h"
                         line="114"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="106">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="107">red value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="108">green value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="109">blue value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-color.h"
                 line="110">alpha value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="string" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ColorPrivate" c:type="GeglColorPrivate*"/>
      </field>
    </class>
    <record name="ColorClass"
            c:type="GeglColorClass"
            glib:is-gtype-struct-for="Color">
      <source-position filename="gegl/property-types/gegl-color.h" line="45"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ColorPrivate"
            c:type="GeglColorPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="gegl/property-types/gegl-color.h" line="34"/>
    </record>
    <class name="Config"
           c:symbol-prefix="config"
           c:type="GeglConfig"
           parent="GObject.Object"
           glib:type-name="GeglConfig"
           glib:get-type="gegl_config_get_type">
      <property name="application-license"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="chunk-size"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="1048576">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="mipmap-rendering"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="quality"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="1.000000">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="queue-size"
                writable="1"
                transfer-ownership="none"
                default-value="52428800">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="swap"
                writable="1"
                transfer-ownership="none"
                default-value="NULL">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="swap-compression"
                writable="1"
                transfer-ownership="none"
                default-value="NULL">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="threads"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="8">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-cache-size"
                writable="1"
                transfer-ownership="none"
                default-value="774782976">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-height"
                writable="1"
                transfer-ownership="none"
                default-value="128">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-width"
                writable="1"
                transfer-ownership="none"
                default-value="128">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="use-opencl"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <class name="Curve"
           c:symbol-prefix="curve"
           c:type="GeglCurve"
           parent="GObject.Object"
           glib:type-name="GeglCurve"
           glib:get-type="gegl_curve_get_type"
           glib:type-struct="CurveClass">
      <source-position filename="gegl/property-types/gegl-curve.h" line="51"/>
      <constructor name="new" c:identifier="gegl_curve_new">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="55">Create a #GeglCurve that can store a curve with values between @y_min and
@y_max.

Returns the newly created #GeglCurve.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="65"/>
        <return-value transfer-ownership="full">
          <type name="Curve" c:type="GeglCurve*"/>
        </return-value>
        <parameters>
          <parameter name="y_min" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="57">minimum y value for curve.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y_max" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="58">maximum y value for curve.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_default" c:identifier="gegl_curve_new_default">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="68">Create a default #GeglCurve with an identify mapping of
(0.0..1.0) -&gt; (0.0..1.0).

Returns the newly created default #GeglCurve.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="76"/>
        <return-value transfer-ownership="full">
          <type name="Curve" c:type="GeglCurve*"/>
        </return-value>
      </constructor>
      <method name="add_point" c:identifier="gegl_curve_add_point">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="102">Add a point to the curve at @x @y (replacing the value exactly for @x if it
already exists.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="111"/>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="104">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="105">x coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="106">y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="calc_value" c:identifier="gegl_curve_calc_value">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="153">Retrieve the number of points in the curve.

Returns the number of points for the coordinates in the curve.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="161"/>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="155">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="calc_values"
              c:identifier="gegl_curve_calc_values"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="164">Compute a set (lookup table) of coordinates.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="175"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="166">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="x_min" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="167">the minimum value to compute for</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="x_max" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="168">the maximum value to compute for</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="num_samples" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="169">number of samples to calculate</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="xs" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="170">return location for the x coordinates</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="ys" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="171">return location for the y coordinates</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="duplicate" c:identifier="gegl_curve_duplicate">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="78">Create a copy of @curve.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="86"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-curve.h"
               line="84">A new copy of @curve.</doc>
          <type name="Curve" c:type="GeglCurve*"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="80">the curve to duplicate.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point" c:identifier="gegl_curve_get_point">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="115">Retrive the coordinates for an index.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="124"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="117">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="118">the position of the value number to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="119">x coordinate return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="120">y coordinate return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_y_bounds" c:identifier="gegl_curve_get_y_bounds">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="89">Get the bounds on the values of the curve and store the values in
the return locaitons provided in @min_y and @max_y.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="98"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="91">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="min_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="92">return location for minimal value.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="max_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="93">return location for maximal value.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="num_points" c:identifier="gegl_curve_num_points">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="143">Retrieve the number of points in the curve.

Returns the number of points for the coordinates in the curve.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="151"/>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="145">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_point" c:identifier="gegl_curve_set_point">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="129">Replace an existing point in a curve.</doc>
        <source-position filename="gegl/property-types/gegl-curve.h"
                         line="138"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="131">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="132">the position of the value number to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="133">x coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-curve.h"
                 line="134">y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="CurveClass"
            c:type="GeglCurveClass"
            glib:is-gtype-struct-for="Curve">
      <source-position filename="gegl/property-types/gegl-curve.h" line="51"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="DistanceMetric"
                 glib:type-name="GeglDistanceMetric"
                 glib:get-type="gegl_distance_metric_get_type"
                 c:type="GeglDistanceMetric">
      <member name="euclidean"
              value="0"
              c:identifier="GEGL_DISTANCE_METRIC_EUCLIDEAN"
              glib:nick="euclidean"
              glib:name="Euclidean">
      </member>
      <member name="manhattan"
              value="1"
              c:identifier="GEGL_DISTANCE_METRIC_MANHATTAN"
              glib:nick="manhattan"
              glib:name="Manhattan">
      </member>
      <member name="chebyshev"
              value="2"
              c:identifier="GEGL_DISTANCE_METRIC_CHEBYSHEV"
              glib:nick="chebyshev"
              glib:name="Chebyshev">
      </member>
    </enumeration>
    <enumeration name="DitherMethod"
                 glib:type-name="GeglDitherMethod"
                 glib:get-type="gegl_dither_method_get_type"
                 c:type="GeglDitherMethod">
      <member name="none"
              value="0"
              c:identifier="GEGL_DITHER_NONE"
              glib:nick="none"
              glib:name="None">
      </member>
      <member name="floyd_steinberg"
              value="1"
              c:identifier="GEGL_DITHER_FLOYD_STEINBERG"
              glib:nick="floyd-steinberg"
              glib:name="Floyd-Steinberg">
      </member>
      <member name="bayer"
              value="2"
              c:identifier="GEGL_DITHER_BAYER"
              glib:nick="bayer"
              glib:name="Bayer">
      </member>
      <member name="random"
              value="3"
              c:identifier="GEGL_DITHER_RANDOM"
              glib:nick="random"
              glib:name="Random">
      </member>
      <member name="random_covariant"
              value="4"
              c:identifier="GEGL_DITHER_RANDOM_COVARIANT"
              glib:nick="random-covariant"
              glib:name="Random Covariant">
      </member>
      <member name="add"
              value="5"
              c:identifier="Arithmetic add"
              glib:nick="add"
              glib:name="Arithmetic add">
      </member>
      <member name="add_covariant"
              value="6"
              c:identifier="Arithmetic add covariant"
              glib:nick="add-covariant"
              glib:name="Arithmetic add covariant">
      </member>
      <member name="xor"
              value="7"
              c:identifier="Arithmetic xor"
              glib:nick="xor"
              glib:name="Arithmetic xor">
      </member>
      <member name="xor_covariant"
              value="8"
              c:identifier="Arithmetic xor covariant"
              glib:nick="xor-covariant"
              glib:name="Arithmetic xor covariant">
      </member>
      <member name="blue_noise"
              value="9"
              c:identifier="GEGL_DITHER_BLUE_NOISE"
              glib:nick="blue-noise"
              glib:name="Blue Noise">
      </member>
      <member name="blue_noise_covariant"
              value="10"
              c:identifier="GEGL_DITHER_BLUE_NOISE_COVARIANT"
              glib:nick="blue-noise-covariant"
              glib:name="Blue Noise Covariant">
      </member>
    </enumeration>
    <constant name="FLOAT_EPSILON"
              value="0.000010"
              c:type="GEGL_FLOAT_EPSILON">
      <source-position filename="gegl/buffer/gegl-rectangle.h" line="335"/>
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <function-macro name="FLOAT_EQUAL"
                    c:identifier="GEGL_FLOAT_EQUAL"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-rectangle.h" line="337"/>
      <parameters>
        <parameter name="v1">
        </parameter>
        <parameter name="v2">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FLOAT_IS_ZERO"
                    c:identifier="GEGL_FLOAT_IS_ZERO"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-rectangle.h" line="336"/>
      <parameters>
        <parameter name="value">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="FlattenerFunc"
              c:type="GeglFlattenerFunc"
              introspectable="0">
      <source-position filename="gegl/property-types/gegl-path.h" line="468"/>
      <return-value>
        <type name="PathList" c:type="GeglPathList*"/>
      </return-value>
      <parameters>
        <parameter name="original" transfer-ownership="none">
          <type name="PathList" c:type="GeglPathList*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="IS_AUDIO"
                    c:identifier="GEGL_IS_AUDIO"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="29"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_AUDIO_CLASS"
                    c:identifier="GEGL_IS_AUDIO_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="30"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BUFFER"
                    c:identifier="GEGL_IS_BUFFER"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-buffer.h" line="779"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_COLOR"
                    c:identifier="GEGL_IS_COLOR"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-color.h" line="29"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_COLOR_CLASS"
                    c:identifier="GEGL_IS_COLOR_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-color.h" line="30"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CONFIG"
                    c:identifier="GEGL_IS_CONFIG"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="56"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CURVE"
                    c:identifier="GEGL_IS_CURVE"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-curve.h" line="37"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_CURVE_CLASS"
                    c:identifier="GEGL_IS_CURVE_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-curve.h" line="38"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_NODE"
                    c:identifier="GEGL_IS_NODE"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="82"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_OPERATION"
                    c:identifier="GEGL_IS_OPERATION"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="75"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_PATH"
                    c:identifier="GEGL_IS_PARAM_PATH"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-path.h" line="415"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_AUDIO_FRAGMENT"
                    c:identifier="GEGL_IS_PARAM_SPEC_AUDIO_FRAGMENT"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="132"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_COLOR"
                    c:identifier="GEGL_IS_PARAM_SPEC_COLOR"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-color.h" line="146"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_CURVE"
                    c:identifier="GEGL_IS_PARAM_SPEC_CURVE"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-curve.h" line="186"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_DOUBLE"
                    c:identifier="GEGL_IS_PARAM_SPEC_DOUBLE"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="48"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_ENUM"
                    c:identifier="GEGL_IS_PARAM_SPEC_ENUM"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="252"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_FILE_PATH"
                    c:identifier="GEGL_IS_PARAM_SPEC_FILE_PATH"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="208"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_FORMAT"
                    c:identifier="GEGL_IS_PARAM_SPEC_FORMAT"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="330"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_INT"
                    c:identifier="GEGL_IS_PARAM_SPEC_INT"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="113"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_SEED"
                    c:identifier="GEGL_IS_PARAM_SPEC_SEED"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="296"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_STRING"
                    c:identifier="GEGL_IS_PARAM_SPEC_STRING"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="167"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_URI"
                    c:identifier="GEGL_IS_PARAM_SPEC_URI"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="363"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PATH"
                    c:identifier="GEGL_IS_PATH"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-path.h" line="39"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PATH_CLASS"
                    c:identifier="GEGL_IS_PATH_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-path.h" line="40"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PROCESSOR"
                    c:identifier="GEGL_IS_PROCESSOR"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="89"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_STATS"
                    c:identifier="GEGL_IS_STATS"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="62"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TILE_BACKEND"
                    c:identifier="GEGL_IS_TILE_BACKEND"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="34"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TILE_BACKEND_CLASS"
                    c:identifier="GEGL_IS_TILE_BACKEND_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="35"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TILE_HANDLER"
                    c:identifier="GEGL_IS_TILE_HANDLER"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="38"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TILE_HANDLER_CLASS"
                    c:identifier="GEGL_IS_TILE_HANDLER_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="39"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TILE_SOURCE"
                    c:identifier="GEGL_IS_TILE_SOURCE"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="37"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TILE_SOURCE_CLASS"
                    c:identifier="GEGL_IS_TILE_SOURCE_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="38"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="LOOKUP_MAX_ENTRIES"
              value="819200"
              c:type="GEGL_LOOKUP_MAX_ENTRIES">
      <source-position filename="gegl/gegl-lookup.h" line="29"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Lookup" c:type="GeglLookup">
      <source-position filename="gegl/gegl-lookup.h" line="39"/>
      <field name="function" writable="1">
        <type name="LookupFunction" c:type="GeglLookupFunction"/>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="shift" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="positive_min" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="positive_max" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="negative_min" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="negative_max" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="bitmask" writable="1">
        <array zero-terminated="0" fixed-size="25600">
          <type name="guint32" c:type="guint32"/>
        </array>
      </field>
      <field name="table" writable="1">
        <array zero-terminated="0">
          <type name="gfloat" c:type="gfloat"/>
        </array>
      </field>
      <method name="free" c:identifier="gegl_lookup_free" introspectable="0">
        <source-position filename="gegl/gegl-lookup.h" line="71"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lookup" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="69">#GeglLookup to free</doc>
            <type name="Lookup" c:type="GeglLookup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="gegl_lookup_new" introspectable="0">
        <source-position filename="gegl/gegl-lookup.h" line="64"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="62">a #GeglLookup</doc>
          <type name="Lookup" c:type="GeglLookup*"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="59">The function to build a lookup for</doc>
            <type name="LookupFunction" c:type="GeglLookupFunction"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="60">A user data pointer passed to lookup calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_full"
                c:identifier="gegl_lookup_new_full"
                introspectable="0">
        <source-position filename="gegl/gegl-lookup.h" line="52"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="50">a #GeglLookup</doc>
          <type name="Lookup" c:type="GeglLookup*"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none" closure="1">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="44">The function to build a lookup for</doc>
            <type name="LookupFunction" c:type="GeglLookupFunction"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="45">A user data pointer passed to lookup calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="46">Lower bound of the lookup</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="47">Upper bound of the lookup</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="precision" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-lookup.h"
                 line="48">The precision of the lookup table</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="LookupFunction" c:type="GeglLookupFunction">
      <source-position filename="gegl/gegl-lookup.h" line="26"/>
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="gfloat"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="MAJOR_VERSION" value="0" c:type="GEGL_MAJOR_VERSION">
      <source-position filename="gegl/gegl-version.h" line="36"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAX_AUDIO_CHANNELS"
              value="8"
              c:type="GEGL_MAX_AUDIO_CHANNELS">
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="36"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="47" c:type="GEGL_MICRO_VERSION">
      <source-position filename="gegl/gegl-version.h" line="38"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="4" c:type="GEGL_MINOR_VERSION">
      <source-position filename="gegl/gegl-version.h" line="37"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="MapFlags" c:type="GeglMapFlags">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadata.h"
           line="92">Flags controlling the mapping strategy.</doc>
      <source-position filename="gegl/gegl-metadata.h" line="102"/>
      <member name="map_exclude_unmapped"
              value="1"
              c:identifier="GEGL_MAP_EXCLUDE_UNMAPPED">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="94">Prevent further mapping from being registered.</doc>
      </member>
    </enumeration>
    <record name="Matrix3"
            c:type="GeglMatrix3"
            glib:type-name="GeglMatrix3"
            glib:get-type="gegl_matrix3_get_type"
            c:symbol-prefix="matrix3">
      <source-position filename="gegl/gegl-matrix.h" line="39"/>
      <field name="coeff" writable="1">
        <array zero-terminated="0" fixed-size="9">
          <type name="gdouble" c:type="gdouble"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gegl_matrix3_new">
        <source-position filename="gegl/gegl-matrix.h" line="57"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-matrix.h"
               line="55">A newly allocated #GeglMatrix3</doc>
          <type name="Matrix3" c:type="GeglMatrix3*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="gegl_matrix3_copy">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="137">Returns a copy of @src.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="143"/>
        <return-value transfer-ownership="full">
          <type name="Matrix3" c:type="GeglMatrix3*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="139">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_into" c:identifier="gegl_matrix3_copy_into">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="127">Copies the matrix in @src into @dst.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="129">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="130">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="determinant" c:identifier="gegl_matrix3_determinant">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="145">Returns the determinant for the matrix.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="151"/>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="147">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gegl_matrix3_equal">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="75">Check if two matrices are equal.

Returns TRUE if the matrices are equal.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="84"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="77">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="matrix2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="78">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="identity" c:identifier="gegl_matrix3_identity">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="59">Set the provided @matrix to the identity matrix.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="65"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="61">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="gegl_matrix3_invert">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="153">Inverts @matrix.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="159"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="155">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_affine" c:identifier="gegl_matrix3_is_affine">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="117">Check if a matrix only does an affine transformation.

Returns TRUE if the matrix only does an affine transformation.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="125"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="119">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_identity" c:identifier="gegl_matrix3_is_identity">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="87">Check if a matrix is the identity matrix.

Returns TRUE if the matrix is the identity matrix.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="95"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="89">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_scale" c:identifier="gegl_matrix3_is_scale">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="97">Check if a matrix only does scaling.

Returns TRUE if the matrix only does scaling.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="99">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_translate" c:identifier="gegl_matrix3_is_translate">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="107">Check if a matrix only does translation.

Returns TRUE if the matrix only does trasnlation.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="115"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="109">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="gegl_matrix3_multiply">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="161">Multiples @product = @left · @right</doc>
        <source-position filename="gegl/gegl-matrix.h" line="169"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="163">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="164">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </parameter>
          <parameter name="product" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="165">a #GeglMatrix3 to store the result in.</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="originate" c:identifier="gegl_matrix3_originate">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="173">Shift the origin of the transformation specified by @matrix
to (@x, @y). In other words, calculate the matrix that:

1. Translates the input by (-@x, -@y).

2. Transforms the result using the original @matrix.

3. Translates the result by (@x, @y).</doc>
        <source-position filename="gegl/gegl-matrix.h" line="189"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="175">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="176">x coordinate of new origin</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="177">y coordinate of new origin.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_string" c:identifier="gegl_matrix3_parse_string">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="208">Parse a transofmation matrix from a string.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="216"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="210">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="211">a string describing the matrix (right now a small subset of the
transform strings allowed by SVG)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="round_error" c:identifier="gegl_matrix3_round_error">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="67">Rounds numerical errors in @matrix to the nearest integer.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="73"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="69">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gegl_matrix3_to_string">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="218">Serialize a #GeglMatrix3 to a string.

Returns a freshly allocated string representing that #GeglMatrix3, the
returned string should be g_free()'d.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="228"/>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="220">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="gegl_matrix3_transform_point">
        <doc xml:space="preserve"
             filename="gegl/gegl-matrix.h"
             line="194">transforms the coordinates provided in @x and @y and changes to the
coordinates gotten when the transformed with the matrix.</doc>
        <source-position filename="gegl/gegl-matrix.h" line="204"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="196">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="const GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="197">pointer to an x coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-matrix.h"
                 line="198">pointer to an y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <interface name="Metadata"
               c:symbol-prefix="metadata"
               c:type="GeglMetadata"
               glib:type-name="GeglMetadata"
               glib:get-type="gegl_metadata_get_type"
               glib:type-struct="MetadataInterface">
      <source-position filename="gegl/gegl-metadata.h" line="183"/>
      <virtual-method name="get_resolution" invoker="get_resolution">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="231">Retrieve resolution from the application image metadata.  Intended for use
by the image file writer.  If resolution is not supported by the application
or if the operation fails %FALSE is returned and the resolution values are
not updated.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="166"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="243">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="233">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="unit" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="234">#GeglResolutionUnit return location</doc>
            <type name="ResolutionUnit" c:type="GeglResolutionUnit*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="235">X resolution return location</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="236">Y resolution return location</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_get_value" invoker="iter_get_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="304">Retrieve image file metadata from the application.  Intended for use by the
image file writer. If the operation fails it returns %FALSE and @value is
not updated.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="180"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="314">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="306">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="307">#GeglMetadataIter referencing the value to get</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="308">Value to set in the interface</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_init" invoker="iter_init">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="266">Initialise an iterator to find all supported metadata keys.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="173"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="268">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="269">#GeglMetadataIter to be initialised</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_lookup" invoker="iter_lookup">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="249">Look up the specified key and initialise an iterator to reference the
associated metadata. The iterator is used in conjunction with
gegl_metadata_set_value() and gegl_metadata_get_value(). Note that this
iterator is not valid for gegl_metadata_iter_next().</doc>
        <source-position filename="gegl/gegl-metadata.h" line="170"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="260">%TRUE if key is found.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="251">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="252">#GeglMetadataIter to be initialised</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="253">Name of the value look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_next" invoker="iter_next">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="276">Move the iterator to the next metadata item</doc>
        <source-position filename="gegl/gegl-metadata.h" line="175"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="283">key name if found, else %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="278">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="279">#GeglMetadataIter to be updated</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="iter_set_value" invoker="iter_set_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="288">Set application data retrieved from image file's metadata.  Intended for use
by the image file reader.  If the operation fails it returns %FALSE and
@value is ignored.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="177"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="298">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="290">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="291">#GeglMetadataIter referencing the value to set</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="292">Value to set in the interface</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="register_map" invoker="register_map">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="185">Set the name of the file module and pass an array of mappings from
file-format specific metadata names to those used by Gegl. A GValue
transformation function may be supplied, e.g. to parse or format timestamps.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="156"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="187">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="file_module" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="188">String identifying the file module, e.g, `"gegl:png-save"`</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="189">Flags specifying capabilities of underlying file format</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="190">Array of mappings from file module metadata
             names to Gegl well-known names.</doc>
            <array length="3"
                   zero-terminated="0"
                   c:type="const GeglMetadataMap*">
              <type name="MetadataMap" c:type="GeglMetadataMap"/>
            </array>
          </parameter>
          <parameter name="n_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="192">Number of entries in @map</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_resolution" invoker="set_resolution">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="214">Set resolution retrieved from image file's metadata.  Intended for use by
the image file reader.  If resolution is not supported by the application or
if the operation fails %FALSE is returned and the values are ignored.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="163"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="225">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="216">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="unit" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="217">Specify #GeglResolutionUnit</doc>
            <type name="ResolutionUnit" c:type="GeglResolutionUnit"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="218">X resolution</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="219">Y resolution</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_resolution"
              c:identifier="gegl_metadata_get_resolution">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="231">Retrieve resolution from the application image metadata.  Intended for use
by the image file writer.  If resolution is not supported by the application
or if the operation fails %FALSE is returned and the resolution values are
not updated.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="245"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="243">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="233">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="unit" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="234">#GeglResolutionUnit return location</doc>
            <type name="ResolutionUnit" c:type="GeglResolutionUnit*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="235">X resolution return location</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="236">Y resolution return location</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_get_value"
              c:identifier="gegl_metadata_iter_get_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="304">Retrieve image file metadata from the application.  Intended for use by the
image file writer. If the operation fails it returns %FALSE and @value is
not updated.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="316"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="314">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="306">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="307">#GeglMetadataIter referencing the value to get</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="308">Value to set in the interface</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_init" c:identifier="gegl_metadata_iter_init">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="266">Initialise an iterator to find all supported metadata keys.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="273"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="268">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="269">#GeglMetadataIter to be initialised</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_lookup" c:identifier="gegl_metadata_iter_lookup">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="249">Look up the specified key and initialise an iterator to reference the
associated metadata. The iterator is used in conjunction with
gegl_metadata_set_value() and gegl_metadata_get_value(). Note that this
iterator is not valid for gegl_metadata_iter_next().</doc>
        <source-position filename="gegl/gegl-metadata.h" line="262"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="260">%TRUE if key is found.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="251">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="252">#GeglMetadataIter to be initialised</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="253">Name of the value look up</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_next" c:identifier="gegl_metadata_iter_next">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="276">Move the iterator to the next metadata item</doc>
        <source-position filename="gegl/gegl-metadata.h" line="285"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="283">key name if found, else %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="278">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="279">#GeglMetadataIter to be updated</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="iter_set_value"
              c:identifier="gegl_metadata_iter_set_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="288">Set application data retrieved from image file's metadata.  Intended for use
by the image file reader.  If the operation fails it returns %FALSE and
@value is ignored.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="300"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="298">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="290">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="iter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="291">#GeglMetadataIter referencing the value to set</doc>
            <type name="MetadataIter" c:type="GeglMetadataIter*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="292">Value to set in the interface</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_map" c:identifier="gegl_metadata_register_map">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="185">Set the name of the file module and pass an array of mappings from
file-format specific metadata names to those used by Gegl. A GValue
transformation function may be supplied, e.g. to parse or format timestamps.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="198"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="187">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="file_module" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="188">String identifying the file module, e.g, `"gegl:png-save"`</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="189">Flags specifying capabilities of underlying file format</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="190">Array of mappings from file module metadata
             names to Gegl well-known names.</doc>
            <array length="3"
                   zero-terminated="0"
                   c:type="const GeglMetadataMap*">
              <type name="MetadataMap" c:type="GeglMetadataMap"/>
            </array>
          </parameter>
          <parameter name="n_map" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="192">Number of entries in @map</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolution"
              c:identifier="gegl_metadata_set_resolution">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="214">Set resolution retrieved from image file's metadata.  Intended for use by
the image file reader.  If resolution is not supported by the application or
if the operation fails %FALSE is returned and the values are ignored.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="227"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadata.h"
               line="225">%TRUE if successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="216">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
          <parameter name="unit" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="217">Specify #GeglResolutionUnit</doc>
            <type name="ResolutionUnit" c:type="GeglResolutionUnit"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="218">X resolution</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="219">Y resolution</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="unregister_map"
              c:identifier="gegl_metadata_unregister_map">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="204">Unregister the file module mappings and any further mappings added or
modified by the application.  This should be called after the file module
completes operations.</doc>
        <source-position filename="gegl/gegl-metadata.h" line="212"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="metadata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="206">The #GeglMetadata interface</doc>
            <type name="Metadata" c:type="GeglMetadata*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <class name="MetadataHash"
           c:symbol-prefix="metadata_hash"
           c:type="GeglMetadataHash"
           parent="MetadataStore"
           glib:type-name="GeglMetadataHash"
           glib:get-type="gegl_metadata_hash_get_type"
           glib:type-struct="MetadataHashClass">
      <source-position filename="gegl/gegl-metadatahash.h" line="28"/>
      <implements name="Metadata"/>
      <constructor name="new" c:identifier="gegl_metadata_hash_new">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatahash.h"
             line="45">Create a new #GeglMetadataHash</doc>
        <source-position filename="gegl/gegl-metadatahash.h" line="52"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatahash.h"
               line="50">New #GeglMetadataHash cast to #GeglMetadataStore</doc>
          <type name="MetadataStore" c:type="GeglMetadataStore*"/>
        </return-value>
      </constructor>
    </class>
    <record name="MetadataHashClass"
            c:type="GeglMetadataHashClass"
            glib:is-gtype-struct-for="MetadataHash">
      <source-position filename="gegl/gegl-metadatahash.h" line="28"/>
      <field name="parent_class">
        <type name="MetadataStoreClass" c:type="GeglMetadataStoreClass"/>
      </field>
    </record>
    <record name="MetadataInterface"
            c:type="GeglMetadataInterface"
            glib:is-gtype-struct-for="Metadata">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadata.h"
           line="137">The #GeglMetadata interface structure.</doc>
      <source-position filename="gegl/gegl-metadata.h" line="183"/>
      <field name="base_iface" readable="0" private="1">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="register_map">
        <callback name="register_map">
          <source-position filename="gegl/gegl-metadata.h" line="156"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="187">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="file_module" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="188">String identifying the file module, e.g, `"gegl:png-save"`</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="189">Flags specifying capabilities of underlying file format</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="map" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="190">Array of mappings from file module metadata
             names to Gegl well-known names.</doc>
              <array length="4"
                     zero-terminated="0"
                     c:type="const GeglMetadataMap*">
                <type name="MetadataMap" c:type="GeglMetadataMap"/>
              </array>
            </parameter>
            <parameter name="n_map" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="192">Number of entries in @map</doc>
              <type name="gsize" c:type="gsize"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_resolution">
        <callback name="set_resolution">
          <source-position filename="gegl/gegl-metadata.h" line="163"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="225">%TRUE if successful.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="216">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="unit" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="217">Specify #GeglResolutionUnit</doc>
              <type name="ResolutionUnit" c:type="GeglResolutionUnit"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="218">X resolution</doc>
              <type name="gfloat" c:type="gfloat"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="219">Y resolution</doc>
              <type name="gfloat" c:type="gfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_resolution">
        <callback name="get_resolution">
          <source-position filename="gegl/gegl-metadata.h" line="166"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="243">%TRUE if successful.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="233">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="unit" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="234">#GeglResolutionUnit return location</doc>
              <type name="ResolutionUnit" c:type="GeglResolutionUnit*"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="235">X resolution return location</doc>
              <type name="gfloat" c:type="gfloat*"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="236">Y resolution return location</doc>
              <type name="gfloat" c:type="gfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_lookup">
        <callback name="iter_lookup">
          <source-position filename="gegl/gegl-metadata.h" line="170"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="260">%TRUE if key is found.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="251">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="252">#GeglMetadataIter to be initialised</doc>
              <type name="MetadataIter" c:type="GeglMetadataIter*"/>
            </parameter>
            <parameter name="key" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="253">Name of the value look up</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_init">
        <callback name="iter_init">
          <source-position filename="gegl/gegl-metadata.h" line="173"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="268">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="269">#GeglMetadataIter to be initialised</doc>
              <type name="MetadataIter" c:type="GeglMetadataIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_next">
        <callback name="iter_next">
          <source-position filename="gegl/gegl-metadata.h" line="175"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="283">key name if found, else %NULL</doc>
            <type name="utf8" c:type="const gchar*"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="278">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="279">#GeglMetadataIter to be updated</doc>
              <type name="MetadataIter" c:type="GeglMetadataIter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_set_value">
        <callback name="iter_set_value">
          <source-position filename="gegl/gegl-metadata.h" line="177"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="298">%TRUE if successful.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="290">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="291">#GeglMetadataIter referencing the value to set</doc>
              <type name="MetadataIter" c:type="GeglMetadataIter*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="292">Value to set in the interface</doc>
              <type name="GObject.Value" c:type="const GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="iter_get_value">
        <callback name="iter_get_value">
          <source-position filename="gegl/gegl-metadata.h" line="180"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadata.h"
                 line="314">%TRUE if successful.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="metadata" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="306">The #GeglMetadata interface</doc>
              <type name="Metadata" c:type="GeglMetadata*"/>
            </parameter>
            <parameter name="iter" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="307">#GeglMetadataIter referencing the value to get</doc>
              <type name="MetadataIter" c:type="GeglMetadataIter*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadata.h"
                   line="308">Value to set in the interface</doc>
              <type name="GObject.Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="MetadataIter" c:type="GeglMetadataIter">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadata.h"
           line="124">An opaque type representing a metadata iterator.</doc>
      <source-position filename="gegl/gegl-metadata.h" line="135"/>
      <field name="stamp" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="user_data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="user_data2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="user_data3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="MetadataMap" c:type="GeglMetadataMap">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadata.h"
           line="108">Struct to describe how a metadata variable is mapped from the name used by
the image file module to the name used by Gegl.  An optional transform
function may be specified, e.g. to transform from a #GDatetime to a string.</doc>
      <source-position filename="gegl/gegl-metadata.h" line="122"/>
      <field name="local_name" writable="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="110">Name of metadata variable used in the file module.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="name" writable="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="111">Standard metadata variable name used by Gegl.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </field>
      <field name="transform" writable="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="112">Optional #GValue transform function.</doc>
        <type name="GObject.ValueTransform" c:type="GValueTransform"/>
      </field>
    </record>
    <class name="MetadataStore"
           c:symbol-prefix="metadata_store"
           c:type="GeglMetadataStore"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="GeglMetadataStore"
           glib:get-type="gegl_metadata_store_get_type"
           glib:type-struct="MetadataStoreClass">
      <source-position filename="gegl/gegl-metadatastore.h" line="159"/>
      <implements name="Metadata"/>
      <virtual-method name="_declare">
        <source-position filename="gegl/gegl-metadatastore.h" line="131"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="shadow" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="_get_value">
        <source-position filename="gegl/gegl-metadatastore.h" line="139"/>
        <return-value transfer-ownership="none">
          <type name="GObject.Value" c:type="const GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="generate_value" introspectable="0">
        <source-position filename="gegl/gegl-metadatastore.h" line="152"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="transform" transfer-ownership="none">
            <type name="GObject.ValueTransform" c:type="GValueTransform"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="has_value" invoker="has_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="608">Test whether the #GeglMetadataStore contains a value for the specified name.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="141"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="615">%TRUE if metadata is declared and contains a valid value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="610">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="611">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="parse_value" introspectable="0">
        <source-position filename="gegl/gegl-metadatastore.h" line="148"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="transform" transfer-ownership="none">
            <type name="GObject.ValueTransform" c:type="GValueTransform"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pspec" introspectable="0">
        <source-position filename="gegl/gegl-metadatastore.h" line="134"/>
        <return-value>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="register_hook">
        <source-position filename="gegl/gegl-metadatastore.h" line="145"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="file_module_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_value" invoker="set_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="632">Set the specified metadata value. If @value is %NULL the default value from
the associated #GParamSpec is used. This operation will fail if the value
has not been previously declared.  A `changed::name` signal is emitted when
the value is set. If the value is shadowed by a property a `notify::name`
signal is also emitted.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="136"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="634">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="635">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="636">(nullable): A valid #GValue or %NULL</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="declare" c:identifier="gegl_metadata_store_declare">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="598">Declare a metadata value using a #GParamSpec.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="605"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="600">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="601">A #GParamSpec</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_artist"
              c:identifier="gegl_metadata_store_get_artist"
              glib:get-property="artist">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="373">Get name of image creator.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="381"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="379">Artist or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="375">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_comment"
              c:identifier="gegl_metadata_store_get_comment"
              glib:get-property="comment">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="509">Get the comment.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="517"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="515">Comment or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="511">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_copyright"
              c:identifier="gegl_metadata_store_get_copyright"
              glib:get-property="copyright">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="428">Get the copyright notice.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="436"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="434">Copyright or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="430">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="gegl_metadata_store_get_description"
              glib:get-property="description">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="400">Get description of image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="408"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="406">Description or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="402">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_disclaimer"
              c:identifier="gegl_metadata_store_get_disclaimer"
              glib:get-property="disclaimer">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="456">Get the legal disclaimer.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="464"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="462">Disclaimer or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="458">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_file_module_name"
              c:identifier="gegl_metadata_store_get_file_module_name"
              glib:get-property="file-module-name">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="320">Return the name registered by the current file module.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="328"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="326">Current file module name or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="322">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resolution_unit"
              c:identifier="gegl_metadata_store_get_resolution_unit"
              glib:get-property="resolution-unit">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="244">Get the units used for resolution.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="253"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="250">a #GeglResolutionUnit.</doc>
          <type name="ResolutionUnit" c:type="GeglResolutionUnit"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="246">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resolution_x"
              c:identifier="gegl_metadata_store_get_resolution_x"
              glib:get-property="resolution-x">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="273">Get the X resolution or density in dots per unit.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="281"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="279">X resolution</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="275">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resolution_y"
              c:identifier="gegl_metadata_store_get_resolution_y"
              glib:get-property="resolution-y">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="301">Get the Y resolution or density in dots per unit.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="309"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="307">Y resolution</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="303">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_software"
              c:identifier="gegl_metadata_store_get_software"
              glib:get-property="software">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="535">Get software used to create the image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="543"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="541">Software or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="537">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_source"
              c:identifier="gegl_metadata_store_get_source"
              glib:get-property="source">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="561">Get device used to create the image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="569"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="567">source or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="563">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string" c:identifier="gegl_metadata_store_get_string">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="676">A slightly more efficient version of gegl_metadata_store_get_value()
for string values avoiding a duplication. Otherwise it behaves the same
gegl_metadata_store_get_value().</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="687"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="685">String or %NULL.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="678">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="679">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_timestamp"
              c:identifier="gegl_metadata_store_get_timestamp"
              glib:get-property="timestamp">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="587">Get time of original image creation.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="596"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="593">#GDateTime or %NULL if not set. Free with
                          g_date_time_unref() when done.</doc>
          <type name="GLib.DateTime" c:type="GDateTime*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="589">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_title"
              c:identifier="gegl_metadata_store_get_title"
              glib:get-property="title">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="347">Get title or caption for image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="355"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="353">Title or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="349">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_value" c:identifier="gegl_metadata_store_get_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="648">Retrieve the metadata value. @value must be initialised with a compatible
type. If the value is unset or has not been previously declared @value is
unchanged and an error message is logged.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="658"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="650">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="651">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="652">An initialised #GValue.</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_warning"
              c:identifier="gegl_metadata_store_get_warning"
              glib:get-property="warning">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="483">Get warning.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="491"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="489">Warning or %NULL if not set</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="485">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_value" c:identifier="gegl_metadata_store_has_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="608">Test whether the #GeglMetadataStore contains a value for the specified name.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="617"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="615">%TRUE if metadata is declared and contains a valid value.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="610">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="611">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify" c:identifier="gegl_metadata_store_notify">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="703">gegl_metadata_store_notify() is called by subclasses when the value of a
metadata variable changes. It emits the `::changed` signal with the variable
name as the detail parameter.  Set @shadow = %TRUE if variable is shadowed
by a property so that a notify signal is emitted with the property name as
the detail parameter.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="715"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="705">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="706">The #GParamSpec used to declare the variable.</doc>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </parameter>
          <parameter name="shadow" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="707">The metadata variable shadows a property.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="register" c:identifier="gegl_metadata_store_register">
        <source-position filename="gegl/gegl-metadatastore.h" line="698"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="692">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="local_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="693">Metadata name known to file module</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="694">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="transform" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="695">A #GValueTransform function or %NULL</doc>
            <type name="GObject.ValueTransform" c:type="GValueTransform"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_artist"
              c:identifier="gegl_metadata_store_set_artist"
              glib:set-property="artist">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="363">Set name of image creator.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="370"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="365">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="artist" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="366">Artist string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_comment"
              c:identifier="gegl_metadata_store_set_comment"
              glib:set-property="comment">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="499">Set the miscellaneous comment; conversion from GIF comment.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="506"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="501">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="comment" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="502">Comment string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_copyright"
              c:identifier="gegl_metadata_store_set_copyright"
              glib:set-property="copyright">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="417">Set the copyright notice.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="424"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="419">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="copyright" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="420">Copyright string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_description"
              c:identifier="gegl_metadata_store_set_description"
              glib:set-property="description">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="389">Set description of image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="396"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="391">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="392">Description string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_disclaimer"
              c:identifier="gegl_metadata_store_set_disclaimer"
              glib:set-property="disclaimer">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="445">Set the legal disclaimer.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="452"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="447">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="disclaimer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="448">Disclaimer string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolution_unit"
              c:identifier="gegl_metadata_store_set_resolution_unit"
              glib:set-property="resolution-unit">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="233">Set the units used for the resolution (density) values.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="240"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="235">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="unit" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="236">Units as a #GeglResolutionUnit</doc>
            <type name="ResolutionUnit" c:type="GeglResolutionUnit"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolution_x"
              c:identifier="gegl_metadata_store_set_resolution_x"
              glib:set-property="resolution-x">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="262">Set the X resolution or density in dots per unit.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="269"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="264">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="resolution_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="265">X resolution or density</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resolution_y"
              c:identifier="gegl_metadata_store_set_resolution_y"
              glib:set-property="resolution-y">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="290">Set the Y resolution or density in dots per unit.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="297"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="292">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="resolution_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="293">Y resolution or density</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_software"
              c:identifier="gegl_metadata_store_set_software"
              glib:set-property="software">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="525">Set software used to create the image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="532"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="527">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="software" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="528">Software string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source"
              c:identifier="gegl_metadata_store_set_source"
              glib:set-property="source">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="551">Set device used to create the image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="558"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="553">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="554">Source string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_string" c:identifier="gegl_metadata_store_set_string">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="662">A slightly more efficient version of gegl_metadata_store_set_value()
for string values avoiding a duplication. Otherwise it behaves the same
gegl_metadata_store_set_value().</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="672"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="664">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="665">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="666">String value to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_timestamp"
              c:identifier="gegl_metadata_store_set_timestamp"
              glib:set-property="timestamp">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="577">Set time of original image creation.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="584"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="579">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="580">A #GDateTime</doc>
            <type name="GLib.DateTime" c:type="const GDateTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_title"
              c:identifier="gegl_metadata_store_set_title"
              glib:set-property="title">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="337">Set title or caption for image.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="344"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="339">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="title" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="340">Title string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_value" c:identifier="gegl_metadata_store_set_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="632">Set the specified metadata value. If @value is %NULL the default value from
the associated #GParamSpec is used. This operation will fail if the value
has not been previously declared.  A `changed::name` signal is emitted when
the value is set. If the value is shadowed by a property a `notify::name`
signal is also emitted.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="644"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="634">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="635">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="636">(nullable): A valid #GValue or %NULL</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_warning"
              c:identifier="gegl_metadata_store_set_warning"
              glib:set-property="warning">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="473">Set the warning of nature of content.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="480"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="475">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="warning" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="476">Warning string</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="typeof_value"
              c:identifier="gegl_metadata_store_typeof_value">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="620">Get the declared type of the value in the #GeglMetadataStore.</doc>
        <source-position filename="gegl/gegl-metadatastore.h" line="629"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="627">Declared #GType of metadata value or %G_TYPE_INVALID.</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="622">A #GeglMetadataStore</doc>
            <type name="MetadataStore" c:type="GeglMetadataStore*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="623">Metadata name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="artist"
                writable="1"
                transfer-ownership="none"
                setter="set_artist"
                getter="get_artist"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="357">Name of image creator.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="comment"
                writable="1"
                transfer-ownership="none"
                setter="set_comment"
                getter="get_comment"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="493">Miscellaneous comment; conversion from GIF comment.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="copyright"
                writable="1"
                transfer-ownership="none"
                setter="set_copyright"
                getter="get_copyright"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="411">Copyright notice.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="description"
                writable="1"
                transfer-ownership="none"
                setter="set_description"
                getter="get_description"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="383">Description of image (possibly long).</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="disclaimer"
                writable="1"
                transfer-ownership="none"
                setter="set_disclaimer"
                getter="get_disclaimer"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="439">Legal disclaimer.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="file-module-name"
                transfer-ownership="none"
                getter="get_file_module_name"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="312">Current file loader/saver module name. Valid only while a #GeglMetadata
mapping is registered. This property is mainly provided for use in signal
handlers.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="resolution-unit"
                writable="1"
                transfer-ownership="none"
                setter="set_resolution_unit"
                getter="get_resolution_unit"
                default-value="GEGL_RESOLUTION_UNIT_DPI">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="227">A #GeglResolutionUnit specifying units for the image resolution (density).</doc>
        <type name="ResolutionUnit"/>
      </property>
      <property name="resolution-x"
                writable="1"
                transfer-ownership="none"
                setter="set_resolution_x"
                getter="get_resolution_x"
                default-value="300.000000">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="256">X resolution or density in dots per unit.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="resolution-y"
                writable="1"
                transfer-ownership="none"
                setter="set_resolution_y"
                getter="get_resolution_y"
                default-value="300.000000">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="284">Y resolution or density in dots per unit.</doc>
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="software"
                writable="1"
                transfer-ownership="none"
                setter="set_software"
                getter="get_software"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="519">Software used to create the image.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="source"
                writable="1"
                transfer-ownership="none"
                setter="set_source"
                getter="get_source"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="545">Device used to create the image.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="timestamp"
                writable="1"
                transfer-ownership="none"
                setter="set_timestamp"
                getter="get_timestamp">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="571">Time of original image creation.</doc>
        <type name="GLib.DateTime"/>
      </property>
      <property name="title"
                writable="1"
                transfer-ownership="none"
                setter="set_title"
                getter="get_title"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="331">Short (one line) title or caption for image.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="warning"
                writable="1"
                transfer-ownership="none"
                setter="set_warning"
                getter="get_warning"
                default-value="NULL">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="467">Warning of nature of content.</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="last" detailed="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="161">`::changed` is emitted when a metadata value is changed. This is analogous
to the `GObject::notify` signal.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="164">A #GParamSpec declaring the metadata value</doc>
            <type name="GObject.ParamSpec"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="generate-value" when="last" detailed="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="194">If a signal handler is connected to `::generate-value` a signal is emitted
when the file module accesses a value using gegl_metadata_get_value().
The signal handler must generate a value of the type specified in the pspec
argument. The signal handler's return value indicates the success of the
operation.

If no handler is connected the mapped metadata value is accessed normally,</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="208">%TRUE if a value is generated successfully.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="197">A #GParamSpec declaring the metadata value</doc>
            <type name="GObject.ParamSpec"/>
          </parameter>
          <parameter name="value"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="198">An initialised #GValue.</doc>
            <type name="GObject.Value"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="mapped" when="last">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="170">`::mapped` is emitted after a file module registers a mapping and before
other processing takes place.  An application may respond to the signal by
registering additional mappings or overriding existing values, for example
it might override the TIFF ImageDescription tag to format multiple metadata
values into the description.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file_module" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="173">The file module name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="exclude_unmapped" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="174">%TRUE if the file module cannot handle unmapped values</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="parse-value" when="last" detailed="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="211">If a signal handler is connected to `::parse-value` a signal is emitted when
the file module accesses a value using gegl_metadata_set_value().  The
signal handler should parse the value supplied in the #GValue and may set
any number of metadata values using gegl_metadata_store_set_value().

If no handler is connected the mapped metadata value is set normally,</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-metadatastore.h"
               line="224">%TRUE if parsing is successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="pspec" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="214">A #GParamSpec declaring the metadata value</doc>
            <type name="GObject.ParamSpec"/>
          </parameter>
          <parameter name="value"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="215">A #GValue containing the value to parse.</doc>
            <type name="GObject.Value"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="unmapped" when="last">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadatastore.h"
             line="183">`::unmapped` is emitted when a file module tries to look up an unmapped
metadata name. When the handler returns a second attempt is made to look
up the metadata.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="file_module" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="186">The file module name</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
          <parameter name="local_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="187">The unmapped metadata name as used by the file module</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="MetadataStoreClass"
            c:type="GeglMetadataStoreClass"
            glib:is-gtype-struct-for="MetadataStore">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadatastore.h"
           line="67">The class structure for the #GeglMetadataStore</doc>
      <source-position filename="gegl/gegl-metadatastore.h" line="159"/>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="_declare" introspectable="0">
        <callback name="_declare">
          <source-position filename="gegl/gegl-metadatastore.h" line="131"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="shadow" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pspec" introspectable="0">
        <callback name="pspec" introspectable="0">
          <source-position filename="gegl/gegl-metadatastore.h" line="134"/>
          <return-value>
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_value">
        <callback name="set_value">
          <source-position filename="gegl/gegl-metadatastore.h" line="136"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadatastore.h"
                   line="634">A #GeglMetadataStore</doc>
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadatastore.h"
                   line="635">Metadata name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadatastore.h"
                   line="636">(nullable): A valid #GValue or %NULL</doc>
              <type name="GObject.Value" c:type="const GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_get_value" introspectable="0">
        <callback name="_get_value">
          <source-position filename="gegl/gegl-metadatastore.h" line="139"/>
          <return-value transfer-ownership="none">
            <type name="GObject.Value" c:type="const GValue*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="has_value">
        <callback name="has_value">
          <source-position filename="gegl/gegl-metadatastore.h" line="141"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-metadatastore.h"
                 line="615">%TRUE if metadata is declared and contains a valid value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadatastore.h"
                   line="610">A #GeglMetadataStore</doc>
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="gegl/gegl-metadatastore.h"
                   line="611">Metadata name</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="register_hook">
        <callback name="register_hook">
          <source-position filename="gegl/gegl-metadatastore.h" line="145"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="file_module_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="flags" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="parse_value" introspectable="0">
        <callback name="parse_value" introspectable="0">
          <source-position filename="gegl/gegl-metadatastore.h" line="148"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="transform" transfer-ownership="none">
              <type name="GObject.ValueTransform" c:type="GValueTransform"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GObject.Value" c:type="const GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="generate_value" introspectable="0">
        <callback name="generate_value" introspectable="0">
          <source-position filename="gegl/gegl-metadatastore.h" line="152"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="MetadataStore" c:type="GeglMetadataStore*"/>
            </parameter>
            <parameter name="pspec" transfer-ownership="none">
              <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
            </parameter>
            <parameter name="transform" transfer-ownership="none">
              <type name="GObject.ValueTransform" c:type="GValueTransform"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GObject.Value" c:type="GValue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <function-macro name="NODE" c:identifier="GEGL_NODE" introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="81"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Node"
           c:symbol-prefix="node"
           c:type="GeglNode"
           parent="GObject.Object"
           glib:type-name="GeglNode"
           glib:get-type="gegl_node_get_type">
      <constructor name="new" c:identifier="gegl_node_new">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="55">Create a new graph that can contain further processing nodes.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="64"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="60">A new top level #GeglNode (which can be used as a graph). When you
are done using this graph instance it should be unreferenced with g_object_unref.
This will also free any sub nodes created from this node.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_file" c:identifier="gegl_node_new_from_file">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="663">The #GeglNode returned contains the graph described by the tree of stacks
in the XML document. The tree is connected to the "output" pad of the
returned node and thus can be used directly for processing.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="673"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="671">a GeglNode containing the parsed XML as a subgraph.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="665">the path to a file on the local file system to be parsed.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_serialized"
                   c:identifier="gegl_node_new_from_serialized">
        <source-position filename="gegl/gegl-utils.h" line="92"/>
        <return-value transfer-ownership="full">
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <parameter name="chaindata" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path_root" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_xml" c:identifier="gegl_node_new_from_xml">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="648">The #GeglNode returned contains the graph described by the tree of stacks
in the XML document. The tree is connected to the "output" pad of the
returned node and thus can be used directly for processing.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="660"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="658">a GeglNode containing the parsed XML as a subgraph.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <parameter name="xmldata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="650">a \0 terminated string containing XML data to be parsed.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path_root" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="651">a file system path that relative paths in the XML will be
resolved in relation to.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_child" c:identifier="gegl_node_add_child">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="371">Make the GeglNode @graph, take a reference on child. This reference
will be dropped when the reference count on the graph reaches zero.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="381"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="379">the child.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="graph" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="373">a GeglNode (graph)</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="374">a GeglNode.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="blit" c:identifier="gegl_node_blit" introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="280">Render a rectangular region from a node.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="300"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="282">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="283">the scale to render at 1.0 is default, other values changes the
width/height of the sampled region.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="285">the rectangle to render from the node, the coordinate system used is
coordinates after scale has been applied.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="287">the #BablFormat desired.</doc>
            <type name="Babl.Object" c:type="const Babl*"/>
          </parameter>
          <parameter name="destination_buf"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="288">a memory buffer large enough to contain the data, can be
left as NULL when forcing a rendering of a region.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="290">rowstride in bytes, or GEGL_AUTO_ROWSTRIDE to compute the
rowstride based on the width and bytes per pixel for the specified format.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="292">an or'ed combination of GEGL_BLIT_DEFAULT, GEGL_BLIT_CACHE and
GEGL_BLIT_DIRTY. if cache is enabled, a cache will be set up for subsequent
requests of image data from this node. By passing in GEGL_BLIT_DIRTY the
function will return with the latest rendered results in the cache without
regard to wheter the regions has been rendered or not.</doc>
            <type name="BlitFlags" c:type="GeglBlitFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="blit_buffer" c:identifier="gegl_node_blit_buffer">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="308">Render a rectangular region from a node to the given buffer.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="317"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="310">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="311">the #GeglBuffer to render to.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="roi"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="312">the rectangle to render.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="313">mipmap level to render (0 for all)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="abyss_policy" transfer-ownership="none">
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="gegl_node_connect">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="138">Makes a connection between the pads of two nodes, one pad should
be a source pad the other a sink pad, order does not matter.

Returns TRUE if the connection was successfully made.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="151"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="140">a node</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="a_pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="141">and the pad of the node we want connected.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="142">another node</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="b_pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="143">and its pad to be connected.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_from" c:identifier="gegl_node_connect_from">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="103">Makes a connection between the pads of two nodes.

Returns TRUE if the connection was successfully made.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="115"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="105">the node we're connecting an input to</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="input_pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="106">the name of the input pad we are connecting to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="107">the node producing data we want to connect.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="output_pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="108">the output pad we want to use on the source.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to" c:identifier="gegl_node_connect_to">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="121">Makes a connection between the pads of two nodes.

Returns TRUE if the connection was successfully made.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="132"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="123">the node producing data we want to connect.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="output_pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="124">the output pad we want to use on the source.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="125">the node we're connecting an input to</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="input_pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="126">the name of the input pad we are connecting to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_child" c:identifier="gegl_node_create_child">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="593">Creates a new processing node that performs the specified operation.
All properties of the operation will have their default values. This
is included as an addition to #gegl_node_new_child in the public API to have
a non varargs entry point for bindings as well as sometimes simpler more
readable code.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="611"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="604">a newly created node. The node will be destroyed by the parent.
Calling g_object_unref on a node will cause the node to be dropped by the
parent. (You may also add additional references using
g_object_ref/g_object_unref, but in general relying on the parents reference
counting is easiest.)</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="595">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="596">the type of node to create.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="detect" c:identifier="gegl_node_detect">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="421">Performs hit detection by returning the node providing data at a given
coordinate pair. Currently operates only on bounding boxes and not
pixel data.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="434"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="431">the GeglNode providing the
data ending up at @x,@y in the output of @node.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="423">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="424">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="425">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="gegl_node_disconnect">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="178">Disconnects node connected to @input_pad of @node (if any).

Returns TRUE if a connection was broken.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="187"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="180">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="input_pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="181">the input pad to disconnect.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_property" c:identifier="gegl_node_find_property">
        <source-position filename="gegl/graph/gegl-node.h" line="447"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="444">the GParamSpec of property or NULL
if no such property exists.</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="441">the node to lookup a paramspec on</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="442">the name of the property to get a paramspec for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="gegl_node_get" introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="236">Gets properties of a #GeglNode.
---
double level;
char  *path;

gegl_node_get (png_save, "path", &amp;path, NULL);
gegl_node_get (threshold, "level", &amp;level, NULL);</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="251"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="238">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="239">name of the first property to get.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="240">return location for the first property, followed optionally by more
name/value pairs, followed by NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounding_box"
              c:identifier="gegl_node_get_bounding_box"
              shadowed-by="introspectable_get_bounding_box"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="452">Returns the position and dimensions of a rectangle spanning the area
defined by a node.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="459"/>
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="454">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_children" c:identifier="gegl_node_get_children">
        <source-position filename="gegl/graph/gegl-node.h" line="469"/>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="465">a list
of the nodes contained within a GeglNode that is a subgraph.
Use g_list_free () on the list when done.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Node"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="463">the node to retrieve the children of.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_consumers" c:identifier="gegl_node_get_consumers">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="471">Retrieve which pads on which nodes are connected to a named output_pad,
and the number of connections. Both the location for the generated
nodes array and pads array can be left as NULL. If they are non NULL
both should be freed with g_free. The arrays are NULL terminated.

Returns the number of consumers connected to this output_pad.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="485"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="473">the node we are querying.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="output_pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="474">the output pad we want to know who uses.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="nodes"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="475">optional return location for array of nodes.</doc>
            <array c:type="GeglNode***">
              <type name="Node" c:type="GeglNode**"/>
            </array>
          </parameter>
          <parameter name="pads"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="476">optional return location for array of pad names.</doc>
            <array c:type="const gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_gegl_operation"
              c:identifier="gegl_node_get_gegl_operation"
              glib:get-property="gegl-operation">
        <source-position filename="gegl/graph/gegl-node.h" line="521"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="518">The operation object
associated with this node or NULL if there is no op associated.</doc>
          <type name="Operation" c:type="GeglOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="516">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_input_proxy" c:identifier="gegl_node_get_input_proxy">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="490">Proxies are used to route between nodes of a subgraph contained within
a node.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="501"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="498">Returns an input proxy for the named pad.
If no input proxy exists with this name a new one will be created.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="492">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="493">the name of the pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_operation"
              c:identifier="gegl_node_get_operation"
              glib:get-property="operation">
        <source-position filename="gegl/graph/gegl-node.h" line="512"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="508">The type of processing operation associated with this
node, or NULL if there is no op associated. The special name
"GraphNode" is returned if the node is the container of a subgraph.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="506">a #GeglNode</doc>
            <type name="Node" c:type="const GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_output_proxy"
              c:identifier="gegl_node_get_output_proxy">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="523">Proxies are used to route between nodes of a subgraph contained within
a node.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="534"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="531">Returns a output proxy for the named pad.
If no output proxy exists with this name a new one will be created.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="525">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="526">the name of the pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="gegl_node_get_parent">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="398">Returns a GeglNode that keeps a reference on a child.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="406"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="404">the parent of a node or NULL.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="400">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_passthrough"
              c:identifier="gegl_node_get_passthrough"
              glib:get-property="passthrough">
        <source-position filename="gegl/graph/gegl-node.h" line="706"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_producer" c:identifier="gegl_node_get_producer">
        <source-position filename="gegl/graph/gegl-node.h" line="547"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="544">the node providing data
or NULL if no node is connected to the input_pad.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="539">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="input_pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="540">the input pad we want to get the producer for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="output_pad_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="541">optional pointer to a location where we can store a
                  freshly allocated string with the name of the output pad.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_property"
              c:identifier="gegl_node_get_property"
              shadowed-by="introspectable_get_property"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="615">This is mainly included for language bindings. Using #gegl_node_get is
more convenient when programming in C.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="625"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="617">the node to get a property from</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="618">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="619">pointer to a GValue where the value of the property should be stored</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist"
              c:identifier="gegl_node_get_valist"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="255">valist version of #gegl_node_get</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="264"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="257">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="258">name of the first property to get.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="259">return location for the first property, followed optionally by more
name/value pairs, followed by NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_pad" c:identifier="gegl_node_has_pad">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="551">Returns TRUE if the node has a pad with the specified name</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="558"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="553">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="pad_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="554">the pad name we are looking for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="introspectable_get_bounding_box"
              c:identifier="gegl_node_introspectable_get_bounding_box"
              shadows="get_bounding_box">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="81">Returns the position and dimensions of a rectangle spanning the area
defined by a node.</doc>
        <source-position filename="gegl/gegl-introspection-support.h"
                         line="91"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-introspection-support.h"
               line="88">pointer a #GeglRectangle</doc>
          <type name="Rectangle" c:type="GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="83">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="introspectable_get_property"
              c:identifier="gegl_node_introspectable_get_property"
              shadows="get_property">
        <source-position filename="gegl/gegl-introspection-support.h"
                         line="101"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-introspection-support.h"
               line="98">pointer to a GValue containing the value of the property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="95">the node to get a property from</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-introspection-support.h"
                 line="96">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_graph" c:identifier="gegl_node_is_graph">
        <source-position filename="gegl/graph/gegl-node.h" line="711"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="link" c:identifier="gegl_node_link">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="155">This is equivalent to gegl_node_connect (source, "output", sink, "input");</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="162"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="157">the producer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="158">the consumer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_many"
              c:identifier="gegl_node_link_many"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="165">Synthetic sugar for linking a chain of nodes with "output"-&gt;"input". The
list is NULL terminated.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="174"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="167">the producer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="168">the first consumer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="169">NULL, or optionally more consumers followed by NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="list_input_pads" c:identifier="gegl_node_list_input_pads">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="561">If the node has any input pads this function returns a null terminated
array of pad names, otherwise it returns NULL. The return value can be
freed with g_strfreev().</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="571"/>
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="563">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_output_pads"
              c:identifier="gegl_node_list_output_pads">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="573">If the node has any output pads this function returns a null terminated
array of pad names, otherwise it returns NULL. The return value can be
freed with g_strfreev().</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="583"/>
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="575">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_child"
              c:identifier="gegl_node_new_child"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="66">Creates a new processing node that performs the specified operation with
a NULL terminated list of key/value pairs for initial parameter values
configuring the operation. Usually the first pair should be "operation"
and the type of operation to be associated. If no operation is provided
the node doesn't have an initial operation and can be used to construct
a subgraph with special middle-man routing nodes created with
#gegl_node_get_output_proxy and #gegl_node_get_input_proxy.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="87"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="81">A newly created #GeglNode. The node will be destroyed by the parent.
Calling g_object_unref on a node will cause the node to be dropped by the
parent. (You may also add additional references using
g_object_ref/g_object_unref, but in general relying on the parents reference
counting is easiest.)</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="68">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="69">the first property name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="70">first property value, optionally followed by more key/value pairs,
terminated with NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="new_processor" c:identifier="gegl_node_new_processor">
        <source-position filename="gegl/process/gegl-processor.h" line="42"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/process/gegl-processor.h"
               line="40">a new #GeglProcessor.</doc>
          <type name="Processor" c:type="GeglProcessor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/process/gegl-processor.h"
                 line="36">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/process/gegl-processor.h"
                 line="37">the #GeglRectangle to work on or NULL to work on all available
data.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="process" c:identifier="gegl_node_process">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="323">Render a composition. This can be used for instance on a node with a "png-save"
operation to render all necessary data, and make it be written to file. This
function wraps the usage of a GeglProcessor in a single blocking function
call. If you need a non-blocking operation, then make a direct use of
#gegl_processor_work. See #GeglProcessor.

---
GeglNode      *gegl;
GeglRectangle  roi;
GeglNode      *png_save;
unsigned char *buffer;

gegl = gegl_parse_xml (xml_data);
roi      = gegl_node_get_bounding_box (gegl);
# create png_save from the graph, the parent/child relationship
# only mean anything when it comes to memory management.
png_save = gegl_node_new_child (gegl,
                                "operation", "gegl:png-save",
                                "path",      "output.png",
                                NULL);

gegl_node_link (gegl, png_save);
gegl_node_process (png_save);

buffer = malloc (roi.w*roi.h*4);
gegl_node_blit (gegl,
                1.0,
                &amp;roi,
                babl_format("R'G'B'A u8"),
                buffer,
                GEGL_AUTO_ROWSTRIDE,
                GEGL_BLIT_DEFAULT);</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="360"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink_node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="325">a #GeglNode without outputs.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="progress" c:identifier="gegl_node_progress">
        <source-position filename="gegl/graph/gegl-node.h" line="713"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_child" c:identifier="gegl_node_remove_child">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="384">Removes a child from a GeglNode. The reference previously held will be
dropped so increase the reference count before removing when reparenting
a child between two graphs.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="395"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="393">the child.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="graph" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="386">a GeglNode (graph)</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="387">a GeglNode.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gegl_node_set" introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="202">Set properties on a node, possible properties to be set are the properties
of the currently set operations as well as &lt;em&gt;"name"&lt;/em&gt; and
&lt;em&gt;"operation"&lt;/em&gt;. &lt;em&gt;"operation"&lt;/em&gt; changes the current operations
set for the node, &lt;em&gt;"name"&lt;/em&gt; doesn't have any role internally in
GEGL.
---
gegl_node_set (node, "brightness", -0.2,
                     "contrast",   2.0,
                     NULL);</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="219"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="204">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="205">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="206">value for the first property, followed optionally by more name/value
pairs, followed by NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_enum_as_string"
              c:identifier="gegl_node_set_enum_as_string">
        <source-position filename="gegl/graph/gegl-node.h" line="717"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_passthrough"
              c:identifier="gegl_node_set_passthrough"
              glib:set-property="passthrough">
        <source-position filename="gegl/graph/gegl-node.h" line="708"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="passthrough" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_property" c:identifier="gegl_node_set_property">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="629">This is mainly included for language bindings. Using #gegl_node_set is
more convenient when programming in C.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="638"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="631">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="632">the name of the property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="633">a GValue containing the value to be set in the property.</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_time" c:identifier="gegl_node_set_time">
        <doc xml:space="preserve"
             filename="gegl/gegl-utils.h"
             line="97">Sets the right value in animated properties of this node and all its
dependendcies to be the specified time position.</doc>
        <source-position filename="gegl/gegl-utils.h" line="106"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-utils.h"
                 line="99">a a GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-utils.h"
                 line="100">the time to set the properties which have keyfraes attached to</doc>
            <type name="gdouble" c:type="double"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="gegl_node_set_valist"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="223">valist version of #gegl_node_set</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="232"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="225">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="226">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="227">value for the first property, followed optionally by more name/value
pairs, followed by NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_xml" c:identifier="gegl_node_to_xml">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="675">Returns a freshly allocated \0 terminated string containing a XML
serialization of the composition produced by a node (and thus also
the nodes contributing data to the specified node). To export a
gegl graph, connect the internal output node to an output proxy (see
#gegl_node_get_output_proxy.) and use the proxy node as the basis
for the serialization.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="687"/>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="677">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="path_root" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="678">filesystem path to construct relative paths from.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_xml_full" c:identifier="gegl_node_to_xml_full">
        <doc xml:space="preserve"
             filename="gegl/graph/gegl-node.h"
             line="690">Returns a freshly allocated \0 terminated string containing a XML
serialization of a segment of a graph from @head to @tail nodes.
If @tail is %NULL then this behaves just like #gegl_node_to_xml.</doc>
        <source-position filename="gegl/graph/gegl-node.h" line="702"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/graph/gegl-node.h"
               line="700">XML serialization of a graph segment.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="head" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="692">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="tail"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="693">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="path_root" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/graph/gegl-node.h"
                 line="694">filesystem path to construct relative paths from.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="cache-policy"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="Auto">
        <type name="CachePolicy"/>
      </property>
      <property name="dont-cache"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="gegl-operation"
                writable="1"
                construct="1"
                transfer-ownership="none"
                getter="get_gegl_operation">
        <type name="Operation"/>
      </property>
      <property name="name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="operation"
                writable="1"
                construct="1"
                transfer-ownership="none"
                getter="get_operation">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="passthrough"
                writable="1"
                construct="1"
                transfer-ownership="none"
                setter="set_passthrough"
                getter="get_passthrough"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="use-opencl"
                writable="1"
                construct="1"
                transfer-ownership="none"
                default-value="TRUE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <glib:signal name="computed" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Rectangle"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidated" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Rectangle"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="progress" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="NodeFunction" c:type="GeglNodeFunction">
      <source-position filename="gegl/property-types/gegl-path.h" line="283"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="PathItem" c:type="const GeglPathItem*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="OPERATION"
                    c:identifier="GEGL_OPERATION"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="74"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Operation"
           c:symbol-prefix="operation"
           c:type="GeglOperation"
           parent="GObject.Object"
           glib:type-name="GeglOperation"
           glib:get-type="gegl_operation_get_type">
      <function name="find_property"
                c:identifier="gegl_operation_find_property">
        <source-position filename="gegl/gegl-operations-util.h" line="89"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-operations-util.h"
               line="86">The paramspec of the matching property - or
NULL if there as no match.</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="83">the name of the operation type we want to locate a property on.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="84">the name of the property we seek.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_key" c:identifier="gegl_operation_get_key">
        <source-position filename="gegl/gegl-operations-util.h" line="151"/>
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_op_version"
                c:identifier="gegl_operation_get_op_version">
        <source-position filename="gegl/graph/gegl-node.h" line="715"/>
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="op_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_property_key"
                c:identifier="gegl_operation_get_property_key">
        <source-position filename="gegl/gegl-operations-util.h" line="102"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-operations-util.h"
               line="98">NULL or a string with the meta-data value for the operation
key.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="94">the name of the operation type we want to query to property keys for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="95">the property to query a key for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_key_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="96">the property mata data key to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_keys" c:identifier="gegl_operation_list_keys">
        <source-position filename="gegl/gegl-operations-util.h" line="148"/>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve"
               filename="gegl/gegl-operations-util.h"
               line="145">An allocated NULL
terminated array of operation-key names. The list should be freed with g_free after use.</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="142">the name of the operation type we want to query to property keys for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_keys"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="143">return location for number of property keys.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_properties"
                c:identifier="gegl_operation_list_properties">
        <source-position filename="gegl/gegl-operations-util.h" line="77"/>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve"
               filename="gegl/gegl-operations-util.h"
               line="74">An allocated array of #GParamSpecs describing the properties
of the operation available when a node has operation_type set. The list should be freed with g_free after use.</doc>
          <array length="1" zero-terminated="0" c:type="GParamSpec**">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="71">the name of the operation type we want to query to properties of.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_properties_p"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="72">return location for number of properties.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_property_keys"
                c:identifier="gegl_operation_list_property_keys">
        <source-position filename="gegl/gegl-operations-util.h" line="116"/>
        <return-value transfer-ownership="container">
          <doc xml:space="preserve"
               filename="gegl/gegl-operations-util.h"
               line="113">An allocated NULL terminated array of property-key names. The list should be freed with g_free after use.</doc>
          <array length="2" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="108">the name of the operation type we want to query to property keys for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="109">the property to query a key for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_keys"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/gegl-operations-util.h"
                 line="110">return location for number of property
keys.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <record name="OperationContext"
            c:type="GeglOperationContext"
            disguised="1"
            opaque="1">
      <source-position filename="gegl/gegl-types.h" line="69"/>
    </record>
    <enumeration name="Orientation"
                 glib:type-name="GeglOrientation"
                 glib:get-type="gegl_orientation_get_type"
                 c:type="GeglOrientation">
      <member name="horizontal"
              value="0"
              c:identifier="GEGL_ORIENTATION_HORIZONTAL"
              glib:nick="horizontal"
              glib:name="Horizontal">
      </member>
      <member name="vertical"
              value="1"
              c:identifier="GEGL_ORIENTATION_VERTICAL"
              glib:nick="vertical"
              glib:name="Vertical">
      </member>
    </enumeration>
    <constant name="PARAM_NO_VALIDATE"
              value="64"
              c:type="GEGL_PARAM_NO_VALIDATE">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="33"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PARAM_SPEC_DOUBLE"
                    c:identifier="GEGL_PARAM_SPEC_DOUBLE"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="47"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_ENUM"
                    c:identifier="GEGL_PARAM_SPEC_ENUM"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="250"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_FILE_PATH"
                    c:identifier="GEGL_PARAM_SPEC_FILE_PATH"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="207"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_FORMAT"
                    c:identifier="GEGL_PARAM_SPEC_FORMAT"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="329"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_INT"
                    c:identifier="GEGL_PARAM_SPEC_INT"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="112"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_SEED"
                    c:identifier="GEGL_PARAM_SPEC_SEED"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="295"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_STRING"
                    c:identifier="GEGL_PARAM_SPEC_STRING"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="166"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PARAM_SPEC_URI"
                    c:identifier="GEGL_PARAM_SPEC_URI"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="362"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PATH" c:identifier="GEGL_PATH" introspectable="0">
      <source-position filename="gegl/property-types/gegl-path.h" line="37"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PATH_CLASS"
                    c:identifier="GEGL_PATH_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-path.h" line="38"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PATH_GET_CLASS"
                    c:identifier="GEGL_PATH_GET_CLASS"
                    introspectable="0">
      <source-position filename="gegl/property-types/gegl-path.h" line="41"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PROCESSOR"
                    c:identifier="GEGL_PROCESSOR"
                    introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="88"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <bitfield name="PadType" c:type="GeglPadType">
      <source-position filename="gegl/gegl-types.h" line="35"/>
      <member name="output" value="256" c:identifier="GEGL_PARAM_PAD_OUTPUT">
      </member>
      <member name="input" value="512" c:identifier="GEGL_PARAM_PAD_INPUT">
      </member>
    </bitfield>
    <callback name="ParallelDistributeAreaFunc"
              c:type="GeglParallelDistributeAreaFunc">
      <doc xml:space="preserve"
           filename="gegl/gegl-parallel.h"
           line="58">Specifies the type of function passed to
gegl_parallel_distribute_area().

The function should process the sub-area specified by @area.</doc>
      <source-position filename="gegl/gegl-parallel.h" line="69"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="area" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="60">the current sub-area</doc>
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="61">user data pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ParallelDistributeFunc"
              c:type="GeglParallelDistributeFunc">
      <doc xml:space="preserve"
           filename="gegl/gegl-parallel.h"
           line="26">Specifies the type of function passed to gegl_parallel_distribute().

The function should process the @i-th part of the data, out of @n
equal parts.  @n may be less-than or equal-to the @max_n argument
passed to gegl_parallel_distribute().</doc>
      <source-position filename="gegl/gegl-parallel.h" line="38"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="i" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="28">the current thread index, in the range [0,@n)</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="29">the number of threads execution is distributed across</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="30">user data pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ParallelDistributeRangeFunc"
              c:type="GeglParallelDistributeRangeFunc">
      <doc xml:space="preserve"
           filename="gegl/gegl-parallel.h"
           line="42">Specifies the type of function passed to
gegl_parallel_distribute_range().

The function should process @size elements of the data, starting
at @offset.</doc>
      <source-position filename="gegl/gegl-parallel.h" line="54"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="44">the current data offset</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="45">the current data size</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="46">user data pointer</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ParamAudioFragment"
           c:symbol-prefix="param_audio_fragment"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamAudioFragment"
           glib:get-type="gegl_param_audio_fragment_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamColor"
           c:symbol-prefix="param_color"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamColor"
           glib:get-type="gegl_param_color_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamCurve"
           c:symbol-prefix="param_curve"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamCurve"
           glib:get-type="gegl_param_curve_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamDouble"
           c:symbol-prefix="param_double"
           parent="GObject.ParamSpecDouble"
           glib:type-name="GeglParamDouble"
           glib:get-type="gegl_param_double_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamEnum"
           c:symbol-prefix="param_enum"
           parent="GObject.ParamSpecEnum"
           glib:type-name="GeglParamEnum"
           glib:get-type="gegl_param_enum_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamFilePath"
           c:symbol-prefix="param_file_path"
           parent="GObject.ParamSpecString"
           glib:type-name="GeglParamFilePath"
           glib:get-type="gegl_param_file_path_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamFormat"
           c:symbol-prefix="param_format"
           parent="GObject.ParamSpecPointer"
           glib:type-name="GeglParamFormat"
           glib:get-type="gegl_param_format_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamInt"
           c:symbol-prefix="param_int"
           parent="GObject.ParamSpecInt"
           glib:type-name="GeglParamInt"
           glib:get-type="gegl_param_int_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamPath"
           c:symbol-prefix="param_path"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamPath"
           glib:get-type="gegl_param_path_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamSeed"
           c:symbol-prefix="param_seed"
           parent="GObject.ParamSpecUInt"
           glib:type-name="GeglParamSeed"
           glib:get-type="gegl_param_seed_get_type"
           glib:fundamental="1">
    </class>
    <record name="ParamSpecDouble" c:type="GeglParamSpecDouble">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="65"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecDouble" c:type="GParamSpecDouble"/>
      </field>
      <field name="ui_minimum" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_maximum" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_gamma" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_step_small" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_step_big" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_digits" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="set_digits"
              c:identifier="gegl_param_spec_double_set_digits">
        <source-position filename="gegl/property-types/gegl-paramspecs.h"
                         line="104"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpecDouble" c:type="GeglParamSpecDouble*"/>
          </instance-parameter>
          <parameter name="digits" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_steps" c:identifier="gegl_param_spec_double_set_steps">
        <source-position filename="gegl/property-types/gegl-paramspecs.h"
                         line="100"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpecDouble" c:type="GeglParamSpecDouble*"/>
          </instance-parameter>
          <parameter name="small_step" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="big_step" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ParamSpecEnum" c:type="GeglParamSpecEnum">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="261"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecEnum" c:type="GParamSpecEnum"/>
      </field>
      <field name="excluded_values" writable="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <method name="exclude_value"
              c:identifier="gegl_param_spec_enum_exclude_value">
        <source-position filename="gegl/property-types/gegl-paramspecs.h"
                         line="285"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="espec" transfer-ownership="none">
            <type name="ParamSpecEnum" c:type="GeglParamSpecEnum*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ParamSpecFilePath" c:type="GeglParamSpecFilePath">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="218"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecString" c:type="GParamSpecString"/>
      </field>
      <field name="no_validate" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="null_ok" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecFormat" c:type="GeglParamSpecFormat">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="335"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecPointer" c:type="GParamSpecPointer"/>
      </field>
    </record>
    <record name="ParamSpecInt" c:type="GeglParamSpecInt">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="124"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecInt" c:type="GParamSpecInt"/>
      </field>
      <field name="ui_minimum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="ui_maximum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="ui_gamma" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_step_small" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="ui_step_big" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="set_steps" c:identifier="gegl_param_spec_int_set_steps">
        <source-position filename="gegl/property-types/gegl-paramspecs.h"
                         line="157"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpecInt" c:type="GeglParamSpecInt*"/>
          </instance-parameter>
          <parameter name="small_step" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="big_step" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ParamSpecSeed" c:type="GeglParamSpecSeed">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="304"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecUInt" c:type="GParamSpecUInt"/>
      </field>
      <field name="ui_minimum" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="ui_maximum" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecString" c:type="GeglParamSpecString">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="175"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecString" c:type="GParamSpecString"/>
      </field>
      <field name="no_validate" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="null_ok" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecUri" c:type="GeglParamSpecUri">
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="373"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecString" c:type="GParamSpecString"/>
      </field>
      <field name="no_validate" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="null_ok" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <class name="ParamString"
           c:symbol-prefix="param_string"
           parent="GObject.ParamSpecString"
           glib:type-name="GeglParamString"
           glib:get-type="gegl_param_string_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamUri"
           c:symbol-prefix="param_uri"
           parent="GObject.ParamSpecString"
           glib:type-name="GeglParamUri"
           glib:get-type="gegl_param_uri_get_type"
           glib:fundamental="1">
    </class>
    <class name="Path"
           c:symbol-prefix="path"
           c:type="GeglPath"
           parent="GObject.Object"
           glib:type-name="GeglPath"
           glib:get-type="gegl_path_get_type"
           glib:type-struct="PathClass">
      <source-position filename="gegl/property-types/gegl-path.h" line="43"/>
      <constructor name="new" c:identifier="gegl_path_new">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="96">Creates a new #GeglPath with no nodes.

Returns the newly created #GeglPath</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="103"/>
        <return-value transfer-ownership="full">
          <type name="Path" c:type="GeglPath*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="gegl_path_new_from_string">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="105">Creates a new #GeglPath with the nodes described in the string
@instructions. See gegl_path_parse_string() for details of the
format of the string.

Returns the newly created #GeglPath</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="115"/>
        <return-value transfer-ownership="full">
          <type name="Path" c:type="GeglPath*"/>
        </return-value>
        <parameters>
          <parameter name="instructions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="107">a string describing the path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="add_flattener"
                c:identifier="gegl_path_add_flattener"
                introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="470">Add a new flattener, the flattener should produce a type of path that
GeglPath already understands, if the flattener is unable to flatten
the incoming path (doesn't understand the instructions), the original
path should be returned.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="479"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="472">a #GeglFlattenerFunc</doc>
            <type name="FlattenerFunc" c:type="GeglFlattenerFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="add_type" c:identifier="gegl_path_add_type">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="418">Adds a new type to the path system, FIXME this should probably
return something on registration conflicts, for now it expects
all registered paths to be aware of each other.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="428"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="420">a gchar to recognize in path descriptions.</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="421">the number of floating point data items the instruction takes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="422">a human readable description of this entry</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="append" c:identifier="gegl_path_append" introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="367">Use as follows: gegl_path_append (path, 'M', 0.0, 0.0);
and gegl_path_append (path, 'C', 10.0, 10.0, 50.0, 10.0, 60.0, 0.0) the
number of arguments are determined from the instruction provided.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="376"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="369">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="370">first instruction.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="calc" c:identifier="gegl_path_calc">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="232">Compute the coordinates of the path at the @position (length measured from
start of path, not including discontinuities).</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="242"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="234">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="235">how far along the path.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="236">return location for x coordinate.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="237">return location for y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="calc_values"
              c:identifier="gegl_path_calc_values"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="247">Compute @num_samples for a path into the provided arrays @xs and @ys
the returned values include the start and end positions of the path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="257"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="249">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="num_samples"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="250">number of samples to compute</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="xs"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="251">return location for x coordinates</doc>
            <array length="0" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
          <parameter name="ys"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="252">return location for y coordinates</doc>
            <array length="0" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="calc_y_for_x" c:identifier="gegl_path_calc_y_for_x">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="218">Compute a corresponding y coordinate for a given x input coordinate,
returns 0 if computed correctly and -1 if the path doesn't exist for the
specified x coordinate.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="228"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="220">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="221">x coordinate to compute for</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="222">return location for y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gegl_path_clear">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="315">Remove all nods from a @path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="321"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="317">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="closest_point" c:identifier="gegl_path_closest_point">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="196">Figure out what and where on a path is closest to arbitrary coordinates.

Returns the length along the path where the closest point was encountered.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="210"/>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="198">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="199">x coordinate.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="200">y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="on_path_x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="201">return location for x coordinate on the path that was closest</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="on_path_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="202">return location for y coordinate on the path that was closest</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="node_pos_before"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="203">the node position interpreted before this position
was deemed the closest coordinate.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dirty" c:identifier="gegl_path_dirty">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="527">Marks the path as dirty and issues an invalidation for the path rendering,
use this if modifying the values of a GeglPathPoint inline.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="535"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="529">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="gegl_path_foreach">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="288">Execute a provided function for every node in the path (useful for
drawing and otherwise traversing a path.)</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="297"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="290">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="each_item"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="291">a function to call for each node in the path.</doc>
            <type name="NodeFunction" c:type="GeglNodeFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="292">user data to pass to the function (in addition to the GeglPathItem).</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_flat" c:identifier="gegl_path_foreach_flat">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="301">Execute a provided function for the segments of a poly line approximating
the path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="310"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="303">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="each_item"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="304">a function to call for each node in the path.</doc>
            <type name="NodeFunction" c:type="GeglNodeFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="305">user data to pass to a node.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="freeze" c:identifier="gegl_path_freeze">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="379">Make the @GeglPath stop firing signals as it changes must be paired with a
gegl_path_thaw() for the signals to start again.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="386"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="381">a @GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bounds" c:identifier="gegl_path_get_bounds">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="262">Compute the bounding box of a path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="272"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="264">a #GeglPath.</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="min_x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="265">return location for minimum x coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="max_x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="266">return location for maximum x coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="min_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="267">return location for minimum y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="max_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="268">return location for maximum y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flat_path"
              c:identifier="gegl_path_get_flat_path"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="490">Return a polyline version of @path</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="496"/>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="492">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="gegl_path_get_length">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="137">Returns the total length of the path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="145"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="143">the length of the path.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="139">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_matrix" c:identifier="gegl_path_get_matrix">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="186">Get the transformation matrix of the path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="193"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="188">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="189">a #GeglMatrix3 to copy the matrix into</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_nodes" c:identifier="gegl_path_get_n_nodes">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="127">Retrieves the number of nodes in the path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="133">the number of nodes in the path.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="129">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_node" c:identifier="gegl_path_get_node">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="147">Retrieve the node of the path at position @pos.

Returns TRUE if the node was successfully retrieved.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="157"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="149">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="150">the node number to retrieve</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="node"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="151">a pointer to a #GeglPathItem record to be written.</doc>
            <type name="PathItem" c:type="GeglPathItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_path"
              c:identifier="gegl_path_get_path"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="482">Return the internal untouched #GeglPathList</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="488"/>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="484">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert_node" c:identifier="gegl_path_insert_node">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="323">Insert the new node @node at position @pos in @path.
if @pos = -1, the node is added in the last position.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="332"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="325">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="326">the position we want the new node to have.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="327">pointer to a structure describing the GeglPathItem we want to store</doc>
            <type name="PathItem" c:type="const GeglPathItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="gegl_path_is_empty">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="117">Check if the path contains any nodes.

Returns TRUE if the path has no nodes.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="125"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="119">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_string" c:identifier="gegl_path_parse_string">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="356">Parses @instructions and appends corresponding nodes to path (call
gegl_path_clean() first if you want to replace the existing path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="364"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="358">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="instructions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="359">a string describing a path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_node" c:identifier="gegl_path_remove_node">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="346">Removes the node number @pos in @path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="353"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="348">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="349">a node in the path.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_node" c:identifier="gegl_path_replace_node">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="335">Replaces the exiting node at position @pos in @path.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="343"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="337">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="338">the position we want the new node to have.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="339">pointer to a structure describing the GeglPathItem we want to store.</doc>
            <type name="PathItem" c:type="const GeglPathItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_matrix" c:identifier="gegl_path_set_matrix">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="173">Set the transformation matrix of the path.

The path is transformed through this matrix when being evaluated,
causing the calculated positions and length to be changed by the transform.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="183"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="175">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="176">a #GeglMatrix3 to copy the matrix from</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="thaw" c:identifier="gegl_path_thaw">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="388">Restart firing signals (unless the path has been frozen multiple times).</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="394"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="390">a @GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gegl_path_to_string">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="161">Serialize the paths nodes to a string.</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="170"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="167">return a string with instructions describing the string you
need to free this with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="163">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="PathClass"
            c:type="GeglPathClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Path">
      <source-position filename="gegl/property-types/gegl-path.h" line="43"/>
    </record>
    <record name="PathItem" c:type="GeglPathItem">
      <source-position filename="gegl/property-types/gegl-path.h" line="93"/>
      <field name="type" writable="1">
        <type name="gchar" c:type="gchar"/>
      </field>
      <field name="point" writable="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="PathPoint" c:type="GeglPathPoint"/>
        </array>
      </field>
    </record>
    <record name="PathList" c:type="GeglPathList">
      <source-position filename="gegl/property-types/gegl-path.h" line="442"/>
      <field name="next" writable="1">
        <type name="gpointer" c:type="GeglPathList*"/>
      </field>
      <field name="d" writable="1">
        <type name="PathItem" c:type="GeglPathItem"/>
      </field>
      <method name="append"
              c:identifier="gegl_path_list_append"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="445">Appends to path list, if head is NULL a new list is created</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="452"/>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="head" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="447">a #GeglPathList</doc>
            <type name="PathList" c:type="GeglPathList*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="448">additional #GeglPathList items to append</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="gegl_path_list_destroy"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="454">Frees up a path list</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="460"/>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="456">A #GeglPathList</doc>
            <type name="PathList" c:type="GeglPathList*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="PathPoint" c:type="GeglPathPoint">
      <source-position filename="gegl/property-types/gegl-path.h" line="85"/>
      <field name="x" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <method name="dist"
              c:identifier="gegl_path_point_dist"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="516">Compute the distance between #GeglPathPoint @a and @b</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="523"/>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="518">an arbitrary GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="519">an arbitrary GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lerp"
              c:identifier="gegl_path_point_lerp"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="502">linear interpolation between two #GeglPathPoint</doc>
        <source-position filename="gegl/property-types/gegl-path.h"
                         line="511"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="504">return location for the result</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="505">origin GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="506">destination GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/property-types/gegl-path.h"
                 line="507">ratio between @a and @b</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="Processor"
           c:symbol-prefix="processor"
           c:type="GeglProcessor"
           parent="GObject.Object"
           glib:type-name="GeglProcessor"
           glib:get-type="gegl_processor_get_type">
      <method name="get_buffer" c:identifier="gegl_processor_get_buffer">
        <doc xml:space="preserve"
             filename="gegl/process/gegl-processor.h"
             line="81">Returns the (cache) buffer the processor is rendering into, another way of
getting to the same pixel data is calling gegl_node_blit with flags
indicating that we want caching and accept dirty data.</doc>
        <source-position filename="gegl/process/gegl-processor.h" line="92"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/process/gegl-processor.h"
               line="89">the #GeglBuffer rendered into.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/process/gegl-processor.h"
                 line="83">a #GeglProcessor</doc>
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_level" c:identifier="gegl_processor_set_level">
        <source-position filename="gegl/process/gegl-processor.h" line="45"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rectangle"
              c:identifier="gegl_processor_set_rectangle"
              glib:set-property="rectangle">
        <doc xml:space="preserve"
             filename="gegl/process/gegl-processor.h"
             line="50">Change the rectangle a #GeglProcessor is working on.</doc>
        <source-position filename="gegl/process/gegl-processor.h" line="58"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/process/gegl-processor.h"
                 line="52">a #GeglProcessor</doc>
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/process/gegl-processor.h"
                 line="53">the new #GeglRectangle the processor shold work on or NULL
to make it work on all data in the buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scale" c:identifier="gegl_processor_set_scale">
        <source-position filename="gegl/process/gegl-processor.h" line="47"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="scale" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="work" c:identifier="gegl_processor_work">
        <doc xml:space="preserve"
             filename="gegl/process/gegl-processor.h"
             line="62">Do an iteration of work for the processor.

Returns TRUE if there is more work to be done.

---
GeglProcessor *processor = gegl_node_new_processor (node, &amp;roi);
double         progress;

while (gegl_processor_work (processor, &amp;progress))
  g_warning ("%f%% complete", progress);
g_object_unref (processor);</doc>
        <source-position filename="gegl/process/gegl-processor.h" line="79"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/process/gegl-processor.h"
                 line="64">a #GeglProcessor</doc>
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="progress"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/process/gegl-processor.h"
                 line="65">a location to store the (estimated) percentage complete.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <property name="chunksize"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="1048576">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="node"
                readable="0"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Node"/>
      </property>
      <property name="progress"
                writable="1"
                transfer-ownership="none"
                default-value="0.000000">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="rectangle"
                writable="1"
                transfer-ownership="none"
                setter="set_rectangle">
        <type name="gpointer" c:type="gpointer"/>
      </property>
    </class>
    <function-macro name="RECTANGLE"
                    c:identifier="GEGL_RECTANGLE"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-rectangle.h" line="31"/>
      <parameters>
        <parameter name="x">
        </parameter>
        <parameter name="y">
        </parameter>
        <parameter name="w">
        </parameter>
        <parameter name="h">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Random"
            c:type="GeglRandom"
            opaque="1"
            glib:type-name="GeglRandom"
            glib:get-type="gegl_random_get_type"
            c:symbol-prefix="random">
      <source-position filename="gegl/gegl-types.h" line="92"/>
      <constructor name="new" c:identifier="gegl_random_new">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="45">Creates a new random number generator initialized with a random seed.
This structure needs to be freed by the user with gegl_random_free();</doc>
        <source-position filename="gegl/gegl-random.h" line="51"/>
        <return-value transfer-ownership="full">
          <type name="Random" c:type="GeglRandom*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_seed"
                   c:identifier="gegl_random_new_with_seed">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="36">Return an opaque structure associated to the seed.
This structure needs to be freed by the user with gegl_random_free();</doc>
        <source-position filename="gegl/gegl-random.h" line="43"/>
        <return-value transfer-ownership="full">
          <type name="Random" c:type="GeglRandom*"/>
        </return-value>
        <parameters>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="38">an integer seed, change for different permutation.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="duplicate" c:identifier="gegl_random_duplicate">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="53">Return a new copy of an existing GeglRandom</doc>
        <source-position filename="gegl/gegl-random.h" line="59"/>
        <return-value transfer-ownership="full">
          <type name="Random" c:type="GeglRandom*"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="55">The GeglRandom to duplicate</doc>
            <type name="Random" c:type="GeglRandom*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="float" c:identifier="gegl_random_float">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="143">Return a random floating point number in range 0.0 .. 1.0.</doc>
        <source-position filename="gegl/gegl-random.h" line="154"/>
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="145">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="146">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="147">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="148">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="149">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="float_range" c:identifier="gegl_random_float_range">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="80">Return a random floating point number in the range specified,
for the given x,y coordinates and GeglRandom provided, if multiple different
numbers are needed pass in incrementing n's.</doc>
        <source-position filename="gegl/gegl-random.h" line="95"/>
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="82">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="83">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="84">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="85">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="86">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="88">minimum value</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="89">maximum value</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gegl_random_free">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="61">Free a GeglRandom structure created with gegl_random_new() or
gegl_random_new_with_seed()</doc>
        <source-position filename="gegl/gegl-random.h" line="68"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="63">The GeglRandom structure to free</doc>
            <type name="Random" c:type="GeglRandom*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="int" c:identifier="gegl_random_int">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="126">Return a random integer number in range 0 .. MAX_UINT</doc>
        <source-position filename="gegl/gegl-random.h" line="137"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="128">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="129">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="130">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="131">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="132">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="int_range" c:identifier="gegl_random_int_range">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="103">Return a random integer point number in the range specified,
for the given x,y coordinates and GeglRandom provided, if multiple different
numbers are needed pass in incrementing n's.</doc>
        <source-position filename="gegl/gegl-random.h" line="118"/>
        <return-value transfer-ownership="none">
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="105">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="106">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="107">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="108">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="109">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="111">minimum value</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="112">maximum value+1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seed" c:identifier="gegl_random_set_seed">
        <doc xml:space="preserve"
             filename="gegl/gegl-random.h"
             line="70">Change the seed of an existing GeglRandom.</doc>
        <source-position filename="gegl/gegl-random.h" line="77"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="72">The GeglRandom to set</doc>
            <type name="Random" c:type="GeglRandom*"/>
          </instance-parameter>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/gegl-random.h"
                 line="73">an integer seed, change for different permutation.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Rectangle"
            c:type="GeglRectangle"
            glib:type-name="GeglRectangle"
            glib:get-type="gegl_rectangle_get_type"
            c:symbol-prefix="rectangle">
      <source-position filename="gegl/buffer/gegl-buffer.h" line="42"/>
      <field name="x" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="y" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="width" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="height" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <constructor name="new" c:identifier="gegl_rectangle_new">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="66">Creates a new rectangle set with the values from @x, @y, @width and @height.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="75"/>
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle*"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="68">upper left x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="69">upper left y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="70">width in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="71">height in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="align" c:identifier="gegl_rectangle_align">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="159">Aligns @rectangle to a regular tile grid, of which @tile is a representative
tile, and stores the result in @destination.

@alignment can be one of:

  GEGL_RECTANGLE_ALIGNMENT_SUBSET:  Calculate the biggest aligned rectangle
  contained in @rectangle.

  GEGL_RECTANGLE_ALIGNMENT_SUPERSET:  Calculate the smallest aligned
  rectangle containing @rectangle.

  GEGL_RECTANGLE_ALIGNMENT_NEAREST:  Calculate the nearest aligned rectangle
  to @rectangle.

@destination may point to the same object as @rectangle or @tile.

Returns TRUE if the result is not empty.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="184"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="161">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="162">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="tile" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="163">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="alignment" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="164">a #GeglRectangleAlignment value</doc>
            <type name="RectangleAlignment" c:type="GeglRectangleAlignment"/>
          </parameter>
        </parameters>
      </method>
      <method name="align_to_buffer"
              c:identifier="gegl_rectangle_align_to_buffer">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="189">Aligns @rectangle to the tile grid of @buffer, and stores the result in
@destination.

@alignment has the same meaning as for gegl_rectangle_align().

@destination may point to the same object as @rectangle.

Returns TRUE if the result is not empty.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="205"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="191">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="192">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="193">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="alignment" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="194">a #GeglRectangleAlignment value</doc>
            <type name="RectangleAlignment" c:type="GeglRectangleAlignment"/>
          </parameter>
        </parameters>
      </method>
      <method name="bounding_box" c:identifier="gegl_rectangle_bounding_box">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="210">Computes the bounding box of the rectangles @source1 and @source2 and stores the
resulting bounding box in @destination.

@destination may point to the same object as @source1 or @source2.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="221"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="212">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="source1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="213">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="source2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="214">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains" c:identifier="gegl_rectangle_contains">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="296">Checks if the #GeglRectangle @child is fully contained within @parent.

Returns TRUE if the @child is fully contained in @parent.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="305"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="298">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="299">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gegl_rectangle_copy">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="146">Copies the rectangle information stored in @source over the information in
@destination.

@destination may point to the same object as @source.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="156"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="148">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="149">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="gegl_rectangle_dump">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="324">For debugging purposes, not stable API.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="330"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="326">A GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="gegl_rectangle_dup">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="136">Create a new copy of @rectangle.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="144"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-rectangle.h"
               line="142">a #GeglRectangle</doc>
          <type name="Rectangle" c:type="GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="138">the #GeglRectangle to duplicate</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gegl_rectangle_equal">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="96">Check if two #GeglRectangles are equal.

Returns TRUE if @rectangle and @rectangle2 are equal.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="98">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
          <parameter name="rectangle2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="99">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_coords" c:identifier="gegl_rectangle_equal_coords">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="108">Check if a rectangle is equal to a set of parameters.

Returns TRUE if @rectangle and @x,@y @width x @height are equal.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="120"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="110">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="111">X coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="112">Y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="113">width of rectangle</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="114">height of rectangle</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect" c:identifier="gegl_rectangle_intersect">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="225">Calculates the intersection of two rectangles. If the rectangles do not
intersect, dest's width and height are set to 0 and its x and y values
are undefined.

@dest may point to the same object as @src1 or @src2.

Returns TRUE if the rectangles intersect.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="239"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="227">return location for the intersection of @src1 and @src2, or NULL.</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="src1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="228">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="src2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="229">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="gegl_rectangle_is_empty">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="126">Check if a rectangle has zero area.

Returns TRUE if the width or height of @rectangle is 0.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="128">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_infinite_plane"
              c:identifier="gegl_rectangle_is_infinite_plane">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="315">Returns TRUE if the GeglRectangle represents an infininte plane,
FALSE otherwise.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="322"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="317">A GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gegl_rectangle_set">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="80">Sets the @x, @y, @width and @height on @rectangle.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="90"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="82">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="83">upper left x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="84">upper left y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="85">width in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="86">height in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract" c:identifier="gegl_rectangle_subtract">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="243">Subtracts @subtrahend from @minuend, and stores the resulting rectangles in
@destination.  Between 0 and 4 disjoint rectangles may be produced.

@destination may contain @minuend or @subtrahend.

Returns the number of resulting rectangles.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="256"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="245">an array of 4 #GeglRectangle elements</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="minuend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="246">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="subtrahend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="247">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract_bounding_box"
              c:identifier="gegl_rectangle_subtract_bounding_box">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="260">Computes the bounding box of the area formed by subtracting @subtrahend
from @minuend, and stores the result in @destination.

@destination may point to the same object as @minuend or @subtrahend.

Returns TRUE if the result is not empty.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="274"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="262">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="minuend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="263">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="subtrahend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="264">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="xor" c:identifier="gegl_rectangle_xor">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="278">Computes the symmetric difference of the rectangles @source1 and @source2,
and stores the resulting rectangles in @destination.  Between 0 and 4
disjoint rectangles may be produced.

@destination may contain @rectangle1 or @rectangle2.

Returns the number of resulting rectangles.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="292"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="280">an array of 4 #GeglRectangle elements</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="source1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="281">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="source2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-rectangle.h"
                 line="282">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <function name="infinite_plane"
                c:identifier="gegl_rectangle_infinite_plane">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-rectangle.h"
             line="308">Returns a GeglRectangle that represents an infininte plane.</doc>
        <source-position filename="gegl/buffer/gegl-rectangle.h" line="313"/>
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle"/>
        </return-value>
      </function>
    </record>
    <enumeration name="RectangleAlignment"
                 glib:type-name="GeglRectangleAlignment"
                 glib:get-type="gegl_rectangle_alignment_get_type"
                 c:type="GeglRectangleAlignment">
      <member name="subset"
              value="0"
              c:identifier="GEGL_RECTANGLE_ALIGNMENT_SUBSET"
              glib:nick="subset"
              glib:name="Subset">
      </member>
      <member name="superset"
              value="1"
              c:identifier="GEGL_RECTANGLE_ALIGNMENT_SUPERSET"
              glib:nick="superset"
              glib:name="Superset">
      </member>
      <member name="nearest"
              value="2"
              c:identifier="GEGL_RECTANGLE_ALIGNMENT_NEAREST"
              glib:nick="nearest"
              glib:name="Nearest">
      </member>
    </enumeration>
    <enumeration name="ResolutionUnit"
                 glib:type-name="GeglResolutionUnit"
                 glib:get-type="gegl_resolution_unit_get_type"
                 c:type="GeglResolutionUnit">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadata.h"
           line="75">An enumerated type specifying resolution (density) units.  If resolution
units are unknown, X and Y resolution specify the pixel aspect ratio.</doc>
      <member name="none"
              value="0"
              c:identifier="GEGL_RESOLUTION_UNIT_NONE"
              glib:nick="none"
              glib:name="GEGL_RESOLUTION_UNIT_NONE">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="77">Unknown or resolution not applicable.</doc>
      </member>
      <member name="dpi"
              value="1"
              c:identifier="GEGL_RESOLUTION_UNIT_DPI"
              glib:nick="dpi"
              glib:name="GEGL_RESOLUTION_UNIT_DPI">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="78">Dots or pixels per inch.</doc>
      </member>
      <member name="dpm"
              value="2"
              c:identifier="GEGL_RESOLUTION_UNIT_DPM"
              glib:nick="dpm"
              glib:name="GEGL_RESOLUTION_UNIT_DPM">
        <doc xml:space="preserve"
             filename="gegl/gegl-metadata.h"
             line="79">Dots or pixels per metre.</doc>
      </member>
    </enumeration>
    <function-macro name="STATS" c:identifier="GEGL_STATS" introspectable="0">
      <source-position filename="gegl/gegl-types.h" line="61"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Sampler" c:type="GeglSampler" disguised="1" opaque="1">
      <source-position filename="gegl/buffer/gegl-buffer.h" line="32"/>
      <method name="get" c:identifier="gegl_sampler_get">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="560">Perform a sampling with the provided @sampler.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="575"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sampler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="562">a GeglSampler gotten from gegl_buffer_sampler_new</doc>
            <type name="Sampler" c:type="GeglSampler*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="563">x coordinate to sample</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="564">y coordinate to sample</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="565">matrix representing extent of sampling area in source buffer.</doc>
            <type name="BufferMatrix2" c:type="GeglBufferMatrix2*"/>
          </parameter>
          <parameter name="output"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="566">memory location for output data.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="567">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_context_rect"
              c:identifier="gegl_sampler_get_context_rect">
        <source-position filename="gegl/buffer/gegl-buffer.h" line="617"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="615">The context rectangle of the given @sampler.</doc>
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sampler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-buffer.h"
                 line="613">a GeglSampler gotten from gegl_buffer_sampler_new</doc>
            <type name="Sampler" c:type="GeglSampler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fun"
              c:identifier="gegl_sampler_get_fun"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer.h"
             line="510">Get the raw sampler function, the raw sampler function does not do
additional NaN / inifinity checks on passed in coordinates.</doc>
        <source-position filename="gegl/buffer/gegl-buffer.h" line="516"/>
        <return-value>
          <type name="SamplerGetFun" c:type="GeglSamplerGetFun"/>
        </return-value>
        <parameters>
          <instance-parameter name="sampler" transfer-ownership="none">
            <type name="Sampler" c:type="GeglSampler*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="SamplerGetFun" c:type="GeglSamplerGetFun">
      <source-position filename="gegl/buffer/gegl-buffer.h" line="503"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <type name="Sampler" c:type="GeglSampler*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="scale" transfer-ownership="none">
          <type name="BufferMatrix2" c:type="GeglBufferMatrix2*"/>
        </parameter>
        <parameter name="output"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="repeat_mode" transfer-ownership="none">
          <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SamplerType"
                 glib:type-name="GeglSamplerType"
                 glib:get-type="gegl_sampler_type_get_type"
                 c:type="GeglSamplerType">
      <member name="nearest"
              value="0"
              c:identifier="GEGL_SAMPLER_NEAREST"
              glib:nick="nearest"
              glib:name="Nearest">
      </member>
      <member name="linear"
              value="1"
              c:identifier="GEGL_SAMPLER_LINEAR"
              glib:nick="linear"
              glib:name="Linear">
      </member>
      <member name="cubic"
              value="2"
              c:identifier="GEGL_SAMPLER_CUBIC"
              glib:nick="cubic"
              glib:name="Cubic">
      </member>
      <member name="nohalo"
              value="3"
              c:identifier="GEGL_SAMPLER_NOHALO"
              glib:nick="nohalo"
              glib:name="NoHalo">
      </member>
      <member name="lohalo"
              value="4"
              c:identifier="GEGL_SAMPLER_LOHALO"
              glib:nick="lohalo"
              glib:name="LoHalo">
      </member>
    </enumeration>
    <bitfield name="SerializeFlag" c:type="GeglSerializeFlag">
      <source-position filename="gegl/gegl-utils.h" line="30"/>
      <member name="trim_defaults"
              value="1"
              c:identifier="GEGL_SERIALIZE_TRIM_DEFAULTS">
      </member>
      <member name="version" value="2" c:identifier="GEGL_SERIALIZE_VERSION">
      </member>
      <member name="indent" value="4" c:identifier="GEGL_SERIALIZE_INDENT">
      </member>
      <member name="bake_anim"
              value="8"
              c:identifier="GEGL_SERIALIZE_BAKE_ANIM">
      </member>
    </bitfield>
    <enumeration name="SplitStrategy" c:type="GeglSplitStrategy">
      <source-position filename="gegl/gegl-types.h" line="49"/>
      <member name="auto" value="0" c:identifier="GEGL_SPLIT_STRATEGY_AUTO">
      </member>
      <member name="horizontal"
              value="1"
              c:identifier="GEGL_SPLIT_STRATEGY_HORIZONTAL">
      </member>
      <member name="vertical"
              value="2"
              c:identifier="GEGL_SPLIT_STRATEGY_VERTICAL">
      </member>
    </enumeration>
    <class name="Stats"
           c:symbol-prefix="stats"
           c:type="GeglStats"
           parent="GObject.Object"
           glib:type-name="GeglStats"
           glib:get-type="gegl_stats_get_type">
      <property name="active-threads"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="assigned-threads"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="scratch-total"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-busy"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="swap-file-size"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-queue-full"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="swap-queue-stalls"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="swap-queued-total"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-read-total"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-reading"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="swap-total" transfer-ownership="none" default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-total-uncompressed"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-write-total"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-writing"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="tile-alloc-total"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-cache-hits"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-cache-misses"
                transfer-ownership="none"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-cache-total"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-cache-total-max"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-cache-total-uncompressed"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="zoom-total" transfer-ownership="none" default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
    </class>
    <function-macro name="TILE_BACKEND"
                    c:identifier="GEGL_TILE_BACKEND"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="32"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_BACKEND_CLASS"
                    c:identifier="GEGL_TILE_BACKEND_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="33"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_BACKEND_GET_CLASS"
                    c:identifier="GEGL_TILE_BACKEND_GET_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="36"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_HANDLER"
                    c:identifier="GEGL_TILE_HANDLER"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="36"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_HANDLER_CLASS"
                    c:identifier="GEGL_TILE_HANDLER_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="37"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_HANDLER_GET_CLASS"
                    c:identifier="GEGL_TILE_HANDLER_GET_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="40"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_SOURCE"
                    c:identifier="GEGL_TILE_SOURCE"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_SOURCE_CLASS"
                    c:identifier="GEGL_TILE_SOURCE_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="36"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TILE_SOURCE_GET_CLASS"
                    c:identifier="GEGL_TILE_SOURCE_GET_CLASS"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="39"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Tile" c:type="GeglTile" disguised="1" opaque="1">
      <source-position filename="gegl/buffer/gegl-buffer-backend.h" line="25"/>
    </record>
    <class name="TileBackend"
           c:symbol-prefix="tile_backend"
           c:type="GeglTileBackend"
           parent="TileSource"
           glib:type-name="GeglTileBackend"
           glib:get-type="gegl_tile_backend_get_type"
           glib:type-struct="TileBackendClass">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="51"/>
      <function name="unlink_swap"
                c:identifier="gegl_tile_backend_unlink_swap"
                deprecated="1"
                deprecated-version="0.4.14">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-backend.h"
             line="152">Delete a swap file from disk. This must be used by tile backends which may
swap to disk under certain circonstances.

For safety, this function will check that the swap file is in the swap
directory before deletion but it won't perform any other check.</doc>
        <doc-deprecated xml:space="preserve">This function is not compatible with a dynamically-
changing swap path. Use gegl_buffer_swap_remove_file() instead.</doc-deprecated>
        <source-position filename="gegl/buffer/gegl-tile-backend.h"
                         line="166"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="154">the path where the gegl tile backend has swapped.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="command" c:identifier="gegl_tile_backend_command">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-backend.h"
             line="129">The default tile-backend command handler.  Tile backends should forward
commands they don't handle themselves to this function.</doc>
        <source-position filename="gegl/buffer/gegl-tile-backend.h"
                         line="143"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-backend.h"
               line="141">Command result.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="131">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
          <parameter name="command" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="132">the tile command</doc>
            <type name="TileCommand" c:type="GeglTileCommand"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="133">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="134">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="135">tile zoom level</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="136">user data</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_extent"
              c:identifier="gegl_tile_backend_get_extent"
              introspectable="0">
        <source-position filename="gegl/buffer/gegl-tile-backend.h"
                         line="114"/>
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="112">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flush_on_destroy"
              c:identifier="gegl_tile_backend_get_flush_on_destroy"
              glib:get-property="flush-on-destroy">
        <source-position filename="gegl/buffer/gegl-tile-backend.h"
                         line="127"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format"
              c:identifier="gegl_tile_backend_get_format"
              glib:get-property="format"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-backend.h"
             line="77">Gets pixel format of @tile_backend</doc>
        <source-position filename="gegl/buffer/gegl-tile-backend.h" line="85"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-backend.h"
               line="83">the #Babl format</doc>
          <type name="Babl.Object" c:type="const Babl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="79">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile_height"
              c:identifier="gegl_tile_backend_get_tile_height"
              glib:get-property="tile-height">
        <source-position filename="gegl/buffer/gegl-tile-backend.h" line="75"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-backend.h"
               line="73">the height of tile from this backend</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="71">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile_size"
              c:identifier="gegl_tile_backend_get_tile_size"
              glib:get-property="tile-size">
        <source-position filename="gegl/buffer/gegl-tile-backend.h" line="59"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-backend.h"
               line="57">the size in bytes for a tile from this backend</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="55">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile_width"
              c:identifier="gegl_tile_backend_get_tile_width"
              glib:get-property="tile-width">
        <source-position filename="gegl/buffer/gegl-tile-backend.h" line="67"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-backend.h"
               line="65">the width of tile from this backend</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="63">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_storage"
              c:identifier="gegl_tile_backend_peek_storage">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-backend.h"
             line="87">Gets a pointer to the GeglTileStorage that uses the backend</doc>
        <source-position filename="gegl/buffer/gegl-tile-backend.h" line="95"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-backend.h"
               line="93">the #GeglTileStorage</doc>
          <type name="TileSource" c:type="GeglTileSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="89">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_extent" c:identifier="gegl_tile_backend_set_extent">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-backend.h"
             line="97">Specify the extent of the backend, can be used to pre-prime the
backend with the width/height information when constructing proxy
GeglBuffers to interact with other systems</doc>
        <source-position filename="gegl/buffer/gegl-tile-backend.h"
                         line="106"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="99">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="100">the new extent</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flush_on_destroy"
              c:identifier="gegl_tile_backend_set_flush_on_destroy"
              glib:set-property="flush-on-destroy">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-backend.h"
             line="116">Control whether cached data will be written to the backend before it
is destroyed. If false unwritten data will be discarded.</doc>
        <source-position filename="gegl/buffer/gegl-tile-backend.h"
                         line="124"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="118">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
          <parameter name="flush_on_destroy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-backend.h"
                 line="119">true if the backend needs to be flushed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="flush-on-destroy"
                writable="1"
                transfer-ownership="none"
                setter="set_flush_on_destroy"
                getter="get_flush_on_destroy"
                default-value="TRUE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="format"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_format">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="px-size" transfer-ownership="none" default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-height"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_tile_height"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-size"
                transfer-ownership="none"
                getter="get_tile_size"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-width"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_tile_width"
                default-value="0">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="TileSource" c:type="GeglTileSource"/>
      </field>
      <field name="priv">
        <type name="TileBackendPrivate" c:type="GeglTileBackendPrivate*"/>
      </field>
    </class>
    <record name="TileBackendClass"
            c:type="GeglTileBackendClass"
            glib:is-gtype-struct-for="TileBackend">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="51"/>
      <field name="parent_class">
        <type name="TileSourceClass" c:type="GeglTileSourceClass"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TileBackendPrivate"
            c:type="GeglTileBackendPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="gegl/buffer/gegl-tile-backend.h" line="39"/>
    </record>
    <callback name="TileCallback" c:type="GeglTileCallback">
      <source-position filename="gegl/buffer/gegl-buffer-backend.h" line="30"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="tile" transfer-ownership="none">
          <type name="Tile" c:type="GeglTile*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TileCommand" c:type="GeglTileCommand">
      <source-position filename="gegl/buffer/gegl-buffer-backend.h" line="56"/>
      <member name="egl_tile_idle" value="0" c:identifier="GEGL_TILE_IDLE">
      </member>
      <member name="egl_tile_set" value="1" c:identifier="GEGL_TILE_SET">
      </member>
      <member name="egl_tile_get" value="2" c:identifier="GEGL_TILE_GET">
      </member>
      <member name="egl_tile_is_cached"
              value="3"
              c:identifier="GEGL_TILE_IS_CACHED">
      </member>
      <member name="egl_tile_exist" value="4" c:identifier="GEGL_TILE_EXIST">
      </member>
      <member name="egl_tile_void" value="5" c:identifier="GEGL_TILE_VOID">
      </member>
      <member name="egl_tile_flush" value="6" c:identifier="GEGL_TILE_FLUSH">
      </member>
      <member name="egl_tile_refetch"
              value="7"
              c:identifier="GEGL_TILE_REFETCH">
      </member>
      <member name="egl_tile_reinit" value="8" c:identifier="GEGL_TILE_REINIT">
      </member>
      <member name="gegl_tile_last_0_4_8_command"
              value="9"
              c:identifier="_GEGL_TILE_LAST_0_4_8_COMMAND">
      </member>
      <member name="egl_tile_copy" value="9" c:identifier="GEGL_TILE_COPY">
      </member>
      <member name="egl_tile_last_command"
              value="10"
              c:identifier="GEGL_TILE_LAST_COMMAND">
      </member>
    </enumeration>
    <record name="TileCopyParams" c:type="GeglTileCopyParams">
      <source-position filename="gegl/buffer/gegl-buffer-backend.h" line="65"/>
      <field name="dst_buffer" writable="1">
        <type name="Buffer" c:type="GeglBuffer*"/>
      </field>
      <field name="dst_x" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="dst_y" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="dst_z" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
    </record>
    <class name="TileHandler"
           c:symbol-prefix="tile_handler"
           c:type="GeglTileHandler"
           parent="TileSource"
           glib:type-name="GeglTileHandler"
           glib:get-type="gegl_tile_handler_get_type"
           glib:type-struct="TileHandlerClass">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="59"/>
      <method name="create_tile"
              c:identifier="gegl_tile_handler_create_tile"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-handler.h"
             line="70">Create a new tile associated with this tile handler.</doc>
        <source-position filename="gegl/buffer/gegl-tile-handler.h" line="81"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-handler.h"
               line="79">the new tile</doc>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="72">a #GeglTileHandler</doc>
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="73">The tile space x coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="74">The tile space y coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="75">The tile space z coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="damage_rect" c:identifier="gegl_tile_handler_damage_rect">
        <source-position filename="gegl/buffer/gegl-tile-handler.h"
                         line="152"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="damage_tile" c:identifier="gegl_tile_handler_damage_tile">
        <source-position filename="gegl/buffer/gegl-tile-handler.h"
                         line="147"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="damage" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_tile"
              c:identifier="gegl_tile_handler_dup_tile"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-handler.h"
             line="129">Create a duplicate of @tile, associated with this tile handler.</doc>
        <source-position filename="gegl/buffer/gegl-tile-handler.h"
                         line="141"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-handler.h"
               line="139">the new tile</doc>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="131">a #GeglTileHandler</doc>
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="tile" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="132">the #GeglTile to copy</doc>
            <type name="Tile" c:type="GeglTile*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="133">The tile space x coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="134">The tile space y coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="135">The tile space z coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_source_tile"
              c:identifier="gegl_tile_handler_get_source_tile"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-handler.h"
             line="107">Fetches the tile at the given coordinates from @handler source.  If the tile
doesn't exist, or if @handler doesn't have a source, creates a new tile
associated with this tile handler.

If @preserve_data is FALSE, the tile contents are unspecified.</doc>
        <source-position filename="gegl/buffer/gegl-tile-handler.h"
                         line="123"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-handler.h"
               line="121">the tile</doc>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="109">a #GeglTileHandler</doc>
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="110">The tile space x coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="111">The tile space y coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="112">The tile space z coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="preserve_data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="113">whether existing tile data should be preserved</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_tile"
              c:identifier="gegl_tile_handler_get_tile"
              introspectable="0">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-tile-handler.h"
             line="86">Fetches the tile at the given coordinates from @handler.  If the tile
doesn't exist, creates a new tile associated with this tile handler.

If @preserve_data is FALSE, the tile contents are unspecified.</doc>
        <source-position filename="gegl/buffer/gegl-tile-handler.h"
                         line="101"/>
        <return-value>
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-tile-handler.h"
               line="99">the tile</doc>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="88">a #GeglTileHandler</doc>
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="89">The tile space x coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="90">The tile space y coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="91">The tile space z coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="preserve_data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="gegl/buffer/gegl-tile-handler.h"
                 line="92">whether existing tile data should be preserved</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="lock" c:identifier="gegl_tile_handler_lock">
        <source-position filename="gegl/buffer/gegl-tile-handler.h"
                         line="155"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_source"
              c:identifier="gegl_tile_handler_set_source"
              glib:set-property="source">
        <source-position filename="gegl/buffer/gegl-tile-handler.h" line="63"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <type name="TileSource" c:type="GeglTileSource*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unlock" c:identifier="gegl_tile_handler_unlock">
        <source-position filename="gegl/buffer/gegl-tile-handler.h"
                         line="156"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="source"
                writable="1"
                construct="1"
                transfer-ownership="none"
                setter="set_source">
        <type name="GObject.Object"/>
      </property>
      <field name="parent_instance">
        <type name="TileSource" c:type="GeglTileSource"/>
      </field>
      <field name="source">
        <type name="TileSource" c:type="GeglTileSource*"/>
      </field>
      <field name="priv">
        <type name="TileHandlerPrivate" c:type="GeglTileHandlerPrivate*"/>
      </field>
    </class>
    <record name="TileHandlerClass"
            c:type="GeglTileHandlerClass"
            glib:is-gtype-struct-for="TileHandler">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="59"/>
      <field name="parent_class">
        <type name="TileSourceClass" c:type="GeglTileSourceClass"/>
      </field>
    </record>
    <record name="TileHandlerPrivate"
            c:type="GeglTileHandlerPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="43"/>
    </record>
    <class name="TileSource"
           c:symbol-prefix="tile_source"
           c:type="GeglTileSource"
           parent="GObject.Object"
           glib:type-name="GeglTileSource"
           glib:get-type="gegl_tile_source_get_type"
           glib:type-struct="TileSourceClass">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="60"/>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="command">
        <type name="TileSourceCommand" c:type="GeglTileSourceCommand"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="TileSourceClass"
            c:type="GeglTileSourceClass"
            glib:is-gtype-struct-for="TileSource">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="60"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TileSourceCommand" c:type="GeglTileSourceCommand">
      <source-position filename="gegl/buffer/gegl-tile-source.h" line="42"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="gegl_tile_source" transfer-ownership="none">
          <type name="TileSource" c:type="GeglTileSource*"/>
        </parameter>
        <parameter name="command" transfer-ownership="none">
          <type name="TileCommand" c:type="GeglTileCommand"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="VALUE_HOLDS_MATRIX3"
                    c:identifier="GEGL_VALUE_HOLDS_MATRIX3"
                    introspectable="0">
      <source-position filename="gegl/gegl-matrix.h" line="42"/>
      <parameters>
        <parameter name="value">
        </parameter>
      </parameters>
    </function-macro>
    <function name="apply_op" c:identifier="gegl_apply_op" introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/gegl-apply.h"
           line="25">Apply the operation to buffer, overwritting the contents of buffer.</doc>
      <source-position filename="gegl/gegl-apply.h" line="35"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="27">the #GeglBuffer to apply onto</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="28">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="29">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="apply_op_valist"
              c:identifier="gegl_apply_op_valist"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/gegl-apply.h"
           line="73">Apply the operation to buffer, overwritting the contents of buffer.</doc>
      <source-position filename="gegl/gegl-apply.h" line="83"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="75">the #GeglBuffer to apply onto</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="76">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="77">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="babl_variant" c:identifier="gegl_babl_variant">
      <source-position filename="gegl/gegl-utils.h" line="122"/>
      <return-value transfer-ownership="none">
        <type name="Babl.Object" c:type="const Babl*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <type name="Babl.Object" c:type="const Babl*"/>
        </parameter>
        <parameter name="variant" transfer-ownership="none">
          <type name="BablVariant" c:type="GeglBablVariant"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="buffer_get_height"
                    c:identifier="gegl_buffer_get_height"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-buffer.h"
           line="227">Evaluates to the height of the buffer's extent.</doc>
      <source-position filename="gegl/buffer/gegl-buffer.h" line="233"/>
      <parameters>
        <parameter name="buffer">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="229">a GeglBuffer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="buffer_get_pixel_count"
                    c:identifier="gegl_buffer_get_pixel_count"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-buffer.h"
           line="235">Returns the number of pixels of the extent of the buffer.</doc>
      <source-position filename="gegl/buffer/gegl-buffer.h" line="241"/>
      <parameters>
        <parameter name="buffer">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="237">a GeglBuffer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="buffer_get_width"
                    c:identifier="gegl_buffer_get_width"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-buffer.h"
           line="219">Evaluates to the width of the buffer's extent.</doc>
      <source-position filename="gegl/buffer/gegl-buffer.h" line="225"/>
      <parameters>
        <parameter name="buffer">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="221">a GeglBuffer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="buffer_get_x"
                    c:identifier="gegl_buffer_get_x"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-buffer.h"
           line="203">Evaluates to the X coordinate of the upper left corner of the buffer's extent.</doc>
      <source-position filename="gegl/buffer/gegl-buffer.h" line="209"/>
      <parameters>
        <parameter name="buffer">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="205">a GeglBuffer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="buffer_get_y"
                    c:identifier="gegl_buffer_get_y"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-buffer.h"
           line="211">Evaluates to the Y coordinate of the upper left corner of the buffer's extent.</doc>
      <source-position filename="gegl/buffer/gegl-buffer.h" line="217"/>
      <parameters>
        <parameter name="buffer">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-buffer.h"
               line="213">a GeglBuffer</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="buffer_iterator_empty_new"
              c:identifier="gegl_buffer_iterator_empty_new"
              moved-to="BufferIterator.empty_new"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-buffer-iterator.h"
           line="53">Create a new buffer iterator without adding any buffers.</doc>
      <source-position filename="gegl/buffer/gegl-buffer-iterator.h"
                       line="59"/>
      <return-value>
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-buffer-iterator.h"
             line="57">a new buffer iterator.</doc>
        <type name="BufferIterator" c:type="GeglBufferIterator*"/>
      </return-value>
      <parameters>
        <parameter name="max_slots" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="calloc" c:identifier="gegl_calloc" introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-memory.h"
           line="57">allocated 0'd memory.</doc>
      <source-position filename="gegl/buffer/gegl-memory.h" line="64"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="59">size of items to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_memb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="60">number of members</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="cl_disable" c:identifier="gegl_cl_disable">
      <doc xml:space="preserve"
           filename="gegl/opencl/gegl-cl-introspection-support.h"
           line="22">Disable OpenCL</doc>
      <source-position filename="gegl/opencl/gegl-cl-introspection-support.h"
                       line="27"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cl_init" c:identifier="gegl_cl_init" throws="1">
      <doc xml:space="preserve"
           filename="gegl/opencl/gegl-cl-introspection-support.h"
           line="2">Initialize and enable OpenCL, calling this function again
will re-enable OpenCL if it has been disabled.</doc>
      <source-position filename="gegl/opencl/gegl-cl-introspection-support.h"
                       line="11"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gegl/opencl/gegl-cl-introspection-support.h"
             line="9">True if OpenCL was initialized</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="cl_is_accelerated" c:identifier="gegl_cl_is_accelerated">
      <doc xml:space="preserve"
           filename="gegl/opencl/gegl-cl-introspection-support.h"
           line="13">Check if OpenCL is enabled.</doc>
      <source-position filename="gegl/opencl/gegl-cl-introspection-support.h"
                       line="20"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gegl/opencl/gegl-cl-introspection-support.h"
             line="18">True if OpenCL is initialized and enabled</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="config" c:identifier="gegl_config">
      <doc xml:space="preserve"
           filename="gegl/gegl-init.h"
           line="87">Returns a GeglConfig object with properties that can be manipulated to control
GEGLs behavior.</doc>
      <source-position filename="gegl/gegl-init.h" line="95"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gegl/gegl-init.h"
             line="93">a #GeglConfig</doc>
        <type name="Config" c:type="GeglConfig*"/>
      </return-value>
    </function>
    <function name="create_chain" c:identifier="gegl_create_chain" throws="1">
      <doc xml:space="preserve"
           filename="gegl/gegl-utils.h"
           line="51">Create a node chain from an unparsed commandline string.</doc>
      <source-position filename="gegl/gegl-utils.h" line="63"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ops" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="53">an argv style, NULL terminated array of arguments</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="op_start" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="54">node to pass in as input of chain</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="op_end" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="55">node to get processed data</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="56">the time to use for interpolatino of keyframed values</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="rel_dim" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="57">relative dimension to scale rel suffixed values by</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="path_root" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="58">path in filesystem to use as relative root</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_chain_argv"
              c:identifier="gegl_create_chain_argv"
              throws="1">
      <doc xml:space="preserve"
           filename="gegl/gegl-utils.h"
           line="32">Create a node chain from argv style list of op data.</doc>
      <source-position filename="gegl/gegl-utils.h" line="44"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ops" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="34">an argv style, NULL terminated array of arguments</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="op_start" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="35">node to pass in as input of chain</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="op_end" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="36">node to get processed data</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="37">the time to use for interpolatino of keyframed values</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="rel_dim" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="38">relative dimension to scale rel suffixed values by</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="path_root" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="39">path in filesystem to use as relative root</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="exit" c:identifier="gegl_exit">
      <doc xml:space="preserve"
           filename="gegl/gegl-init.h"
           line="70">Call this function when you're done using GEGL. It will clean up
caches and write/dump debug information if the correct debug flags
are set.</doc>
      <source-position filename="gegl/gegl-init.h" line="77"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="filter_op"
              c:identifier="gegl_filter_op"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/gegl-apply.h"
           line="39">Apply the operation to source_buffer, returning the result in a new buffer.</doc>
      <source-position filename="gegl/gegl-apply.h" line="50"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/gegl-apply.h"
             line="48">the result of the filter</doc>
        <type name="Buffer" c:type="GeglBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="41">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="42">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="43">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_op_valist"
              c:identifier="gegl_filter_op_valist"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/gegl-apply.h"
           line="87">Apply the operation to source_buffer, returning the result in a new buffer.</doc>
      <source-position filename="gegl/gegl-apply.h" line="98"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/gegl-apply.h"
             line="96">the result of the filter</doc>
        <type name="Buffer" c:type="GeglBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="89">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="90">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="91">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="format" c:identifier="gegl_format">
      <doc xml:space="preserve"
           filename="gegl/gegl-introspection-support.h"
           line="32">Returns a value sutable to pass to the GeglBuffer constructor
or any other property that expects a Babl format.</doc>
      <source-position filename="gegl/gegl-introspection-support.h" line="43"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="39">the format pointer</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="format_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-introspection-support.h"
               line="34">A Babl format name, e.g. "RGBA float"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_name" c:identifier="gegl_format_get_name">
      <source-position filename="gegl/gegl-introspection-support.h" line="53"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="gegl/gegl-introspection-support.h"
             line="49">the format name</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-introspection-support.h"
               line="47">A Babl pointer</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="free" c:identifier="gegl_free" introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-memory.h"
           line="49">Frees the memory pointed to by @mem. If @mem is NULL, does nothing.</doc>
      <source-position filename="gegl/buffer/gegl-memory.h" line="55"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="51">the memory to free.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="gegl-metadata">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadata.h"
           line="26">Objects which need to store or retrieve image metadata when saving and
loading image files should implement GeglMetadata. The object should be cast
with GEGL_METADATA() and passed to the file load or save module via the
`metadata` property. Image file modules should not implement the metadata
property if either the module or file format does not support metadata.

Gegl understands (but is not limited to) the following well-known metadata
variables:

- artist: Name of image creator.
- comment: Miscellaneous comment; conversion from GIF comment.
- copyright: Copyright notice.
- description: Description of image (possibly long).
- disclaimer: Legal disclaimer.
- software: Software used to create the image.
- source: Device used to create the image.
- timestamp: Time of original image creation.
- title: Short (one line) title or caption for image.
- warning: Warning of nature of content.

The Gegl Metadata subsystem can be used in one of three ways described
below in order of increasing complexity:

1. Recommended: Create a #GeglMetadataHash and pass it to a file loader
   or saver via its `metadata` property. #GeglMetadataHash is a subclass of
   #GeglMetadataStore which saves metadata in a hash table but which adds no
   new properties or methods.  Image file metadata to be retrieved or saved
   is accessed via #GeglMetadataStore properties or methods. Metadata values
   not directly supported by Gegl may be declared using a #GParamSpec.
2. Subclass #GeglMetadataStore. This may be useful if an application stores
   metadata in internal structures which may be accessed via the subclass.
   The subclass is used identically to #GeglMetadataHash.
   #GeglMetadataStore aims to be sufficiently flexible to cover the majority
   of application requirements.
3. Implement the #GeglMetadata interface. This option should only be used if
   #GeglMetadataStore cannot adequately satisfy application requirements.
   Particular attention should be paid to semantics of the interface methods
   as the file modules interact directly with these.

For more complex requirements than provided by the metadata subsystem it is
probably better to use a library such as `exiv2` or similar.</doc>
    </docsection>
    <docsection name="gegl-metadatahash">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadatahash.h"
           line="35">#GeglMetadataHash is a #GeglMetadataStore implementing the data store using
a hash table. It adds no new methods or properties to #GeglMetadataStore.</doc>
    </docsection>
    <docsection name="gegl-metadatastore">
      <doc xml:space="preserve"
           filename="gegl/gegl-metadatastore.h"
           line="35">#GeglMetadataStore is a non-instantiable base class implementing the
#GeglMetadata interface and provides methods for metadata access using
well-known names.  For consistency with other #GObject features, the naming
convention for metadata variables is the same as for GObject properties.

Methods are provided allowing the application to test whether a particular
metadata item has a value and to set or get the values. If a metadata value
does not exist, a GLib warning is printed. The
gegl_metadata_store_has_value() method can be used to test silently for
unset variables.

Signals are provided to allow an application to intercept metadata values
from file modules, for example a Jpeg comment block might be parsed to set
multiple metadata values, or multiple values may be formatted into the
comment block.

Image resolution and resolution units are accessible only as properties.
Well-known metatdata values are shadowed by properties to allow applications
to take advantage of features such as introspection and property binding.

#GeglMetadataStore does not itself implement the storage mechanism, it must
be subclassed to provide this. #GeglMetadataHash implements a store using a
hash table.  For convenience gegl_metadata_hash_new() casts its return value
to #GeglMetadataStore as it does not add any new methods or properties.</doc>
    </docsection>
    <function name="get_option_group"
              c:identifier="gegl_get_option_group"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/gegl-init.h"
           line="60">Returns a GOptionGroup for the commandline arguments recognized
by GEGL. You should add this group to your GOptionContext
with g_option_context_add_group() if you are using
g_option_context_parse() to parse your commandline arguments.</doc>
      <source-position filename="gegl/gegl-init.h" line="68"/>
      <return-value transfer-ownership="full">
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="get_version" c:identifier="gegl_get_version">
      <doc xml:space="preserve"
           filename="gegl/gegl-version.h"
           line="40">This function fetches the version of the GEGL library being used by
the running process.</doc>
      <source-position filename="gegl/gegl-version.h" line="49"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="major"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-version.h"
               line="42">a pointer to a int where the major version number will be stored</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="minor"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-version.h"
               line="43">ditto for the minor version number</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="micro"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-version.h"
               line="44">ditto for the micro version number</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="graph_dump_outputs" c:identifier="gegl_graph_dump_outputs">
      <doc xml:space="preserve"
           filename="gegl/process/gegl-graph-debug.h"
           line="22">Dump the bounds and format of each node in the graph to stdout.</doc>
      <source-position filename="gegl/process/gegl-graph-debug.h" line="28"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/process/gegl-graph-debug.h"
               line="24">The final node of the graph</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="graph_dump_request" c:identifier="gegl_graph_dump_request">
      <doc xml:space="preserve"
           filename="gegl/process/gegl-graph-debug.h"
           line="30">Dump the region that will be rendered for each node to fulfill
the request.</doc>
      <source-position filename="gegl/process/gegl-graph-debug.h" line="38"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/process/gegl-graph-debug.h"
               line="32">The final node of the graph</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="roi" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/process/gegl-graph-debug.h"
               line="33">The request rectangle</doc>
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </parameter>
      </parameters>
    </function>
    <function name="has_operation" c:identifier="gegl_has_operation">
      <source-position filename="gegl/gegl-operations-util.h" line="67"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gegl/gegl-operations-util.h"
             line="63">A boolean telling whether the operation is present or not. This
also returns true for any compat-name registered by operations.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="operation_type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-operations-util.h"
               line="61">the name of the operation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="gegl_init">
      <doc xml:space="preserve"
           filename="gegl/gegl-init.h"
           line="43">Call this function before using any other GEGL functions. It will
initialize everything needed to operate GEGL and parses some
standard command line options.  @argc and @argv are adjusted
accordingly so your own code will never see those standard
arguments.

Note that there is an alternative way to initialize GEGL: if you
are calling g_option_context_parse() with the option group returned
by #gegl_get_option_group(), you don't have to call #gegl_init().</doc>
      <source-position filename="gegl/gegl-init.h" line="58"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="argc"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-init.h"
               line="45">a pointer to the number of command line arguments.</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="argv"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-init.h"
               line="46">a pointer to the array of command line arguments.</doc>
          <array length="0" zero-terminated="0" c:type="gchar***">
            <type name="utf8" c:type="gchar**"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="is_main_thread" c:identifier="gegl_is_main_thread">
      <source-position filename="gegl/gegl-init.h" line="115"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="list_operations" c:identifier="gegl_list_operations">
      <source-position filename="gegl/gegl-operations-util.h" line="57"/>
      <return-value transfer-ownership="container">
        <doc xml:space="preserve"
             filename="gegl/gegl-operations-util.h"
             line="40">An
alphabetically sorted array of available operation names. This excludes any
compat-name registered by operations. The list should be freed with g_free
after use.
---
gchar **operations;
guint   n_operations;
gint i;

operations = gegl_list_operations (&amp;n_operations);
g_print ("Available operations:\n");
for (i=0; i &lt; n_operations; i++)
  {
    g_print ("\t%s\n", operations[i]);
  }
g_free (operations);</doc>
        <array length="0" zero-terminated="0" c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="n_operations_p"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="gegl/gegl-operations-util.h"
               line="38">return location for number of operations.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="load_module_directory"
              c:identifier="gegl_load_module_directory">
      <doc xml:space="preserve"
           filename="gegl/gegl-init.h"
           line="79">Load all gegl modules found in the given directory.</doc>
      <source-position filename="gegl/gegl-init.h" line="85"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-init.h"
               line="81">the directory to load modules from</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="lookup_new"
              c:identifier="gegl_lookup_new"
              moved-to="Lookup.new"
              introspectable="0">
      <source-position filename="gegl/gegl-lookup.h" line="64"/>
      <return-value>
        <doc xml:space="preserve"
             filename="gegl/gegl-lookup.h"
             line="62">a #GeglLookup</doc>
        <type name="Lookup" c:type="GeglLookup*"/>
      </return-value>
      <parameters>
        <parameter name="function" transfer-ownership="none" closure="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="59">The function to build a lookup for</doc>
          <type name="LookupFunction" c:type="GeglLookupFunction"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="60">A user data pointer passed to lookup calls</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="lookup_new_full"
              c:identifier="gegl_lookup_new_full"
              moved-to="Lookup.new_full"
              introspectable="0">
      <source-position filename="gegl/gegl-lookup.h" line="52"/>
      <return-value>
        <doc xml:space="preserve"
             filename="gegl/gegl-lookup.h"
             line="50">a #GeglLookup</doc>
        <type name="Lookup" c:type="GeglLookup*"/>
      </return-value>
      <parameters>
        <parameter name="function" transfer-ownership="none" closure="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="44">The function to build a lookup for</doc>
          <type name="LookupFunction" c:type="GeglLookupFunction"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="45">A user data pointer passed to lookup calls</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="46">Lower bound of the lookup</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="47">Upper bound of the lookup</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="precision" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-lookup.h"
               line="48">The precision of the lookup table</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
      </parameters>
    </function>
    <function name="malloc" c:identifier="gegl_malloc" introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-memory.h"
           line="28">Allocates @n_bytes of memory. If @n_bytes is 0, returns NULL.

Returns a pointer to the allocated memory.</doc>
      <source-position filename="gegl/buffer/gegl-memory.h" line="36"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="30">the number of bytes to allocte.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="memeq_zero"
              c:identifier="gegl_memeq_zero"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-memory.h"
           line="67">Checks if all the bytes of the memory block @ptr, of size @size,
are equal to zero.</doc>
      <source-position filename="gegl/buffer/gegl-memory.h" line="77"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gegl/buffer/gegl-memory.h"
             line="75">TRUE if all the bytes are equal to zero.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="69">pointer to the memory block</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="70">block size</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="memset_pattern"
              c:identifier="gegl_memset_pattern"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-memory.h"
           line="80">Fill @dst_ptr with @count copies of the bytes in @src_ptr.</doc>
      <source-position filename="gegl/buffer/gegl-memory.h" line="89"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dst_ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="82">pointer to copy to</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="src_ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="83">pointer to copy from</doc>
          <type name="gpointer" c:type="gconstpointer"/>
        </parameter>
        <parameter name="pattern_size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="84">the length of @src_ptr</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="85">number of copies</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="parallel_distribute"
              c:identifier="gegl_parallel_distribute">
      <doc xml:space="preserve"
           filename="gegl/gegl-parallel.h"
           line="73">Distributes the execution of a function across multiple threads,
by calling it with a different index on each thread.</doc>
      <source-position filename="gegl/gegl-parallel.h" line="82"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="max_n" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="75">the maximal number of threads to use</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="2">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="76">the function to call</doc>
          <type name="ParallelDistributeFunc"
                c:type="GeglParallelDistributeFunc"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="77">user data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="parallel_distribute_area"
              c:identifier="gegl_parallel_distribute_area">
      <doc xml:space="preserve"
           filename="gegl/gegl-parallel.h"
           line="103">Distributes the processing of a planar data-structure across
multiple threads, by calling the given function with different
sub-areas on different threads.</doc>
      <source-position filename="gegl/gegl-parallel.h" line="116"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="area" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="105">the area to process</doc>
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </parameter>
        <parameter name="thread_cost" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="106">the cost of using each additional thread, relative
              to the cost of processing a single data element</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="split_strategy" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="108">the strategy to use for dividing the area</doc>
          <type name="SplitStrategy" c:type="GeglSplitStrategy"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="4">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="109">the function to call</doc>
          <type name="ParallelDistributeAreaFunc"
                c:type="GeglParallelDistributeAreaFunc"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="110">user data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="parallel_distribute_range"
              c:identifier="gegl_parallel_distribute_range">
      <doc xml:space="preserve"
           filename="gegl/gegl-parallel.h"
           line="86">Distributes the processing of a linear data-structure across
multiple threads, by calling the given function with different
sub-ranges on different threads.</doc>
      <source-position filename="gegl/gegl-parallel.h" line="98"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="88">the total size of the data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="thread_cost" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="89">the cost of using each additional thread, relative
              to the cost of processing a single data element</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="3">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="91">the function to call</doc>
          <type name="ParallelDistributeRangeFunc"
                c:type="GeglParallelDistributeRangeFunc"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/gegl-parallel.h"
               line="92">user data to pass to the function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_audio_fragment"
              c:identifier="gegl_param_spec_audio_fragment">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-audio-fragment.h"
           line="136">Creates a new #GParamSpec instance specifying a #GeglAudioFragment property.</doc>
      <source-position filename="gegl/property-types/gegl-audio-fragment.h"
                       line="147"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-audio-fragment.h"
             line="145">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-audio-fragment.h"
               line="138">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-audio-fragment.h"
               line="139">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-audio-fragment.h"
               line="140">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-audio-fragment.h"
               line="141">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_color" c:identifier="gegl_param_spec_color">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-color.h"
           line="150">Creates a new #GParamSpec instance specifying a #GeglColor property.</doc>
      <source-position filename="gegl/property-types/gegl-color.h" line="162"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="160">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="152">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="153">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="154">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_color" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="155">the default value for the property specified</doc>
          <type name="Color" c:type="GeglColor*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="156">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_color_from_string"
              c:identifier="gegl_param_spec_color_from_string">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-color.h"
           line="168">Creates a new #GParamSpec instance specifying a #GeglColor property.</doc>
      <source-position filename="gegl/property-types/gegl-color.h" line="180"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="178">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="170">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="171">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="172">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_color_string" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="173">the default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="174">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_color_get_default"
              c:identifier="gegl_param_spec_color_get_default">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-color.h"
           line="185">Get the default color value of the param spec</doc>
      <source-position filename="gegl/property-types/gegl-color.h" line="194"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-color.h"
             line="191">the default #GeglColor</doc>
        <type name="Color" c:type="GeglColor*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-color.h"
               line="187">a #GeglColor #GParamSpec</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_curve" c:identifier="gegl_param_spec_curve">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-curve.h"
           line="190">Creates a new #GParamSpec instance specifying a #GeglCurve property.</doc>
      <source-position filename="gegl/property-types/gegl-curve.h" line="202"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-curve.h"
             line="200">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-curve.h"
               line="192">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-curve.h"
               line="193">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-curve.h"
               line="194">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_curve" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-curve.h"
               line="195">the default value for the property specified</doc>
          <type name="Curve" c:type="GeglCurve*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-curve.h"
               line="196">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_double" c:identifier="gegl_param_spec_double">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="69">Creates a new #GeglParamSpecDouble instance.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="86"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="84">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="71">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="72">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="73">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="74">minimum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="75">maximum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="76">default value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="ui_minimum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="77">minimum value a user should be allowed to input</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="ui_maximum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="78">maximum value a user should be allowed to input</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="ui_gamma" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="79">the gamma that should be used when adjusting the value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="80">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_enum" c:identifier="gegl_param_spec_enum">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="265">Creates a new #GeglParamSpecEnum instance.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="278"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="276">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="267">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="268">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="269">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="enum_type" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="270">the enum type to get valid values from</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="271">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="272">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_file_path"
              c:identifier="gegl_param_spec_file_path">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="222">Creates a new #GeglParamSpecFilePath instance.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="236"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="234">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="224">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="225">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="226">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="no_validate" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="227">true if the string should be validated with g_utf8_validate</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="null_ok" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="228">true if the string can be NULL</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="229">default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="230">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_format" c:identifier="gegl_param_spec_format">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="339">Creates a new #GeglParamSpecFormat instance specifying a Babl format.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="350"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="348">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="341">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="342">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="343">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="344">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_get_property_key"
              c:identifier="gegl_param_spec_get_property_key">
      <source-position filename="gegl/gegl-operations-util.h" line="120"/>
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="key_name" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_int" c:identifier="gegl_param_spec_int">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="128">Creates a new #GeglParamSpecInt instance.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="145"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="143">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="130">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="131">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="132">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="133">minimum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="134">maximum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="135">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="ui_minimum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="136">minimum value a user should be allowed to input</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="ui_maximum" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="137">maximum value a user should be allowed to input</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="ui_gamma" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="138">the gamma that should be used when adjusting the value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="139">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_path" c:identifier="gegl_param_spec_path">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-path.h"
           line="396">Creates a new #GParamSpec instance specifying a #GeglPath property.</doc>
      <source-position filename="gegl/property-types/gegl-path.h" line="408"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-path.h"
             line="406">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="398">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="399">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="400">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_path" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="401">the default value for the property specified</doc>
          <type name="Path" c:type="GeglPath*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-path.h"
               line="402">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_seed" c:identifier="gegl_param_spec_seed">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="308">Creates a new #GeglParamSpecSeed instance specifying an integer random seed.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="319"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="317">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="310">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="311">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="312">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="313">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_set_property_key"
              c:identifier="gegl_param_spec_set_property_key">
      <source-position filename="gegl/gegl-operations-util.h" line="123"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="key_name" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_string" c:identifier="gegl_param_spec_string">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="179">Creates a new #GeglParamSpecString instance.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="193"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="191">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="181">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="182">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="183">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="no_validate" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="184">true if the string should be validated with g_utf8_validate</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="null_ok" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="185">true if the string can be NULL</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="186">default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="187">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_uri" c:identifier="gegl_param_spec_uri">
      <doc xml:space="preserve"
           filename="gegl/property-types/gegl-paramspecs.h"
           line="377">Creates a new #GeglParamSpecUri instance.</doc>
      <source-position filename="gegl/property-types/gegl-paramspecs.h"
                       line="391"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="gegl/property-types/gegl-paramspecs.h"
             line="389">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="379">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="380">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="381">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="no_validate" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="382">true if the string should be validated with g_utf8_validate</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="null_ok" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="383">true if the string can be NULL</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="384">default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/property-types/gegl-paramspecs.h"
               line="385">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_infinite_plane"
              c:identifier="gegl_rectangle_infinite_plane"
              moved-to="Rectangle.infinite_plane">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-rectangle.h"
           line="308">Returns a GeglRectangle that represents an infininte plane.</doc>
      <source-position filename="gegl/buffer/gegl-rectangle.h" line="313"/>
      <return-value transfer-ownership="full">
        <type name="Rectangle" c:type="GeglRectangle"/>
      </return-value>
    </function>
    <function name="render_op"
              c:identifier="gegl_render_op"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/gegl-apply.h"
           line="55">Apply the operation to source_buffer, writing the results to target_buffer.</doc>
      <source-position filename="gegl/gegl-apply.h" line="66"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="57">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="target_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="58">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="59">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="60">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="render_op_valist"
              c:identifier="gegl_render_op_valist"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/gegl-apply.h"
           line="102">Apply the operation to source_buffer, writing the results to target_buffer.</doc>
      <source-position filename="gegl/gegl-apply.h" line="113"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="104">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="target_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="105">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="106">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-apply.h"
               line="107">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="reset_stats" c:identifier="gegl_reset_stats">
      <doc xml:space="preserve"
           filename="gegl/gegl-init.h"
           line="107">Resets the cumulative data gathered by the #GeglStats object returned
by #gegl_stats().</doc>
      <source-position filename="gegl/gegl-init.h" line="113"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function-macro name="sampler_compute_scale"
                    c:identifier="gegl_sampler_compute_scale"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-buffer.h" line="597"/>
      <parameters>
        <parameter name="matrix">
        </parameter>
        <parameter name="x">
        </parameter>
        <parameter name="y">
        </parameter>
      </parameters>
    </function-macro>
    <function name="scratch_alloc"
              c:identifier="gegl_scratch_alloc"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-scratch.h"
           line="23">Allocates @size bytes of scratch memory.

Returns a pointer to the allocated memory.</doc>
      <source-position filename="gegl/buffer/gegl-scratch.h" line="31"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-scratch.h"
               line="25">the number of bytes to allocte.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="scratch_alloc0"
              c:identifier="gegl_scratch_alloc0"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-scratch.h"
           line="33">Allocates @size bytes of scratch memory, initialized to zero.

Returns a pointer to the allocated memory.</doc>
      <source-position filename="gegl/buffer/gegl-scratch.h" line="41"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-scratch.h"
               line="35">the number of bytes to allocte.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="scratch_free"
              c:identifier="gegl_scratch_free"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-scratch.h"
           line="43">Frees the memory pointed to by @ptr.

The memory must have been allocated using one of the scratch-memory
allocation functions.</doc>
      <source-position filename="gegl/buffer/gegl-scratch.h" line="52"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-scratch.h"
               line="45">the memory to free.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="scratch_new"
                    c:identifier="gegl_scratch_new"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-scratch.h"
           line="58">Allocates @n elements of type @type using scratch memory.
The returned pointer is cast to a pointer to the given type.
Care is taken to avoid overflow when calculating the size of
the allocated block.

Since the returned pointer is already cast to the right type,
it is normally unnecessary to cast it explicitly, and doing
so might hide memory allocation errors.</doc>
      <source-position filename="gegl/buffer/gegl-scratch.h" line="75"/>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-scratch.h"
               line="60">the type of the elements to allocate</doc>
        </parameter>
        <parameter name="n">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-scratch.h"
               line="61">the number of elements to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="scratch_new0"
                    c:identifier="gegl_scratch_new0"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-scratch.h"
           line="79">Allocates @n elements of type @type using scratch memory,
initialized to 0.
The returned pointer is cast to a pointer to the given type.
Care is taken to avoid overflow when calculating the size of
the allocated block.

Since the returned pointer is already cast to the right type,
it is normally unnecessary to cast it explicitly, and doing
so might hide memory allocation errors.</doc>
      <source-position filename="gegl/buffer/gegl-scratch.h" line="97"/>
      <parameters>
        <parameter name="type">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-scratch.h"
               line="81">the type of the elements to allocate</doc>
        </parameter>
        <parameter name="n">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-scratch.h"
               line="82">the number of elements to allocate</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="serialize" c:identifier="gegl_serialize">
      <source-position filename="gegl/gegl-utils.h" line="80"/>
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="73">first node in chain to serialize</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="74">last node in chain to serialize</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="basepath" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="75">top-level absolute path to turn into relative root</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="serialize_flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/gegl-utils.h"
               line="76">anded together combination of:
GEGL_SERIALIZE_TRIM_DEFAULTS, GEGL_SERIALIZE_VERSION, GEGL_SERIALIZE_INDENT.</doc>
          <type name="SerializeFlag" c:type="GeglSerializeFlag"/>
        </parameter>
      </parameters>
    </function>
    <function name="stats" c:identifier="gegl_stats">
      <doc xml:space="preserve"
           filename="gegl/gegl-init.h"
           line="97">Returns a GeglStats object with properties that can be read to monitor
GEGL statistics.</doc>
      <source-position filename="gegl/gegl-init.h" line="105"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="gegl/gegl-init.h"
             line="103">a #GeglStats</doc>
        <type name="Stats" c:type="GeglStats*"/>
      </return-value>
    </function>
    <function-macro name="tile_handler_get_source"
                    c:identifier="gegl_tile_handler_get_source"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="66"/>
      <parameters>
        <parameter name="handler">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="tile_handler_source_command"
                    c:identifier="gegl_tile_handler_source_command"
                    introspectable="0">
      <source-position filename="gegl/buffer/gegl-tile-handler.h" line="68"/>
      <parameters>
        <parameter name="handler">
        </parameter>
        <parameter name="command">
        </parameter>
        <parameter name="x">
        </parameter>
        <parameter name="y">
        </parameter>
        <parameter name="z">
        </parameter>
        <parameter name="data">
        </parameter>
      </parameters>
    </function-macro>
    <function name="try_malloc"
              c:identifier="gegl_try_malloc"
              introspectable="0">
      <doc xml:space="preserve"
           filename="gegl/buffer/gegl-memory.h"
           line="38">Allocates @n_bytes of memory. If allocation fails, or if @n_bytes is 0,
returns %NULL.

Returns a pointer to the allocated memory, or NULL.</doc>
      <source-position filename="gegl/buffer/gegl-memory.h" line="47"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="gegl/buffer/gegl-memory.h"
               line="40">the number of bytes to allocte.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
