<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GL" version="1.0"/>
  <include name="GObject" version="2.0"/>
  <package name="cogl-2.0-experimental"/>
  <c:include name="cogl/cogl.h"/>
  <namespace name="Cogl"
             version="2.0"
             shared-library="libcogl.so.20"
             c:identifier-prefixes="Cogl"
             c:symbol-prefixes="cogl,cogl2">
    <alias name="Angle" c:type="CoglAngle">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="214">Integer representation of an angle such that 1024 corresponds to
full circle (i.e., 2 * pi).</doc>
      <source-position filename="cogl-types.h" line="222"/>
      <type name="gint32" c:type="int32_t"/>
    </alias>
    <alias name="Bool" c:type="CoglBool" stability="Stable">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="65">A boolean data type used throughout the Cogl C api. This should be
used in conjunction with the %TRUE and %FALSE macro defines for
setting and testing boolean values.</doc>
      <source-position filename="cogl-types.h" line="75"/>
      <type name="gint" c:type="int"/>
    </alias>
    <alias name="Buffer" c:type="CoglBuffer">
      <source-position filename="cogl-buffer.h" line="73"/>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="Handle" c:type="CoglHandle">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="137">Type used for storing references to cogl objects, the CoglHandle is
a fully opaque type without any public data members.</doc>
      <source-position filename="cogl-types.h" line="143"/>
      <type name="gpointer" c:type="void*"/>
    </alias>
    <alias name="MetaTexture" c:type="CoglMetaTexture">
      <source-position filename="cogl-meta-texture.h" line="99"/>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="PrimitiveTexture" c:type="CoglPrimitiveTexture">
      <source-position filename="cogl-primitive-texture.h" line="70"/>
      <type name="none" c:type="void"/>
    </alias>
    <alias name="UserDataDestroyCallback" c:type="CoglUserDataDestroyCallback">
      <doc xml:space="preserve"
           filename="cogl-object.h"
           line="122">When associating private data with a #CoglObject a callback can be
given which will be called either if the object is destroyed or if
cogl_object_set_user_data() is called with NULL user_data for the
same key.</doc>
      <source-position filename="cogl-object.h" line="135"/>
      <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
    </alias>
    <constant name="AFIRST_BIT" value="64" c:type="COGL_AFIRST_BIT">
      <source-position filename="cogl-types.h" line="230"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="ATLAS_TEXTURE"
                    c:identifier="COGL_ATLAS_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl-atlas-texture.h" line="72"/>
      <parameters>
        <parameter name="tex">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATTRIBUTE_BUFFER"
                    c:identifier="COGL_ATTRIBUTE_BUFFER"
                    introspectable="0">
      <source-position filename="cogl-attribute-buffer.h" line="62"/>
      <parameters>
        <parameter name="buffer">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="A_BIT" value="16" c:type="COGL_A_BIT">
      <source-position filename="cogl-types.h" line="228"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="AtlasTexture"
           c:symbol-prefix="atlas_texture"
           c:type="CoglAtlasTexture"
           parent="Object"
           glib:type-name="CoglAtlasTexture"
           glib:get-type="cogl_atlas_texture_get_gtype"
           glib:fundamental="1">
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_atlas_texture_new_from_bitmap"
                   version="1.16"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-atlas-texture.h"
             line="207">Creates a new #CoglAtlasTexture texture based on data residing in a
@bitmap. A #CoglAtlasTexture represents a sub-region within one of
Cogl's shared texture atlases.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Allocate call can fail if Cogl considers the internal
format to be incompatible with the format of its internal
atlases.&lt;/note&gt;

&lt;note&gt;The returned #CoglAtlasTexture is a high-level meta-texture
with some limitations. See the documentation for #CoglMetaTexture
for more details.&lt;/note&gt;</doc>
        <source-position filename="cogl-atlas-texture.h" line="239"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-atlas-texture.h"
               line="234">A new #CoglAtlasTexture object.</doc>
          <type name="AtlasTexture" c:type="CoglAtlasTexture*"/>
        </return-value>
        <parameters>
          <parameter name="bmp" transfer-ownership="none">
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_atlas_texture_new_from_data"
                   version="1.16"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-atlas-texture.h"
             line="158">Creates a new #CoglAtlasTexture texture based on data residing in
memory. A #CoglAtlasTexture represents a sub-region within one of
Cogl's shared texture atlases.

&lt;note&gt;This api will always immediately allocate GPU memory for the
texture and upload the given data so that the @data pointer does
not need to remain valid once this function returns. This means it
is not possible to configure the texture before it is allocated. If
you do need to configure the texture before allocation (to specify
constraints on the internal format for example) then you can
instead create a #CoglBitmap for your data and use
cogl_atlas_texture_new_from_bitmap() or use
cogl_atlas_texture_new_with_size() and then upload data using
cogl_texture_set_data()&lt;/note&gt;

&lt;note&gt;Allocate call can fail if Cogl considers the internal
format to be incompatible with the format of its internal
atlases.&lt;/note&gt;

&lt;note&gt;The returned #CoglAtlasTexture is a high-level
meta-texture with some limitations. See the documentation for
#CoglMetaTexture for more details.&lt;/note&gt;</doc>
        <source-position filename="cogl-atlas-texture.h" line="199"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-atlas-texture.h"
               line="193">A new #CoglAtlasTexture object or
         %NULL on failure and @error will be updated.</doc>
          <type name="AtlasTexture" c:type="CoglAtlasTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="160">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="161">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="162">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="163">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="164">the memory offset in bytes between the start of each
   row in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="167">pointer to the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_atlas_texture_new_from_file"
                   version="1.16"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-atlas-texture.h"
             line="120">Creates a #CoglAtlasTexture from an image file. A #CoglAtlasTexture
represents a sub-region within one of Cogl's shared texture
atlases.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Allocate call can fail if Cogl considers the internal
format to be incompatible with the format of its internal
atlases.&lt;/note&gt;

&lt;note&gt;The returned #CoglAtlasTexture is a high-level meta-texture
with some limitations. See the documentation for #CoglMetaTexture
for more details.&lt;/note&gt;</doc>
        <source-position filename="cogl-atlas-texture.h" line="154"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-atlas-texture.h"
               line="148">A new #CoglAtlasTexture object or
         %NULL on failure and @error will be updated.</doc>
          <type name="AtlasTexture" c:type="CoglAtlasTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="122">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="123">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_atlas_texture_new_with_size"
                   version="1.16"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-atlas-texture.h"
             line="83">Creates a #CoglAtlasTexture with a given @width and @height. A
#CoglAtlasTexture represents a sub-region within one of Cogl's
shared texture atlases.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Allocate call can fail if Cogl considers the internal
format to be incompatible with the format of its internal
atlases.&lt;/note&gt;

&lt;note&gt;The returned #CoglAtlasTexture is a high-level meta-texture
with some limitations. See the documentation for #CoglMetaTexture
for more details.&lt;/note&gt;</doc>
        <source-position filename="cogl-atlas-texture.h" line="116"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-atlas-texture.h"
               line="111">A new #CoglAtlasTexture object.</doc>
          <type name="AtlasTexture" c:type="CoglAtlasTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="85">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="86">The width of your atlased texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-atlas-texture.h"
                 line="87">The height of your atlased texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="Attribute"
           c:symbol-prefix="attribute"
           c:type="CoglAttribute"
           parent="Object"
           glib:type-name="CoglAttribute"
           glib:get-type="cogl_attribute_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_attribute_new"
                   version="1.4"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="72">Describes the layout for a list of vertex attribute values (For
example, a list of texture coordinates or colors).

The @name is used to access the attribute inside a GLSL vertex
shader and there are some special names you should use if they are
applicable:
 &lt;itemizedlist&gt;
   &lt;listitem&gt;"cogl_position_in" (used for vertex positions)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_color_in" (used for vertex colors)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_tex_coord0_in", "cogl_tex_coord1", ...
(used for vertex texture coordinates)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_normal_in" (used for vertex normals)&lt;/listitem&gt;
   &lt;listitem&gt;"cogl_point_size_in" (used to set the size of points
   per-vertex. Note this can only be used if
   %COGL_FEATURE_ID_POINT_SIZE_ATTRIBUTE is advertised and
   cogl_pipeline_set_per_vertex_point_size() is called on the pipeline.
   &lt;/listitem&gt;
 &lt;/itemizedlist&gt;

The attribute values corresponding to different vertices can either
be tightly packed or interleaved with other attribute values. For
example it's common to define a structure for a single vertex like:
|[
typedef struct
{
  float x, y, z; /&lt;!-- --&gt;* position attribute *&lt;!-- --&gt;/
  float s, t; /&lt;!-- --&gt;* texture coordinate attribute *&lt;!-- --&gt;/
} MyVertex;
]|

And then create an array of vertex data something like:
|[
MyVertex vertices[100] = { .... }
]|

In this case, to describe either the position or texture coordinate
attribute you have to move &lt;literal&gt;sizeof (MyVertex)&lt;/literal&gt; bytes to
move from one vertex to the next.  This is called the attribute
@stride. If you weren't interleving attributes and you instead had
a packed array of float x, y pairs then the attribute stride would
be &lt;literal&gt;(2 * sizeof (float))&lt;/literal&gt;. So the @stride is the number of
bytes to move to find the attribute value of the next vertex.

Normally a list of attributes starts at the beginning of an array.
So for the &lt;literal&gt;MyVertex&lt;/literal&gt; example above the @offset is the
offset inside the &lt;literal&gt;MyVertex&lt;/literal&gt; structure to the first
component of the attribute. For the texture coordinate attribute
the offset would be &lt;literal&gt;offsetof (MyVertex, s)&lt;/literal&gt; or instead of
using the offsetof macro you could use &lt;literal&gt;sizeof (float) *
3&lt;/literal&gt;.  If you've divided your @array into blocks of non-interleved
attributes then you will need to calculate the @offset as the number of
bytes in blocks preceding the attribute you're describing.

An attribute often has more than one component. For example a color
is often comprised of 4 red, green, blue and alpha @components, and a
position may be comprised of 2 x and y @components. You should aim
to keep the number of components to a minimum as more components
means more data needs to be mapped into the GPU which can be a
bottlneck when dealing with a large number of vertices.

Finally you need to specify the component data type. Here you
should aim to use the smallest type that meets your precision
requirements. Again the larger the type then more data needs to be
mapped into the GPU which can be a bottlneck when dealing with
a large number of vertices.</doc>
        <source-position filename="cogl-attribute.h" line="163"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="153">A newly allocated #CoglAttribute
         describing the layout for a list of attribute values
         stored in @array.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attribute_buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="74">The #CoglAttributeBuffer containing the actual
                   attribute data</doc>
            <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="76">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="stride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="77">The number of bytes to jump to get to the next attribute
         value for the next vertex. (Usually
         &lt;literal&gt;sizeof (MyVertex)&lt;/literal&gt;)</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="80">The byte offset from the start of @attribute_buffer for
         the first attribute value. (Usually
         &lt;literal&gt;offsetof (MyVertex, component0)&lt;/literal&gt;</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="83">The number of components (e.g. 4 for an rgba color or
             3 for and (x,y,z) position)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="85">FIXME</doc>
            <type name="AttributeType" c:type="CoglAttributeType"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_1f"
                   c:identifier="cogl_attribute_new_const_1f">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="170">Creates a new, single component, attribute whose value remains
constant across all the vertices of a primitive without needing to
duplicate the value for each vertex.

The constant @value is a single precision floating point scalar
which should have a corresponding declaration in GLSL code like:

[|
attribute float name;
|]</doc>
        <source-position filename="cogl-attribute.h" line="191"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="187">A newly allocated #CoglAttribute
         representing the given constant @value.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="172">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="173">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="174">The constant value for the attribute</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_2f"
                   c:identifier="cogl_attribute_new_const_2f">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="195">Creates a new, 2 component, attribute whose value remains
constant across all the vertices of a primitive without needing to
duplicate the value for each vertex.

The constants (@component0, @component1) represent a 2 component
float vector which should have a corresponding declaration in GLSL
code like:

[|
attribute vec2 name;
|]</doc>
        <source-position filename="cogl-attribute.h" line="218"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="214">A newly allocated #CoglAttribute
         representing the given constant vector.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="197">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="198">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="component0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="199">The first component of a 2 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="component1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="200">The second component of a 2 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_2fv"
                   c:identifier="cogl_attribute_new_const_2fv">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="292">Creates a new, 2 component, attribute whose value remains
constant across all the vertices of a primitive without needing to
duplicate the value for each vertex.

The constants (value[0], value[1]) represent a 2 component float
vector which should have a corresponding declaration in GLSL code
like:

[|
attribute vec2 name;
|]</doc>
        <source-position filename="cogl-attribute.h" line="314"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="310">A newly allocated #CoglAttribute
         representing the given constant vector.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="294">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="295">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="296">A pointer to a 2 component float vector</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_2x2fv"
                   c:identifier="cogl_attribute_new_const_2x2fv">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="377">Creates a new matrix attribute whose value remains constant
across all the vertices of a primitive without needing to duplicate
the value for each vertex.

@matrix2x2 represent a square 2 by 2 matrix specified in
column-major order (each pair of consecutive numbers represents a
column) which should have a corresponding declaration in GLSL code
like:

[|
attribute mat2 name;
|]

If @transpose is %TRUE then all matrix components are rotated
around the diagonal of the matrix such that the first column
becomes the first row and the second column becomes the second row.</doc>
        <source-position filename="cogl-attribute.h" line="406"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="402">A newly allocated #CoglAttribute
         representing the given constant matrix.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="379">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="380">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="matrix2x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="381">A pointer to a 2 by 2 matrix</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="382">Whether the matrix should be transposed on upload or
            not</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_3f"
                   c:identifier="cogl_attribute_new_const_3f">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="223">Creates a new, 3 component, attribute whose value remains
constant across all the vertices of a primitive without needing to
duplicate the value for each vertex.

The constants (@component0, @component1, @component2) represent a 3
component float vector which should have a corresponding
declaration in GLSL code like:

[|
attribute vec3 name;
|]

unless the built in name "cogl_normal_in" is being used where no
explicit GLSL declaration need be made.</doc>
        <source-position filename="cogl-attribute.h" line="250"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="246">A newly allocated #CoglAttribute
         representing the given constant vector.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="225">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="226">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="component0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="227">The first component of a 3 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="component1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="228">The second component of a 3 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="component2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="229">The third component of a 3 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_3fv"
                   c:identifier="cogl_attribute_new_const_3fv">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="318">Creates a new, 3 component, attribute whose value remains
constant across all the vertices of a primitive without needing to
duplicate the value for each vertex.

The constants (value[0], value[1], value[2]) represent a 3
component float vector which should have a corresponding
declaration in GLSL code like:

[|
attribute vec3 name;
|]

unless the built in name "cogl_normal_in" is being used where no
explicit GLSL declaration need be made.</doc>
        <source-position filename="cogl-attribute.h" line="343"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="339">A newly allocated #CoglAttribute
         representing the given constant vector.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="320">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="321">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="322">A pointer to a 3 component float vector</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_3x3fv"
                   c:identifier="cogl_attribute_new_const_3x3fv">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="411">Creates a new matrix attribute whose value remains constant
across all the vertices of a primitive without needing to duplicate
the value for each vertex.

@matrix3x3 represent a square 3 by 3 matrix specified in
column-major order (each triple of consecutive numbers represents a
column) which should have a corresponding declaration in GLSL code
like:

[|
attribute mat3 name;
|]

If @transpose is %TRUE then all matrix components are rotated
around the diagonal of the matrix such that the first column
becomes the first row and the second column becomes the second row
etc.</doc>
        <source-position filename="cogl-attribute.h" line="441"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="437">A newly allocated #CoglAttribute
         representing the given constant matrix.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="413">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="414">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="matrix3x3" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="415">A pointer to a 3 by 3 matrix</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="416">Whether the matrix should be transposed on upload or
            not</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_4f"
                   c:identifier="cogl_attribute_new_const_4f">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="256">Creates a new, 4 component, attribute whose value remains
constant across all the vertices of a primitive without needing to
duplicate the value for each vertex.

The constants (@component0, @component1, @component2, @constant3)
represent a 4 component float vector which should have a
corresponding declaration in GLSL code like:

[|
attribute vec4 name;
|]

unless one of the built in names "cogl_color_in",
"cogl_tex_coord0_in or "cogl_tex_coord1_in" etc is being used where
no explicit GLSL declaration need be made.</doc>
        <source-position filename="cogl-attribute.h" line="285"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="281">A newly allocated #CoglAttribute
         representing the given constant vector.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="258">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="259">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="component0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="260">The first component of a 4 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="component1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="261">The second component of a 4 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="component2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="262">The third component of a 4 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="component3" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="263">The fourth component of a 4 component vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_4fv"
                   c:identifier="cogl_attribute_new_const_4fv">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="347">Creates a new, 4 component, attribute whose value remains
constant across all the vertices of a primitive without needing to
duplicate the value for each vertex.

The constants (value[0], value[1], value[2], value[3]) represent a
4 component float vector which should have a corresponding
declaration in GLSL code like:

[|
attribute vec4 name;
|]

unless one of the built in names "cogl_color_in",
"cogl_tex_coord0_in or "cogl_tex_coord1_in" etc is being used where
no explicit GLSL declaration need be made.</doc>
        <source-position filename="cogl-attribute.h" line="373"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="369">A newly allocated #CoglAttribute
         representing the given constant vector.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="349">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="350">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="351">A pointer to a 4 component float vector</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_const_4x4fv"
                   c:identifier="cogl_attribute_new_const_4x4fv">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="446">Creates a new matrix attribute whose value remains constant
across all the vertices of a primitive without needing to duplicate
the value for each vertex.

@matrix4x4 represent a square 4 by 4 matrix specified in
column-major order (each 4-tuple of consecutive numbers represents a
column) which should have a corresponding declaration in GLSL code
like:

[|
attribute mat4 name;
|]

If @transpose is %TRUE then all matrix components are rotated
around the diagonal of the matrix such that the first column
becomes the first row and the second column becomes the second row
etc.</doc>
        <source-position filename="cogl-attribute.h" line="476"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="472">A newly allocated #CoglAttribute
         representing the given constant matrix.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="448">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="449">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="matrix4x4" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="450">A pointer to a 4 by 4 matrix</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="451">Whether the matrix should be transposed on upload or
            not</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_buffer"
              c:identifier="cogl_attribute_get_buffer"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-attribute.h" line="527"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="520">the #CoglAttributeBuffer that was
       set with cogl_attribute_set_buffer() or cogl_attribute_new().</doc>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="518">A #CoglAttribute</doc>
            <type name="Attribute" c:type="CoglAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_normalized"
              c:identifier="cogl_attribute_get_normalized"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-attribute.h" line="514"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="507">the value of the normalized property set with
cogl_attribute_set_normalized().</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="505">A #CoglAttribute</doc>
            <type name="Attribute" c:type="CoglAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_buffer"
              c:identifier="cogl_attribute_set_buffer"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="529">Sets a new #CoglAttributeBuffer for the attribute.</doc>
        <source-position filename="cogl-attribute.h" line="540"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="531">A #CoglAttribute</doc>
            <type name="Attribute" c:type="CoglAttribute*"/>
          </instance-parameter>
          <parameter name="attribute_buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="532">A #CoglAttributeBuffer</doc>
            <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_normalized"
              c:identifier="cogl_attribute_set_normalized"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="481">Sets whether fixed point attribute types are mapped to the range
0→1. For example when this property is TRUE and a
%COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE type is used then the value 255
will be mapped to 1.0.

The default value of this property depends on the name of the
attribute. For the builtin properties cogl_color_in and
cogl_normal_in it will default to TRUE and for all other names it
will default to FALSE.</doc>
        <source-position filename="cogl-attribute.h" line="500"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="483">A #CoglAttribute</doc>
            <type name="Attribute" c:type="CoglAttribute*"/>
          </instance-parameter>
          <parameter name="normalized" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute.h"
                 line="484">The new value for the normalized property.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="AttributeBuffer"
           c:symbol-prefix="attribute_buffer"
           c:type="CoglAttributeBuffer"
           parent="Object"
           glib:type-name="CoglAttributeBuffer"
           glib:get-type="cogl_attribute_buffer_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_attribute_buffer_new"
                   version="1.4"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-attribute-buffer.h"
             line="100">Describes a new #CoglAttributeBuffer of @size bytes to contain
arrays of vertex attribute data and also uploads @size bytes read
from @data to the new buffer.

You should never pass a %NULL data pointer.

&lt;note&gt;This function does not report out-of-memory errors back to
the caller by returning %NULL and so you can assume this function
always succeeds.&lt;/note&gt;

&lt;note&gt;In the unlikely case that there is an out of memory problem
then Cogl will abort the application with a message. If your
application needs to gracefully handle out-of-memory errors then
you can use cogl_attribute_buffer_new_with_size() and then
explicitly catch errors with cogl_buffer_set_data() or
cogl_buffer_map().&lt;/note&gt;</doc>
        <source-position filename="cogl-attribute-buffer.h" line="130"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute-buffer.h"
               line="124">A newly allocated #CoglAttributeBuffer (never %NULL)</doc>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute-buffer.h"
                 line="102">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute-buffer.h"
                 line="103">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute-buffer.h"
                 line="104">An optional pointer to vertex data to
       upload immediately.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="gpointer" c:type="void"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_attribute_buffer_new_with_size"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-attribute-buffer.h"
             line="73">Describes a new #CoglAttributeBuffer of @size bytes to contain
arrays of vertex attribute data. Afterwards data can be set using
cogl_buffer_set_data() or by mapping it into the application's
address space using cogl_buffer_map().

The underlying storage of this buffer isn't allocated by this
function so that you have an opportunity to use the
cogl_buffer_set_update_hint() and cogl_buffer_set_usage_hint()
functions which may influence how the storage is allocated. The
storage will be allocated once you upload data to the buffer.

Note: You can assume this function always succeeds and won't return
%NULL</doc>
        <source-position filename="cogl-attribute-buffer.h" line="97"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-attribute-buffer.h"
               line="92">A newly allocated #CoglAttributeBuffer. Never %NULL.</doc>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute-buffer.h"
                 line="75">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-attribute-buffer.h"
                 line="76">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <enumeration name="AttributeType"
                 version="1.0"
                 glib:type-name="CoglAttributeType"
                 glib:get-type="cogl_attribute_type_get_type"
                 c:type="CoglAttributeType">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="670">Data types for the components of a vertex attribute.</doc>
      <member name="byte"
              value="5120"
              c:identifier="COGL_ATTRIBUTE_TYPE_BYTE"
              glib:nick="byte"
              glib:name="COGL_ATTRIBUTE_TYPE_BYTE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="672">Data is the same size of a byte</doc>
      </member>
      <member name="unsigned_byte"
              value="5121"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE"
              glib:nick="unsigned-byte"
              glib:name="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="673">Data is the same size of an
  unsigned byte</doc>
      </member>
      <member name="short"
              value="5122"
              c:identifier="COGL_ATTRIBUTE_TYPE_SHORT"
              glib:nick="short"
              glib:name="COGL_ATTRIBUTE_TYPE_SHORT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="675">Data is the same size of a short integer</doc>
      </member>
      <member name="unsigned_short"
              value="5123"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT"
              glib:nick="unsigned-short"
              glib:name="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="676">Data is the same size of
  an unsigned short integer</doc>
      </member>
      <member name="float"
              value="5126"
              c:identifier="COGL_ATTRIBUTE_TYPE_FLOAT"
              glib:nick="float"
              glib:name="COGL_ATTRIBUTE_TYPE_FLOAT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="678">Data is the same size of a float</doc>
      </member>
    </enumeration>
    <constant name="BGR_BIT" value="32" c:type="COGL_BGR_BIT">
      <source-position filename="cogl-types.h" line="229"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="BUFFER"
                    c:identifier="COGL_BUFFER"
                    introspectable="0">
      <source-position filename="cogl-buffer.h" line="76"/>
      <parameters>
        <parameter name="buffer">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Bitmap"
           c:symbol-prefix="bitmap"
           c:type="CoglBitmap"
           parent="Object"
           glib:type-name="CoglBitmap"
           glib:get-type="cogl_bitmap_get_gtype"
           glib:fundamental="1">
      <constructor name="new_for_data"
                   c:identifier="cogl_bitmap_new_for_data"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="180">Creates a bitmap using some existing data. The data is not copied
so the application must keep the buffer alive for the lifetime of
the #CoglBitmap. This can be used for example with
cogl_framebuffer_read_pixels_into_bitmap() to read data directly
into an application buffer with the specified rowstride.</doc>
        <source-position filename="cogl-bitmap.h" line="201"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="196">A new #CoglBitmap.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="182">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="183">The width of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="184">The height of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="185">The format of the pixel data.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="186">The rowstride of the bitmap (the number of bytes from
  the start of one row of the bitmap to the next).</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="188">A pointer to the data. The bitmap will take ownership of this data.</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_buffer"
                   c:identifier="cogl_bitmap_new_from_buffer"
                   version="1.8"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="118">Wraps some image data that has been uploaded into a #CoglBuffer as
a #CoglBitmap. The data is not copied in this process.</doc>
        <source-position filename="cogl-bitmap.h" line="138"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="132">a #CoglBitmap encapsulating the given @buffer.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="120">A #CoglBuffer containing image data</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="121">The #CoglPixelFormat defining the format of the image data
         in the given @buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="123">The width of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="124">The height of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="125">The rowstride in bytes of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="126">The offset into the given @buffer to the first pixel that
         should be considered part of the #CoglBitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_bitmap_new_from_file"
                   version="1.0"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="77">Loads an image file from disk. This function can be safely called from
within a thread.</doc>
        <source-position filename="cogl-bitmap.h" line="91"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="85">a #CoglBitmap to the new loaded
              image data, or %NULL if loading the image failed.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="79">the file to load.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_bitmap_new_with_size"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="145">Creates a new #CoglBitmap with the given width, height and format.
The initial contents of the bitmap are undefined.

The data for the bitmap will be stored in a newly created
#CoglPixelBuffer. You can get a pointer to the pixel buffer using
cogl_bitmap_get_buffer(). The #CoglBuffer API can then be
used to fill the bitmap with data.

&lt;note&gt;Cogl will try its best to provide a hardware array you can
map, write into and effectively do a zero copy upload when creating
a texture from it with cogl_texture_new_from_bitmap(). For various
reasons, such arrays are likely to have a stride larger than width
* bytes_per_pixel. The user must take the stride into account when
writing into it. The stride can be retrieved with
cogl_bitmap_get_rowstride().&lt;/note&gt;</doc>
        <source-position filename="cogl-bitmap.h" line="175"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="168">a #CoglPixelBuffer representing the
              newly created array or %NULL on failure</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="147">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="148">width of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="149">height of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="150">the format of the pixels the array will store</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="get_size_from_file"
                c:identifier="cogl_bitmap_get_size_from_file"
                version="1.0">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="270">Parses an image file enough to extract the width and height
of the bitmap.</doc>
        <source-position filename="cogl-bitmap.h" line="284"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="279">%TRUE if the image was successfully parsed</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="272">the file to check</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="width"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="273">return location for the bitmap width, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="height"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="274">return location for the bitmap height, or %NULL</doc>
            <type name="gint" c:type="int*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_buffer"
              c:identifier="cogl_bitmap_get_buffer"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-bitmap.h" line="266"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="258">the #CoglPixelBuffer that this
  buffer uses for storage. Note that if the bitmap was created with
  cogl_bitmap_new_from_file() then it will not actually be using a
  pixel buffer and this function will return %NULL.</doc>
          <type name="PixelBuffer" c:type="CoglPixelBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="256">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format"
              c:identifier="cogl_bitmap_get_format"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-bitmap.h" line="217"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="212">the #CoglPixelFormat that the data for the bitmap is in.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="210">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="cogl_bitmap_get_height"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-bitmap.h" line="239"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="234">the height of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="232">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rowstride"
              c:identifier="cogl_bitmap_get_rowstride"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-bitmap.h" line="252"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="245">the rowstride of the bitmap. This is the number of
  bytes between the address of start of one row to the address of the
  next row in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="243">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="cogl_bitmap_get_width"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-bitmap.h" line="228"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="223">the width of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-bitmap.h"
                 line="221">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="BitmapError"
                 version="1.4"
                 glib:type-name="CoglBitmapError"
                 glib:get-type="cogl_bitmap_error_get_type"
                 c:type="CoglBitmapError">
      <doc xml:space="preserve"
           filename="cogl-bitmap.h"
           line="311">Error codes that can be thrown when performing bitmap
operations. Note that gdk_pixbuf_new_from_file() can also throw
errors directly from the underlying image loading library. For
example, if GdkPixbuf is used then errors #GdkPixbufError&lt;!-- --&gt;s
will be used directly.</doc>
      <member name="failed"
              value="0"
              c:identifier="COGL_BITMAP_ERROR_FAILED"
              glib:nick="failed"
              glib:name="COGL_BITMAP_ERROR_FAILED">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="313">Generic failure code, something went
  wrong.</doc>
      </member>
      <member name="unknown_type"
              value="1"
              c:identifier="COGL_BITMAP_ERROR_UNKNOWN_TYPE"
              glib:nick="unknown-type"
              glib:name="COGL_BITMAP_ERROR_UNKNOWN_TYPE">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="315">Unknown image type.</doc>
      </member>
      <member name="corrupt_image"
              value="2"
              c:identifier="COGL_BITMAP_ERROR_CORRUPT_IMAGE"
              glib:nick="corrupt-image"
              glib:name="COGL_BITMAP_ERROR_CORRUPT_IMAGE">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="316">An image file was broken somehow.</doc>
      </member>
      <function name="quark" c:identifier="cogl_bitmap_error_quark">
        <source-position filename="cogl-bitmap.h" line="332"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <enumeration name="BlendStringError"
                 version="1.0"
                 glib:type-name="CoglBlendStringError"
                 glib:get-type="cogl_blend_string_error_get_type"
                 c:type="CoglBlendStringError">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="608">Error enumeration for the blend strings parser</doc>
      <member name="parse_error"
              value="0"
              c:identifier="COGL_BLEND_STRING_ERROR_PARSE_ERROR"
              glib:nick="parse-error"
              glib:name="COGL_BLEND_STRING_ERROR_PARSE_ERROR">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="610">Generic parse error</doc>
      </member>
      <member name="argument_parse_error"
              value="1"
              c:identifier="COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR"
              glib:nick="argument-parse-error"
              glib:name="COGL_BLEND_STRING_ERROR_ARGUMENT_PARSE_ERROR">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="611">Argument parse error</doc>
      </member>
      <member name="invalid_error"
              value="2"
              c:identifier="COGL_BLEND_STRING_ERROR_INVALID_ERROR"
              glib:nick="invalid-error"
              glib:name="COGL_BLEND_STRING_ERROR_INVALID_ERROR">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="612">Internal parser error</doc>
      </member>
      <member name="gpu_unsupported_error"
              value="3"
              c:identifier="COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR"
              glib:nick="gpu-unsupported-error"
              glib:name="COGL_BLEND_STRING_ERROR_GPU_UNSUPPORTED_ERROR">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="613">Blend string not
  supported by the GPU</doc>
      </member>
      <function name="quark" c:identifier="cogl_blend_string_error_quark">
        <source-position filename="cogl-types.h" line="628"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="BufferAccess"
              version="1.2"
              stability="Unstable"
              c:type="CoglBufferAccess">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="174">The access hints for cogl_buffer_set_update_hint()</doc>
      <source-position filename="cogl-buffer.h" line="190"/>
      <member name="read" value="1" c:identifier="COGL_BUFFER_ACCESS_READ">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="176">the buffer will be read</doc>
      </member>
      <member name="write" value="2" c:identifier="COGL_BUFFER_ACCESS_WRITE">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="177">the buffer will written to</doc>
      </member>
      <member name="read_write"
              value="3"
              c:identifier="COGL_BUFFER_ACCESS_READ_WRITE">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="178">the buffer will be used for both reading and
  writing</doc>
      </member>
    </bitfield>
    <bitfield name="BufferBit"
              version="1.0"
              glib:type-name="CoglBufferBit"
              glib:get-type="cogl_buffer_bit_get_type"
              c:type="CoglBufferBit">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="895">Types of auxiliary buffers</doc>
      <member name="color"
              value="1"
              c:identifier="COGL_BUFFER_BIT_COLOR"
              glib:nick="color"
              glib:name="COGL_BUFFER_BIT_COLOR">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="897">Selects the primary color buffer</doc>
      </member>
      <member name="depth"
              value="2"
              c:identifier="COGL_BUFFER_BIT_DEPTH"
              glib:nick="depth"
              glib:name="COGL_BUFFER_BIT_DEPTH">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="898">Selects the depth buffer</doc>
      </member>
      <member name="stencil"
              value="4"
              c:identifier="COGL_BUFFER_BIT_STENCIL"
              glib:nick="stencil"
              glib:name="COGL_BUFFER_BIT_STENCIL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="899">Selects the stencil buffer</doc>
      </member>
    </bitfield>
    <enumeration name="BufferError"
                 stability="Unstable"
                 c:type="CoglBufferError">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="81">Error enumeration for #CoglBuffer</doc>
      <source-position filename="cogl-buffer.h" line="93"/>
      <member name="buffer_error_map"
              value="0"
              c:identifier="COGL_BUFFER_ERROR_MAP">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="83">A buffer could not be mapped either
   because the feature isn't supported or because a system
   limitation was hit.</doc>
      </member>
    </enumeration>
    <bitfield name="BufferMapHint"
              version="1.4"
              stability="Unstable"
              c:type="CoglBufferMapHint">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="193">Hints to Cogl about how you are planning to modify the data once it
is mapped.</doc>
      <source-position filename="cogl-buffer.h" line="213"/>
      <member name="" value="1" c:identifier="COGL_BUFFER_MAP_HINT_DISCARD">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="195">Tells Cogl that you plan to replace
   all the buffer's contents. When this flag is used to map a
   buffer, the entire contents of the buffer become undefined, even
   if only a subregion of the buffer is mapped.</doc>
      </member>
      <member name="_range"
              value="2"
              c:identifier="COGL_BUFFER_MAP_HINT_DISCARD_RANGE">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="199">Tells Cogl that you plan to
   replace all the contents of the mapped region. The contents of
   the region specified are undefined after this flag is used to
   map a buffer.</doc>
      </member>
    </bitfield>
    <bitfield name="BufferTarget"
              version="0.8"
              glib:type-name="CoglBufferTarget"
              glib:get-type="cogl_buffer_target_get_type"
              c:type="CoglBufferTarget">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="476">Target flags for FBOs.</doc>
      <member name="window_buffer"
              value="2"
              c:identifier="COGL_WINDOW_BUFFER"
              glib:nick="window-buffer"
              glib:name="COGL_WINDOW_BUFFER">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="478">FIXME</doc>
      </member>
      <member name="offscreen_buffer"
              value="4"
              c:identifier="COGL_OFFSCREEN_BUFFER"
              glib:nick="offscreen-buffer"
              glib:name="COGL_OFFSCREEN_BUFFER">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="479">FIXME</doc>
      </member>
    </bitfield>
    <enumeration name="BufferUpdateHint"
                 version="1.2"
                 stability="Unstable"
                 c:type="CoglBufferUpdateHint">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="126">The update hint on a buffer allows the user to give some detail on how often
the buffer data is going to be updated.</doc>
      <source-position filename="cogl-buffer.h" line="143"/>
      <member name="static"
              value="0"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STATIC">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="128">the buffer will not change over time</doc>
      </member>
      <member name="dynamic"
              value="1"
              c:identifier="COGL_BUFFER_UPDATE_HINT_DYNAMIC">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="129">the buffer will change from time to time</doc>
      </member>
      <member name="stream"
              value="2"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STREAM">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="130">the buffer will be used once or a couple of
  times</doc>
      </member>
    </enumeration>
    <function-macro name="CONTEXT"
                    c:identifier="COGL_CONTEXT"
                    introspectable="0">
      <source-position filename="cogl-context.h" line="102"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Color"
            c:type="CoglColor"
            version="1.0"
            glib:type-name="CoglColor"
            glib:get-type="cogl_color_get_gtype"
            c:symbol-prefix="color">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="491">A structure for holding a color definition. The contents of
the CoglColor structure are private and should never by accessed
directly.</doc>
      <source-position filename="cogl-types.h" line="518"/>
      <field name="private_member_red" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_green" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_blue" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_alpha" readable="0" private="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="private_member_padding0" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding1" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding2" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <constructor name="new" c:identifier="cogl_color_new" version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="66">Creates a new (empty) color</doc>
        <source-position filename="cogl-color.h" line="77"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="71">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocated resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="cogl_color_copy" version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="79">Creates a copy of @color</doc>
        <source-position filename="cogl-color.h" line="91"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="85">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocate resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="81">the color to copy</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_color_free" version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="93">Frees the resources allocated by cogl_color_new() and cogl_color_copy()</doc>
        <source-position filename="cogl-color.h" line="102"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="95">the color to free</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha"
              c:identifier="cogl_color_get_alpha"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="351">Retrieves the alpha channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl-color.h" line="363"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="358">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="353">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_byte"
              c:identifier="cogl_color_get_alpha_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="239">Retrieves the alpha channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl-color.h" line="251"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="246">the alpha channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="241">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_float"
              c:identifier="cogl_color_get_alpha_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="295">Retrieves the alpha channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl-color.h" line="307"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="302">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="297">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue" c:identifier="cogl_color_get_blue" version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="337">Retrieves the blue channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl-color.h" line="349"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="344">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="339">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_byte"
              c:identifier="cogl_color_get_blue_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="225">Retrieves the blue channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl-color.h" line="237"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="232">the blue channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="227">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_float"
              c:identifier="cogl_color_get_blue_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="281">Retrieves the blue channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl-color.h" line="293"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="288">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="283">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green"
              c:identifier="cogl_color_get_green"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="323">Retrieves the green channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl-color.h" line="335"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="330">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="325">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_byte"
              c:identifier="cogl_color_get_green_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="211">Retrieves the green channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl-color.h" line="223"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="218">the green channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="213">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_float"
              c:identifier="cogl_color_get_green_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="267">Retrieves the green channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl-color.h" line="279"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="274">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="269">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red" c:identifier="cogl_color_get_red" version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="309">Retrieves the red channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl-color.h" line="321"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="316">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="311">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_byte"
              c:identifier="cogl_color_get_red_byte"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="197">Retrieves the red channel of @color as a byte value
between 0 and 255</doc>
        <source-position filename="cogl-color.h" line="209"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="204">the red channel of the passed color</doc>
          <type name="guint8" c:type="unsigned char"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="199">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red_float"
              c:identifier="cogl_color_get_red_float"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="253">Retrieves the red channel of @color as a floating point
value between 0.0 and 1.0</doc>
        <source-position filename="cogl-color.h" line="265"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="260">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="255">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_from_4f"
              c:identifier="cogl_color_init_from_4f"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="144">Sets the values of the passed channels into a #CoglColor</doc>
        <source-position filename="cogl-color.h" line="157"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="146">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="147">value of the red channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="148">value of the green channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="149">value of the blue channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="150">value of the alpha channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4fv"
              c:identifier="cogl_color_init_from_4fv"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="184">Sets the values of the passed channels into a #CoglColor</doc>
        <source-position filename="cogl-color.h" line="194"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="186">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="color_array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="187">a pointer to an array of 4 float color components</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_4ub"
              c:identifier="cogl_color_init_from_4ub"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="104">Sets the values of the passed channels into a #CoglColor.</doc>
        <source-position filename="cogl-color.h" line="117"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="106">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="107">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="108">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="109">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="110">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="premultiply"
              c:identifier="cogl_color_premultiply"
              version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="521">Converts a non-premultiplied color to a pre-multiplied color. For
example, semi-transparent red is (1.0, 0, 0, 0.5) when non-premultiplied
and (0.5, 0, 0, 0.5) when premultiplied.</doc>
        <source-position filename="cogl-color.h" line="532"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="523">the color to premultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_alpha"
              c:identifier="cogl_color_set_alpha"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="508">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="cogl-color.h" line="518"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="510">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="511">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_byte"
              c:identifier="cogl_color_set_alpha_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="404">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="cogl-color.h" line="414"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="406">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="407">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_float"
              c:identifier="cogl_color_set_alpha_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="456">Sets the alpha channel of @color to @alpha.</doc>
        <source-position filename="cogl-color.h" line="466"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="458">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="459">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue" c:identifier="cogl_color_set_blue" version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="495">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="cogl-color.h" line="505"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="497">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="498">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_byte"
              c:identifier="cogl_color_set_blue_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="391">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="cogl-color.h" line="401"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="393">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="394">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blue_float"
              c:identifier="cogl_color_set_blue_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="443">Sets the blue channel of @color to @blue.</doc>
        <source-position filename="cogl-color.h" line="453"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="445">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="446">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4f"
              c:identifier="cogl_color_set_from_4f"
              version="1.0"
              deprecated="1"
              deprecated-version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="163">Sets the values of the passed channels into a #CoglColor</doc>
        <doc-deprecated xml:space="preserve">Use cogl_color_init_from_4f instead.</doc-deprecated>
        <source-position filename="cogl-color.h" line="178"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="165">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="166">value of the red channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="167">value of the green channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="168">value of the blue channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="169">value of the alpha channel, between 0 and %1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_from_4ub"
              c:identifier="cogl_color_set_from_4ub"
              version="1.0"
              deprecated="1"
              deprecated-version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="123">Sets the values of the passed channels into a #CoglColor.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_color_init_from_4ub instead.</doc-deprecated>
        <source-position filename="cogl-color.h" line="138"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="125">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="126">value of the red channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="127">value of the green channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="128">value of the blue channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="129">value of the alpha channel, between 0 and 255</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green"
              c:identifier="cogl_color_set_green"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="482">Sets the green channel of @color to @green.</doc>
        <source-position filename="cogl-color.h" line="492"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="484">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="485">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_byte"
              c:identifier="cogl_color_set_green_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="378">Sets the green channel of @color to @green.</doc>
        <source-position filename="cogl-color.h" line="388"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="380">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="381">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_green_float"
              c:identifier="cogl_color_set_green_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="430">Sets the green channel of @color to @green.</doc>
        <source-position filename="cogl-color.h" line="440"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="432">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="433">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red" c:identifier="cogl_color_set_red" version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="469">Sets the red channel of @color to @red.</doc>
        <source-position filename="cogl-color.h" line="479"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="471">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="472">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_byte"
              c:identifier="cogl_color_set_red_byte"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="365">Sets the red channel of @color to @red.</doc>
        <source-position filename="cogl-color.h" line="375"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="367">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="368">a byte value between 0 and 255</doc>
            <type name="guint8" c:type="unsigned char"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_red_float"
              c:identifier="cogl_color_set_red_float"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="417">Sets the red channel of @color to @red.</doc>
        <source-position filename="cogl-color.h" line="427"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="419">a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="420">a float value between 0.0f and 1.0f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_hsl" c:identifier="cogl_color_to_hsl" version="1.16">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="564">Converts @color to the HLS format.

The @hue value is in the 0 .. 360 range. The @luminance and
@saturation values are in the 0 .. 1 range.</doc>
        <source-position filename="cogl-color.h" line="579"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="566">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
          <parameter name="hue"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="567">return location for the hue value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="saturation"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="568">return location for the saturation value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="luminance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="569">return location for the luminance value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="unpremultiply"
              c:identifier="cogl_color_unpremultiply"
              version="1.4">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="534">Converts a pre-multiplied color to a non-premultiplied color. For
example, semi-transparent red is (0.5, 0, 0, 0.5) when premultiplied
and (1.0, 0, 0, 0.5) when non-premultiplied.</doc>
        <source-position filename="cogl-color.h" line="545"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="536">the color to unpremultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_color_equal" version="1.0">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="547">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
        <source-position filename="cogl-color.h" line="562"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="557">%TRUE if the two colors are the same.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="549">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="550">a #CoglColor</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_from_hsl"
                c:identifier="cogl_color_init_from_hsl"
                version="1.16">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="584">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
        <source-position filename="cogl-color.h" line="597"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="586">return location for a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="587">hue value, in the 0 .. 360 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="saturation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="588">saturation value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="luminance" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-color.h"
                 line="589">luminance value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="ColorMask"
              glib:type-name="CoglColorMask"
              glib:get-type="cogl_color_mask_get_type"
              c:type="CoglColorMask">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="854">Defines a bit mask of color channels. This can be used with
cogl_pipeline_set_color_mask() for example to define which color
channels should be written to the current framebuffer when
drawing something.</doc>
      <member name="none"
              value="0"
              c:identifier="COGL_COLOR_MASK_NONE"
              glib:nick="none"
              glib:name="COGL_COLOR_MASK_NONE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="856">None of the color channels are masked</doc>
      </member>
      <member name="red"
              value="1"
              c:identifier="COGL_COLOR_MASK_RED"
              glib:nick="red"
              glib:name="COGL_COLOR_MASK_RED">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="857">Masks the red color channel</doc>
      </member>
      <member name="green"
              value="2"
              c:identifier="COGL_COLOR_MASK_GREEN"
              glib:nick="green"
              glib:name="COGL_COLOR_MASK_GREEN">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="858">Masks the green color channel</doc>
      </member>
      <member name="blue"
              value="4"
              c:identifier="COGL_COLOR_MASK_BLUE"
              glib:nick="blue"
              glib:name="COGL_COLOR_MASK_BLUE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="859">Masks the blue color channel</doc>
      </member>
      <member name="alpha"
              value="8"
              c:identifier="COGL_COLOR_MASK_ALPHA"
              glib:nick="alpha"
              glib:name="COGL_COLOR_MASK_ALPHA">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="860">Masks the alpha color channel</doc>
      </member>
      <member name="all"
              value="15"
              c:identifier="COGL_COLOR_MASK_ALL"
              glib:nick="all"
              glib:name="COGL_COLOR_MASK_ALL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="861">All of the color channels are masked</doc>
      </member>
    </bitfield>
    <class name="Context"
           c:symbol-prefix="context"
           c:type="CoglContext"
           parent="Object"
           glib:type-name="CoglContext"
           glib:get-type="cogl_context_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_context_new"
                   version="1.8"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="113">Creates a new #CoglContext which acts as an application sandbox
for any state objects that are allocated.</doc>
        <source-position filename="cogl-context.h" line="126"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="121">A newly allocated #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <parameter name="display"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-context.h"
                 line="115">A #CoglDisplay pointer</doc>
            <type name="Display" c:type="CoglDisplay*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_display"
              c:identifier="cogl_context_get_display"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="129">Retrieves the #CoglDisplay that is internally associated with the
given @context. This will return the same #CoglDisplay that was
passed to cogl_context_new() or if %NULL was passed to
cogl_context_new() then this function returns a pointer to the
display that was automatically setup internally.</doc>
        <source-position filename="cogl-context.h" line="145"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="139">The #CoglDisplay associated with the
              given @context.</doc>
          <type name="Display" c:type="CoglDisplay*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-context.h"
                 line="131">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_renderer"
              c:identifier="cogl_context_get_renderer"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="147">Retrieves the #CoglRenderer that is internally associated with the
given @context. This will return the same #CoglRenderer that was
passed to cogl_display_new() or if %NULL was passed to
cogl_display_new() or cogl_context_new() then this function returns
a pointer to the renderer that was automatically connected
internally.</doc>
        <source-position filename="cogl-context.h" line="164"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="158">The #CoglRenderer associated with the
              given @context.</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-context.h"
                 line="149">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <function-macro name="DEPRECATED_FOR"
                    c:identifier="COGL_DEPRECATED_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="47"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_0_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_0_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="135"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_10_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_10_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="205"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_12_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_12_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="219"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_14_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_14_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="233"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_16_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_16_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="247"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_18_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_18_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="261"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_20_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_20_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="275"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_2_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_2_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="149"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_4_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_4_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="163"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_6_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_6_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="177"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DEPRECATED_IN_1_8_FOR"
                    c:identifier="COGL_DEPRECATED_IN_1_8_FOR"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="191"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="DEPTH_BIT" value="256" c:type="COGL_DEPTH_BIT">
      <source-position filename="cogl-types.h" line="232"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="DISPLAY"
                    c:identifier="COGL_DISPLAY"
                    introspectable="0">
      <source-position filename="cogl-display.h" line="77"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="DebugObjectForeachTypeCallback"
              c:type="CoglDebugObjectForeachTypeCallback"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-object.h"
           line="157">A callback function to use for cogl_debug_object_foreach_type().</doc>
      <source-position filename="cogl-object.h" line="167"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-object.h"
               line="159">A pointer to a struct containing information about the type.</doc>
          <type name="DebugObjectTypeInfo"
                c:type="const CoglDebugObjectTypeInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DebugObjectTypeInfo"
            c:type="CoglDebugObjectTypeInfo"
            version="1.8"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-object.h"
           line="140">This struct is used to pass information to the callback when
cogl_debug_object_foreach_type() is called.</doc>
      <source-position filename="cogl-object.h" line="155"/>
      <field name="name" writable="1">
        <doc xml:space="preserve"
             filename="cogl-object.h"
             line="142">A human readable name for the type.</doc>
        <type name="utf8" c:type="const char*"/>
      </field>
      <field name="instance_count" writable="1">
        <doc xml:space="preserve"
             filename="cogl-object.h"
             line="143">The number of objects of this type that are
  currently in use</doc>
        <type name="gulong" c:type="unsigned long"/>
      </field>
    </record>
    <record name="DepthState" c:type="CoglDepthState" version="2.0">
      <source-position filename="cogl-depth-state.h" line="73"/>
      <field name="private_member_magic" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_test_enabled" readable="0" private="1">
        <type name="Bool" c:type="CoglBool"/>
      </field>
      <field name="private_member_test_function" readable="0" private="1">
        <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
      </field>
      <field name="private_member_write_enabled" readable="0" private="1">
        <type name="Bool" c:type="CoglBool"/>
      </field>
      <field name="private_member_range_near" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="private_member_range_far" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="private_member_padding0" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding1" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding2" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding3" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding4" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding5" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding6" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding7" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding8" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_padding9" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <method name="get_range"
              c:identifier="cogl_depth_state_get_range"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="250">Gets the current range to which normalized depth values are mapped
before writing to the depth buffer. This corresponds to the range
set with cogl_depth_state_set_range().</doc>
        <source-position filename="cogl-depth-state.h" line="264"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="252">A #CoglDepthState object</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="near_val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="253">A pointer to store the near component of the depth range</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="far_val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="254">A pointer to store the far component of the depth range</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_test_enabled"
              c:identifier="cogl_depth_state_get_test_enabled"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="119">Gets the current depth test enabled state as previously set by
cogl_depth_state_set_test_enabled().</doc>
        <source-position filename="cogl-depth-state.h" line="131"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-depth-state.h"
               line="126">The pipeline's current depth test enabled state.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="121">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_test_function"
              c:identifier="cogl_depth_state_get_test_function"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="193">Gets the current depth test enable state as previously set via
cogl_depth_state_set_test_enabled().</doc>
        <source-position filename="cogl-depth-state.h" line="205"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-depth-state.h"
               line="200">The current depth test enable state.</doc>
          <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="195">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_write_enabled"
              c:identifier="cogl_depth_state_get_write_enabled"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="157">Gets the depth writing enable state as set by the corresponding
cogl_depth_state_set_write_enabled().</doc>
        <source-position filename="cogl-depth-state.h" line="169"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-depth-state.h"
               line="164">The current depth writing enable state</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="159">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init"
              c:identifier="cogl_depth_state_init"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="75">Initializes the members of @state to their default values.

You should never pass an un initialized #CoglDepthState structure
to cogl_pipeline_set_depth_state().</doc>
        <source-position filename="cogl-depth-state.h" line="88"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="77">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_range"
              c:identifier="cogl_depth_state_set_range"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="207">Sets the range to map depth values in normalized device coordinates
to before writing out to a depth buffer.

After your geometry has be transformed, clipped and had perspective
division applied placing it in normalized device
coordinates all depth values between the near and far z clipping
planes are in the range -1 to 1. Before writing any depth value to
the depth buffer though the value is mapped into the range [0, 1].

With this function you can change the range which depth values are
mapped too although the range must still lye within the range [0,
1].

If your driver does not support this feature (for example you are
using GLES 1 drivers) then if you don't use the default range
values you will get an error reported when calling
cogl_pipeline_set_depth_state (). You can check ahead of time for
the %COGL_FEATURE_ID_DEPTH_RANGE feature with
cogl_has_feature() to know if this function will succeed.

By default normalized device coordinate depth values are mapped to
the full range of depth buffer values, [0, 1].

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state().</doc>
        <source-position filename="cogl-depth-state.h" line="246"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="209">A #CoglDepthState object</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="near_val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="210">The near component of the desired depth range which will be
clamped to the range [0, 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far_val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="212">The far component of the desired depth range which will be
clamped to the range [0, 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_test_enabled"
              c:identifier="cogl_depth_state_set_test_enabled"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="90">Enables or disables depth testing according to the value of
@enable.

If depth testing is enable then the #CoglDepthTestFunction set
using cogl_depth_state_set_test_function() us used to evaluate
the depth value of incoming fragments against the corresponding
value stored in the current depth buffer, and if the test passes
then the fragments depth value is used to update the depth buffer.
(unless you have disabled depth writing via
cogl_depth_state_set_write_enabled())

By default depth testing is disabled.

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <source-position filename="cogl-depth-state.h" line="116"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="92">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="93">The enable state you want</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_test_function"
              c:identifier="cogl_depth_state_set_test_function"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="171">Sets the #CoglDepthTestFunction used to compare the depth value of
an incoming fragment against the corresponding value in the current
depth buffer.

By default the depth test function is %COGL_DEPTH_TEST_FUNCTION_LESS

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <source-position filename="cogl-depth-state.h" line="190"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="173">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="function" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="174">The #CoglDepthTestFunction to set</doc>
            <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_write_enabled"
              c:identifier="cogl_depth_state_set_write_enabled"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-depth-state.h"
             line="133">Enables or disables depth buffer writing according to the value of
@enable. Normally when depth testing is enabled and the comparison
between a fragment's depth value and the corresponding depth buffer
value passes then the fragment's depth is written to the depth
buffer unless writing is disabled here.

By default depth writing is enabled

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <source-position filename="cogl-depth-state.h" line="154"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="135">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-depth-state.h"
                 line="136">The enable state you want</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DepthTestFunction"
                 glib:type-name="CoglDepthTestFunction"
                 glib:get-type="cogl_depth_test_function_get_type"
                 c:type="CoglDepthTestFunction">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="750">When using depth testing one of these functions is used to compare
the depth of an incoming fragment against the depth value currently
stored in the depth buffer. The function is changed using
cogl_depth_state_set_test_function().

The test is only done when depth testing is explicitly enabled. (See
cogl_depth_state_set_test_enabled())</doc>
      <member name="never"
              value="512"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NEVER"
              glib:nick="never"
              glib:name="COGL_DEPTH_TEST_FUNCTION_NEVER">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="752">Never passes.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LESS"
              glib:nick="less"
              glib:name="COGL_DEPTH_TEST_FUNCTION_LESS">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="753">Passes if the fragment's depth
value is less than the value currently in the depth buffer.</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_EQUAL"
              glib:nick="equal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_EQUAL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="755">Passes if the fragment's depth
value is equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LEQUAL"
              glib:nick="lequal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_LEQUAL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="757">Passes if the fragment's depth
value is less or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GREATER"
              glib:nick="greater"
              glib:name="COGL_DEPTH_TEST_FUNCTION_GREATER">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="759">Passes if the fragment's depth
value is greater than the value currently in the depth buffer.</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL"
              glib:nick="notequal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="761">Passes if the fragment's depth
value is not equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GEQUAL"
              glib:nick="gequal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_GEQUAL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="763">Passes if the fragment's depth
value greater than or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_ALWAYS"
              glib:nick="always"
              glib:name="COGL_DEPTH_TEST_FUNCTION_ALWAYS">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="765">Always passes.</doc>
      </member>
    </enumeration>
    <class name="Display"
           c:symbol-prefix="display"
           c:type="CoglDisplay"
           parent="Object"
           glib:type-name="CoglDisplay"
           glib:get-type="cogl_display_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_display_new"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-display.h"
             line="88">Explicitly allocates a new #CoglDisplay object to encapsulate the
common state of the display pipeline that applies to the whole
application.

&lt;note&gt;Many applications don't need to explicitly use
cogl_display_new() and can just jump straight to cogl_context_new()
and pass a %NULL display argument so Cogl will automatically
connect and setup a renderer and display.&lt;/note&gt;

A @display can only be made for a specific choice of renderer which
is why this takes the @renderer argument.

A common use for explicitly allocating a display object is to
define a template for allocating onscreen framebuffers which is
what the @onscreen_template argument is for, or alternatively
you can use cogl_display_set_onscreen_template().

When a display is first allocated via cogl_display_new() it is in a
mutable configuration mode. It's designed this way so we can
extend the apis available for configuring a display without
requiring huge numbers of constructor arguments.

When you have finished configuring a display object you can
optionally call cogl_display_setup() to explicitly apply the
configuration and check for errors. Alternaitvely you can pass the
display to cogl_context_new() and Cogl will implicitly apply your
configuration but if there are errors then the application will
abort with a message. For simple applications with no fallback
options then relying on the implicit setup can be fine.</doc>
        <source-position filename="cogl-display.h" line="129"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-display.h"
               line="123">A newly allocated #CoglDisplay
              object in a mutable configuration mode.</doc>
          <type name="Display" c:type="CoglDisplay*"/>
        </return-value>
        <parameters>
          <parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-display.h"
                 line="90">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </parameter>
          <parameter name="onscreen_template" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-display.h"
                 line="91">A #CoglOnscreenTemplate</doc>
            <type name="OnscreenTemplate" c:type="CoglOnscreenTemplate*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_renderer"
              c:identifier="cogl_display_get_renderer"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-display.h"
             line="132">Queries the #CoglRenderer associated with the given @display.</doc>
        <source-position filename="cogl-display.h" line="144"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-display.h"
               line="138">The associated #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-display.h"
                 line="134">a #CoglDisplay</doc>
            <type name="Display" c:type="CoglDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_onscreen_template"
              c:identifier="cogl_display_set_onscreen_template"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-display.h"
             line="146">Specifies a template for creating #CoglOnscreen framebuffers.

Depending on the system, the constraints for creating #CoglOnscreen
framebuffers need to be known before setting up a #CoglDisplay because the
final setup of the display may constrain how onscreen framebuffers may be
allocated. If Cogl knows how an application wants to allocate onscreen
framebuffers then it can try to make sure to setup the display accordingly.</doc>
        <source-position filename="cogl-display.h" line="163"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-display.h"
                 line="148">a #CoglDisplay</doc>
            <type name="Display" c:type="CoglDisplay*"/>
          </instance-parameter>
          <parameter name="onscreen_template" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-display.h"
                 line="149">A template for creating #CoglOnscreen framebuffers</doc>
            <type name="OnscreenTemplate" c:type="CoglOnscreenTemplate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="setup"
              c:identifier="cogl_display_setup"
              version="1.10"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-display.h"
             line="166">Explicitly sets up the given @display object. Use of this api is
optional since Cogl will internally setup the display if not done
explicitly.

When a display is first allocated via cogl_display_new() it is in a
mutable configuration mode. This allows us to extend the apis
available for configuring a display without requiring huge numbers
of constructor arguments.

Its possible to request a configuration that might not be
supportable on the current system and so this api provides a means
to apply the configuration explicitly but if it fails then an
exception will be returned so you can handle the error gracefully
and perhaps fall back to an alternative configuration.

If you instead rely on Cogl implicitly calling cogl_display_setup()
for you then if there is an error with the configuration you won't
get an opportunity to handle that and the application may abort
with a message.  For simple applications that don't have any
fallback options this behaviour may be fine.</doc>
        <source-position filename="cogl-display.h" line="198"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-display.h"
               line="192">Returns %TRUE if there was no error, else it returns
              %FALSE and returns an exception via @error.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-display.h"
                 line="168">a #CoglDisplay</doc>
            <type name="Display" c:type="CoglDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="Driver"
                 version="1.10"
                 stability="Unstable"
                 c:type="CoglDriver">
      <doc xml:space="preserve"
           filename="cogl-renderer.h"
           line="349">Identifiers for underlying hardware drivers that may be used by
Cogl for rendering.</doc>
      <source-position filename="cogl-renderer.h" line="374"/>
      <member name="any" value="0" c:identifier="COGL_DRIVER_ANY">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="351">Implies no preference for which driver is used</doc>
      </member>
      <member name="nop" value="1" c:identifier="COGL_DRIVER_NOP">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="352">A No-Op driver.</doc>
      </member>
      <member name="gl" value="2" c:identifier="COGL_DRIVER_GL">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="353">An OpenGL driver.</doc>
      </member>
      <member name="gl3" value="3" c:identifier="COGL_DRIVER_GL3">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="354">An OpenGL driver using the core GL 3.1 profile</doc>
      </member>
      <member name="gles1" value="4" c:identifier="COGL_DRIVER_GLES1">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="355">An OpenGL ES 1.1 driver.</doc>
      </member>
      <member name="gles2" value="5" c:identifier="COGL_DRIVER_GLES2">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="356">An OpenGL ES 2.0 driver.</doc>
      </member>
      <member name="webgl" value="6" c:identifier="COGL_DRIVER_WEBGL">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="357">A WebGL driver.</doc>
      </member>
    </enumeration>
    <record name="Euler"
            c:type="CoglEuler"
            version="2.0"
            glib:type-name="CoglEuler"
            glib:get-type="cogl_euler_get_gtype"
            c:symbol-prefix="euler">
      <doc xml:space="preserve"
           filename="cogl-euler.h"
           line="130">Represents an ordered rotation first of @heading degrees around an
object's y axis, then @pitch degrees around an object's x axis and
finally @roll degrees around an object's z axis.

&lt;note&gt;It's important to understand the that axis are associated
with the object being rotated, so the axis also rotate in sequence
with the rotations being applied.&lt;/note&gt;

The members of a #CoglEuler can be initialized, for example, with
cogl_euler_init() and cogl_euler_init_from_quaternion ().

You may also want to look at cogl_quaternion_init_from_euler() if
you want to do interpolation between 3d rotations.</doc>
      <source-position filename="cogl-euler.h" line="166"/>
      <field name="heading" writable="1">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="132">Angle to rotate around an object's y axis</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="pitch" writable="1">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="133">Angle to rotate around an object's x axis</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="roll" writable="1">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="134">Angle to rotate around an object's z axis</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding0" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding1" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding2" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding3" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding4" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <method name="copy" c:identifier="cogl_euler_copy" version="2.0">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="240">Allocates a new #CoglEuler and initilizes it with the component
angles of @src. The newly allocated euler should be freed using
cogl_euler_free().</doc>
        <source-position filename="cogl-euler.h" line="252"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-euler.h"
               line="248">A newly allocated #CoglEuler</doc>
          <type name="Euler" c:type="CoglEuler*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="242">A #CoglEuler to copy</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_euler_free" version="2.0">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="254">Frees a #CoglEuler that was previously allocated using
cogl_euler_copy().</doc>
        <source-position filename="cogl-euler.h" line="264"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="256">A #CoglEuler allocated via cogl_euler_copy()</doc>
            <type name="Euler" c:type="CoglEuler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="cogl_euler_init" version="2.0">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="178">Initializes @euler to represent a rotation of @x_angle degrees
around the x axis, then @y_angle degrees around the y_axis and
@z_angle degrees around the z axis.</doc>
        <source-position filename="cogl-euler.h" line="192"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="180">The #CoglEuler angle to initialize</doc>
            <type name="Euler" c:type="CoglEuler*"/>
          </instance-parameter>
          <parameter name="heading" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="181">Angle to rotate around an object's y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="pitch" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="182">Angle to rotate around an object's x axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="roll" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="183">Angle to rotate around an object's z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_matrix"
              c:identifier="cogl_euler_init_from_matrix">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="197">Extracts a euler rotation from the given @matrix and
initializses @euler with the component x, y and z rotation angles.</doc>
        <source-position filename="cogl-euler.h" line="207"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="199">The #CoglEuler angle to initialize</doc>
            <type name="Euler" c:type="CoglEuler*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="200">A #CoglMatrix containing a rotation, but no scaling,
         mirroring or skewing.</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_quaternion"
              c:identifier="cogl_euler_init_from_quaternion">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="210">Initializes a @euler rotation with the equivalent rotation
represented by the given @quaternion.</doc>
        <source-position filename="cogl-euler.h" line="219"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="212">The #CoglEuler angle to initialize</doc>
            <type name="Euler" c:type="CoglEuler*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="213">A #CoglEuler with the rotation to initialize with</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_euler_equal" version="2.0">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="222">Compares the two given euler angles @v1 and @v1 and it they are
equal returns %TRUE else %FALSE.

&lt;note&gt;This function only checks that all three components rotations
are numerically equal, it does not consider that some rotations
can be represented with different component rotations&lt;/note&gt;</doc>
        <source-position filename="cogl-euler.h" line="238"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-euler.h"
               line="234">%TRUE if @v1 and @v2 are equal else %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="224">The first euler angle to compare</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-euler.h"
                 line="225">The second euler angle to compare</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function-macro name="FRAMEBUFFER"
                    c:identifier="COGL_FRAMEBUFFER"
                    introspectable="0">
      <source-position filename="cogl-framebuffer.h" line="51"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="FRAME_INFO"
                    c:identifier="COGL_FRAME_INFO"
                    introspectable="0">
      <source-position filename="cogl-frame-info.h" line="51"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <callback name="FeatureCallback"
              c:type="CoglFeatureCallback"
              version="0.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="342">A callback used with cogl_foreach_feature() for enumerating all
context level features supported by Cogl.</doc>
      <source-position filename="cogl-context.h" line="353"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="344">A single feature currently supported by Cogl</doc>
          <type name="FeatureID" c:type="CoglFeatureID"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="345">A private pointer passed to cogl_foreach_feature().</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="FeatureFlags"
              version="0.8"
              glib:type-name="CoglFeatureFlags"
              glib:get-type="cogl_feature_flags_get_type"
              c:type="CoglFeatureFlags">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="401">Flags for the supported features.</doc>
      <member name="texture_rectangle"
              value="2"
              c:identifier="COGL_FEATURE_TEXTURE_RECTANGLE"
              glib:nick="texture-rectangle"
              glib:name="COGL_FEATURE_TEXTURE_RECTANGLE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="403">ARB_texture_rectangle support</doc>
      </member>
      <member name="texture_npot"
              value="4"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT"
              glib:nick="texture-npot"
              glib:name="COGL_FEATURE_TEXTURE_NPOT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="404">Non power of two textures are supported
   by the hardware. This is a equivalent to the
   %COGL_FEATURE_TEXTURE_NPOT_BASIC, %COGL_FEATURE_TEXTURE_NPOT_MIPMAP
   and %COGL_FEATURE_TEXTURE_NPOT_REPEAT features combined.</doc>
      </member>
      <member name="texture_yuv"
              value="8"
              c:identifier="COGL_FEATURE_TEXTURE_YUV"
              glib:nick="texture-yuv"
              glib:name="COGL_FEATURE_TEXTURE_YUV">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="408">ycbcr conversion support</doc>
      </member>
      <member name="texture_read_pixels"
              value="16"
              c:identifier="COGL_FEATURE_TEXTURE_READ_PIXELS"
              glib:nick="texture-read-pixels"
              glib:name="COGL_FEATURE_TEXTURE_READ_PIXELS">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="409">glReadPixels() support</doc>
      </member>
      <member name="shaders_glsl"
              value="32"
              c:identifier="COGL_FEATURE_SHADERS_GLSL"
              glib:nick="shaders-glsl"
              glib:name="COGL_FEATURE_SHADERS_GLSL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="410">GLSL support</doc>
      </member>
      <member name="offscreen"
              value="64"
              c:identifier="COGL_FEATURE_OFFSCREEN"
              glib:nick="offscreen"
              glib:name="COGL_FEATURE_OFFSCREEN">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="412">FBO support</doc>
      </member>
      <member name="offscreen_multisample"
              value="128"
              c:identifier="COGL_FEATURE_OFFSCREEN_MULTISAMPLE"
              glib:nick="offscreen-multisample"
              glib:name="COGL_FEATURE_OFFSCREEN_MULTISAMPLE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="413">Multisample support on FBOs</doc>
      </member>
      <member name="offscreen_blit"
              value="256"
              c:identifier="COGL_FEATURE_OFFSCREEN_BLIT"
              glib:nick="offscreen-blit"
              glib:name="COGL_FEATURE_OFFSCREEN_BLIT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="414">Blit support on FBOs</doc>
      </member>
      <member name="four_clip_planes"
              value="512"
              c:identifier="COGL_FEATURE_FOUR_CLIP_PLANES"
              glib:nick="four-clip-planes"
              glib:name="COGL_FEATURE_FOUR_CLIP_PLANES">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="415">At least 4 clip planes available</doc>
      </member>
      <member name="stencil_buffer"
              value="1024"
              c:identifier="COGL_FEATURE_STENCIL_BUFFER"
              glib:nick="stencil-buffer"
              glib:name="COGL_FEATURE_STENCIL_BUFFER">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="416">Stencil buffer support</doc>
      </member>
      <member name="vbos"
              value="2048"
              c:identifier="COGL_FEATURE_VBOS"
              glib:nick="vbos"
              glib:name="COGL_FEATURE_VBOS">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="417">VBO support</doc>
      </member>
      <member name="pbos"
              value="4096"
              c:identifier="COGL_FEATURE_PBOS"
              glib:nick="pbos"
              glib:name="COGL_FEATURE_PBOS">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="418">PBO support</doc>
      </member>
      <member name="unsigned_int_indices"
              value="8192"
              c:identifier="COGL_FEATURE_UNSIGNED_INT_INDICES"
              glib:nick="unsigned-int-indices"
              glib:name="COGL_FEATURE_UNSIGNED_INT_INDICES">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="419">Set if
    %COGL_INDICES_TYPE_UNSIGNED_INT is supported in
    cogl_vertex_buffer_indices_new().</doc>
      </member>
      <member name="depth_range"
              value="16384"
              c:identifier="COGL_FEATURE_DEPTH_RANGE"
              glib:nick="depth-range"
              glib:name="COGL_FEATURE_DEPTH_RANGE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="422">cogl_material_set_depth_range() support</doc>
      </member>
      <member name="texture_npot_basic"
              value="32768"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_BASIC"
              glib:nick="texture-npot-basic"
              glib:name="COGL_FEATURE_TEXTURE_NPOT_BASIC">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="423">The hardware supports non power
    of two textures, but you also need to check the
    %COGL_FEATURE_TEXTURE_NPOT_MIPMAP and %COGL_FEATURE_TEXTURE_NPOT_REPEAT
    features to know if the hardware supports npot texture mipmaps
    or repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE respectively.</doc>
      </member>
      <member name="texture_npot_mipmap"
              value="65536"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_MIPMAP"
              glib:nick="texture-npot-mipmap"
              glib:name="COGL_FEATURE_TEXTURE_NPOT_MIPMAP">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="429">Mipmapping is supported in
    conjuntion with non power of two textures.</doc>
      </member>
      <member name="texture_npot_repeat"
              value="131072"
              c:identifier="COGL_FEATURE_TEXTURE_NPOT_REPEAT"
              glib:nick="texture-npot-repeat"
              glib:name="COGL_FEATURE_TEXTURE_NPOT_REPEAT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="431">Repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE are supported by the
    hardware.</doc>
      </member>
      <member name="point_sprite"
              value="262144"
              c:identifier="COGL_FEATURE_POINT_SPRITE"
              glib:nick="point-sprite"
              glib:name="COGL_FEATURE_POINT_SPRITE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="434">Whether
    cogl_material_set_layer_point_sprite_coords_enabled() is supported.</doc>
      </member>
      <member name="texture_3d"
              value="524288"
              c:identifier="COGL_FEATURE_TEXTURE_3D"
              glib:nick="texture-3d"
              glib:name="COGL_FEATURE_TEXTURE_3D">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="436">3D texture support</doc>
      </member>
      <member name="shaders_arbfp"
              value="1048576"
              c:identifier="COGL_FEATURE_SHADERS_ARBFP"
              glib:nick="shaders-arbfp"
              glib:name="COGL_FEATURE_SHADERS_ARBFP">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="411">ARBFP support</doc>
      </member>
      <member name="map_buffer_for_read"
              value="2097152"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_READ"
              glib:nick="map-buffer-for-read"
              glib:name="COGL_FEATURE_MAP_BUFFER_FOR_READ">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="437">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including read support.</doc>
      </member>
      <member name="map_buffer_for_write"
              value="4194304"
              c:identifier="COGL_FEATURE_MAP_BUFFER_FOR_WRITE"
              glib:nick="map-buffer-for-write"
              glib:name="COGL_FEATURE_MAP_BUFFER_FOR_WRITE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="439">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including write support.</doc>
      </member>
      <member name="onscreen_multiple"
              value="8388608"
              c:identifier="COGL_FEATURE_ONSCREEN_MULTIPLE"
              glib:nick="onscreen-multiple"
              glib:name="COGL_FEATURE_ONSCREEN_MULTIPLE">
      </member>
      <member name="depth_texture"
              value="16777216"
              c:identifier="COGL_FEATURE_DEPTH_TEXTURE"
              glib:nick="depth-texture"
              glib:name="COGL_FEATURE_DEPTH_TEXTURE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="441">Whether #CoglFramebuffer support rendering the
    depth buffer to a texture.</doc>
      </member>
    </bitfield>
    <enumeration name="FeatureID" version="1.10" c:type="CoglFeatureID">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="203">All the capabilities that can vary between different GPUs supported
by Cogl. Applications that depend on any of these features should explicitly
check for them using cogl_has_feature() or cogl_has_features().</doc>
      <source-position filename="cogl-context.h" line="296"/>
      <member name="ogl_feature_id_texture_npot_basic"
              value="1"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT_BASIC">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="205">The hardware supports non power
    of two textures, but you also need to check the
    %COGL_FEATURE_ID_TEXTURE_NPOT_MIPMAP and %COGL_FEATURE_ID_TEXTURE_NPOT_REPEAT
    features to know if the hardware supports npot texture mipmaps
    or repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE respectively.</doc>
      </member>
      <member name="ogl_feature_id_texture_npot_mipmap"
              value="2"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT_MIPMAP">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="211">Mipmapping is supported in
    conjuntion with non power of two textures.</doc>
      </member>
      <member name="ogl_feature_id_texture_npot_repeat"
              value="3"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT_REPEAT">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="213">Repeat modes other than
    %COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE are supported by the
    hardware.</doc>
      </member>
      <member name="ogl_feature_id_texture_npot"
              value="4"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NPOT">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="216">Non power of two textures are supported
   by the hardware. This is a equivalent to the
   %COGL_FEATURE_ID_TEXTURE_NPOT_BASIC, %COGL_FEATURE_ID_TEXTURE_NPOT_MIPMAP
   and %COGL_FEATURE_ID_TEXTURE_NPOT_REPEAT features combined.</doc>
      </member>
      <member name="ogl_feature_id_texture_rectangle"
              value="5"
              c:identifier="COGL_FEATURE_ID_TEXTURE_RECTANGLE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="220">Support for rectangular
   textures with non-normalized texture coordinates.</doc>
      </member>
      <member name="ogl_feature_id_texture_3d"
              value="6"
              c:identifier="COGL_FEATURE_ID_TEXTURE_3D">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="225">3D texture support</doc>
      </member>
      <member name="ogl_feature_id_glsl"
              value="7"
              c:identifier="COGL_FEATURE_ID_GLSL">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="231">GLSL support</doc>
      </member>
      <member name="ogl_feature_id_arbfp"
              value="8"
              c:identifier="COGL_FEATURE_ID_ARBFP">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="232">ARBFP support</doc>
      </member>
      <member name="ogl_feature_id_offscreen"
              value="9"
              c:identifier="COGL_FEATURE_ID_OFFSCREEN">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="226">Offscreen rendering support</doc>
      </member>
      <member name="ogl_feature_id_offscreen_multisample"
              value="10"
              c:identifier="COGL_FEATURE_ID_OFFSCREEN_MULTISAMPLE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="227">Multisample support for
   offscreen framebuffers</doc>
      </member>
      <member name="ogl_feature_id_onscreen_multiple"
              value="11"
              c:identifier="COGL_FEATURE_ID_ONSCREEN_MULTIPLE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="229">Multiple onscreen framebuffers
   supported.</doc>
      </member>
      <member name="ogl_feature_id_unsigned_int_indices"
              value="12"
              c:identifier="COGL_FEATURE_ID_UNSIGNED_INT_INDICES">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="233">Set if
    %COGL_INDICES_TYPE_UNSIGNED_INT is supported in
    cogl_indices_new().</doc>
      </member>
      <member name="ogl_feature_id_depth_range"
              value="13"
              c:identifier="COGL_FEATURE_ID_DEPTH_RANGE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="236">cogl_pipeline_set_depth_range() support</doc>
      </member>
      <member name="ogl_feature_id_point_sprite"
              value="14"
              c:identifier="COGL_FEATURE_ID_POINT_SPRITE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="237">Whether
    cogl_pipeline_set_layer_point_sprite_coords_enabled() is supported.</doc>
      </member>
      <member name="ogl_feature_id_map_buffer_for_read"
              value="15"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_READ">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="241">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including read support.</doc>
      </member>
      <member name="ogl_feature_id_map_buffer_for_write"
              value="16"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_WRITE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="243">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including write support.</doc>
      </member>
      <member name="ogl_feature_id_mirrored_repeat"
              value="17"
              c:identifier="COGL_FEATURE_ID_MIRRORED_REPEAT">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="245">Whether
   %COGL_PIPELINE_WRAP_MODE_MIRRORED_REPEAT is supported.</doc>
      </member>
      <member name="ogl_feature_id_swap_buffers_event"
              value="18"
              c:identifier="COGL_FEATURE_ID_SWAP_BUFFERS_EVENT">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="247">Available if the window system supports reporting an event
    for swap buffer completions.</doc>
      </member>
      <member name="ogl_feature_id_gles2_context"
              value="19"
              c:identifier="COGL_FEATURE_ID_GLES2_CONTEXT">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="253">Whether creating new GLES2 contexts is
   suported.</doc>
      </member>
      <member name="ogl_feature_id_depth_texture"
              value="20"
              c:identifier="COGL_FEATURE_ID_DEPTH_TEXTURE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="255">Whether #CoglFramebuffer support rendering
    the depth buffer to a texture.</doc>
      </member>
      <member name="ogl_feature_id_presentation_time"
              value="21"
              c:identifier="COGL_FEATURE_ID_PRESENTATION_TIME">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="257">Whether frame presentation
   time stamps will be recorded in #CoglFrameInfo objects.</doc>
      </member>
      <member name="ogl_feature_id_fence"
              value="22"
              c:identifier="COGL_FEATURE_ID_FENCE">
      </member>
      <member name="ogl_feature_id_per_vertex_point_size"
              value="23"
              c:identifier="COGL_FEATURE_ID_PER_VERTEX_POINT_SIZE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="239">Whether cogl_point_size_in
    can be used as an attribute to set a per-vertex point size.</doc>
      </member>
      <member name="ogl_feature_id_texture_rg"
              value="24"
              c:identifier="COGL_FEATURE_ID_TEXTURE_RG">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="222">Support for
   %COGL_TEXTURE_COMPONENTS_RG as the internal components of a
   texture.</doc>
      </member>
      <member name="ogl_feature_id_buffer_age"
              value="25"
              c:identifier="COGL_FEATURE_ID_BUFFER_AGE">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="250">Available if the age of #CoglOnscreen back
   buffers are tracked and so cogl_onscreen_get_buffer_age() can be
   expected to return age values other than 0.</doc>
      </member>
    </enumeration>
    <record name="Fence"
            c:type="CoglFence"
            disguised="1"
            opaque="1"
            version="2.0"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-fence.h"
           line="50">An opaque object representing a fence. This type is currently
unused but in the future may be used to pass extra information
about the fence completion.</doc>
      <source-position filename="cogl-fence.h" line="60"/>
    </record>
    <callback name="FenceCallback"
              c:type="CoglFenceCallback"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-fence.h"
           line="62">The callback prototype used with
cogl_framebuffer_add_fence_callback() for notification of GPU
command completion.</doc>
      <source-position filename="cogl-fence.h" line="76"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="fence" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-fence.h"
               line="64">Unused. In the future this parameter may be used to pass
  extra information about the fence completion but for now it
  should be ignored.</doc>
          <type name="Fence" c:type="CoglFence*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve"
               filename="cogl-fence.h"
               line="67">The private data passed to cogl_framebuffer_add_fence_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="FenceClosure"
            c:type="CoglFenceClosure"
            disguised="1"
            opaque="1"
            version="2.0"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-fence.h"
           line="79">An opaque type representing one future callback to be made when the
GPU command stream has passed a certain point.</doc>
      <source-position filename="cogl-fence.h" line="88"/>
      <method name="get_user_data"
              c:identifier="cogl_fence_closure_get_user_data">
        <source-position filename="cogl-fence.h" line="101"/>
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="closure" transfer-ownership="none">
            <type name="FenceClosure" c:type="CoglFenceClosure*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="FilterReturn"
                 stability="Unstable"
                 glib:type-name="CoglFilterReturn"
                 glib:get-type="cogl_filter_return_get_type"
                 c:type="CoglFilterReturn">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="792">Return values for the #CoglXlibFilterFunc and #CoglWin32FilterFunc functions.</doc>
      <member name="continue"
              value="0"
              c:identifier="COGL_FILTER_CONTINUE"
              glib:nick="continue"
              glib:name="COGL_FILTER_CONTINUE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="794">The event was not handled, continues the
                       processing</doc>
      </member>
      <member name="remove"
              value="1"
              c:identifier="COGL_FILTER_REMOVE"
              glib:nick="remove"
              glib:name="COGL_FILTER_REMOVE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="796">Remove the event, stops the processing</doc>
      </member>
    </enumeration>
    <class name="Fixed"
           c:symbol-prefix="fixed"
           glib:type-name="CoglFixed"
           glib:get-type="cogl_fixed_get_type"
           glib:fundamental="1">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="203">Fixed point number using a (16.16) notation.</doc>
    </class>
    <enumeration name="FogMode"
                 version="1.0"
                 glib:type-name="CoglFogMode"
                 glib:get-type="cogl_fog_mode_get_type"
                 c:type="CoglFogMode">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="565">The fog mode determines the equation used to calculate the fogging blend
factor while fogging is enabled. The simplest %COGL_FOG_MODE_LINEAR mode
determines f as:

|[
  f = end - eye_distance / end - start
]|

Where eye_distance is the distance of the current fragment in eye
coordinates from the origin.</doc>
      <member name="linear"
              value="0"
              c:identifier="COGL_FOG_MODE_LINEAR"
              glib:nick="linear"
              glib:name="COGL_FOG_MODE_LINEAR">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="567">Calculates the fog blend factor as:
|[
  f = end - eye_distance / end - start
]|</doc>
      </member>
      <member name="exponential"
              value="1"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL"
              glib:nick="exponential"
              glib:name="COGL_FOG_MODE_EXPONENTIAL">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="571">Calculates the fog blend factor as:
|[
  f = e ^ -(density * eye_distance)
]|</doc>
      </member>
      <member name="exponential_squared"
              value="2"
              c:identifier="COGL_FOG_MODE_EXPONENTIAL_SQUARED"
              glib:nick="exponential-squared"
              glib:name="COGL_FOG_MODE_EXPONENTIAL_SQUARED">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="575">Calculates the fog blend factor as:
|[
  f = e ^ -(density * eye_distance)^2
]|</doc>
      </member>
    </enumeration>
    <callback name="FrameCallback"
              c:type="CoglFrameCallback"
              version="1.14"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="594">Is a callback that can be registered via
cogl_onscreen_add_frame_callback() to be called when a frame
progresses in some notable way.

Please see the documentation for #CoglFrameEvent and
cogl_onscreen_add_frame_callback() for more details about what
events can be notified.</doc>
      <source-position filename="cogl-onscreen.h" line="614"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="596">The onscreen that the frame is associated with</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="597">A #CoglFrameEvent notifying how the frame has progressed</doc>
          <type name="FrameEvent" c:type="CoglFrameEvent"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="598">The meta information, such as timing information, about
       the frame that has progressed.</doc>
          <type name="FrameInfo" c:type="CoglFrameInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="600">The user pointer passed to
            cogl_onscreen_add_frame_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="FrameClosure"
            c:type="CoglFrameClosure"
            opaque="1"
            version="1.14"
            stability="Unstable"
            glib:type-name="CoglFrameClosure"
            glib:get-type="cogl_frame_closure_get_gtype"
            c:symbol-prefix="frame_closure">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="619">An opaque type that tracks a #CoglFrameCallback and associated user
data. A #CoglFrameClosure pointer will be returned from
cogl_onscreen_add_frame_callback() and it allows you to remove a
callback later using cogl_onscreen_remove_frame_callback().</doc>
      <source-position filename="cogl-onscreen.h" line="630"/>
    </record>
    <enumeration name="FrameEvent"
                 version="1.14"
                 stability="Unstable"
                 c:type="CoglFrameEvent">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="557">Identifiers that are passed to #CoglFrameCallback functions
(registered using cogl_onscreen_add_frame_callback()) that
mark the progression of a frame in some way which usually
means that new information will have been accumulated in the
frame's corresponding #CoglFrameInfo object.

The last event that will be sent for a frame will be a
@COGL_FRAME_EVENT_COMPLETE event and so these are a good
opportunity to collect statistics about a frame since the
#CoglFrameInfo should hold the most data at this point.

&lt;note&gt;A frame may not be completed before the next frame can start
so applications should avoid needing to collect all statistics for
a particular frame before they can start a new frame.&lt;/note&gt;</doc>
      <source-position filename="cogl-onscreen.h" line="592"/>
      <member name="sync" value="1" c:identifier="COGL_FRAME_EVENT_SYNC">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="559">Notifies that the system compositor has
                        acknowledged a frame and is ready for a
                        new frame to be created.</doc>
      </member>
      <member name="complete"
              value="2"
              c:identifier="COGL_FRAME_EVENT_COMPLETE">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="562">Notifies that a frame has ended. This
                            is a good time for applications to
                            collect statistics about the frame
                            since the #CoglFrameInfo should hold
                            the most data at this point. No other
                            events should be expected after a
                            @COGL_FRAME_EVENT_COMPLETE event.</doc>
      </member>
    </enumeration>
    <class name="FrameInfo"
           c:symbol-prefix="frame_info"
           c:type="CoglFrameInfo"
           parent="Object"
           glib:type-name="CoglFrameInfo"
           glib:get-type="cogl_frame_info_get_gtype"
           glib:fundamental="1">
      <method name="get_frame_counter"
              c:identifier="cogl_frame_info_get_frame_counter"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-frame-info.h"
             line="76">Gets the frame counter for the #CoglOnscreen that corresponds
to this frame.</doc>
        <source-position filename="cogl-frame-info.h" line="87"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-frame-info.h"
               line="83">The frame counter value</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-frame-info.h"
                 line="78">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_output"
              c:identifier="cogl_frame_info_get_output"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-frame-info.h"
             line="132">Gets the #CoglOutput that the swapped frame was presented to.</doc>
        <source-position filename="cogl-frame-info.h" line="144"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-frame-info.h"
               line="138">The #CoglOutput that the frame was
       presented to, or %NULL if this could not be determined.</doc>
          <type name="Output" c:type="CoglOutput*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-frame-info.h"
                 line="134">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_presentation_time"
              c:identifier="cogl_frame_info_get_presentation_time"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-frame-info.h"
             line="89">Gets the presentation time for the frame. This is the time at which
the frame became visible to the user.

The presentation time measured in nanoseconds is based on a
monotonic time source. The time source is not necessarily
correlated with system/wall clock time and may represent the time
elapsed since some undefined system event such as when the system
last booted.

&lt;note&gt;Linux kernel version less that 3.8 can result in
non-monotonic timestamps being reported when using a drm based
OpenGL driver. Also some buggy Mesa drivers up to 9.0.1 may also
incorrectly report non-monotonic timestamps.&lt;/note&gt;</doc>
        <source-position filename="cogl-frame-info.h" line="111"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-frame-info.h"
               line="107">the presentation time for the frame</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-frame-info.h"
                 line="91">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refresh_rate"
              c:identifier="cogl_frame_info_get_refresh_rate"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-frame-info.h"
             line="113">Gets the refresh rate in Hertz for the output that the frame was on
at the time the frame was presented.

&lt;note&gt;Some platforms can't associate a #CoglOutput with a
#CoglFrameInfo object but are able to report a refresh rate via
this api. Therefore if you need this information then this api is
more reliable than using cogl_frame_info_get_output() followed by
cogl_output_get_refresh_rate().&lt;/note&gt;</doc>
        <source-position filename="cogl-frame-info.h" line="130"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-frame-info.h"
               line="126">the refresh rate in Hertz</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-frame-info.h"
                 line="115">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <interface name="Framebuffer"
               c:symbol-prefix="framebuffer"
               glib:type-name="CoglFramebuffer"
               glib:get-type="cogl_framebuffer_get_gtype">
      <prerequisite name="Object"/>
      <function name="error_quark" c:identifier="cogl_framebuffer_error_quark">
        <source-position filename="cogl-framebuffer.h" line="1841"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <method name="add_fence_callback"
              c:identifier="cogl_framebuffer_add_fence_callback"
              version="2.0"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-fence.h"
             line="103">Calls the provided callback when all previously-submitted commands have
been executed by the GPU.

Returns non-NULL if the fence succeeded, or %NULL if it was unable to
be inserted and the callback will never be called.  The user does not
need to free the closure; it will be freed automatically when the
callback is called, or cancelled.</doc>
        <source-position filename="cogl-fence.h" line="122"/>
        <return-value>
          <type name="FenceClosure" c:type="CoglFenceClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-fence.h"
                 line="105">The #CoglFramebuffer the commands have been submitted to</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-fence.h"
                 line="106">A #CoglFenceCallback to be called when
           all commands submitted to Cogl have been executed</doc>
            <type name="FenceCallback" c:type="CoglFenceCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-fence.h"
                 line="108">Private data that will be passed to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="allocate"
              c:identifier="cogl_framebuffer_allocate"
              version="1.8"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="117">Explicitly allocates a configured #CoglFramebuffer allowing developers to
check and handle any errors that might arise from an unsupported
configuration so that fallback configurations may be tried.

&lt;note&gt;Many applications don't support any fallback options at least when
they are initially developed and in that case the don't need to use this API
since Cogl will automatically allocate a framebuffer when it first gets
used.  The disadvantage of relying on automatic allocation is that the
program will abort with an error message if there is an error during
automatic allocation.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="138"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="133">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="119">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="cancel_fence_callback"
              c:identifier="cogl_framebuffer_cancel_fence_callback"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-fence.h"
             line="126">Removes a fence previously submitted with
cogl_framebuffer_add_fence_callback(); the callback will not be
called.</doc>
        <source-position filename="cogl-fence.h" line="140"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-fence.h"
                 line="128">The #CoglFramebuffer the commands were submitted to</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-fence.h"
                 line="129">The #CoglFenceClosure returned from
          cogl_framebuffer_add_fence_callback()</doc>
            <type name="FenceClosure" c:type="CoglFenceClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="cogl_framebuffer_clear"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1120">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="cogl-framebuffer.h" line="1135"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1122">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1123">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1125">The color to clear the color buffer too if specified in
        @buffers.</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear4f"
              c:identifier="cogl_framebuffer_clear4f"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1139">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="cogl-framebuffer.h" line="1160"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1141">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1142">A mask of #CoglBufferBit&lt;!-- --&gt;'s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1144">The red component of color to clear the color buffer too if
      specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1146">The green component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1148">The blue component of color to clear the color buffer too if
       specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1150">The alpha component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="discard_buffers"
              c:identifier="cogl_framebuffer_discard_buffers"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1690">Declares that the specified @buffers no longer need to be referenced
by any further rendering commands. This can be an important
optimization to avoid subsequent frames of rendering depending on
the results of a previous frame.

For example; some tile-based rendering GPUs are able to avoid allocating and
accessing system memory for the depth and stencil buffer so long as these
buffers are not required as input for subsequent frames and that can save a
significant amount of memory bandwidth used to save and restore their
contents to system memory between frames.

It is currently considered an error to try and explicitly discard the color
buffer by passing %COGL_BUFFER_BIT_COLOR. This is because the color buffer is
already implicitly discard when you finish rendering to a #CoglOnscreen
framebuffer, and it's not meaningful to try and discard the color buffer of
a #CoglOffscreen framebuffer since they are single-buffered.</doc>
        <source-position filename="cogl-framebuffer.h" line="1718"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1692">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1693">A #CoglBufferBit mask of which ancillary buffers you want
          to discard.</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_attributes"
              c:identifier="cogl_framebuffer_draw_attributes"
              version="1.10"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1238">First defines a geometry primitive by grouping a set of vertex @attributes;
specifying a @first_vertex; a number of vertices (@n_vertices) and
specifying  what kind of topology the vertices have via @mode.

Then the function draws the given @primitive geometry to the specified
destination @framebuffer using the graphics processing pipeline described by
@pipeline.

The list of #CoglAttribute&lt;!-- --&gt;s define the attributes of the vertices to
be drawn, such as positions, colors and normals and the number of attributes
is given as @n_attributes.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or #CoglTexture3D
are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state options such
as cogl_set_depth_test_enabled(), cogl_set_backface_culling_enabled() or
cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="cogl-framebuffer.h" line="1278"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1240">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1241">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1242">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1243">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1244">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1245">An array of pointers to #CoglAttribute&lt;-- --&gt;s defining vertex
             geometry</doc>
            <type name="Attribute" c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1247">The number of attributes in the @attributes array.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_indexed_attributes"
              c:identifier="cogl_framebuffer_draw_indexed_attributes"
              version="1.10"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1352">Behaves the same as cogl_framebuffer_draw_attributes() except that
instead of reading vertex data sequentially from the specified
@attributes the @indices provide an indirection for how the data
should be indexed allowing a random access order to be
specified.

For example an indices array of [0, 1, 2, 0, 2, 3] could be used
used to draw two triangles (@mode = %COGL_VERTICES_MODE_TRIANGLES +
@n_vertices = 6) but only provide attribute data for the 4 corners
of a rectangle. When the GPU needs to read in each of the 6
vertices it will read the @indices array for each vertex in
sequence and use the index to look up the vertex attribute data. So
here you can see that first and fourth vertex will point to the
same data and third and fifth vertex will also point to shared
data.

Drawing with indices can be a good way of minimizing the size of a
mesh by allowing you to avoid data for duplicate vertices because
multiple entries in the index array can refer back to a single
shared vertex.

&lt;note&gt;The @indices array must be at least as long as @first_vertex
+ @n_vertices otherwise the GPU will overrun the indices array when
looking up vertex data.&lt;/note&gt;

Since it's very common to want to draw a run of rectangles using
indices to avoid duplicating vertex data you can use
cogl_get_rectangle_indices() to get a set of indices that can be
shared.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or
#CoglTexture3D are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state
options such as cogl_set_depth_test_enabled(),
cogl_set_backface_culling_enabled() or cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="cogl-framebuffer.h" line="1412"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1354">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1355">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1356">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1357">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1358">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1359">The array of indices used by the GPU to lookup attribute
          data for each vertex.</doc>
            <type name="Indices" c:type="CoglIndices*"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1361">An array of pointers to #CoglAttribute&lt;-- --&gt;s defining vertex
             geometry</doc>
            <type name="Attribute" c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1363">The number of attributes in the @attributes array.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_multitextured_rectangle"
              c:identifier="cogl_framebuffer_draw_multitextured_rectangle"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1513">Draws a textured rectangle to @framebuffer with the given @pipeline
state with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2). As a pipeline may
contain multiple texture layers this interface lets you supply
texture coordinates for each layer of the pipeline.

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture for the first layer such as
#CoglTexture2DSliced textures which may internally be comprised of
multiple low-level textures.  This is unlike low-level drawing apis
such as cogl_primitive_draw() which only support low level texture
types that are directly supported by GPUs such as #CoglTexture2D.

&lt;note&gt;This api can not currently handle multiple high-level meta
texture layers. The first layer may be a high level meta texture
such as #CoglTexture2DSliced but all other layers much be low
level textures such as #CoglTexture2D and additionally they
should be textures that can be sampled using normalized coordinates
(so not #CoglTextureRectangle textures).&lt;/note&gt;

The top left texture coordinate for layer 0 of any pipeline will be
(tex_coords[0], tex_coords[1]) and the bottom right coordinate will
be (tex_coords[2], tex_coords[3]). The coordinates for layer 1
would be (tex_coords[4], tex_coords[5]) (tex_coords[6],
tex_coords[7]) and so on...

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.

&lt;note&gt;Even if you have associated a #CoglTextureRectangle texture
which normally implies working with non-normalized texture
coordinates this api should still be passed normalized texture
coordinates.&lt;/note&gt;

The first pair of coordinates are for the first layer (with the
smallest layer index) and if you supply less texture coordinates
than there are layers in the current source material then default
texture coordinates (0.0, 0.0, 1.0, 1.0) are generated.</doc>
        <source-position filename="cogl-framebuffer.h" line="1580"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1515">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1516">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1517">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1518">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1519">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1520">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tex_coords" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1521">An array containing groups of
  4 float values: [s_1, t_1, s_2, t_2] that are interpreted as two texture
  coordinates; one for the top left texel, and one for the bottom right
  texel. Each value should be between 0.0 and 1.0, where the coordinate
  (0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the
  bottom right.</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="tex_coords_len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1527">The length of the @tex_coords array. (For one layer
  and one group of texture coordinates, this would be 4)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_primitive"
              c:identifier="cogl_framebuffer_draw_primitive"
              version="1.10"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1167">Draws the given @primitive geometry to the specified destination
@framebuffer using the graphics processing state described by @pipeline.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or #CoglTexture3D
are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state options such
as cogl_set_depth_test_enabled(), cogl_set_backface_culling_enabled() or
cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="cogl-framebuffer.h" line="1193"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1169">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1170">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1171">A #CoglPrimitive geometry object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangle"
              c:identifier="cogl_framebuffer_draw_rectangle"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1421">Draws a rectangle to @framebuffer with the given @pipeline state
and with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2).

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

&lt;note&gt;If you want to describe a rectangle with a texture mapped on
it then you can use
cogl_framebuffer_draw_textured_rectangle().&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="1446"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1423">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1424">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1425">X coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1426">Y coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1427">X coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1428">Y coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangles"
              c:identifier="cogl_framebuffer_draw_rectangles"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1589">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_rectangle() does.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The positions for
the second rectangle are (coordinates[4], coordinates[5]) and
(coordinates[6], coordinates[7]) and so on...

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.</doc>
        <source-position filename="cogl-framebuffer.h" line="1624"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1591">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1592">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1593">an array of coordinates
  containing groups of 4 float values: [x_1, y_1, x_2, y_2] that are
  interpreted as two position coordinates; one for the top left of
  the rectangle (x1, y1), and one for the bottom right of the
  rectangle (x2, y2).</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1598">number of rectangles defined in @coordinates.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangle"
              c:identifier="cogl_framebuffer_draw_textured_rectangle"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1453">Draws a textured rectangle to @framebuffer using the given
@pipeline state with the top left corner positioned at (@x_1, @y_1)
and the bottom right corner positioned at (@x_2, @y_2). The top
left corner will have texture coordinates of (@s_1, @t_1) and the
bottom right corner will have texture coordinates of (@s_2, @t_2).

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

&lt;note&gt;The given texture coordinates will only be used for the first
texture layer of the pipeline and if your pipeline has more than
one layer then all other layers will have default texture
coordinates of @s_1=0.0 @t_1=0.0 @s_2=1.0 @t_2=1.0 &lt;/note&gt;

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in @s_1=0, @t_1=0, @s_2=1, @t_2=1.

&lt;note&gt;Even if you have associated a #CoglTextureRectangle texture
with one of your @pipeline layers which normally implies working
with non-normalized texture coordinates this api should still be
passed normalized texture coordinates.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="1502"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1455">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1456">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1457">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1458">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1459">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1460">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1461">S texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1462">T texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1463">S texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1464">T texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangles"
              c:identifier="cogl_framebuffer_draw_textured_rectangles"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1629">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_textured_rectangle() does.

&lt;note&gt;The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.&lt;/note&gt;

This is a high level drawing api that can handle any kind of
#CoglMetaTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The top left
texture coordinate is (coordinates[4], coordinates[5]) and the
bottom right texture coordinate is (coordinates[6],
coordinates[7]). The coordinates for subsequent rectangles
are defined similarly by the subsequent coordinates.

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.

&lt;note&gt;Even if you have associated a #CoglTextureRectangle texture
which normally implies working with non-normalized texture
coordinates this api should still be passed normalized texture
coordinates.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="1683"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1631">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1632">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1633">an array containing
  groups of 8 float values: [x_1, y_1, x_2, y_2, s_1, t_1, s_2, t_2]
  that have the same meaning as the arguments for
  cogl_framebuffer_draw_textured_rectangle().</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1637">number of rectangles to @coordinates to draw</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish"
              c:identifier="cogl_framebuffer_finish"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1721">This blocks the CPU until all pending rendering associated with the
specified framebuffer has completed. It's very rare that developers should
ever need this level of synchronization with the GPU and should never be
used unless you clearly understand why you need to explicitly force
synchronization.

One example might be for benchmarking purposes to be sure timing
measurements reflect the time that the GPU is busy for not just the time it
takes to queue rendering commands.</doc>
        <source-position filename="cogl-framebuffer.h" line="1739"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1723">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="frustum"
              c:identifier="cogl_framebuffer_frustum"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="478">Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.</doc>
        <source-position filename="cogl-framebuffer.h" line="500"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="480">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="481">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="483">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="485">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="487">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="489">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="490">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_bits"
              c:identifier="cogl_framebuffer_get_alpha_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="712">Retrieves the number of alpha bits of @framebuffer</doc>
        <source-position filename="cogl-framebuffer.h" line="724"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="718">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="714">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_bits"
              c:identifier="cogl_framebuffer_get_blue_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="698">Retrieves the number of blue bits of @framebuffer</doc>
        <source-position filename="cogl-framebuffer.h" line="710"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="704">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="700">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color_mask"
              c:identifier="cogl_framebuffer_get_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="834">Gets the current #CoglColorMask of which channels would be written to the
current framebuffer. Each bit set in the mask means that the
corresponding color would be written.</doc>
        <source-position filename="cogl-framebuffer.h" line="847"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="842">A #CoglColorMask</doc>
          <type name="ColorMask" c:type="CoglColorMask"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="836">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context"
              c:identifier="cogl_framebuffer_get_context"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1104">Can be used to query the #CoglContext a given @framebuffer was
instantiated within. This is the #CoglContext that was passed to
cogl_onscreen_new() for example.</doc>
        <source-position filename="cogl-framebuffer.h" line="1118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="1112">The #CoglContext that the given
              @framebuffer was instantiated within.</doc>
          <type name="Context" c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1106">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_bits"
              c:identifier="cogl_framebuffer_get_depth_bits"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="726">Retrieves the number of depth bits of @framebuffer</doc>
        <source-position filename="cogl-framebuffer.h" line="738"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="732">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="728">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_texture"
              c:identifier="cogl_framebuffer_get_depth_texture"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="940">Retrieves the depth buffer of @framebuffer as a #CoglTexture. You need to
call cogl_framebuffer_get_depth_texture(fb, TRUE); before using this
function.

&lt;note&gt;Calling this function implicitely allocates the framebuffer.&lt;/note&gt;
&lt;note&gt;The texture returned stays valid as long as the framebuffer stays
valid.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="958"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="952">the depth texture</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="942">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_texture_enabled"
              c:identifier="cogl_framebuffer_get_depth_texture_enabled"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="924">Queries whether texture based depth buffer has been enabled via
cogl_framebuffer_set_depth_texture_enabled().</doc>
        <source-position filename="cogl-framebuffer.h" line="938"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="931">%TRUE if a depth texture has been enabled, else
              %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="926">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_write_enabled"
              c:identifier="cogl_framebuffer_get_depth_write_enabled"
              version="1.18"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="801">Queries whether depth buffer writing is enabled for @framebuffer. This
can be controlled via cogl_framebuffer_set_depth_write_enabled().</doc>
        <source-position filename="cogl-framebuffer.h" line="813"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="808">%TRUE if depth writing is enabled or %FALSE if not.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="803">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dither_enabled"
              c:identifier="cogl_framebuffer_get_dither_enabled"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="757">Returns whether dithering has been requested for the given @framebuffer.
See cogl_framebuffer_set_dither_enabled() for more details about dithering.

&lt;note&gt;This may return %TRUE even when the underlying @framebuffer
display pipeline does not support dithering. This value only represents
the user's request for dithering.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="773"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="768">%TRUE if dithering has been requested or %FALSE if not.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="759">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_bits"
              c:identifier="cogl_framebuffer_get_green_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="684">Retrieves the number of green bits of @framebuffer</doc>
        <source-position filename="cogl-framebuffer.h" line="696"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="690">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="686">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="cogl_framebuffer_get_height"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="154">Queries the current height of the given @framebuffer.</doc>
        <source-position filename="cogl-framebuffer.h" line="165"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="160">The height of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="156">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_stereo"
              c:identifier="cogl_framebuffer_get_is_stereo">
        <source-position filename="cogl-framebuffer.h" line="755"/>
        <return-value transfer-ownership="none">
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modelview_matrix"
              c:identifier="cogl_framebuffer_get_modelview_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="423">Stores the current model-view matrix in @matrix.</doc>
        <source-position filename="cogl-framebuffer.h" line="434"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="425">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="426">return location for the model-view matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_projection_matrix"
              c:identifier="cogl_framebuffer_get_projection_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="537">Stores the current projection matrix in @matrix.</doc>
        <source-position filename="cogl-framebuffer.h" line="548"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="539">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="540">return location for the projection matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_red_bits"
              c:identifier="cogl_framebuffer_get_red_bits"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="670">Retrieves the number of red bits of @framebuffer</doc>
        <source-position filename="cogl-framebuffer.h" line="682"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="676">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="672">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_samples_per_pixel"
              c:identifier="cogl_framebuffer_get_samples_per_pixel"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1005">Gets the number of points that are sampled per-pixel when
rasterizing geometry. Usually by default this will return 0 which
means that single-sample not multisample rendering has been chosen.
When using a GPU supporting multisample rendering it's possible to
increase the number of samples per pixel using
cogl_framebuffer_set_samples_per_pixel().

Calling cogl_framebuffer_get_samples_per_pixel() before the
framebuffer has been allocated will simply return the value set
using cogl_framebuffer_set_samples_per_pixel(). After the
framebuffer has been allocated the value will reflect the actual
number of samples that will be made by the GPU.</doc>
        <source-position filename="cogl-framebuffer.h" line="1030"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="1022">The number of point samples made per pixel when
         rasterizing geometry or 0 if single-sample rendering
         has been chosen.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1007">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stereo_mode"
              c:identifier="cogl_framebuffer_get_stereo_mode"
              version="1.20"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="866">Gets the current #CoglStereoMode, which defines which stereo buffers
should be drawn to. See cogl_framebuffer_set_stereo_mode().</doc>
        <source-position filename="cogl-framebuffer.h" line="878"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="873">A #CoglStereoMode</doc>
          <type name="StereoMode" c:type="CoglStereoMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="868">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport4fv"
              c:identifier="cogl_framebuffer_get_viewport4fv"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="259">Queries the x, y, width and height components of the current viewport as set
using cogl_framebuffer_set_viewport() or the default values which are 0, 0,
framebuffer_width and framebuffer_height.  The values are written into the
given @viewport array.</doc>
        <source-position filename="cogl-framebuffer.h" line="275"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="261">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="viewport"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="262">A pointer to an
           array of 4 floats to receive the (x, y, width, height)
           components of the current viewport.</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_viewport_height"
              c:identifier="cogl_framebuffer_get_viewport_height"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="245">Queries the height of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the height of the framebuffer.</doc>
        <source-position filename="cogl-framebuffer.h" line="257"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="252">The height of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="247">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_width"
              c:identifier="cogl_framebuffer_get_viewport_width"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="231">Queries the width of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the width of the framebuffer.</doc>
        <source-position filename="cogl-framebuffer.h" line="243"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="238">The width of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="233">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_x"
              c:identifier="cogl_framebuffer_get_viewport_x"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="203">Queries the x coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="cogl-framebuffer.h" line="215"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="210">The x coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="205">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_y"
              c:identifier="cogl_framebuffer_get_viewport_y"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="217">Queries the y coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="cogl-framebuffer.h" line="229"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="224">The y coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="219">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="cogl_framebuffer_get_width"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="141">Queries the current width of the given @framebuffer.</doc>
        <source-position filename="cogl-framebuffer.h" line="152"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="147">The width of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="143">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="identity_matrix"
              c:identifier="cogl_framebuffer_identity_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="301">Resets the current model-view matrix to the identity matrix.</doc>
        <source-position filename="cogl-framebuffer.h" line="311"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="303">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="orthographic"
              c:identifier="cogl_framebuffer_orthographic"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="508">Replaces the current projection matrix with an orthographic projection
matrix.</doc>
        <source-position filename="cogl-framebuffer.h" line="529"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="510">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="511">The x coordinate for the first vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="512">The y coordinate for the first horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="513">The x coordinate for the second vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="514">The y coordinate for the second horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="515">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="518">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective"
              c:identifier="cogl_framebuffer_perspective"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="451">Replaces the current projection matrix with a perspective matrix
based on the provided values.

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="472"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="453">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="454">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="455">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="456">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="458">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_clip"
              c:identifier="cogl_framebuffer_pop_clip"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="656">Reverts the clipping region to the state before the last call to
cogl_framebuffer_push_scissor_clip(), cogl_framebuffer_push_rectangle_clip()
cogl_framebuffer_push_path_clip(), or cogl_framebuffer_push_primitive_clip().</doc>
        <source-position filename="cogl-framebuffer.h" line="668"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="658">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_matrix"
              c:identifier="cogl_framebuffer_pop_matrix"
              version="1.10">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="290">Restores the model-view matrix on the top of the matrix stack.</doc>
        <source-position filename="cogl-framebuffer.h" line="299"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="292">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_matrix"
              c:identifier="cogl_framebuffer_push_matrix"
              version="1.10">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="278">Copies the current model-view matrix onto the matrix stack. The matrix
can later be restored with cogl_framebuffer_pop_matrix().</doc>
        <source-position filename="cogl-framebuffer.h" line="288"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="280">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_primitive_clip"
              c:identifier="cogl_framebuffer_push_primitive_clip"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="619">Sets a new clipping area using a 2D shaped described with a
#CoglPrimitive. The shape must not contain self overlapping
geometry and must lie on a single 2D plane. A bounding box of the
2D shape in local coordinates (the same coordinates used to
describe the shape) must be given. It is acceptable for the bounds
to be larger than the true bounds but behaviour is undefined if the
bounds are smaller than the true bounds.

The primitive is transformed by the current model-view matrix and
the silhouette is intersected with the previous clipping area.  To
restore the previous clipping area, call
cogl_framebuffer_pop_clip().</doc>
        <source-position filename="cogl-framebuffer.h" line="649"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="621">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="622">A #CoglPrimitive describing a flat 2D shape</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </parameter>
          <parameter name="bounds_x1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="623">x coordinate for the top-left corner of the primitives
            bounds</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_y1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="625">y coordinate for the top-left corner of the primitives
            bounds</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_x2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="627">x coordinate for the bottom-right corner of the
            primitives bounds.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bounds_y2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="629">y coordinate for the bottom-right corner of the
            primitives bounds.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_rectangle_clip"
              c:identifier="cogl_framebuffer_push_rectangle_clip"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="592">Specifies a modelview transformed rectangular clipping area for all
subsequent drawing operations. Any drawing commands that extend
outside the rectangle will be clipped so that only the portion
inside the rectangle will be displayed. The rectangle dimensions
are transformed by the current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_framebuffer_pop_clip().</doc>
        <source-position filename="cogl-framebuffer.h" line="613"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="594">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="595">x coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="596">y coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="597">x coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="598">y coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_scissor_clip"
              c:identifier="cogl_framebuffer_push_scissor_clip"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="565">Specifies a rectangular clipping area for all subsequent drawing
operations. Any drawing commands that extend outside the rectangle
will be clipped so that only the portion inside the rectangle will
be displayed. The rectangle dimensions are not transformed by the
current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_framebuffer_pop_clip().</doc>
        <source-position filename="cogl-framebuffer.h" line="586"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="567">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="568">left edge of the clip rectangle in window coordinates</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="569">top edge of the clip rectangle in window coordinates</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="570">width of the clip rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="571">height of the clip rectangle</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels"
              c:identifier="cogl_framebuffer_read_pixels"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1774">This is a convenience wrapper around
cogl_framebuffer_read_pixels_into_bitmap() which allocates a
temporary #CoglBitmap to read pixel data directly into the given
buffer. The rowstride of the buffer is assumed to be the width of
the region times the bytes per pixel of the format. The source for
the data is always taken from the color buffer. If you want to use
any other rowstride or source, please use the
cogl_framebuffer_read_pixels_into_bitmap() function directly.

The implementation of the function looks like this:

|[
bitmap = cogl_bitmap_new_for_data (context,
                                   width, height,
                                   format,
                                   /&lt;!-- --&gt;* rowstride *&lt;!-- --&gt;/
                                   bpp * width,
                                   pixels);
cogl_framebuffer_read_pixels_into_bitmap (framebuffer,
                                          x, y,
                                          COGL_READ_PIXELS_COLOR_BUFFER,
                                          bitmap);
cogl_object_unref (bitmap);
]|</doc>
        <source-position filename="cogl-framebuffer.h" line="1814"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="1809">%TRUE if the read succeeded or %FALSE otherwise.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1776">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1777">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1778">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1779">The width of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1780">The height of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1781">The pixel format to store the data in</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="pixels" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1782">The address of the buffer to store the data in</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels_into_bitmap"
              c:identifier="cogl_framebuffer_read_pixels_into_bitmap"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1741">This reads a rectangle of pixels from the given framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and a rectangle of pixels with the same size as the bitmap is
read right and downwards from that point.

Currently Cogl assumes that the framebuffer is in a premultiplied
format so if the format of @bitmap is non-premultiplied it will
convert it. To read the pixel values without any conversion you
should either specify a format that doesn't use an alpha channel or
use one of the formats ending in PRE.</doc>
        <source-position filename="cogl-framebuffer.h" line="1768"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="1761">%TRUE if the read succeeded or %FALSE otherwise. The
 function is only likely to fail if the bitmap points to a pixel
 buffer and it could not be mapped.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1743">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1744">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1745">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1746">Identifies which auxillary buffer you want to read
         (only COGL_READ_PIXELS_COLOR_BUFFER supported currently)</doc>
            <type name="ReadPixelsFlags" c:type="CoglReadPixelsFlags"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1748">The bitmap to store the results in.</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
      <method name="resolve_samples"
              c:identifier="cogl_framebuffer_resolve_samples"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1033">When point sample rendering (also known as multisample rendering)
has been enabled via cogl_framebuffer_set_samples_per_pixel()
then you can optionally call this function (or
cogl_framebuffer_resolve_samples_region()) to explicitly resolve
the point samples into values for the final color buffer.

Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.

Since Cogl will automatically ensure samples are resolved if the
target color buffer is used as a source this API only needs to be
used if explicit control is desired - perhaps because you want to
ensure that the resolve is completed in advance to avoid later
having to wait for the resolve to complete.

If you are performing incremental updates to a framebuffer you
should consider using cogl_framebuffer_resolve_samples_region()
instead to avoid resolving redundant pixels.</doc>
        <source-position filename="cogl-framebuffer.h" line="1062"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1035">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="resolve_samples_region"
              c:identifier="cogl_framebuffer_resolve_samples_region"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1064">When point sample rendering (also known as multisample rendering)
has been enabled via cogl_framebuffer_set_samples_per_pixel()
then you can optionally call this function (or
cogl_framebuffer_resolve_samples()) to explicitly resolve the point
samples into values for the final color buffer.

Some GPUs will implicitly resolve the point samples during
rendering and so this function is effectively a nop, but with other
architectures it is desirable to defer the resolve step until the
end of the frame.

Use of this API is recommended if incremental, small updates to
a framebuffer are being made because by default Cogl will
implicitly resolve all the point samples of the framebuffer which
can result in redundant work if only a small number of samples have
changed.

Because some GPUs implicitly resolve point samples this function
only guarantees that at-least the region specified will be resolved
and if you have rendered to a larger region then it's possible that
other samples may be implicitly resolved.</doc>
        <source-position filename="cogl-framebuffer.h" line="1098"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1066">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1067">top-left x coordinate of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1068">top-left y coordinate of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1069">width of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1070">height of region to resolve</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate"
              c:identifier="cogl_framebuffer_rotate"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="351">Multiplies the current model-view matrix by one that rotates the
model around the axis-vector specified by @x, @y and @z. The
rotation follows the right-hand thumb rule so for example rotating
by 10 degrees about the axis-vector (0, 0, 1) causes a small
counter-clockwise rotation.</doc>
        <source-position filename="cogl-framebuffer.h" line="369"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="353">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="354">Angle in degrees to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="355">X-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="356">Y-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="357">Z-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler"
              c:identifier="cogl_framebuffer_rotate_euler"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="392">Multiplies the current model-view matrix by one that rotates
according to the rotation described by @euler.</doc>
        <source-position filename="cogl-framebuffer.h" line="404"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="394">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="395">A #CoglEuler</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_quaternion"
              c:identifier="cogl_framebuffer_rotate_quaternion"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="377">Multiplies the current model-view matrix by one that rotates
according to the rotation described by @quaternion.</doc>
        <source-position filename="cogl-framebuffer.h" line="389"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="379">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="380">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale"
              c:identifier="cogl_framebuffer_scale"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="313">Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.</doc>
        <source-position filename="cogl-framebuffer.h" line="327"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="315">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="316">Amount to scale along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="317">Amount to scale along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="318">Amount to scale along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_mask"
              c:identifier="cogl_framebuffer_set_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="849">Defines a bit mask of which color channels should be written to the
given @framebuffer. If a bit is set in @color_mask that means that
color will be written.</doc>
        <source-position filename="cogl-framebuffer.h" line="863"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="851">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="color_mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="852">A #CoglColorMask of which color channels to write to
             the current framebuffer.</doc>
            <type name="ColorMask" c:type="CoglColorMask"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_texture_enabled"
              c:identifier="cogl_framebuffer_set_depth_texture_enabled"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="901">If @enabled is #TRUE, the depth buffer used when rendering to @framebuffer
is available as a texture. You can retrieve the texture with
cogl_framebuffer_get_depth_texture().

&lt;note&gt;It's possible that your GPU does not support depth textures. You
should check the %COGL_FEATURE_ID_DEPTH_TEXTURE feature before using this
function.&lt;/note&gt;
&lt;note&gt;It's not valid to call this function after the framebuffer has been
allocated as the creation of the depth texture is done at allocation time.
&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="921"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="903">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="904">TRUE or FALSE</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_write_enabled"
              c:identifier="cogl_framebuffer_set_depth_write_enabled"
              version="1.18"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="815">Enables or disables depth buffer writing when rendering to @framebuffer.
If depth writing is enabled for both the framebuffer and the rendering
pipeline, and the framebuffer has an associated depth buffer, depth
information will be written to this buffer during rendering.

Depth buffer writing is enabled by default.</doc>
        <source-position filename="cogl-framebuffer.h" line="831"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="817">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="depth_write_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="818">%TRUE to enable depth writing or %FALSE to disable</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dither_enabled"
              c:identifier="cogl_framebuffer_set_dither_enabled"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="775">Enables or disabled dithering if supported by the hardware.

Dithering is a hardware dependent technique to increase the visible
color resolution beyond what the underlying hardware supports by playing
tricks with the colors placed into the framebuffer to give the illusion
of other colors. (For example this can be compared to half-toning used
by some news papers to show varying levels of grey even though their may
only be black and white are available).

If the current display pipeline for @framebuffer does not support dithering
then this has no affect.

Dithering is enabled by default.</doc>
        <source-position filename="cogl-framebuffer.h" line="798"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="777">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="dither_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="778">%TRUE to enable dithering or %FALSE to disable</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modelview_matrix"
              c:identifier="cogl_framebuffer_set_modelview_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="437">Sets @matrix as the new model-view matrix.</doc>
        <source-position filename="cogl-framebuffer.h" line="448"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="439">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="440">the new model-view matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_projection_matrix"
              c:identifier="cogl_framebuffer_set_projection_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="551">Sets @matrix as the new projection matrix.</doc>
        <source-position filename="cogl-framebuffer.h" line="562"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="553">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="554">the new projection matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_samples_per_pixel"
              c:identifier="cogl_framebuffer_set_samples_per_pixel"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="960">Requires that when rendering to @framebuffer then @n point samples
should be made per pixel which will all contribute to the final
resolved color for that pixel. The idea is that the hardware aims
to get quality similar to what you would get if you rendered
everything twice as big (for 4 samples per pixel) and then scaled
that image back down with filtering. It can effectively remove the
jagged edges of polygons and should be more efficient than if you
were to manually render at a higher resolution and downscale
because the hardware is often able to take some shortcuts. For
example the GPU may only calculate a single texture sample for all
points of a single pixel, and for tile based architectures all the
extra sample data (such as depth and stencil samples) may be
handled on-chip and so avoid increased demand on system memory
bandwidth.

By default this value is usually set to 0 and that is referred to
as "single-sample" rendering. A value of 1 or greater is referred
to as "multisample" rendering.

&lt;note&gt;There are some semantic differences between single-sample
rendering and multisampling with just 1 point sample such as it
being redundant to use the cogl_framebuffer_resolve_samples() and
cogl_framebuffer_resolve_samples_region() apis with single-sample
rendering.&lt;/note&gt;

&lt;note&gt;It's recommended that
cogl_framebuffer_resolve_samples_region() be explicitly used at the
end of rendering to a point sample buffer to minimize the number of
samples that get resolved. By default Cogl will implicitly resolve
all framebuffer samples but if only a small region of a
framebuffer has changed this can lead to redundant work being
done.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="1002"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="962">A #CoglFramebuffer framebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="samples_per_pixel" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="963">The minimum number of samples per pixel</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stereo_mode"
              c:identifier="cogl_framebuffer_set_stereo_mode"
              version="1.20"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="880">Sets which stereo buffers should be drawn to. The default
is %COGL_STEREO_BOTH, which means that both the left and
right buffers will be affected by drawing. For this to have
an effect, the display system must support stereo drawables,
and the framebuffer must have been created with stereo
enabled. (See cogl_onscreen_template_set_stereo_enabled(),
cogl_framebuffer_get_is_stereo().)</doc>
        <source-position filename="cogl-framebuffer.h" line="898"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="882">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="stereo_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="883">A #CoglStereoMode specifying which stereo buffers
              should be drawn tow.</doc>
            <type name="StereoMode" c:type="CoglStereoMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_viewport"
              c:identifier="cogl_framebuffer_set_viewport"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="167">Defines a scale and offset for everything rendered relative to the
top-left of the destination framebuffer.

By default the viewport has an origin of (0,0) and width and height
that match the framebuffer's size. Assuming a default projection and
modelview matrix then you could translate the contents of a window
down and right by leaving the viewport size unchanged by moving the
offset to (10,10). The viewport coordinates are measured in pixels.
If you left the x and y origin as (0,0) you could scale the windows
contents down by specify and width and height that's half the real
size of the framebuffer.

&lt;note&gt;Although the function takes floating point arguments, existing
drivers only allow the use of integer values. In the future floating
point values will be exposed via a checkable feature.&lt;/note&gt;</doc>
        <source-position filename="cogl-framebuffer.h" line="197"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="169">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="170">The top-left x coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="172">The top-left y coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="174">The width of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="175">The height of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform"
              c:identifier="cogl_framebuffer_transform"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="409">Multiplies the current model-view matrix by the given matrix.</doc>
        <source-position filename="cogl-framebuffer.h" line="420"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="411">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="412">the matrix to multiply with the current model-view</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate"
              c:identifier="cogl_framebuffer_translate"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="332">Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.</doc>
        <source-position filename="cogl-framebuffer.h" line="346"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="334">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="335">Distance to translate along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="336">Distance to translate along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="337">Distance to translate along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="vdraw_attributes"
              c:identifier="cogl_framebuffer_vdraw_attributes"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1197">First defines a geometry primitive by grouping a set of vertex attributes;
specifying a @first_vertex; a number of vertices (@n_vertices) and
specifying  what kind of topology the vertices have via @mode.

Then the function draws the given @primitive geometry to the specified
destination @framebuffer using the graphics processing pipeline described by
@pipeline.

The list of #CoglAttribute&lt;!-- --&gt;s define the attributes of the vertices to
be drawn, such as positions, colors and normals and should be %NULL
terminated.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or #CoglTexture3D
are associated with layers of the given @pipeline.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="cogl-framebuffer.h" line="1231"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1199">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1200">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1201">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1202">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1203">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1204">A set of vertex #CoglAttribute&lt;!-- --&gt;s defining vertex geometry</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="vdraw_indexed_attributes"
              c:identifier="cogl_framebuffer_vdraw_indexed_attributes"
              version="1.10"
              introspectable="0"
              deprecated="1"
              deprecated-version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1286">Behaves the same as cogl_framebuffer_vdraw_attributes() except that
instead of reading vertex data sequentially from the specified
attributes the @indices provide an indirection for how the data
should be indexed allowing a random access order to be
specified.

For example an indices array of [0, 1, 2, 0, 2, 3] could be used
used to draw two triangles (@mode = %COGL_VERTICES_MODE_TRIANGLES +
@n_vertices = 6) but only provide attribute data for the 4 corners
of a rectangle. When the GPU needs to read in each of the 6
vertices it will read the @indices array for each vertex in
sequence and use the index to look up the vertex attribute data. So
here you can see that first and fourth vertex will point to the
same data and third and fifth vertex will also point to shared
data.

Drawing with indices can be a good way of minimizing the size of a
mesh by allowing you to avoid data for duplicate vertices because
multiple entries in the index array can refer back to a single
shared vertex.

&lt;note&gt;The @indices array must be at least as long as @first_vertex
+ @n_vertices otherwise the GPU will overrun the indices array when
looking up vertex data.&lt;/note&gt;

Since it's very common to want to draw a run of rectangles using
indices to avoid duplicating vertex data you can use
cogl_get_rectangle_indices() to get a set of indices that can be
shared.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or
#CoglTexture3D are associated with layers of the given @pipeline.

&lt;note&gt;This api doesn't support any of the legacy global state
options such as cogl_set_depth_test_enabled(),
cogl_set_backface_culling_enabled() or cogl_program_use()&lt;/note&gt;</doc>
        <doc-deprecated xml:space="preserve">Use #CoglPrimitive&lt;!-- --&gt;s and
                  cogl_primitive_draw() instead</doc-deprecated>
        <source-position filename="cogl-framebuffer.h" line="1344"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1288">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1289">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1290">The #CoglVerticesMode defining the topology of vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1291">The vertex offset within the given attributes to draw from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1292">The number of vertices to draw from the given attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1293">The array of indices used by the GPU to lookup attribute
          data for each vertex.</doc>
            <type name="Indices" c:type="CoglIndices*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-framebuffer.h"
                 line="1295">A set of vertex #CoglAttribute&lt;!-- --&gt;s defining vertex geometry</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <enumeration name="FramebufferError" c:type="CoglFramebufferError">
      <source-position filename="cogl-framebuffer.h" line="1852"/>
      <member name="framebuffer_error_allocate"
              value="0"
              c:identifier="COGL_FRAMEBUFFER_ERROR_ALLOCATE">
      </member>
    </enumeration>
    <callback name="FuncPtr" c:type="CoglFuncPtr">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="182">The type used by cogl for function pointers, note that this type
is used as a generic catch-all cast for function pointers and the
actual arguments and return type may be different.</doc>
      <source-position filename="cogl-types.h" line="189"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </callback>
    <class name="GLES2Context"
           c:symbol-prefix="gles2_context"
           c:type="CoglGLES2Context"
           version="1.12"
           stability="Unstable"
           parent="Object"
           glib:type-name="CoglGLES2Context"
           glib:get-type="cogl_gles2_context_get_gtype"
           glib:fundamental="1">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="106">Represents an OpenGLES 2.0 api context used as a sandbox for
OpenGLES 2.0 state. This is comparable to an EGLContext for those
who have used OpenGLES 2.0 with EGL before.</doc>
      <constructor name="new"
                   c:identifier="cogl_gles2_context_new"
                   version="2.0"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="192">Allocates a new OpenGLES 2.0 context that can be used to render to
#CoglOffscreen framebuffers (Rendering to #CoglOnscreen
framebuffers is not currently supported).

To actually access the OpenGLES 2.0 api itself you need to use
cogl_gles2_context_get_vtable(). You should not try to directly link
to and use the symbols provided by the a system OpenGLES 2.0
driver.

Once you have allocated an OpenGLES 2.0 context you can make it
current using cogl_push_gles2_context(). For those familiar with
using the EGL api, this serves a similar purpose to eglMakeCurrent.

&lt;note&gt;Before using this api applications can check for OpenGLES 2.0
api support by checking for %COGL_FEATURE_ID_GLES2_CONTEXT support
with cogl_has_feature(). This function will return %FALSE and
return an %COGL_GLES2_CONTEXT_ERROR_UNSUPPORTED error if the
feature isn't available.&lt;/note&gt;</doc>
        <source-position filename="cogl-gles2.h" line="222"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="217">A newly allocated #CoglGLES2Context or %NULL if there
              was an error and @error will be updated in that case.</doc>
          <type name="GLES2Context" c:type="CoglGLES2Context*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-gles2.h"
                 line="194">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_vtable"
              c:identifier="cogl_gles2_context_get_vtable"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="224">Queries the OpenGLES 2.0 api function pointers that should be
used for rendering with the given @gles2_ctx.

&lt;note&gt;You should not try to directly link to and use the symbols
provided by any system OpenGLES 2.0 driver.&lt;/note&gt;</doc>
        <source-position filename="cogl-gles2.h" line="241"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="236">A pointer to a #CoglGLES2Vtable providing pointers
              to functions for the full OpenGLES 2.0 api.</doc>
          <type name="GLES2Vtable" c:type="const CoglGLES2Vtable*"/>
        </return-value>
        <parameters>
          <instance-parameter name="gles2_ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-gles2.h"
                 line="226">A #CoglGLES2Context allocated with
            cogl_gles2_context_new()</doc>
            <type name="GLES2Context" c:type="CoglGLES2Context*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="GLES2ContextError" c:type="CoglGLES2ContextError">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="177">Error codes that relate to the cogl_gles2_context api.</doc>
      <source-position filename="cogl-gles2.h" line="190"/>
      <member name="unsupported"
              value="0"
              c:identifier="COGL_GLES2_CONTEXT_ERROR_UNSUPPORTED">
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="179">Creating GLES2 contexts
   isn't supported. Applications should use cogl_has_feature() to
   check for the %COGL_FEATURE_ID_GLES2_CONTEXT.</doc>
      </member>
      <member name="driver"
              value="1"
              c:identifier="COGL_GLES2_CONTEXT_ERROR_DRIVER">
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="182">An underlying driver error
   occured.</doc>
      </member>
    </enumeration>
    <record name="GLES2Vtable"
            c:type="CoglGLES2Vtable"
            version="1.12"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="118">Provides function pointers for the full OpenGLES 2.0 api. The
api must be accessed this way and not by directly calling
symbols of any system OpenGLES 2.0 api.</doc>
      <source-position filename="cogl-gles2.h" line="152"/>
      <field name="glBindTexture">
        <callback name="glBindTexture">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="66"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="texture" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBlendFunc">
        <callback name="glBlendFunc">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="68"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sfactor" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="dfactor" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glClear">
        <callback name="glClear">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="70"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mask" transfer-ownership="none">
              <type name="GL.bitfield" c:type="GLbitfield"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glClearColor">
        <callback name="glClearColor">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="72"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="red" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
            <parameter name="green" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
            <parameter name="blue" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
            <parameter name="alpha" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glClearStencil">
        <callback name="glClearStencil">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="77"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="s" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glColorMask">
        <callback name="glColorMask">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="79"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="red" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
            <parameter name="green" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
            <parameter name="blue" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
            <parameter name="alpha" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCopyTexSubImage2D">
        <callback name="glCopyTexSubImage2D">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="84"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="level" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="xoffset" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="yoffset" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDeleteTextures">
        <callback name="glDeleteTextures">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="93"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="textures" transfer-ownership="none">
              <type name="GL.uint" c:type="const GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDepthFunc">
        <callback name="glDepthFunc">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="95"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="func" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDepthMask">
        <callback name="glDepthMask">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="97"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="flag" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDisable">
        <callback name="glDisable">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="99"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cap" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDrawArrays">
        <callback name="glDrawArrays">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="101"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mode" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="first" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDrawElements">
        <callback name="glDrawElements">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="103"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mode" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="indices" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glEnable">
        <callback name="glEnable">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="108"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="cap" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glFinish">
        <callback name="glFinish">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="110"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="glFlush">
        <callback name="glFlush">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="112"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="glFrontFace">
        <callback name="glFrontFace">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="114"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mode" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCullFace">
        <callback name="glCullFace">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="116"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mode" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGenTextures">
        <callback name="glGenTextures">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="118"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="textures" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetError" introspectable="0">
        <callback name="glGetError" introspectable="0">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="120"/>
          <return-value>
            <type name="GL.enum" c:type="GLenum"/>
          </return-value>
        </callback>
      </field>
      <field name="glGetIntegerv">
        <callback name="glGetIntegerv">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="122"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetBooleanv">
        <callback name="glGetBooleanv">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="124"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetFloatv">
        <callback name="glGetFloatv">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="126"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetString" introspectable="0">
        <callback name="glGetString" introspectable="0">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="128"/>
          <return-value transfer-ownership="none">
            <type c:type="const GLubyte*"/>
          </return-value>
          <parameters>
            <parameter name="name" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glHint">
        <callback name="glHint">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="130"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="mode" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glIsTexture" introspectable="0">
        <callback name="glIsTexture" introspectable="0">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="132"/>
          <return-value>
            <type name="GL.boolean" c:type="GLboolean"/>
          </return-value>
          <parameters>
            <parameter name="texture" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glPixelStorei">
        <callback name="glPixelStorei">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="134"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="param" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glReadPixels">
        <callback name="glReadPixels">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="136"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="format" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pixels" transfer-ownership="none">
              <type name="GL.void" c:type="GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glScissor">
        <callback name="glScissor">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="144"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glStencilFunc">
        <callback name="glStencilFunc">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="146"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="func" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="ref" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="mask" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glStencilMask">
        <callback name="glStencilMask">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="148"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mask" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glStencilOp">
        <callback name="glStencilOp">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="150"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="fail" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="zfail" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="zpass" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glTexImage2D">
        <callback name="glTexImage2D">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="152"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="level" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="internalformat" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="border" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="format" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pixels" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glTexParameterf">
        <callback name="glTexParameterf">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="162"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="param" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glTexParameterfv">
        <callback name="glTexParameterfv">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="164"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glTexParameteri">
        <callback name="glTexParameteri">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="166"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="param" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glTexParameteriv">
        <callback name="glTexParameteriv">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="168"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="const GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetTexParameterfv">
        <callback name="glGetTexParameterfv">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="170"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetTexParameteriv">
        <callback name="glGetTexParameteriv">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="172"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glTexSubImage2D">
        <callback name="glTexSubImage2D">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="174"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="level" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="xoffset" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="yoffset" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="format" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pixels" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCopyTexImage2D">
        <callback name="glCopyTexImage2D">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="184"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="level" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="internalformat" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="border" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glViewport">
        <callback name="glViewport">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="193"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glIsEnabled" introspectable="0">
        <callback name="glIsEnabled" introspectable="0">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="195"/>
          <return-value>
            <type name="GL.boolean" c:type="GLboolean"/>
          </return-value>
          <parameters>
            <parameter name="cap" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glLineWidth">
        <callback name="glLineWidth">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="196"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glPolygonOffset">
        <callback name="glPolygonOffset">
          <source-position filename="gl-prototypes/cogl-core-functions.h"
                           line="197"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="factor" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="units" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDepthRangef">
        <callback name="glDepthRangef">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="65"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="near_val" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="far_val" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glClearDepthf">
        <callback name="glClearDepthf">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="67"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="depth" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCompressedTexImage2D">
        <callback name="glCompressedTexImage2D">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="77"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="level" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="internalformat" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="border" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="imageSize" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCompressedTexSubImage2D">
        <callback name="glCompressedTexSubImage2D">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="86"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="level" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="xoffset" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="yoffset" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="format" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="imageSize" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glSampleCoverage">
        <callback name="glSampleCoverage">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="96"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
            <parameter name="invert" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetBufferParameteriv">
        <callback name="glGetBufferParameteriv">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="106"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGenBuffers">
        <callback name="glGenBuffers">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="115"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="buffers" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBindBuffer">
        <callback name="glBindBuffer">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="118"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBufferData">
        <callback name="glBufferData">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="121"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="GL.sizeiptr" c:type="GLsizeiptr"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
            <parameter name="usage" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBufferSubData">
        <callback name="glBufferSubData">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="126"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="GL.intptr" c:type="GLintptr"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="GL.sizeiptr" c:type="GLsizeiptr"/>
            </parameter>
            <parameter name="data" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDeleteBuffers">
        <callback name="glDeleteBuffers">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="131"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="buffers" transfer-ownership="none">
              <type name="GL.uint" c:type="const GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glIsBuffer" introspectable="0">
        <callback name="glIsBuffer" introspectable="0">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="134"/>
          <return-value>
            <type name="GL.boolean" c:type="GLboolean"/>
          </return-value>
          <parameters>
            <parameter name="buffer" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glActiveTexture">
        <callback name="glActiveTexture">
          <source-position filename="gl-prototypes/cogl-in-gles-core-functions.h"
                           line="145"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="texture" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGenRenderbuffers">
        <callback name="glGenRenderbuffers">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="67"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="renderbuffers" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDeleteRenderbuffers">
        <callback name="glDeleteRenderbuffers">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="70"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="renderbuffers" transfer-ownership="none">
              <type name="GL.uint" c:type="const GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBindRenderbuffer">
        <callback name="glBindRenderbuffer">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="73"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="renderbuffer" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glRenderbufferStorage">
        <callback name="glRenderbufferStorage">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="76"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="internalformat" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="width" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="height" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGenFramebuffers">
        <callback name="glGenFramebuffers">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="81"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="framebuffers" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBindFramebuffer">
        <callback name="glBindFramebuffer">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="84"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="framebuffer" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glFramebufferTexture2D">
        <callback name="glFramebufferTexture2D">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="87"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="attachment" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="textarget" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="texture" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="level" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glFramebufferRenderbuffer">
        <callback name="glFramebufferRenderbuffer">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="93"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="attachment" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="renderbuffertarget" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="renderbuffer" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glIsRenderbuffer" introspectable="0">
        <callback name="glIsRenderbuffer" introspectable="0">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="98"/>
          <return-value>
            <type name="GL.boolean" c:type="GLboolean"/>
          </return-value>
          <parameters>
            <parameter name="renderbuffer" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCheckFramebufferStatus" introspectable="0">
        <callback name="glCheckFramebufferStatus" introspectable="0">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="100"/>
          <return-value>
            <type name="GL.enum" c:type="GLenum"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDeleteFramebuffers">
        <callback name="glDeleteFramebuffers">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="102"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="framebuffers" transfer-ownership="none">
              <type name="GL.uint" c:type="const GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGenerateMipmap">
        <callback name="glGenerateMipmap">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="105"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetFramebufferAttachmentParameteriv">
        <callback name="glGetFramebufferAttachmentParameteriv">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="107"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="attachment" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetRenderbufferParameteriv">
        <callback name="glGetRenderbufferParameteriv">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="112"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="target" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glIsFramebuffer" introspectable="0">
        <callback name="glIsFramebuffer" introspectable="0">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="116"/>
          <return-value>
            <type name="GL.boolean" c:type="GLboolean"/>
          </return-value>
          <parameters>
            <parameter name="framebuffer" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBlendEquation">
        <callback name="glBlendEquation">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="124"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="mode" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBlendColor">
        <callback name="glBlendColor">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="126"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="red" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
            <parameter name="green" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
            <parameter name="blue" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
            <parameter name="alpha" transfer-ownership="none">
              <type name="GL.clampf" c:type="GLclampf"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBlendFuncSeparate">
        <callback name="glBlendFuncSeparate">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="138"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="srcRGB" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="dstRGB" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="srcAlpha" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="dstAlpha" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBlendEquationSeparate">
        <callback name="glBlendEquationSeparate">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="150"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="modeRGB" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="modeAlpha" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glReleaseShaderCompiler">
        <callback name="glReleaseShaderCompiler">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="160"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
        </callback>
      </field>
      <field name="glGetShaderPrecisionFormat">
        <callback name="glGetShaderPrecisionFormat">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="161"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="shadertype" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="precisiontype" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="range" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
            <parameter name="precision" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glShaderBinary">
        <callback name="glShaderBinary">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="166"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="n" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="shaders" transfer-ownership="none">
              <type name="GL.uint" c:type="const GLuint*"/>
            </parameter>
            <parameter name="binaryformat" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="binary" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glStencilFuncSeparate">
        <callback name="glStencilFuncSeparate">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="180"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="face" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="func" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="ref" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="mask" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glStencilMaskSeparate">
        <callback name="glStencilMaskSeparate">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="182"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="face" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="mask" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glStencilOpSeparate">
        <callback name="glStencilOpSeparate">
          <source-position filename="gl-prototypes/cogl-in-gles2-core-functions.h"
                           line="184"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="face" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="fail" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="zfail" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="zpass" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCreateProgram" introspectable="0">
        <callback name="glCreateProgram" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="65"/>
          <return-value>
            <type name="GL.uint" c:type="GLuint"/>
          </return-value>
        </callback>
      </field>
      <field name="glCreateShader" introspectable="0">
        <callback name="glCreateShader" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="67"/>
          <return-value>
            <type name="GL.uint" c:type="GLuint"/>
          </return-value>
          <parameters>
            <parameter name="shaderType" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDeleteShader">
        <callback name="glDeleteShader">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="69"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glAttachShader">
        <callback name="glAttachShader">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="71"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUseProgram">
        <callback name="glUseProgram">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="74"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDeleteProgram">
        <callback name="glDeleteProgram">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="76"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetShaderInfoLog">
        <callback name="glGetShaderInfoLog">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="78"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="maxLength" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei*"/>
            </parameter>
            <parameter name="infoLog" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetProgramInfoLog">
        <callback name="glGetProgramInfoLog">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="83"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="bufSize" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei*"/>
            </parameter>
            <parameter name="infoLog" transfer-ownership="none">
              <type name="utf8" c:type="char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetShaderiv">
        <callback name="glGetShaderiv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="88"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetProgramiv">
        <callback name="glGetProgramiv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="92"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDetachShader">
        <callback name="glDetachShader">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="96"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetAttachedShaders">
        <callback name="glGetAttachedShaders">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="98"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="maxcount" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei*"/>
            </parameter>
            <parameter name="shaders" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glIsShader" introspectable="0">
        <callback name="glIsShader" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="103"/>
          <return-value>
            <type name="GL.boolean" c:type="GLboolean"/>
          </return-value>
          <parameters>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glIsProgram" introspectable="0">
        <callback name="glIsProgram" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="105"/>
          <return-value>
            <type name="GL.boolean" c:type="GLboolean"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glShaderSource">
        <callback name="glShaderSource">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="115"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="string" transfer-ownership="none">
              <type name="utf8" c:type="const char* const*"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="GL.int" c:type="const GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glCompileShader">
        <callback name="glCompileShader">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="120"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glLinkProgram">
        <callback name="glLinkProgram">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="122"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetUniformLocation" introspectable="0">
        <callback name="glGetUniformLocation" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="124"/>
          <return-value>
            <type name="GL.int" c:type="GLint"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform1f">
        <callback name="glUniform1f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="127"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform2f">
        <callback name="glUniform2f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="130"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="v1" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform3f">
        <callback name="glUniform3f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="134"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="v1" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="v2" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform4f">
        <callback name="glUniform4f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="139"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="v1" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="v2" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="v3" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform1fv">
        <callback name="glUniform1fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="145"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform2fv">
        <callback name="glUniform2fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="149"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform3fv">
        <callback name="glUniform3fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="153"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform4fv">
        <callback name="glUniform4fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="157"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform1i">
        <callback name="glUniform1i">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="161"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform2i">
        <callback name="glUniform2i">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="164"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v1" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform3i">
        <callback name="glUniform3i">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="168"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v1" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v2" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform4i">
        <callback name="glUniform4i">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="173"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v0" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v1" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v2" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="v3" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform1iv">
        <callback name="glUniform1iv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="179"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.int" c:type="const GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform2iv">
        <callback name="glUniform2iv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="183"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.int" c:type="const GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform3iv">
        <callback name="glUniform3iv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="187"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.int" c:type="const GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniform4iv">
        <callback name="glUniform4iv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="191"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.int" c:type="const GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniformMatrix2fv">
        <callback name="glUniformMatrix2fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="195"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="transpose" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniformMatrix3fv">
        <callback name="glUniformMatrix3fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="200"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="transpose" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glUniformMatrix4fv">
        <callback name="glUniformMatrix4fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="205"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="count" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="transpose" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
            <parameter name="value" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetUniformfv">
        <callback name="glGetUniformfv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="211"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetUniformiv">
        <callback name="glGetUniformiv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="215"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="location" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetActiveUniform" introspectable="0">
        <callback name="glGetActiveUniform" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="219"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="bufsize" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type c:type="GLchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetShaderSource" introspectable="0">
        <callback name="glGetShaderSource" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="227"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="shader" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="bufsize" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei*"/>
            </parameter>
            <parameter name="source" transfer-ownership="none">
              <type c:type="GLchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glValidateProgram">
        <callback name="glValidateProgram">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="232"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttribPointer">
        <callback name="glVertexAttribPointer">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="241"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="GL.int" c:type="GLint"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="normalized" transfer-ownership="none">
              <type name="GL.boolean" c:type="GLboolean"/>
            </parameter>
            <parameter name="stride" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="pointer" transfer-ownership="none">
              <type name="GL.void" c:type="const GLvoid*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glEnableVertexAttribArray">
        <callback name="glEnableVertexAttribArray">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="248"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glDisableVertexAttribArray">
        <callback name="glDisableVertexAttribArray">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="250"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib1f">
        <callback name="glVertexAttrib1f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="252"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indx" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib1fv">
        <callback name="glVertexAttrib1fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="253"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indx" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="values" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib2f">
        <callback name="glVertexAttrib2f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="255"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indx" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib2fv">
        <callback name="glVertexAttrib2fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="256"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indx" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="values" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib3f">
        <callback name="glVertexAttrib3f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="258"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indx" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="z" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib3fv">
        <callback name="glVertexAttrib3fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="260"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indx" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="values" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib4f">
        <callback name="glVertexAttrib4f">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="262"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="z" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
            <parameter name="w" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glVertexAttrib4fv">
        <callback name="glVertexAttrib4fv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="264"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="indx" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="values" transfer-ownership="none">
              <type name="GL.float" c:type="const GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetVertexAttribfv">
        <callback name="glGetVertexAttribfv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="266"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.float" c:type="GLfloat*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetVertexAttribiv">
        <callback name="glGetVertexAttribiv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="268"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetVertexAttribPointerv">
        <callback name="glGetVertexAttribPointerv">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="270"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="pname" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum"/>
            </parameter>
            <parameter name="pointer" transfer-ownership="none">
              <type name="GL.void" c:type="GLvoid**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetAttribLocation" introspectable="0">
        <callback name="glGetAttribLocation" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="272"/>
          <return-value>
            <type name="GL.int" c:type="GLint"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type name="utf8" c:type="const char*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glBindAttribLocation" introspectable="0">
        <callback name="glBindAttribLocation" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="274"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type c:type="const GLchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="glGetActiveAttrib" introspectable="0">
        <callback name="glGetActiveAttrib" introspectable="0">
          <source-position filename="gl-prototypes/cogl-glsl-functions.h"
                           line="278"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="program" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="index" transfer-ownership="none">
              <type name="GL.uint" c:type="GLuint"/>
            </parameter>
            <parameter name="bufsize" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei"/>
            </parameter>
            <parameter name="length" transfer-ownership="none">
              <type name="GL.sizei" c:type="GLsizei*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="GL.int" c:type="GLint*"/>
            </parameter>
            <parameter name="type" transfer-ownership="none">
              <type name="GL.enum" c:type="GLenum*"/>
            </parameter>
            <parameter name="name" transfer-ownership="none">
              <type c:type="GLchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function-macro name="GLIB_ERROR"
                    c:identifier="COGL_GLIB_ERROR"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl-error.h"
           line="169">Simply casts a #CoglError to a #CoglError

If Cogl is built with GLib support then it can safely be assumed
that a CoglError is a GError and can be used directly with the
GError api.</doc>
      <source-position filename="cogl-error.h" line="180"/>
      <parameters>
        <parameter name="COGL_ERROR">
          <doc xml:space="preserve"
               filename="cogl-error.h"
               line="171">A #CoglError thrown by the Cogl api or %NULL</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GTYPE_DEFINE_BASE_CLASS"
                    c:identifier="COGL_GTYPE_DEFINE_BASE_CLASS"
                    introspectable="0">
      <source-position filename="cogl-gtype-private.h" line="136"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
        <parameter name="...">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GTYPE_DEFINE_BOXED"
                    c:identifier="COGL_GTYPE_DEFINE_BOXED"
                    introspectable="0">
      <source-position filename="cogl-gtype-private.h" line="63"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="underscore_name">
        </parameter>
        <parameter name="copy_func">
        </parameter>
        <parameter name="free_func">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GTYPE_DEFINE_CLASS"
                    c:identifier="COGL_GTYPE_DEFINE_CLASS"
                    introspectable="0">
      <source-position filename="cogl-gtype-private.h" line="233"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
        <parameter name="...">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GTYPE_DEFINE_INTERFACE"
                    c:identifier="COGL_GTYPE_DEFINE_INTERFACE"
                    introspectable="0">
      <source-position filename="cogl-gtype-private.h" line="172"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="GTYPE_IMPLEMENT_INTERFACE"
                    c:identifier="COGL_GTYPE_IMPLEMENT_INTERFACE"
                    introspectable="0">
      <source-position filename="cogl-gtype-private.h" line="79"/>
      <parameters>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <record name="GtypeClass" c:type="CoglGtypeClass">
      <source-position filename="cogl-gtype-private.h" line="57"/>
      <field name="base_class" writable="1">
        <type name="GObject.TypeClass" c:type="GTypeClass"/>
      </field>
      <field name="dummy" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="GtypeObject" c:type="CoglGtypeObject">
      <source-position filename="cogl-gtype-private.h" line="50"/>
      <field name="parent_instance" writable="1">
        <type name="GObject.TypeInstance" c:type="GTypeInstance"/>
      </field>
      <field name="dummy" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <function-macro name="INDEX_BUFFER"
                    c:identifier="COGL_INDEX_BUFFER"
                    introspectable="0">
      <source-position filename="cogl-index-buffer.h" line="57"/>
      <parameters>
        <parameter name="buffer">
        </parameter>
      </parameters>
    </function-macro>
    <class name="IndexBuffer"
           c:symbol-prefix="index_buffer"
           c:type="CoglIndexBuffer"
           parent="Object"
           glib:type-name="CoglIndexBuffer"
           glib:get-type="cogl_index_buffer_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_index_buffer_new"
                   version="1.4"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-index-buffer.h"
             line="70">Declares a new #CoglIndexBuffer of @size bytes to contain vertex
indices. Once declared, data can be set using
cogl_buffer_set_data() or by mapping it into the application's
address space using cogl_buffer_map().</doc>
        <source-position filename="cogl-index-buffer.h" line="86"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-index-buffer.h"
               line="80">A newly allocated #CoglIndexBuffer</doc>
          <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-index-buffer.h"
                 line="72">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-index-buffer.h"
                 line="73">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="Indices"
           c:symbol-prefix="indices"
           c:type="CoglIndices"
           parent="Object"
           glib:type-name="CoglIndices"
           glib:get-type="cogl_indices_get_gtype"
           glib:fundamental="1">
      <constructor name="new" c:identifier="cogl_indices_new">
        <source-position filename="cogl-indices.h" line="122"/>
        <return-value transfer-ownership="full">
          <type name="Indices" c:type="CoglIndices*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="IndicesType" c:type="CoglIndicesType"/>
          </parameter>
          <parameter name="indices_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="n_indices" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_buffer"
                   c:identifier="cogl_indices_new_for_buffer">
        <source-position filename="cogl-indices.h" line="128"/>
        <return-value transfer-ownership="full">
          <type name="Indices" c:type="CoglIndices*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <type name="IndicesType" c:type="CoglIndicesType"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_buffer"
              c:identifier="cogl_indices_get_buffer"
              introspectable="0">
        <source-position filename="cogl-indices.h" line="133"/>
        <return-value>
          <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="indices" transfer-ownership="none">
            <type name="Indices" c:type="CoglIndices*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="cogl_indices_get_offset">
        <source-position filename="cogl-indices.h" line="139"/>
        <return-value transfer-ownership="none">
          <type name="gsize" c:type="size_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="indices" transfer-ownership="none">
            <type name="Indices" c:type="CoglIndices*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type" c:identifier="cogl_indices_get_type">
        <source-position filename="cogl-indices.h" line="136"/>
        <return-value transfer-ownership="none">
          <type name="IndicesType" c:type="CoglIndicesType"/>
        </return-value>
        <parameters>
          <instance-parameter name="indices" transfer-ownership="none">
            <type name="Indices" c:type="CoglIndices*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_offset" c:identifier="cogl_indices_set_offset">
        <source-position filename="cogl-indices.h" line="142"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="indices" transfer-ownership="none">
            <type name="Indices" c:type="CoglIndices*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="IndicesType"
                 glib:type-name="CoglIndicesType"
                 glib:get-type="cogl_indices_type_get_type"
                 c:type="CoglIndicesType">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="692">You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.

Note that %COGL_INDICES_TYPE_UNSIGNED_INT is only supported if the
%COGL_FEATURE_ID_UNSIGNED_INT_INDICES feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized.</doc>
      <member name="byte"
              value="0"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_BYTE"
              glib:nick="byte"
              glib:name="COGL_INDICES_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="694">Your indices are unsigned bytes</doc>
      </member>
      <member name="short"
              value="1"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_SHORT"
              glib:nick="short"
              glib:name="COGL_INDICES_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="695">Your indices are unsigned shorts</doc>
      </member>
      <member name="int"
              value="2"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_INT"
              glib:nick="int"
              glib:name="COGL_INDICES_TYPE_UNSIGNED_INT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="696">Your indices are unsigned ints</doc>
      </member>
    </enumeration>
    <record name="KmsCrtc" c:type="CoglKmsCrtc">
      <source-position filename="cogl-kms-display.h" line="72"/>
      <field name="id" writable="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="x" writable="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="y" writable="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="mode" introspectable="0" writable="1">
        <type c:type="drmModeModeInfo"/>
      </field>
      <field name="connectors" writable="1">
        <type name="guint32" c:type="uint32_t*"/>
      </field>
      <field name="count" writable="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="ignore" writable="1">
        <type name="Bool" c:type="CoglBool"/>
      </field>
    </record>
    <function-macro name="META_TEXTURE"
                    c:identifier="COGL_META_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl-meta-texture.h" line="102"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="MaterialAlphaFunc"
                 glib:type-name="CoglMaterialAlphaFunc"
                 glib:get-type="cogl_material_alpha_func_get_type"
                 c:type="CoglMaterialAlphaFunc">
      <member name="never"
              value="512"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NEVER"
              glib:nick="never"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_NEVER">
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LESS"
              glib:nick="less"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_LESS">
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_EQUAL"
              glib:nick="equal"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_EQUAL">
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_LEQUAL"
              glib:nick="lequal"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_LEQUAL">
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GREATER"
              glib:nick="greater"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_GREATER">
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL"
              glib:nick="notequal"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_NOTEQUAL">
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_GEQUAL"
              glib:nick="gequal"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_GEQUAL">
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_MATERIAL_ALPHA_FUNC_ALWAYS"
              glib:nick="always"
              glib:name="COGL_MATERIAL_ALPHA_FUNC_ALWAYS">
      </member>
    </enumeration>
    <enumeration name="MaterialFilter"
                 glib:type-name="CoglMaterialFilter"
                 glib:get-type="cogl_material_filter_get_type"
                 c:type="CoglMaterialFilter">
      <member name="nearest"
              value="9728"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST"
              glib:nick="nearest"
              glib:name="COGL_MATERIAL_FILTER_NEAREST">
      </member>
      <member name="linear"
              value="9729"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR"
              glib:nick="linear"
              glib:name="COGL_MATERIAL_FILTER_LINEAR">
      </member>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST"
              glib:nick="nearest-mipmap-nearest"
              glib:name="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_NEAREST">
      </member>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST"
              glib:nick="linear-mipmap-nearest"
              glib:name="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_NEAREST">
      </member>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR"
              glib:nick="nearest-mipmap-linear"
              glib:name="COGL_MATERIAL_FILTER_NEAREST_MIPMAP_LINEAR">
      </member>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR"
              glib:nick="linear-mipmap-linear"
              glib:name="COGL_MATERIAL_FILTER_LINEAR_MIPMAP_LINEAR">
      </member>
    </enumeration>
    <enumeration name="MaterialLayerType"
                 glib:type-name="CoglMaterialLayerType"
                 glib:get-type="cogl_material_layer_type_get_type"
                 c:type="CoglMaterialLayerType">
      <member name="texture"
              value="0"
              c:identifier="COGL_MATERIAL_LAYER_TYPE_TEXTURE"
              glib:nick="texture"
              glib:name="COGL_MATERIAL_LAYER_TYPE_TEXTURE">
      </member>
    </enumeration>
    <enumeration name="MaterialWrapMode"
                 glib:type-name="CoglMaterialWrapMode"
                 glib:get-type="cogl_material_wrap_mode_get_type"
                 c:type="CoglMaterialWrapMode">
      <member name="repeat"
              value="10497"
              c:identifier="COGL_MATERIAL_WRAP_MODE_REPEAT"
              glib:nick="repeat"
              glib:name="COGL_MATERIAL_WRAP_MODE_REPEAT">
      </member>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE"
              glib:nick="clamp-to-edge"
              glib:name="COGL_MATERIAL_WRAP_MODE_CLAMP_TO_EDGE">
      </member>
      <member name="automatic"
              value="519"
              c:identifier="COGL_MATERIAL_WRAP_MODE_AUTOMATIC"
              glib:nick="automatic"
              glib:name="COGL_MATERIAL_WRAP_MODE_AUTOMATIC">
      </member>
    </enumeration>
    <record name="Matrix"
            c:type="CoglMatrix"
            glib:type-name="CoglMatrix"
            glib:get-type="cogl_matrix_get_gtype"
            c:symbol-prefix="matrix">
      <doc xml:space="preserve"
           filename="cogl-matrix.h"
           line="64">A CoglMatrix holds a 4x4 transform matrix. This is a single precision,
column-major matrix which means it is compatible with what OpenGL expects.

A CoglMatrix can represent transforms such as, rotations, scaling,
translation, sheering, and linear projections. You can combine these
transforms by multiplying multiple matrices in the order you want them
applied.

The transformation of a vertex (x, y, z, w) by a CoglMatrix is given by:

|[
  x_new = xx * x + xy * y + xz * z + xw * w
  y_new = yx * x + yy * y + yz * z + yw * w
  z_new = zx * x + zy * y + zz * z + zw * w
  w_new = wx * x + wy * y + wz * z + ww * w
]|

Where w is normally 1

&lt;note&gt;You must consider the members of the CoglMatrix structure read only,
and all matrix modifications must be done via the cogl_matrix API. This
allows Cogl to annotate the matrices internally. Violation of this will give
undefined results. If you need to initialize a matrix with a constant other
than the identity matrix you can use cogl_matrix_init_from_array().&lt;/note&gt;</doc>
      <source-position filename="cogl-matrix.h" line="126"/>
      <field name="xx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wx" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wy" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="wz" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="xw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="yw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="zw" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ww" writable="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="private_member_inv" readable="0" private="1">
        <array zero-terminated="0" fixed-size="16">
          <type name="gfloat" c:type="float"/>
        </array>
      </field>
      <field name="private_member_type" readable="0" private="1">
        <type name="gulong" c:type="unsigned long"/>
      </field>
      <field name="private_member_flags" readable="0" private="1">
        <type name="gulong" c:type="unsigned long"/>
      </field>
      <field name="private_member__padding3" readable="0" private="1">
        <type name="gulong" c:type="unsigned long"/>
      </field>
      <method name="copy" c:identifier="cogl_matrix_copy" version="1.6">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="570">Allocates a new #CoglMatrix on the heap and initializes it with
the same values as @matrix.</doc>
        <source-position filename="cogl-matrix.h" line="583"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-matrix.h"
               line="577">A newly allocated #CoglMatrix which
should be freed using cogl_matrix_free()</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="572">A 4x4 transformation matrix you want to copy</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_matrix_free" version="1.6">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="585">Frees a #CoglMatrix that was previously allocated via a call to
cogl_matrix_copy().</doc>
        <source-position filename="cogl-matrix.h" line="595"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="587">A 4x4 transformation matrix you want to free</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="frustum" c:identifier="cogl_matrix_frustum">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="322">Multiplies @matrix by the given frustum perspective matrix.</doc>
        <source-position filename="cogl-matrix.h" line="339"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="324">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="325">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="327">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="329">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="331">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="333">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="334">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_array" c:identifier="cogl_matrix_get_array">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="520">Casts @matrix to a float array which can be directly passed to OpenGL.</doc>
        <source-position filename="cogl-matrix.h" line="529"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix.h"
               line="526">a pointer to the float array</doc>
          <type name="gfloat" c:type="const float*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="522">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_inverse"
              c:identifier="cogl_matrix_get_inverse"
              version="1.2">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="597">Gets the inverse transform of a given matrix and uses it to initialize
a new #CoglMatrix.

&lt;note&gt;Although the first parameter is annotated as const to indicate
that the transform it represents isn't modified this function may
technically save a copy of the inverse transform within the given
#CoglMatrix so that subsequent requests for the inverse transform may
avoid costly inversion calculations.&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix.h" line="618"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix.h"
               line="611">%TRUE if the inverse was successfully calculated or %FALSE
  for degenerate transformations that can't be inverted (in this case the
  @inverse matrix will simply be initialized with the identity matrix)</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="599">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="inverse"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="600">The destination for a 4x4 inverse transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_array"
              c:identifier="cogl_matrix_init_from_array">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="509">Initializes @matrix with the contents of @array</doc>
        <source-position filename="cogl-matrix.h" line="517"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="511">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="512">A linear array of 16 floats (column-major order)</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_euler"
              c:identifier="cogl_matrix_init_from_euler">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="543">Initializes @matrix from a #CoglEuler rotation.</doc>
        <source-position filename="cogl-matrix.h" line="551"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="545">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="546">A #CoglEuler</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_quaternion"
              c:identifier="cogl_matrix_init_from_quaternion">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="532">Initializes @matrix from a #CoglQuaternion rotation.</doc>
        <source-position filename="cogl-matrix.h" line="540"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="534">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="535">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity" c:identifier="cogl_matrix_init_identity">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="130">Resets matrix to the identity matrix:

|[
  .xx=1; .xy=0; .xz=0; .xw=0;
  .yx=0; .yy=1; .yz=0; .yw=0;
  .zx=0; .zy=0; .zz=1; .zw=0;
  .wx=0; .wy=0; .wz=0; .ww=1;
]|</doc>
        <source-position filename="cogl-matrix.h" line="144"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="132">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_translation"
              c:identifier="cogl_matrix_init_translation"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="146">Resets matrix to the (tx, ty, tz) translation matrix:

|[
  .xx=1; .xy=0; .xz=0; .xw=tx;
  .yx=0; .yy=1; .yz=0; .yw=ty;
  .zx=0; .zy=0; .zz=1; .zw=tz;
  .wx=0; .wy=0; .wz=0; .ww=1;
]|</doc>
        <source-position filename="cogl-matrix.h" line="165"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="148">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="tx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="149">x coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="ty" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="150">y coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tz" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="151">z coordinate of the translation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_identity"
              c:identifier="cogl_matrix_is_identity"
              version="1.8">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="759">Determines if the given matrix is an identity matrix.</doc>
        <source-position filename="cogl-matrix.h" line="769"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix.h"
               line="765">%TRUE if @matrix is an identity matrix else %FALSE</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="761">A #CoglMatrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="look_at"
              c:identifier="cogl_matrix_look_at"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="267">Applies a view transform @matrix that positions the camera at
the coordinate (@eye_position_x, @eye_position_y, @eye_position_z)
looking towards an object at the coordinate (@object_x, @object_y,
@object_z). The top of the camera is aligned to the given world up
vector, which is normally simply (0, 1, 0) to map up to the
positive direction of the y axis.

Because there is a lot of missleading documentation online for
gluLookAt regarding the up vector we want to try and be a bit
clearer here.

The up vector should simply be relative to your world coordinates
and does not need to change as you move the eye and object
positions.  Many online sources may claim that the up vector needs
to be perpendicular to the vector between the eye and object
position (partly because the man page is somewhat missleading) but
that is not necessary for this function.

&lt;note&gt;You should never look directly along the world-up
vector.&lt;/note&gt;

&lt;note&gt;It is assumed you are using a typical projection matrix where
your origin maps to the center of your viewport.&lt;/note&gt;

&lt;note&gt;Almost always when you use this function it should be the first
transform applied to a new modelview transform&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix.h" line="311"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="269">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="eye_position_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="270">The X coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="271">The Y coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="eye_position_z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="272">The Z coordinate to look from</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="273">The X coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="274">The Y coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="object_z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="275">The Z coordinate of the object to look at</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="276">The X component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="277">The Y component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="world_up_z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="278">The Z component of the world's up direction vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="cogl_matrix_multiply">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="170">Multiplies the two supplied matrices together and stores
the resulting matrix inside @result.

&lt;note&gt;It is possible to multiply the @a matrix in-place, so
@result can be equal to @a but can't be equal to @b.&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix.h" line="183"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="172">The address of a 4x4 matrix to store the result in</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="173">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="174">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ortho"
              c:identifier="cogl_matrix_ortho"
              deprecated="1"
              deprecated-version="1.10">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="400">Multiplies @matrix by a parallel projection matrix.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_matrix_orthographic()</doc-deprecated>
        <source-position filename="cogl-matrix.h" line="420"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="402">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="403">The coordinate for the left clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="404">The coordinate for the right clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="405">The coordinate for the bottom clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="406">The coordinate for the top clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="407">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="410">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="orthographic"
              c:identifier="cogl_matrix_orthographic"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="371">Multiplies @matrix by a parallel projection matrix.</doc>
        <source-position filename="cogl-matrix.h" line="391"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="373">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="374">The x coordinate for the first vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="375">The y coordinate for the first horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="376">The x coordinate for the second vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="377">The y coordinate for the second horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="378">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="381">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="cogl_matrix_perspective">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="347">Multiplies @matrix by the described perspective matrix

&lt;note&gt;You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix.h" line="364"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="349">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="350">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="351">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="352">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="354">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="project_points"
              c:identifier="cogl_matrix_project_points"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="702">Projects an array of input points and writes the result to another
array of output points. The input points can either have 2, 3 or 4
components each. The output points always have 4 components (known
as homogenous coordinates). The output array can simply point to
the input array to do the transform in-place.

Here's an example with differing input/output strides:
|[
typedef struct {
  float x,y;
  uint8_t r,g,b,a;
  float s,t,p;
} MyInVertex;
typedef struct {
  uint8_t r,g,b,a;
  float x,y,z;
} MyOutVertex;
MyInVertex vertices[N_VERTICES];
MyOutVertex results[N_VERTICES];
CoglMatrix matrix;

my_load_vertices (vertices);
my_get_matrix (&amp;matrix);

cogl_matrix_project_points (&amp;matrix,
                            2,
                            sizeof (MyInVertex),
                            &amp;vertices[0].x,
                            sizeof (MyOutVertex),
                            &amp;results[0].x,
                            N_VERTICES);
]|</doc>
        <source-position filename="cogl-matrix.h" line="749"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="704">A projection matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="705">The number of position components for each input point.
               (either 2, 3 or 4)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="stride_in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="707">The stride in bytes between input points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="708">A pointer to the first component of the first input point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="stride_out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="709">The stride in bytes between output points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="710">A pointer to the first component of the first output point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="n_points" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="711">The number of points to transform.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_matrix_rotate">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="187">Multiplies @matrix with a rotation matrix that applies a rotation
of @angle degrees around the specified 3D vector.</doc>
        <source-position filename="cogl-matrix.h" line="199"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="189">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="190">The angle you want to rotate in degrees</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="191">X component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="192">Y component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="193">Z component of your rotation vector</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler"
              c:identifier="cogl_matrix_rotate_euler"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="220">Multiplies @matrix with a rotation transformation described by the
given #CoglEuler.</doc>
        <source-position filename="cogl-matrix.h" line="231"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="222">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="223">A euler describing a rotation</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_quaternion"
              c:identifier="cogl_matrix_rotate_quaternion"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="206">Multiplies @matrix with a rotation transformation described by the
given #CoglQuaternion.</doc>
        <source-position filename="cogl-matrix.h" line="217"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="208">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="209">A quaternion describing a rotation</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_matrix_scale">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="251">Multiplies @matrix with a transform matrix that scales along the X,
Y and Z axis.</doc>
        <source-position filename="cogl-matrix.h" line="262"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="253">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="sx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="254">The X scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="255">The Y scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="sz" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="256">The Z scale factor</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="cogl_matrix_transform_point">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="625">Transforms a point whos position is given and returned as four float
components.</doc>
        <source-position filename="cogl-matrix.h" line="637"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="627">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="628">The X component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="y"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="629">The Y component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="z"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="630">The Z component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="w"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="631">The W component of your points position</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform_points"
              c:identifier="cogl_matrix_transform_points"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="644">Transforms an array of input points and writes the result to
another array of output points. The input points can either have 2
or 3 components each. The output points always have 3 components.
The output array can simply point to the input array to do the
transform in-place.

If you need to transform 4 component points see
cogl_matrix_project_points().

Here's an example with differing input/output strides:
|[
typedef struct {
  float x,y;
  uint8_t r,g,b,a;
  float s,t,p;
} MyInVertex;
typedef struct {
  uint8_t r,g,b,a;
  float x,y,z;
} MyOutVertex;
MyInVertex vertices[N_VERTICES];
MyOutVertex results[N_VERTICES];
CoglMatrix matrix;

my_load_vertices (vertices);
my_get_matrix (&amp;matrix);

cogl_matrix_transform_points (&amp;matrix,
                              2,
                              sizeof (MyInVertex),
                              &amp;vertices[0].x,
                              sizeof (MyOutVertex),
                              &amp;results[0].x,
                              N_VERTICES);
]|</doc>
        <source-position filename="cogl-matrix.h" line="694"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="646">A transformation matrix</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </instance-parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="647">The number of position components for each input point.
               (either 2 or 3)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="stride_in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="649">The stride in bytes between input points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_in"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="650">A pointer to the first component of the first input point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="stride_out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="651">The stride in bytes between output points.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="points_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="652">A pointer to the first component of the first output point.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="n_points" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="653">The number of points to transform.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_matrix_translate">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="235">Multiplies @matrix with a transform matrix that translates along
the X, Y and Z axis.</doc>
        <source-position filename="cogl-matrix.h" line="246"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="237">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="238">The X translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="239">The Y translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="240">The Z translation you want to apply</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transpose"
              c:identifier="cogl_matrix_transpose"
              version="1.10">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="771">Replaces @matrix with its transpose. Ie, every element (i,j) in the
new matrix is taken from element (j,i) in the old matrix.</doc>
        <source-position filename="cogl-matrix.h" line="781"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="773">A #CoglMatrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="view_2d_in_frustum"
              c:identifier="cogl_matrix_view_2d_in_frustum"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="429">Multiplies @matrix by a view transform that maps the 2D coordinates
(0,0) top left and (@width_2d,@height_2d) bottom right the full viewport
size. Geometry at a depth of 0 will now lie on this 2D plane.

Note: this doesn't multiply the matrix by any projection matrix,
but it assumes you have a perspective projection as defined by
passing the corresponding arguments to cogl_matrix_frustum().

Toolkits such as Clutter that mix 2D and 3D drawing can use this to
create a 2D coordinate system within a 3D perspective projected
view frustum.</doc>
        <source-position filename="cogl-matrix.h" line="460"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="431">A 4x4 transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="432">coord of left vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="433">coord of right vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="434">coord of bottom horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="435">coord of top horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="436">The distance to the near clip plane. Never pass 0 and always pass
  a positive number.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="438">The distance to the 2D plane. (Should always be positive and
  be between @z_near and the z_far value that was passed to
  cogl_matrix_frustum())</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="441">The width of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="442">The height of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="view_2d_in_perspective"
              c:identifier="cogl_matrix_view_2d_in_perspective"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="470">Multiplies @matrix by a view transform that maps the 2D coordinates
(0,0) top left and (@width_2d,@height_2d) bottom right the full viewport
size. Geometry at a depth of 0 will now lie on this 2D plane.

Note: this doesn't multiply the matrix by any projection matrix,
but it assumes you have a perspective projection as defined by
passing the corresponding arguments to cogl_matrix_perspective().

Toolkits such as Clutter that mix 2D and 3D drawing can use this to
create a 2D coordinate system within a 3D perspective projected
view frustum.</doc>
        <source-position filename="cogl-matrix.h" line="499"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <type name="Matrix" c:type="CoglMatrix*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="472">A field of view angle for the Y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="473">The ratio of width to height determining the field of view angle
  for the x axis.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="475">The distance to the near clip plane. Never pass 0 and always pass
  a positive number.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="477">The distance to the 2D plane. (Should always be positive and
  be between @z_near and the z_far value that was passed to
  cogl_matrix_frustum())</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="480">The width of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height_2d" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="481">The height of the 2D coordinate system</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal" c:identifier="cogl_matrix_equal" version="1.4">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="555">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
        <source-position filename="cogl-matrix.h" line="568"/>
        <return-value transfer-ownership="none">
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="557">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-matrix.h"
                 line="558">A 4x4 transformation matrix</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="MatrixEntry"
            c:type="CoglMatrixEntry"
            opaque="1"
            glib:type-name="CoglMatrixEntry"
            glib:get-type="cogl_matrix_entry_get_gtype"
            c:symbol-prefix="matrix_entry">
      <doc xml:space="preserve"
           filename="cogl-matrix-stack.h"
           line="146">Represents a single immutable transformation that was retrieved
from a #CoglMatrixStack using cogl_matrix_stack_get_entry().

Internally a #CoglMatrixEntry represents a single matrix
operation (such as "rotate", "scale", "translate") which is applied
to the transform of a single parent entry.

Using the #CoglMatrixStack api effectively builds up a graph of
these immutable #CoglMatrixEntry structures whereby operations
that can be shared between multiple transformations will result
in shared #CoglMatrixEntry nodes in the graph.

When a #CoglMatrixStack is first created it references one
#CoglMatrixEntry that represents a single "load identity"
operation. This serves as the root entry and all operations
that are then applied to the stack will extend the graph
starting from this root "load identity" entry.

Given the typical usage model for a #CoglMatrixStack and the way
the entries are built up while traversing a scenegraph then in most
cases where an application is interested in comparing two
transformations for equality then it is enough to simply compare
two #CoglMatrixEntry pointers directly. Technically this can lead
to false negatives that could be identified with a deeper
comparison but often these false negatives are unlikely and
don't matter anyway so this enables extremely cheap comparisons.

&lt;note&gt;#CoglMatrixEntry&lt;!-- --&gt;s are reference counted using
cogl_matrix_entry_ref() and cogl_matrix_entry_unref() not with
cogl_object_ref() and cogl_object_unref().&lt;/note&gt;</doc>
      <source-position filename="cogl-matrix-stack.h" line="180"/>
      <method name="calculate_translation"
              c:identifier="cogl_matrix_entry_calculate_translation">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="548">Determines if the only difference between two transforms is a
translation and if so returns what the @x, @y, and @z components of
the translation are.

If the difference between the two translations involves anything
other than a translation then the function returns %FALSE.</doc>
        <source-position filename="cogl-matrix-stack.h" line="568"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="563">%TRUE if the only difference between the transform of
               @entry0 and the transform of @entry1 is a translation,
               otherwise %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="550">The first reference transform</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
          <parameter name="entry1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="551">A second reference transform</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </parameter>
          <parameter name="x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="552">The destination for the x-component of the translation</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="553">The destination for the y-component of the translation</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="z"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="554">The destination for the z-component of the translation</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="cogl_matrix_entry_equal">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="591">Compares two arbitrary #CoglMatrixEntry transforms for equality
returning %TRUE if they are equal or %FALSE otherwise.

&lt;note&gt;In many cases it is unnecessary to use this api and instead
direct pointer comparisons of entries are good enough and much
cheaper too.&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix-stack.h" line="607"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="603">%TRUE if @entry0 represents the same transform as
              @entry1, otherwise %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="593">The first #CoglMatrixEntry to compare</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
          <parameter name="entry1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="594">A second #CoglMatrixEntry to compare</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="cogl_matrix_entry_get">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="491">Resolves the current @entry transform into a #CoglMatrix by
combining the sequence of operations that have been applied to
build up the current transform.

There are two possible ways that this function may return its
result depending on whether it's possible to directly point
to an internal #CoglMatrix or whether the result needs to be
composed of multiple operations.

If an internal matrix contains the required result then this
function will directly return a pointer to that matrix, otherwise
if the function returns %NULL then @matrix will be initialized
to match the transform of @entry.

&lt;note&gt;@matrix will be left untouched if a direct pointer is
returned.&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix-stack.h" line="519"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="514">A direct pointer to a #CoglMatrix transform or %NULL
              and in that case @matrix will be initialized with
              the effective transform represented by @entry.</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="493">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="494">The potential destination for the transform as
                a matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_identity" c:identifier="cogl_matrix_entry_is_identity">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="574">Determines whether @entry is known to represent an identity
transform.

If this returns %TRUE then the entry is definitely the identity
matrix. If it returns %FALSE it may or may not be the identity
matrix but no expensive comparison is performed to verify it.</doc>
        <source-position filename="cogl-matrix-stack.h" line="589"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="585">%TRUE if @entry is definitely an identity transform,
              otherwise %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="576">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="cogl_matrix_entry_ref">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="620">Takes a reference on the given @entry to ensure the @entry stays
alive and remains valid. When you are finished with the @entry then
you should call cogl_matrix_entry_unref().

It is an error to pass an @entry pointer to cogl_object_ref() and
cogl_object_unref()</doc>
        <source-position filename="cogl-matrix-stack.h" line="632"/>
        <return-value transfer-ownership="full">
          <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="622">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="cogl_matrix_entry_unref">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="634">Releases a reference on @entry either taken by calling
cogl_matrix_entry_unref() or to release the reference given when
calling cogl_matrix_stack_get_entry().</doc>
        <source-position filename="cogl-matrix-stack.h" line="643"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="636">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="MatrixStack"
           c:symbol-prefix="matrix_stack"
           c:type="CoglMatrixStack"
           parent="Object"
           glib:type-name="CoglMatrixStack"
           glib:get-type="cogl_matrix_stack_get_gtype"
           glib:fundamental="1">
      <doc xml:space="preserve"
           filename="cogl-matrix-stack.h"
           line="100">Tracks your current position within a hierarchy and lets you build
up a graph of transformations as you traverse through a hierarchy
such as a scenegraph.

A #CoglMatrixStack always maintains a reference to a single
transformation at any point in time, representing the
transformation at the current position in the hierarchy. You can
get a reference to the current transformation by calling
cogl_matrix_stack_get_entry().

When a #CoglMatrixStack is first created with
cogl_matrix_stack_new() then it is conceptually positioned at the
root of your hierarchy and the current transformation simply
represents an identity transformation.

As you traverse your object hierarchy (your scenegraph) then you
should call cogl_matrix_stack_push() whenever you move down one
level and call cogl_matrix_stack_pop() whenever you move back up
one level towards the root.

At any time you can apply a set of operations, such as "rotate",
"scale", "translate" on top of the current transformation of a
#CoglMatrixStack using functions such as
cogl_matrix_stack_rotate(), cogl_matrix_stack_scale() and
cogl_matrix_stack_translate(). These operations will derive a new
current transformation and will never affect a transformation
that you have referenced using cogl_matrix_stack_get_entry().

Internally applying operations to a #CoglMatrixStack builds up a
graph of #CoglMatrixEntry structures which each represent a single
immutable transform.</doc>
      <constructor name="new" c:identifier="cogl_matrix_stack_new">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="192">Allocates a new #CoglMatrixStack that can be used to build up
transformations relating to objects in a scenegraph like hierarchy.
(See the description of #CoglMatrixStack and #CoglMatrixEntry for
more details of what a matrix stack is best suited for)

When a #CoglMatrixStack is first allocated it is conceptually
positioned at the root of your scenegraph hierarchy. As you
traverse your scenegraph then you should call
cogl_matrix_stack_push() whenever you move down a level and
cogl_matrix_stack_pop() whenever you move back up a level towards
the root.

Once you have allocated a #CoglMatrixStack you can get a reference
to the current transformation for the current position in the
hierarchy by calling cogl_matrix_stack_get_entry().

Once you have allocated a #CoglMatrixStack you can apply operations
such as rotate, scale and translate to modify the current transform
for the current position in the hierarchy by calling
cogl_matrix_stack_rotate(), cogl_matrix_stack_scale() and
cogl_matrix_stack_translate().</doc>
        <source-position filename="cogl-matrix-stack.h" line="221"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="218">A newly allocated #CoglMatrixStack</doc>
          <type name="MatrixStack" c:type="CoglMatrixStack*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="194">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="frustum" c:identifier="cogl_matrix_stack_frustum">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="348">Replaces the current matrix with a perspective matrix for a given
viewing frustum defined by 4 side clip planes that all cross
through the origin and 2 near and far clip planes.</doc>
        <source-position filename="cogl-matrix-stack.h" line="367"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="350">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="351">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="353">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="355">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="357">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="359">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="360">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="cogl_matrix_stack_get">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="461">Resolves the current @stack transform into a #CoglMatrix by
combining the operations that have been applied to build up the
current transform.

There are two possible ways that this function may return its
result depending on whether the stack is able to directly point
to an internal #CoglMatrix or whether the result needs to be
composed of multiple operations.

If an internal matrix contains the required result then this
function will directly return a pointer to that matrix, otherwise
if the function returns %NULL then @matrix will be initialized
to match the current transform of @stack.

&lt;note&gt;@matrix will be left untouched if a direct pointer is
returned.&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix-stack.h" line="488"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="483">A direct pointer to the current transform or %NULL
              and in that case @matrix will be initialized with
              the value of the current transform.</doc>
          <type name="Matrix" c:type="CoglMatrix*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="463">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="464">The potential destination for the current matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_entry" c:identifier="cogl_matrix_stack_get_entry">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="440">Gets a reference to the current transform represented by a
#CoglMatrixEntry pointer.

&lt;note&gt;The transform represented by a #CoglMatrixEntry is
immutable.&lt;/note&gt;

&lt;note&gt;#CoglMatrixEntry&lt;!-- --&gt;s are reference counted using
cogl_matrix_entry_ref() and cogl_matrix_entry_unref() and you
should call cogl_matrix_entry_unref() when you are finished with
and entry you get via cogl_matrix_stack_get_entry().&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix-stack.h" line="459"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="455">A pointer to the #CoglMatrixEntry
              representing the current matrix stack transform.</doc>
          <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="442">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_inverse" c:identifier="cogl_matrix_stack_get_inverse">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="424">Gets the inverse transform of the current matrix and uses it to
initialize a new #CoglMatrix.</doc>
        <source-position filename="cogl-matrix-stack.h" line="437"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="432">%TRUE if the inverse was successfully calculated or %FALSE
  for degenerate transformations that can't be inverted (in this case the
  @inverse matrix will simply be initialized with the identity matrix)</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="426">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="inverse"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="427">The destination for a 4x4 inverse transformation matrix</doc>
            <type name="Matrix" c:type="CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_identity"
              c:identifier="cogl_matrix_stack_load_identity">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="251">Resets the current matrix to the identity matrix.</doc>
        <source-position filename="cogl-matrix-stack.h" line="258"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="253">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="cogl_matrix_stack_multiply">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="337">Multiplies the current matrix by the given matrix.</doc>
        <source-position filename="cogl-matrix-stack.h" line="345"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="339">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="340">the matrix to multiply with the current model-view</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="orthographic"
              c:identifier="cogl_matrix_stack_orthographic">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="399">Replaces the current matrix with an orthographic projection matrix.</doc>
        <source-position filename="cogl-matrix-stack.h" line="416"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="401">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="402">The x coordinate for the first vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="403">The y coordinate for the first horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="404">The x coordinate for the second vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="405">The y coordinate for the second horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="406">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the near clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="409">The &lt;emphasis&gt;distance&lt;/emphasis&gt; to the far clipping
  plane (will be &lt;emphasis&gt;negative&lt;/emphasis&gt; if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="cogl_matrix_stack_perspective">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="375">Replaces the current matrix with a perspective matrix based on the
provided values.

&lt;note&gt;You should be careful not to have too great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there wont be enough precision to identify the depth of
objects near to each other.&lt;/note&gt;</doc>
        <source-position filename="cogl-matrix-stack.h" line="393"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="377">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="378">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="379">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="380">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="382">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="cogl_matrix_stack_pop">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="238">Restores the previous transform that was last saved by calling
cogl_matrix_stack_push().

This is usually called while traversing a scenegraph whenever you
return up one level in the graph towards the root node.</doc>
        <source-position filename="cogl-matrix-stack.h" line="249"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="240">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="cogl_matrix_stack_push">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="223">Saves the current transform and starts a new transform that derives
from the current transform.

This is usually called while traversing a scenegraph whenever you
traverse one level deeper. cogl_matrix_stack_pop() can then be
called when going back up one layer to restore the previous
transform of an ancestor.</doc>
        <source-position filename="cogl-matrix-stack.h" line="236"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="225">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_matrix_stack_rotate">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="292">Multiplies the current matrix by one that rotates the around the
axis-vector specified by @x, @y and @z. The rotation follows the
right-hand thumb rule so for example rotating by 10 degrees about
the axis-vector (0, 0, 1) causes a small counter-clockwise
rotation.</doc>
        <source-position filename="cogl-matrix-stack.h" line="307"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="294">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="295">Angle in degrees to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="296">X-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="297">Y-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="298">Z-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler"
              c:identifier="cogl_matrix_stack_rotate_euler">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="325">Multiplies the current matrix by one that rotates according to the
rotation described by @euler.</doc>
        <source-position filename="cogl-matrix-stack.h" line="334"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="327">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="328">A #CoglEuler</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_quaternion"
              c:identifier="cogl_matrix_stack_rotate_quaternion">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="313">Multiplies the current matrix by one that rotates according to the
rotation described by @quaternion.</doc>
        <source-position filename="cogl-matrix-stack.h" line="322"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="315">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="316">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_matrix_stack_scale">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="260">Multiplies the current matrix by one that scales the x, y and z
axes by the given values.</doc>
        <source-position filename="cogl-matrix-stack.h" line="271"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="262">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="263">Amount to scale along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="264">Amount to scale along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="265">Amount to scale along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="cogl_matrix_stack_set">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="522">Replaces the current @stack matrix value with the value of @matrix.
This effectively discards any other operations that were applied
since the last time cogl_matrix_stack_push() was called or since
the stack was initialized.</doc>
        <source-position filename="cogl-matrix-stack.h" line="533"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="524">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="525">A #CoglMatrix replace the current matrix value with</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_matrix_stack_translate">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="276">Multiplies the current matrix by one that translates along all
three axes according to the given values.</doc>
        <source-position filename="cogl-matrix-stack.h" line="287"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="278">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="279">Distance to translate along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="280">Distance to translate along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-matrix-stack.h"
                 line="281">Distance to translate along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <callback name="MetaTextureCallback"
              c:type="CoglMetaTextureCallback"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-meta-texture.h"
           line="105">A callback used with cogl_meta_texture_foreach_in_region() to
retrieve details of all the low-level #CoglTexture&lt;!-- --&gt;s that
make up a given #CoglMetaTexture.</doc>
      <source-position filename="cogl-meta-texture.h" line="132"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="sub_texture" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="107">A low-level #CoglTexture making up part of a
              #CoglMetaTexture.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
        <parameter name="sub_texture_coords" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="109">A float 4-tuple ordered like
                     (tx1,ty1,tx2,ty2) defining what region of the
                     current @sub_texture maps to a sub-region of a
                     #CoglMetaTexture. (tx1,ty1) is the top-left
                     sub-region coordinate and (tx2,ty2) is the
                     bottom-right. These are low-level texture
                     coordinates.</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="meta_coords" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="116">A float 4-tuple ordered like (tx1,ty1,tx2,ty2)
              defining what sub-region of a #CoglMetaTexture this
              low-level @sub_texture maps too. (tx1,ty1) is
              the top-left sub-region coordinate and (tx2,ty2) is
              the bottom-right. These are high-level meta-texture
              coordinates.</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="122">A private pointer passed to
            cogl_meta_texture_foreach_in_region().</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="OBJECT"
                    c:identifier="COGL_OBJECT"
                    introspectable="0">
      <source-position filename="cogl-object.h" line="44"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ONSCREEN"
                    c:identifier="COGL_ONSCREEN"
                    introspectable="0">
      <source-position filename="cogl-onscreen.h" line="53"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ONSCREEN_TEMPLATE"
                    c:identifier="COGL_ONSCREEN_TEMPLATE"
                    introspectable="0">
      <source-position filename="cogl-onscreen-template.h" line="50"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="OUTPUT"
                    c:identifier="COGL_OUTPUT"
                    introspectable="0">
      <source-position filename="cogl-output.h" line="71"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Object"
           c:symbol-prefix="object"
           c:type="CoglObject"
           abstract="1"
           glib:type-name="CoglObject"
           glib:get-type="cogl_object_get_gtype"
           glib:fundamental="1"
           glib:ref-func="cogl_object_ref"
           glib:unref-func="cogl_object_unref"
           glib:set-value-func="cogl_object_value_set_object"
           glib:get-value-func="cogl_object_value_get_object">
      <function name="ref" c:identifier="cogl_object_ref" introspectable="0">
        <doc xml:space="preserve"
             filename="cogl-object.h"
             line="64">Increases the reference count of @object by 1</doc>
        <source-position filename="cogl-object.h" line="73"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cogl-object.h"
               line="70">the @object, with its reference count increased</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="66">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="unref"
                c:identifier="cogl_object_unref"
                introspectable="0">
        <doc xml:space="preserve"
             filename="cogl-object.h"
             line="75">Drecreases the reference count of @object by 1; if the reference
count reaches 0, the resources allocated by @object will be freed</doc>
        <source-position filename="cogl-object.h" line="83"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="77">a #CoglObject</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="value_get_object"
                c:identifier="cogl_object_value_get_object">
        <source-position filename="cogl-gtype-private.h" line="274"/>
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </function>
      <function name="value_set_object"
                c:identifier="cogl_object_value_set_object">
        <source-position filename="cogl-gtype-private.h" line="272"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_user_data"
              c:identifier="cogl_object_get_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl-object.h"
             line="193">Finds the user data previously associated with @object using
the given @key. If no user data has been associated with @object
for the given @key this function returns NULL.</doc>
        <source-position filename="cogl-object.h" line="210"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cogl-object.h"
               line="203">The user data previously associated
  with @object using the given @key; or %NULL if no associated
  data is found.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="195">The object with associated private data to query</doc>
            <type name="Object" c:type="CoglObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="196">The address of a #CoglUserDataKey which provides a unique value
      with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_data"
              c:identifier="cogl_object_set_user_data"
              version="1.4"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl-object.h"
             line="170">Associates some private @user_data with a given #CoglObject. To
later remove the association call cogl_object_set_user_data() with
the same @key but NULL for the @user_data.</doc>
        <source-position filename="cogl-object.h" line="188"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="172">The object to associate private data with</doc>
            <type name="Object" c:type="CoglObject*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="173">The address of a #CoglUserDataKey which provides a unique value
  with which to index the private data.</doc>
            <type name="UserDataKey" c:type="CoglUserDataKey*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="175">The data to associate with the given object,
  or %NULL to remove a previous association.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-object.h"
                 line="177">A #CoglUserDataDestroyCallback to call if the object is
  destroyed or if the association is removed by later setting
  %NULL data for the same key.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="Onscreen"
           c:symbol-prefix="onscreen"
           c:type="CoglOnscreen"
           parent="Object"
           glib:type-name="CoglOnscreen"
           glib:get-type="cogl_onscreen_get_gtype"
           glib:fundamental="1">
      <implements name="Framebuffer"/>
      <constructor name="new"
                   c:identifier="cogl_onscreen_new"
                   version="1.8"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="64">Instantiates an "unallocated" #CoglOnscreen framebuffer that may be
configured before later being allocated, either implicitly when
it is first used or explicitly via cogl_framebuffer_allocate().</doc>
        <source-position filename="cogl-onscreen.h" line="79"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="74">A newly instantiated #CoglOnscreen framebuffer</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="66">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="67">The desired framebuffer width</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="68">The desired framebuffer height</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_dirty_callback"
              c:identifier="cogl_onscreen_add_dirty_callback"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="984">Installs a @callback function that will be called whenever the
window system has lost the contents of a region of the onscreen
buffer and the application should redraw it to repair the buffer.
For example this may happen in a window system without a compositor
if a window that was previously covering up the onscreen window has
been moved causing a region of the onscreen to be exposed.

The @callback will be passed a #CoglOnscreenDirtyInfo struct which
decribes a rectangle containing the newly dirtied region. Note that
this may be called multiple times to describe a non-rectangular
region composed of multiple smaller rectangles.

The dirty events are separate from %COGL_FRAME_EVENT_SYNC events so
the application should also listen for this event before rendering
the dirty region to ensure that the framebuffer is actually ready
for rendering.</doc>
        <source-position filename="cogl-onscreen.h" line="1015"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="1009">a #CoglOnscreenDirtyClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="OnscreenDirtyClosure"
                c:type="CoglOnscreenDirtyClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="986">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="987">A callback function to call for dirty events</doc>
            <type name="OnscreenDirtyCallback"
                  c:type="CoglOnscreenDirtyCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="988">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="989">An optional callback to destroy @user_data when the
          @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_frame_callback"
              c:identifier="cogl_onscreen_add_frame_callback"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="641">Installs a @callback function that will be called for significant
events relating to the given @onscreen framebuffer.

The @callback will be used to notify when the system compositor is
ready for this application to render a new frame. In this case
%COGL_FRAME_EVENT_SYNC will be passed as the event argument to the
given @callback in addition to the #CoglFrameInfo corresponding to
the frame beeing acknowledged by the compositor.

The @callback will also be called to notify when the frame has
ended. In this case %COGL_FRAME_EVENT_COMPLETE will be passed as
the event argument to the given @callback in addition to the
#CoglFrameInfo corresponding to the newly presented frame.  The
meaning of "ended" here simply means that no more timing
information will be collected within the corresponding
#CoglFrameInfo and so this is a good opportunity to analyse the
given info. It does not necessarily mean that the GPU has finished
rendering the corresponding frame.

We highly recommend throttling your application according to
%COGL_FRAME_EVENT_SYNC events so that your application can avoid
wasting resources, drawing more frames than your system compositor
can display.</doc>
        <source-position filename="cogl-onscreen.h" line="679"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="673">a #CoglFrameClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="FrameClosure" c:type="CoglFrameClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="643">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="644">A callback function to call for frame events</doc>
            <type name="FrameCallback" c:type="CoglFrameCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="645">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="646">An optional callback to destroy @user_data
          when the @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_resize_callback"
              c:identifier="cogl_onscreen_add_resize_callback"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="868">Registers a @callback with @onscreen that will be called whenever
the @onscreen framebuffer changes size.

The @callback can be removed using
cogl_onscreen_remove_resize_callback() passing the returned closure
pointer.

&lt;note&gt;Since Cogl automatically updates the viewport of an @onscreen
framebuffer that is resized, a resize callback can also be used to
track when the viewport has been changed automatically by Cogl in
case your application needs more specialized control over the
viewport.&lt;/note&gt;

&lt;note&gt;A resize callback will only ever be called while dispatching
Cogl events from the system mainloop; so for example during
cogl_poll_renderer_dispatch(). This is so that callbacks shouldn't
occur while an application might have arbitrary locks held for
example.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="901"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="896">a #CoglOnscreenResizeClosure pointer that can be used to
              remove the callback and associated @user_data later.</doc>
          <type name="OnscreenResizeClosure"
                c:type="CoglOnscreenResizeClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="870">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="871">A #CoglOnscreenResizeCallback to call when
           the @onscreen changes size.</doc>
            <type name="OnscreenResizeCallback"
                  c:type="CoglOnscreenResizeCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="873">Private data to be passed to @callback.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="874">An optional callback to destroy @user_data
          when the @callback is removed or @onscreen is freed.</doc>
            <type name="UserDataDestroyCallback"
                  c:type="CoglUserDataDestroyCallback"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_swap_buffers_callback"
              c:identifier="cogl_onscreen_add_swap_buffers_callback"
              version="1.10"
              deprecated="1"
              deprecated-version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="707">Installs a @callback function that should be called whenever a swap buffers
request (made using cogl_onscreen_swap_buffers()) for the given
@onscreen completes.

&lt;note&gt;Applications should check for the %COGL_FEATURE_ID_SWAP_BUFFERS_EVENT
feature before using this API. It's currently undefined when and if
registered callbacks will be called if this feature is not supported.&lt;/note&gt;

We recommend using this mechanism when available to manually throttle your
applications (in conjunction with  cogl_onscreen_set_swap_throttled()) so
your application will be able to avoid long blocks in the driver caused by
throttling when you request to swap buffers too quickly.</doc>
        <doc-deprecated xml:space="preserve">Use cogl_onscreen_add_frame_callback() instead</doc-deprecated>
        <source-position filename="cogl-onscreen.h" line="735"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="727">a unique identifier that can be used to remove to remove
              the callback later.</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="709">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="710">A callback function to call when a swap
           has completed</doc>
            <type name="SwapBuffersNotify" c:type="CoglSwapBuffersNotify"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="712">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_age"
              c:identifier="cogl_onscreen_get_buffer_age"
              version="1.14"
              stability="Stable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="427">Gets the current age of the buffer contents.

This function allows applications to query the age of the current
back buffer contents for a #CoglOnscreen as the number of frames
elapsed since the contents were most recently defined.

These age values exposes enough information to applications about
how Cogl internally manages back buffers to allow applications to
re-use the contents of old frames and minimize how much must be
redrawn for the next frame.

The back buffer contents can either be reported as invalid (has an
age of 0) or it may be reported to be the same contents as from n
frames prior to the current frame.

The queried value remains valid until the next buffer swap.

&lt;note&gt;One caveat is that under X11 the buffer age does not reflect
changes to buffer contents caused by the window systems. X11
applications must track Expose events to determine what buffer
regions need to additionally be repaired each frame.&lt;/note&gt;

The recommended way to take advantage of this buffer age api is to
build up a circular buffer of length 3 for tracking damage regions
over the last 3 frames and when starting a new frame look at the
age of the buffer and combine the damage regions for the current
frame with the damage regions of previous @age frames so you know
everything that must be redrawn to update the old contents for the
new frame.

&lt;note&gt;If the system doesn't not support being able to track the age
of back buffers then this function will always return 0 which
implies that the contents are undefined.&lt;/note&gt;

&lt;note&gt;The %COGL_FEATURE_ID_BUFFER_AGE feature can optionally be
explicitly checked to determine if Cogl is currently tracking the
age of #CoglOnscreen back buffer contents. If this feature is
missing then this function will always return 0.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="477"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="470">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="429">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_counter"
              c:identifier="cogl_onscreen_get_frame_counter"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="1054">Gets the value of the framebuffers frame counter. This is
a counter that increases by one each time
cogl_onscreen_swap_buffers() or cogl_onscreen_swap_region()
is called.</doc>
        <source-position filename="cogl-onscreen.h" line="1067"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="1062">the current frame counter value</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_resizable"
              c:identifier="cogl_onscreen_get_resizable"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="790">Lets you query whether @onscreen has been marked as resizable via
the cogl_onscreen_set_resizable() api.

By default, if possible, a @onscreen will be created by Cogl
as non resizable, but it is not guaranteed that this is always
possible for all window systems.

&lt;note&gt;If cogl_onscreen_set_resizable(@onscreen, %TRUE) has been
previously called then this function will return %TRUE, but it's
possible that the current windowing system being used does not
support window resizing (consider fullscreen windows on a phone or
a TV). This function is not aware of whether resizing is truly
meaningful with your window system, only whether the @onscreen has
been marked as resizable.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="814"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="809">Returns whether @onscreen has been marked as
              resizable or not.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="792">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hide"
              c:identifier="cogl_onscreen_hide"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="377">This requests to make @onscreen invisible to the user.

Actually the precise semantics of this function depend on the
window system currently in use, and if you don't have a
multi-windowining system this function may in-fact do nothing.

This function does not implicitly allocate the given @onscreen
framebuffer before hiding it.

&lt;note&gt;Since Cogl doesn't explicitly track the visibility status of
onscreen framebuffers it wont try to avoid redundant window system
requests e.g. to show an already visible window. This also means
that it's acceptable to alternatively use native APIs to show and
hide windows without confusing Cogl.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="400"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="379">The onscreen framebuffer to make invisible</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_dirty_callback"
              c:identifier="cogl_onscreen_remove_dirty_callback"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="1020">Removes a callback and associated user data that were previously
registered using cogl_onscreen_add_dirty_callback().

If a destroy callback was passed to
cogl_onscreen_add_dirty_callback() to destroy the user data then
this will also get called.</doc>
        <source-position filename="cogl-onscreen.h" line="1037"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="1022">A #CoglOnscreen</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="1023">A #CoglOnscreenDirtyClosure returned from
          cogl_onscreen_add_dirty_callback()</doc>
            <type name="OnscreenDirtyClosure"
                  c:type="CoglOnscreenDirtyClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_frame_callback"
              c:identifier="cogl_onscreen_remove_frame_callback"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="684">Removes a callback and associated user data that were previously
registered using cogl_onscreen_add_frame_callback().

If a destroy callback was passed to
cogl_onscreen_add_frame_callback() to destroy the user data then
this will get called.</doc>
        <source-position filename="cogl-onscreen.h" line="701"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="686">A #CoglOnscreen</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="687">A #CoglFrameClosure returned from
          cogl_onscreen_add_frame_callback()</doc>
            <type name="FrameClosure" c:type="CoglFrameClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_resize_callback"
              c:identifier="cogl_onscreen_remove_resize_callback"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="906">Removes a resize @callback and @user_data pair that were previously
associated with @onscreen via cogl_onscreen_add_resize_callback().</doc>
        <source-position filename="cogl-onscreen.h" line="917"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="908">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="909">An identifier returned from cogl_onscreen_add_resize_callback()</doc>
            <type name="OnscreenResizeClosure"
                  c:type="CoglOnscreenResizeClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_swap_buffers_callback"
              c:identifier="cogl_onscreen_remove_swap_buffers_callback"
              version="1.10"
              deprecated="1"
              deprecated-version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="739">Removes a callback that was previously registered
using cogl_onscreen_add_swap_buffers_callback().</doc>
        <doc-deprecated xml:space="preserve">Use cogl_onscreen_remove_frame_callback() instead</doc-deprecated>
        <source-position filename="cogl-onscreen.h" line="754"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="741">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="742">An identifier returned from cogl_onscreen_add_swap_buffers_callback()</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_resizable"
              c:identifier="cogl_onscreen_set_resizable"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="757">Lets you request Cogl to mark an @onscreen framebuffer as
resizable or not.

By default, if possible, a @onscreen will be created by Cogl
as non resizable, but it is not guaranteed that this is always
possible for all window systems.

&lt;note&gt;Cogl does not know whether marking the @onscreen framebuffer
is truly meaningful for your current window system (consider
applications being run fullscreen on a phone or TV) so this
function may not have any useful effect. If you are running on a
multi windowing system such as X11 or Win32 or OSX then Cogl will
request to the window system that users be allowed to resize the
@onscreen, although it's still possible that some other window
management policy will block this possibility.&lt;/note&gt;

&lt;note&gt;Whenever an @onscreen framebuffer is resized the viewport
will be automatically updated to match the new size of the
framebuffer with an origin of (0,0). If your application needs more
specialized control of the viewport it will need to register a
resize handler using cogl_onscreen_add_resize_callback() so that it
can track when the viewport has been changed automatically.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="787"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="759">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="resizable" transfer-ownership="none">
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_swap_throttled"
              c:identifier="cogl_onscreen_set_swap_throttled"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="329">Requests that the given @onscreen framebuffer should have swap buffer
requests (made using cogl_onscreen_swap_buffers()) throttled either by a
displays vblank period or perhaps some other mechanism in a composited
environment.</doc>
        <source-position filename="cogl-onscreen.h" line="343"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="331">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="throttled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="332">Whether swap throttling is wanted or not.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="show"
              c:identifier="cogl_onscreen_show"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="346">This requests to make @onscreen visible to the user.

Actually the precise semantics of this function depend on the
window system currently in use, and if you don't have a
multi-windowining system this function may in-fact do nothing.

This function will implicitly allocate the given @onscreen
framebuffer before showing it if it hasn't already been allocated.

When using the Wayland winsys calling this will set the surface to
a toplevel type which will make it appear. If the application wants
to set a different type for the surface, it can avoid calling
cogl_onscreen_show() and set its own type directly with the Wayland
client API via cogl_wayland_onscreen_get_surface().

&lt;note&gt;Since Cogl doesn't explicitly track the visibility status of
onscreen framebuffers it wont try to avoid redundant window system
requests e.g. to show an already visible window. This also means
that it's acceptable to alternatively use native APIs to show and
hide windows without confusing Cogl.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="375"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="348">The onscreen framebuffer to make visible</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="swap_buffers"
              c:identifier="cogl_onscreen_swap_buffers"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="402">Swaps the current back buffer being rendered too, to the front for display.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.

&lt;note&gt;It is highly recommended that applications use
cogl_onscreen_swap_buffers_with_damage() instead whenever possible
and also use the cogl_onscreen_get_buffer_age() api so they can
perform incremental updates to older buffers instead of having to
render a full buffer for every frame.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="424"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="404">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="swap_buffers_with_damage"
              c:identifier="cogl_onscreen_swap_buffers_with_damage"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="479">Swaps the current back buffer being rendered too, to the front for
display and provides information to any system compositor about
what regions of the buffer have changed (damage) with respect to
the last swapped buffer.

This function has the same semantics as
cogl_framebuffer_swap_buffers() except that it additionally allows
applications to pass a list of damaged rectangles which may be
passed on to a compositor so that it can minimize how much of the
screen is redrawn in response to this applications newly swapped
front buffer.

For example if your application is only animating a small object in
the corner of the screen and everything else is remaining static
then it can help the compositor to know that only the bottom right
corner of your newly swapped buffer has really changed with respect
to your previously swapped front buffer.

If @n_rectangles is 0 then the whole buffer will implicitly be
reported as damaged as if cogl_onscreen_swap_buffers() had been
called.

This function also implicitly discards the contents of the color,
depth and stencil buffers as if cogl_framebuffer_discard_buffers()
were used. The significance of the discard is that you should not
expect to be able to start a new frame that incrementally builds on
the contents of the previous frame. If you want to perform
incremental updates to older back buffers then please refer to the
cogl_onscreen_get_buffer_age() api.

Whenever possible it is recommended that applications use this
function instead of cogl_onscreen_swap_buffers() to improve
performance when running under a compositor.

&lt;note&gt;It is highly recommended to use this API in conjunction with
the cogl_onscreen_get_buffer_age() api so that your application can
perform incremental rendering based on old back buffers.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen.h" line="528"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="481">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="482">An array of integer 4-tuples representing damaged
             rectangles as (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="484">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_region"
              c:identifier="cogl_onscreen_swap_region"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="532">Swaps a region of the back buffer being rendered too, to the front for
display.  @rectangles represents the region as array of @n_rectangles each
defined by 4 sequential (x, y, width, height) integers.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.</doc>
        <source-position filename="cogl-onscreen.h" line="553"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="534">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="535">An array of integer 4-tuples representing rectangles as
             (x, y, width, height) tuples.</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen.h"
                 line="537">The number of 4-tuples to be read from @rectangles</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <callback name="OnscreenDirtyCallback"
              c:type="CoglOnscreenDirtyCallback"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="942">Is a callback that can be registered via
cogl_onscreen_add_dirty_callback() to be called when the windowing
system determines that a region of the onscreen window has been
lost and the application should redraw it.</doc>
      <source-position filename="cogl-onscreen.h" line="958"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="944">The onscreen that the frame is associated with</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="945">A #CoglOnscreenDirtyInfo struct containing the details of the
  dirty area</doc>
          <type name="OnscreenDirtyInfo"
                c:type="const CoglOnscreenDirtyInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="947">The user pointer passed to
            cogl_onscreen_add_frame_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OnscreenDirtyClosure"
            c:type="CoglOnscreenDirtyClosure"
            version="1.16"
            stability="Unstable"
            glib:type-name="CoglOnscreenDirtyClosure"
            glib:get-type="cogl_onscreen_dirty_closure_get_gtype"
            c:symbol-prefix="onscreen_dirty_closure">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="962">An opaque type that tracks a #CoglOnscreenDirtyCallback and associated
user data. A #CoglOnscreenDirtyClosure pointer will be returned from
cogl_onscreen_add_dirty_callback() and it allows you to remove a
callback later using cogl_onscreen_remove_dirty_callback().</doc>
      <source-position filename="cogl-onscreen.h" line="973"/>
    </record>
    <record name="OnscreenDirtyInfo"
            c:type="CoglOnscreenDirtyInfo"
            version="1.16"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="920">A structure passed to callbacks registered using
cogl_onscreen_add_dirty_callback(). The members describe a
rectangle within the onscreen buffer that should be redrawn.</doc>
      <source-position filename="cogl-onscreen.h" line="940"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="922">Left edge of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="923">Top edge of the dirty rectangle, measured from the top of the window</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="width" writable="1">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="924">Width of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="height" writable="1">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="925">Height of the dirty rectangle</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <callback name="OnscreenResizeCallback"
              c:type="CoglOnscreenResizeCallback"
              version="2.0">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="816">Is a callback type used with the
cogl_onscreen_add_resize_callback() allowing applications to be
notified whenever an @onscreen framebuffer is resized.

&lt;note&gt;Cogl automatically updates the viewport of an @onscreen
framebuffer that is resized so this callback is also an indication
that the viewport has been modified too&lt;/note&gt;

&lt;note&gt;A resize callback will only ever be called while dispatching
Cogl events from the system mainloop; so for example during
cogl_poll_renderer_dispatch(). This is so that callbacks shouldn't
occur while an application might have arbitrary locks held for
example.&lt;/note&gt;</doc>
      <source-position filename="cogl-onscreen.h" line="840"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="818">A #CoglOnscreen framebuffer that was resized</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="819">The new width of @onscreen</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="820">The new height of @onscreen</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="821">The private passed to
            cogl_onscreen_add_resize_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="OnscreenResizeClosure"
            c:type="CoglOnscreenResizeClosure"
            version="2.0"
            stability="Unstable"
            glib:type-name="CoglOnscreenResizeClosure"
            glib:get-type="cogl_onscreen_resize_closure_get_gtype"
            c:symbol-prefix="onscreen_resize_closure">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="845">An opaque type that tracks a #CoglOnscreenResizeCallback and
associated user data. A #CoglOnscreenResizeClosure pointer will be
returned from cogl_onscreen_add_resize_callback() and it allows you
to remove a callback later using
cogl_onscreen_remove_resize_callback().</doc>
      <source-position filename="cogl-onscreen.h" line="857"/>
    </record>
    <class name="OnscreenTemplate"
           c:symbol-prefix="onscreen_template"
           c:type="CoglOnscreenTemplate"
           parent="Object"
           glib:type-name="CoglOnscreenTemplate"
           glib:get-type="cogl_onscreen_template_get_gtype"
           glib:fundamental="1">
      <constructor name="new" c:identifier="cogl_onscreen_template_new">
        <source-position filename="cogl-onscreen-template.h" line="62"/>
        <return-value transfer-ownership="full">
          <type name="OnscreenTemplate" c:type="CoglOnscreenTemplate*"/>
        </return-value>
        <parameters>
          <parameter name="swap_chain" transfer-ownership="none">
            <type name="SwapChain" c:type="CoglSwapChain*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="set_samples_per_pixel"
              c:identifier="cogl_onscreen_template_set_samples_per_pixel"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen-template.h"
             line="64">Requires that any future CoglOnscreen framebuffers derived from
this template must support making at least @n samples per pixel
which will all contribute to the final resolved color for that
pixel.

By default this value is usually set to 0 and that is referred to
as "single-sample" rendering. A value of 1 or greater is referred
to as "multisample" rendering.

&lt;note&gt;There are some semantic differences between single-sample
rendering and multisampling with just 1 point sample such as it
being redundant to use the cogl_framebuffer_resolve_samples() and
cogl_framebuffer_resolve_samples_region() apis with single-sample
rendering.&lt;/note&gt;</doc>
        <source-position filename="cogl-onscreen-template.h" line="88"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen_template"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen-template.h"
                 line="66">A #CoglOnscreenTemplate template framebuffer</doc>
            <type name="OnscreenTemplate" c:type="CoglOnscreenTemplate*"/>
          </instance-parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen-template.h"
                 line="67">The minimum number of samples per pixel</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_stereo_enabled"
              c:identifier="cogl_onscreen_template_set_stereo_enabled"
              version="1.20"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen-template.h"
             line="109">Sets whether future #CoglOnscreen framebuffers derived from this
template are attempted to be created with both left and right
buffers, for use with stereo display. If the display system
does not support stereo, then creation of the framebuffer will
fail.</doc>
        <source-position filename="cogl-onscreen-template.h" line="124"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen_template"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen-template.h"
                 line="111">A #CoglOnscreenTemplate template framebuffer</doc>
            <type name="OnscreenTemplate" c:type="CoglOnscreenTemplate*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen-template.h"
                 line="112">Whether framebuffers are created with stereo buffers</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_swap_throttled"
              c:identifier="cogl_onscreen_template_set_swap_throttled"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-onscreen-template.h"
             line="92">Requests that any future #CoglOnscreen framebuffers derived from this
template should enable or disable swap throttling according to the given
@throttled argument.</doc>
        <source-position filename="cogl-onscreen-template.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen_template"
                              transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen-template.h"
                 line="94">A #CoglOnscreenTemplate template framebuffer</doc>
            <type name="OnscreenTemplate" c:type="CoglOnscreenTemplate*"/>
          </instance-parameter>
          <parameter name="throttled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-onscreen-template.h"
                 line="95">Whether throttling should be enabled</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <callback name="OnscreenX11MaskCallback"
              c:type="CoglOnscreenX11MaskCallback">
      <source-position filename="cogl-onscreen.h" line="82"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="event_mask" transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Output"
           c:symbol-prefix="output"
           c:type="CoglOutput"
           parent="Object"
           glib:type-name="CoglOutput"
           glib:get-type="cogl_output_get_gtype"
           glib:fundamental="1">
      <method name="get_height"
              c:identifier="cogl_output_get_height"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="179">Gets the height of the output in pixels.</doc>
        <source-position filename="cogl-output.h" line="190"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="185">the height of the output in pixels</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="181">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mm_height"
              c:identifier="cogl_output_get_mm_height"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="209">Gets the physical height of the output. In some cases (such as
as a projector), the value returned here might correspond to
nominal resolution rather than the actual physical size of the
output device.</doc>
        <source-position filename="cogl-output.h" line="224"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="218">the height of the output in millimeters. A value
 of 0 indicates that the height is unknown</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="211">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mm_width"
              c:identifier="cogl_output_get_mm_width"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="192">Gets the physical width of the output. In some cases (such as
as a projector), the value returned here might correspond to
nominal resolution rather than the actual physical size of the
output device.</doc>
        <source-position filename="cogl-output.h" line="207"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="201">the height of the output in millimeters. A value
 of 0 indicates the width is unknown</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="194">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refresh_rate"
              c:identifier="cogl_output_get_refresh_rate"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="241">Gets the number of times per second that the output device refreshes
the display contents.</doc>
        <source-position filename="cogl-output.h" line="254"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="248">the refresh rate of the output device. A value of zero
 indicates that the refresh rate is unknown.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="243">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_subpixel_order"
              c:identifier="cogl_output_get_subpixel_order"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="226">For an output device where each pixel is made up of smaller components
with different colors, returns the layout of the subpixel
components.</doc>
        <source-position filename="cogl-output.h" line="239"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="234">the order of subpixel components for the output device</doc>
          <type name="SubpixelOrder" c:type="CoglSubpixelOrder"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="228">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="cogl_output_get_width"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="166">Gets the width of the output in pixels.</doc>
        <source-position filename="cogl-output.h" line="177"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="172">the width of the output in pixels</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="168">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_x"
              c:identifier="cogl_output_get_x"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="136">Gets the X position of the output with respect to the coordinate
system of the screen.</doc>
        <source-position filename="cogl-output.h" line="149"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="143">the X position of the output as a pixel offset
 from the left side of the screen coordinate space</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="138">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_y"
              c:identifier="cogl_output_get_y"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="151">Gets the Y position of the output with respect to the coordinate
system of the screen.</doc>
        <source-position filename="cogl-output.h" line="164"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="158">the Y position of the output as a pixel offset
 from the top side of the screen coordinate space</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="output" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-output.h"
                 line="153">a #CoglOutput</doc>
            <type name="Output" c:type="CoglOutput*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <callback name="OutputCallback"
              c:type="CoglOutputCallback"
              version="1.14"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-renderer.h"
           line="411">A callback type that can be passed to
cogl_renderer_foreach_output() for iterating display outputs for a
given renderer.</doc>
      <source-position filename="cogl-renderer.h" line="424"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="output" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="413">The current display output being iterated</doc>
          <type name="Output" c:type="CoglOutput*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="414">The user pointer passed to
            cogl_renderer_foreach_output()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function-macro name="PIPELINE"
                    c:identifier="COGL_PIPELINE"
                    introspectable="0">
      <source-position filename="cogl-pipeline.h" line="69"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PIXEL_BUFFER"
                    c:identifier="COGL_PIXEL_BUFFER"
                    introspectable="0">
      <source-position filename="cogl-pixel-buffer.h" line="55"/>
      <parameters>
        <parameter name="buffer">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="PREMULT_BIT" value="128" c:type="COGL_PREMULT_BIT">
      <source-position filename="cogl-types.h" line="231"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PRIMITIVE_TEXTURE"
                    c:identifier="COGL_PRIMITIVE_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl-primitive-texture.h" line="73"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PRIVATE"
                    c:identifier="COGL_PRIVATE"
                    introspectable="0">
      <source-position filename="cogl-types.h" line="121"/>
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Pipeline"
           c:symbol-prefix="pipeline"
           c:type="CoglPipeline"
           parent="Object"
           glib:type-name="CoglPipeline"
           glib:get-type="cogl_pipeline_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_pipeline_new"
                   version="2.0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline.h"
             line="80">Allocates and initializes a default simple pipeline that will color
a primitive white.</doc>
        <source-position filename="cogl-pipeline.h" line="93"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-pipeline.h"
               line="87">a pointer to a new #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline.h"
                 line="82">a #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_layer_snippet"
              c:identifier="cogl_pipeline_add_layer_snippet"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="596">Adds a shader snippet that will hook on to the given layer of the
pipeline. The exact part of the pipeline that the snippet wraps
around depends on the hook that is given to
cogl_snippet_new(). Note that some hooks can't be used with a layer
and need to be added with cogl_pipeline_add_snippet() instead.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="612"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="598">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="599">The layer to hook the snippet to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="600">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_snippet"
              c:identifier="cogl_pipeline_add_snippet"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="959">Adds a shader snippet to @pipeline. The snippet will wrap around or
replace some part of the pipeline as defined by the hook point in
@snippet. Note that some hook points are specific to a layer and
must be added with cogl_pipeline_add_layer_snippet() instead.</doc>
        <source-position filename="cogl-pipeline-state.h" line="973"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="961">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="962">The #CoglSnippet to add to the vertex processing hook</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="cogl_pipeline_copy"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline.h"
             line="95">Creates a new pipeline with the configuration copied from the
source pipeline.

We would strongly advise developers to always aim to use
cogl_pipeline_copy() instead of cogl_pipeline_new() whenever there will
be any similarity between two pipelines. Copying a pipeline helps Cogl
keep track of a pipelines ancestry which we may use to help minimize GPU
state changes.</doc>
        <source-position filename="cogl-pipeline.h" line="114"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-pipeline.h"
               line="108">a pointer to the newly allocated #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline.h"
                 line="97">a #CoglPipeline object to copy</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_layer"
              c:identifier="cogl_pipeline_foreach_layer"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline.h"
             line="147">Iterates all the layer indices of the given @pipeline.</doc>
        <source-position filename="cogl-pipeline.h" line="161"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline.h"
                 line="149">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-pipeline.h"
                 line="150">A #CoglPipelineLayerCallback to be
           called for each layer index</doc>
            <type name="PipelineLayerCallback"
                  c:type="CoglPipelineLayerCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-pipeline.h"
                 line="152">Private data that will be passed to the
            callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_function"
              c:identifier="cogl_pipeline_get_alpha_test_function"
              version="2.0"
              stability="Unstable">
        <source-position filename="cogl-pipeline-state.h" line="375"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="369">The alpha test function of @pipeline.</doc>
          <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="367">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_reference"
              c:identifier="cogl_pipeline_get_alpha_test_reference"
              version="2.0"
              stability="Unstable">
        <source-position filename="cogl-pipeline-state.h" line="387"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="381">The alpha test reference value of @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="379">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ambient"
              c:identifier="cogl_pipeline_get_ambient"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="146">Retrieves the current ambient color for @pipeline</doc>
        <source-position filename="cogl-pipeline-state.h" line="157"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="148">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="149">The location to store the ambient color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color"
              c:identifier="cogl_pipeline_get_color"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="111">Retrieves the current pipeline color.</doc>
        <source-position filename="cogl-pipeline-state.h" line="122"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="113">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="114">The location to store the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_color_mask"
              c:identifier="cogl_pipeline_get_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="575">Gets the current #CoglColorMask of which channels would be written to the
current framebuffer. Each bit set in the mask means that the
corresponding color would be written.</doc>
        <source-position filename="cogl-pipeline-state.h" line="588"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="583">A #CoglColorMask</doc>
          <type name="ColorMask" c:type="CoglColorMask"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="577">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_cull_face_mode"
              c:identifier="cogl_pipeline_get_cull_face_mode"
              version="2.0">
        <source-position filename="cogl-pipeline-state.h" line="767"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="760">the cull face mode that was previously set with
cogl_pipeline_set_cull_face_mode().

Status: Unstable</doc>
          <type name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_state"
              c:identifier="cogl_pipeline_get_depth_state"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="698">Retrieves the current depth state configuration for the given
@pipeline as previously set using cogl_pipeline_set_depth_state().</doc>
        <source-position filename="cogl-pipeline-state.h" line="710"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="700">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state_out"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="701">A destination #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_diffuse"
              c:identifier="cogl_pipeline_get_diffuse"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="178">Retrieves the current diffuse color for @pipeline</doc>
        <source-position filename="cogl-pipeline-state.h" line="189"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="180">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="181">The location to store the diffuse color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_emission"
              c:identifier="cogl_pipeline_get_emission"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="294">Retrieves the pipelines current emission color.</doc>
        <source-position filename="cogl-pipeline-state.h" line="305"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="296">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="297">The location to store the emission color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_front_face_winding"
              c:identifier="cogl_pipeline_get_front_face_winding"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="789">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.</doc>
        <source-position filename="cogl-pipeline-state.h" line="807"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="801">The @pipeline front face winding

Status: Unstable</doc>
          <type name="Winding" c:type="CoglWinding"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="791">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_layer_mag_filter"
              c:identifier="cogl_pipeline_get_layer_mag_filter"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="405">Retrieves the currently set magnification #CoglPipelineFilter set on
the specified layer. The magnification filter determines how the
layer should be sampled when up-scaled.

The default filter is %COGL_PIPELINE_FILTER_LINEAR but this can be
changed using cogl_pipeline_set_layer_filters().</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="423"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="417">The magnification #CoglPipelineFilter for the
              specified layer.</doc>
          <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="407">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="408">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_min_filter"
              c:identifier="cogl_pipeline_get_layer_min_filter"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="384">Retrieves the currently set minification #CoglPipelineFilter set on
the specified layer. The miniifcation filter determines how the
layer should be sampled when down-scaled.

The default filter is %COGL_PIPELINE_FILTER_LINEAR but this can be
changed using cogl_pipeline_set_layer_filters().</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="402"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="396">The minification #CoglPipelineFilter for the
              specified layer.</doc>
          <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="386">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="387">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_get_layer_point_sprite_coords_enabled"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="454">Gets whether point sprite coordinate generation is enabled for this
texture layer.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="469"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="462">whether the texture coordinates will be replaced with
point sprite coordinates.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="456">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="457">the layer number to check.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_texture"
              c:identifier="cogl_pipeline_get_layer_texture"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-pipeline-layer-state.h" line="195"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="189">the texture that was set for the
  given layer of the pipeline or %NULL if no texture was set.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="186">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="187">the index of the layer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_p"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_p"
              version="1.6"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="541">Returns the wrap mode for the 'p' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="556"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="549">the wrap mode for the 'p' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="543">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="544">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_s"
              version="1.6"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="472">Returns the wrap mode for the 's' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="487"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="480">the wrap mode for the 's' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="474">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="475">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_t"
              version="1.6"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="506">Returns the wrap mode for the 't' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="521"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="514">the wrap mode for the 't' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="508">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="509">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_layers"
              c:identifier="cogl_pipeline_get_n_layers"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="346">Retrieves the number of layers defined for the given @pipeline</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="358"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="352">the number of layers</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="348">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_per_vertex_point_size"
              c:identifier="cogl_pipeline_get_per_vertex_point_size"
              version="2.0"
              stability="Unstable">
        <source-position filename="cogl-pipeline-state.h" line="573"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="568">%TRUE if the pipeline has per-vertex point size
  enabled or %FALSE otherwise. The per-vertex point size can be
  enabled with cogl_pipeline_set_per_vertex_point_size().</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="564">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point_size"
              c:identifier="cogl_pipeline_get_point_size"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="516">Get the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API.</doc>
        <source-position filename="cogl-pipeline-state.h" line="529"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="523">the point size of the @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="518">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_shininess"
              c:identifier="cogl_pipeline_get_shininess"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="262">Retrieves the pipelines current emission color.</doc>
        <source-position filename="cogl-pipeline-state.h" line="274"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="268">The pipelines current shininess value</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="264">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_specular"
              c:identifier="cogl_pipeline_get_specular"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="229">Retrieves the pipelines current specular color.</doc>
        <source-position filename="cogl-pipeline-state.h" line="240"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="231">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="232">The location to store the specular color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uniform_location"
              c:identifier="cogl_pipeline_get_uniform_location"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline.h"
             line="165">This is used to get an integer representing the uniform with the
name @uniform_name. The integer can be passed to functions such as
cogl_pipeline_set_uniform_1f() to set the value of a uniform.

This function will always return a valid integer. Ie, unlike
OpenGL, it does not return -1 if the uniform is not available in
this pipeline so it can not be used to test whether uniforms are
present. It is not necessary to set the program on the pipeline
before calling this function.</doc>
        <source-position filename="cogl-pipeline.h" line="186"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline.h"
               line="180">A integer representing the location of the given uniform.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline.h"
                 line="167">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline.h"
                 line="168">The name of a uniform</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_program"
              c:identifier="cogl_pipeline_get_user_program"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="607">Queries what user program has been associated with the given
@pipeline using cogl_pipeline_set_user_program().</doc>
        <source-position filename="cogl-pipeline-state.h" line="620"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="614">The current user program or %COGL_INVALID_HANDLE.</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="609">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_layer"
              c:identifier="cogl_pipeline_remove_layer"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="198">This function removes a layer from your pipeline</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="208"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="200">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="201">Specifies the layer you want to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_test_function"
              c:identifier="cogl_pipeline_set_alpha_test_function"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="342">Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.

The default is %COGL_PIPELINE_ALPHA_FUNC_ALWAYS</doc>
        <source-position filename="cogl-pipeline-state.h" line="361"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="344">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="alpha_func" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="345">A @CoglPipelineAlphaFunc constant</doc>
            <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
          </parameter>
          <parameter name="alpha_reference" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="346">A reference point that the chosen alpha function uses
  to compare incoming fragments to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient"
              c:identifier="cogl_pipeline_set_ambient"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="125">Sets the pipeline's ambient color, in the standard OpenGL lighting
model. The ambient color affects the overall color of the object.

Since the diffuse color will be intense when the light hits the surface
directly, the ambient will be most apparent where the light hits at a
slant.

The default value is (0.2, 0.2, 0.2, 1.0)</doc>
        <source-position filename="cogl-pipeline-state.h" line="143"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="127">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="ambient" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="128">The components of the desired ambient color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ambient_and_diffuse"
              c:identifier="cogl_pipeline_set_ambient_and_diffuse"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="192">Conveniently sets the diffuse and ambient color of @pipeline at the same
time. See cogl_pipeline_set_ambient() and cogl_pipeline_set_diffuse().

The default ambient color is (0.2, 0.2, 0.2, 1.0)

The default diffuse color is (0.8, 0.8, 0.8, 1.0)</doc>
        <source-position filename="cogl-pipeline-state.h" line="208"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="194">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="195">The components of the desired ambient and diffuse colors</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend"
              c:identifier="cogl_pipeline_set_blend"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="389">If not already familiar; please refer &lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt;
for an overview of what blend strings are, and their syntax.

Blending occurs after the alpha test function, and combines fragments with
the framebuffer.

Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:

|[
  &amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
]|

This is the list of source-names usable as blend factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;&lt;para&gt;SRC_COLOR: The color of the in comming fragment&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;DST_COLOR: The color of the framebuffer&lt;/para&gt;&lt;/listitem&gt;
  &lt;listitem&gt;&lt;para&gt;CONSTANT: The constant set via cogl_pipeline_set_blend_constant()&lt;/para&gt;&lt;/listitem&gt;
&lt;/itemizedlist&gt;

The source names can be used according to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source and factor syntax&lt;/link&gt;,
so for example "(1-SRC_COLOR[A])" would be a valid factor, as would
"(CONSTANT[RGB])"

These can also be used as factors:
&lt;itemizedlist&gt;
  &lt;listitem&gt;0: (0, 0, 0, 0)&lt;/listitem&gt;
  &lt;listitem&gt;1: (1, 1, 1, 1)&lt;/listitem&gt;
  &lt;listitem&gt;SRC_ALPHA_SATURATE_FACTOR: (f,f,f,1) where f = MIN(SRC_COLOR[A],1-DST_COLOR[A])&lt;/listitem&gt;
&lt;/itemizedlist&gt;

&lt;note&gt;Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.&lt;/note&gt;

&lt;example id="cogl-Blend-Strings-blend-unpremul"&gt;
  &lt;title&gt;Blend Strings/1&lt;/title&gt;
  &lt;para&gt;Blend a non-premultiplied source over a destination with
  premultiplied alpha:&lt;/para&gt;
  &lt;programlisting&gt;
"RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
"A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

&lt;example id="cogl-Blend-Strings-blend-premul"&gt;
  &lt;title&gt;Blend Strings/2&lt;/title&gt;
  &lt;para&gt;Blend a premultiplied source over a destination with
  premultiplied alpha&lt;/para&gt;
  &lt;programlisting&gt;
"RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  &lt;/programlisting&gt;
&lt;/example&gt;

The default blend string is:
|[
   RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
]|

That gives normal alpha-blending when the calculated color for the pipeline
is in premultiplied form.</doc>
        <source-position filename="cogl-pipeline-state.h" line="472"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="463">%TRUE if the blend string was successfully parsed, and the
  described blending is supported by the underlying driver/hardware. If
  there was an error, %FALSE is returned and @error is set accordingly (if
  present).</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="391">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="392">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
  describing the desired blend function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend_constant"
              c:identifier="cogl_pipeline_set_blend_constant"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="476">When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function.</doc>
        <source-position filename="cogl-pipeline-state.h" line="488"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="478">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="constant_color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="479">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color"
              c:identifier="cogl_pipeline_set_color"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="46">Sets the basic color of the pipeline, used when no lighting is enabled.

Note that if you don't add any layers to the pipeline then the color
will be blended unmodified with the destination; the default blend
expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
semi-transparent red. See cogl_color_premultiply().

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <source-position filename="cogl-pipeline-state.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="48">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="49">The components of the color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4f"
              c:identifier="cogl_pipeline_set_color4f"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="89">Sets the basic color of the pipeline, used when no lighting is enabled.

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <source-position filename="cogl-pipeline-state.h" line="105"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="91">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="92">The red component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="93">The green component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="94">The blue component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="95">The alpha component</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color4ub"
              c:identifier="cogl_pipeline_set_color4ub"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="67">Sets the basic color of the pipeline, used when no lighting is enabled.

The default value is (0xff, 0xff, 0xff, 0xff)</doc>
        <source-position filename="cogl-pipeline-state.h" line="83"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="69">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="70">The red component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="71">The green component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="72">The blue component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="73">The alpha component</doc>
            <type name="guint8" c:type="uint8_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color_mask"
              c:identifier="cogl_pipeline_set_color_mask"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="590">Defines a bit mask of which color channels should be written to the
current framebuffer. If a bit is set in @color_mask that means that
color will be written.</doc>
        <source-position filename="cogl-pipeline-state.h" line="604"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="592">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color_mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="593">A #CoglColorMask of which color channels to write to
             the current framebuffer.</doc>
            <type name="ColorMask" c:type="CoglColorMask"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cull_face_mode"
              c:identifier="cogl_pipeline_set_cull_face_mode"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="732">Sets which faces will be culled when drawing. Face culling can be
used to increase efficiency by avoiding drawing faces that would
get overridden. For example, if a model has gaps so that it is
impossible to see the inside then faces which are facing away from
the screen will never be seen so there is no point in drawing
them. This can be acheived by setting the cull face mode to
%COGL_PIPELINE_CULL_FACE_MODE_BACK.

Face culling relies on the primitives being drawn with a specific
order to represent which faces are facing inside and outside the
model. This order can be specified by calling
cogl_pipeline_set_front_face_winding().

Status: Unstable</doc>
        <source-position filename="cogl-pipeline-state.h" line="754"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="734">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="cull_face_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="735">The new mode to set</doc>
            <type name="PipelineCullFaceMode"
                  c:type="CoglPipelineCullFaceMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_state"
              c:identifier="cogl_pipeline_set_depth_state"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="673">This commits all the depth state configured in @state struct to the
given @pipeline. The configuration values are copied into the
pipeline so there is no requirement to keep the #CoglDepthState
struct around if you don't need it any more.

Note: Since some platforms do not support the depth range feature
it is possible for this function to fail and report an @error.</doc>
        <source-position filename="cogl-pipeline-state.h" line="694"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="687">TRUE if the GPU supports all the given @state else %FALSE
         and returns an @error.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="675">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="676">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="const CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_diffuse"
              c:identifier="cogl_pipeline_set_diffuse"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="160">Sets the pipeline's diffuse color, in the standard OpenGL lighting
model. The diffuse color is most intense where the light hits the
surface directly - perpendicular to the surface.

The default value is (0.8, 0.8, 0.8, 1.0)</doc>
        <source-position filename="cogl-pipeline-state.h" line="175"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="162">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="diffuse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="163">The components of the desired diffuse color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_emission"
              c:identifier="cogl_pipeline_set_emission"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="276">Sets the pipeline's emissive color, in the standard OpenGL lighting
model. It will look like the surface is a light source emitting this
color.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <source-position filename="cogl-pipeline-state.h" line="291"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="278">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="emission" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="279">The components of the desired emissive color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_front_face_winding"
              c:identifier="cogl_pipeline_set_front_face_winding"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="769">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.

Status: Unstable</doc>
        <source-position filename="cogl-pipeline-state.h" line="786"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="771">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="front_winding" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="772">the winding order</doc>
            <type name="Winding" c:type="CoglWinding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine"
              c:identifier="cogl_pipeline_set_layer_combine"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="211">If not already familiar; you can refer
&lt;link linkend="cogl-Blend-Strings"&gt;here&lt;/link&gt; for an overview of what blend
strings are and there syntax.

These are all the functions available for texture combining:
&lt;itemizedlist&gt;
  &lt;listitem&gt;REPLACE(arg0) = arg0&lt;/listitem&gt;
  &lt;listitem&gt;MODULATE(arg0, arg1) = arg0 x arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD(arg0, arg1) = arg0 + arg1&lt;/listitem&gt;
  &lt;listitem&gt;ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5&lt;/listitem&gt;
  &lt;listitem&gt;INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)&lt;/listitem&gt;
  &lt;listitem&gt;SUBTRACT(arg0, arg1) = arg0 - arg1&lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                             (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                             (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
  &lt;listitem&gt;
    &lt;programlisting&gt;
 DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                              (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                              (arg0[B] - 0.5)) * (arg1[B] - 0.5))
    &lt;/programlisting&gt;
  &lt;/listitem&gt;
&lt;/itemizedlist&gt;

Refer to the
&lt;link linkend="cogl-Blend-String-syntax"&gt;color-source syntax&lt;/link&gt; for
describing the arguments. The valid source names for texture combining
are:
&lt;variablelist&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE&lt;/term&gt;
    &lt;listitem&gt;Use the color from the current texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;TEXTURE_0, TEXTURE_1, etc&lt;/term&gt;
    &lt;listitem&gt;Use the color from the specified texture layer&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;CONSTANT&lt;/term&gt;
    &lt;listitem&gt;Use the color from the constant given with
    cogl_pipeline_set_layer_combine_constant()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PRIMARY&lt;/term&gt;
    &lt;listitem&gt;Use the color of the pipeline as set with
    cogl_pipeline_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
  &lt;varlistentry&gt;
    &lt;term&gt;PREVIOUS&lt;/term&gt;
    &lt;listitem&gt;Either use the texture color from the previous layer, or
    if this is layer 0, use the color of the pipeline as set with
    cogl_pipeline_set_color()&lt;/listitem&gt;
  &lt;/varlistentry&gt;
&lt;/variablelist&gt;

&lt;refsect2 id="cogl-Layer-Combine-Examples"&gt;
  &lt;title&gt;Layer Combine Examples&lt;/title&gt;
  &lt;para&gt;This is effectively what the default blending is:&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = MODULATE (PREVIOUS, TEXTURE)
  &lt;/programlisting&gt;&lt;/informalexample&gt;
  &lt;para&gt;This could be used to cross-fade between two images, using
  the alpha component of a constant as the interpolator. The constant
  color is given by calling
  cogl_pipeline_set_layer_combine_constant().&lt;/para&gt;
  &lt;informalexample&gt;&lt;programlisting&gt;
  RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
  &lt;/programlisting&gt;&lt;/informalexample&gt;
&lt;/refsect2&gt;

&lt;note&gt;You can't give a multiplication factor for arguments as you can
with blending.&lt;/note&gt;</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="306"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="298">%TRUE if the blend string was successfully parsed, and the
  described texture combining is supported by the underlying driver and
  or hardware. On failure, %FALSE is returned and @error is set</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="213">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="214">Specifies the layer you want define a combine function for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="215">A &lt;link linkend="cogl-Blend-Strings"&gt;Cogl blend string&lt;/link&gt;
   describing the desired texture combine function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine_constant"
              c:identifier="cogl_pipeline_set_layer_combine_constant"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="311">When you are using the 'CONSTANT' color source in a layer combine
description then you can use this function to define its value.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="325"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="313">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="314">Specifies the layer you want to specify a constant used
              for texture combining</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="316">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_filters"
              c:identifier="cogl_pipeline_set_layer_filters"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="360">Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.

&lt;note&gt;It is an error to pass anything other than
%COGL_PIPELINE_FILTER_NEAREST or %COGL_PIPELINE_FILTER_LINEAR as
magnification filters since magnification doesn't ever need to
reference values stored in the mipmap chain.&lt;/note&gt;</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="379"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="362">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="363">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="364">the filter used when scaling a texture down.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="365">the filter used when magnifying a texture.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_matrix"
              c:identifier="cogl_pipeline_set_layer_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="329">This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a pipeline used to fill your geometry.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="342"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="331">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="332">the index for the layer inside @pipeline</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="333">the transformation matrix for the layer</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_null_texture"
              c:identifier="cogl_pipeline_set_layer_null_texture"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="158">Sets the texture for this layer to be the default texture for the
given type. This is equivalent to calling
cogl_pipeline_set_layer_texture() with %NULL for the texture
argument except that you can also specify the type of default
texture to use. The default texture is a 1x1 pixel white texture.

This function is mostly useful if you want to create a base
pipeline that you want to create multiple copies from using
cogl_pipeline_copy(). In that case this function can be used to
specify the texture type so that any pipeline copies can share the
internal texture type state for efficiency.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="180"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="160">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="161">The layer number to modify</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="162">The type of the default texture to use</doc>
            <type name="TextureType" c:type="CoglTextureType"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_set_layer_point_sprite_coords_enabled"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="426">When rendering points, if @enable is %TRUE then the texture
coordinates for this layer will be replaced with coordinates that
vary from 0.0 to 1.0 across the primitive. The top left of the
point will have the coordinates 0.0,0.0 and the bottom right will
have 1.0,1.0. If @enable is %FALSE then the coordinates will be
fixed for the entire point.

This function will only work if %COGL_FEATURE_ID_POINT_SPRITE is
available. If the feature is not available then the function will
return %FALSE and set @error.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="449"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-layer-state.h"
               line="444">%TRUE if the function succeeds, %FALSE otherwise.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="428">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="429">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="430">whether to enable point sprite coord generation.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_texture"
              c:identifier="cogl_pipeline_set_layer_texture">
        <source-position filename="cogl-pipeline-layer-state.h" line="154"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode"
              c:identifier="cogl_pipeline_set_layer_wrap_mode"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="576">Sets the wrap mode for all three coordinates of texture lookups on
this layer. This is equivalent to calling
cogl_pipeline_set_layer_wrap_mode_s(),
cogl_pipeline_set_layer_wrap_mode_t() and
cogl_pipeline_set_layer_wrap_mode_p() separately.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="592"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="578">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="579">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="580">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_p"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_p"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="559">Sets the wrap mode for the 'p' coordinate of texture lookups on
this layer. 'p' is the third coordinate.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="572"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="561">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="562">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="563">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_s"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="490">Sets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="502"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="492">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="493">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="494">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_t"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="525">Sets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <source-position filename="cogl-pipeline-layer-state.h" line="537"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="527">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="528">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-layer-state.h"
                 line="529">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_per_vertex_point_size"
              c:identifier="cogl_pipeline_set_per_vertex_point_size"
              version="2.0"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="531">Sets whether to use a per-vertex point size or to use the value set
by cogl_pipeline_set_point_size(). If per-vertex point size is
enabled then the point size can be set for an individual point
either by drawing with a #CoglAttribute with the name
‘cogl_point_size_in’ or by writing to the GLSL builtin
‘cogl_point_size_out’ from a vertex shader snippet.

If per-vertex point size is enabled and this attribute is not used
and cogl_point_size_out is not written to then the results are
undefined.

Note that enabling this will only work if the
%COGL_FEATURE_ID_PER_VERTEX_POINT_SIZE feature is available. If
this is not available then the function will return %FALSE and set
a #CoglError.</doc>
        <source-position filename="cogl-pipeline-state.h" line="558"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline-state.h"
               line="555">%TRUE if the change suceeded or %FALSE otherwise</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="533">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="534">whether to enable per-vertex point size</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_point_size"
              c:identifier="cogl_pipeline_set_point_size"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="491">Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the attribute buffer API. Note that typically the GPU
will only support a limited minimum and maximum range of point
sizes. If the chosen point size is outside that range then the
nearest value within that range will be used instead. The size of a
point is in screen space so it will be the same regardless of any
transformations.

If the point size is set to 0.0 then drawing points with the
pipeline will have undefined results. This is the default value so
if an application wants to draw points it must make sure to use a
pipeline that has an explicit point size set on it.</doc>
        <source-position filename="cogl-pipeline-state.h" line="513"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="493">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="point_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="494">the new point size.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_shininess"
              c:identifier="cogl_pipeline_set_shininess"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="243">Sets the shininess of the pipeline, in the standard OpenGL lighting
model, which determines the size of the specular highlights. A
higher @shininess will produce smaller highlights which makes the
object appear more shiny.

The default value is 0.0</doc>
        <source-position filename="cogl-pipeline-state.h" line="259"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="245">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="shininess" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="246">The desired shininess; must be &gt;= 0.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_specular"
              c:identifier="cogl_pipeline_set_specular"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="211">Sets the pipeline's specular color, in the standard OpenGL lighting
model. The intensity of the specular color depends on the viewport
position, and is brightest along the lines of reflection.

The default value is (0.0, 0.0, 0.0, 1.0)</doc>
        <source-position filename="cogl-pipeline-state.h" line="226"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="213">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="specular" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="214">The components of the desired specular color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1f"
              c:identifier="cogl_pipeline_set_uniform_1f"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="809">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
float. It can also be used to set a single member of a float array
uniform.</doc>
        <source-position filename="cogl-pipeline-state.h" line="830"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="811">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="812">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="813">The new value for the uniform</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1i"
              c:identifier="cogl_pipeline_set_uniform_1i"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="834">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
int. It can also be used to set a single member of a int array
uniform or a sampler uniform.</doc>
        <source-position filename="cogl-pipeline-state.h" line="855"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="836">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="837">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="838">The new value for the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_float"
              c:identifier="cogl_pipeline_set_uniform_float"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="859">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any floating point type uniform,
including float arrays and float vectors. For example, to set a
single vec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 float values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="cogl-pipeline-state.h" line="884"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="861">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="862">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="863">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="864">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="865">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_int"
              c:identifier="cogl_pipeline_set_uniform_int"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="890">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any integer type uniform,
including int arrays and int vectors. For example, to set a single
ivec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 int values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="cogl-pipeline-state.h" line="915"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="892">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="893">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="894">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="895">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="896">Pointer to the new values to set</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix"
              c:identifier="cogl_pipeline_set_uniform_matrix"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="921">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any matrix type uniform, including
matrix arrays. For example, to set a single mat4 uniform you would
use 4 for @dimensions and 1 for @count. To set an array of 8
mat3 values, you could use 3 for @dimensions and 8 for @count.

If @transpose is %FALSE then the matrix is expected to be in
column-major order or if it is %TRUE then the matrix is in
row-major order. You can pass a #CoglMatrix by calling by passing
the result of cogl_matrix_get_array() in @value and setting
@transpose to %FALSE.</doc>
        <source-position filename="cogl-pipeline-state.h" line="952"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="923">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="924">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dimensions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="925">The size of the matrix</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="926">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="927">Whether to transpose the matrix</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="928">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_program"
              c:identifier="cogl_pipeline_set_user_program"
              version="2.0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="622">Associates a linked CoglProgram with the given pipeline so that the
program can take full control of vertex and/or fragment processing.

This is an example of how it can be used to associate an ARBfp
program with a #CoglPipeline:
|[
CoglHandle shader;
CoglHandle program;
CoglPipeline *pipeline;

shader = cogl_create_shader (COGL_SHADER_TYPE_FRAGMENT);
cogl_shader_source (shader,
                    "!!ARBfp1.0\n"
                    "MOV result.color,fragment.color;\n"
                    "END\n");
cogl_shader_compile (shader);

program = cogl_create_program ();
cogl_program_attach_shader (program, shader);
cogl_program_link (program);

pipeline = cogl_pipeline_new ();
cogl_pipeline_set_user_program (pipeline, program);

cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
cogl_rectangle (0, 0, 100, 100);
]|

It is possibly worth keeping in mind that this API is not part of
the long term design for how we want to expose shaders to Cogl
developers (We are planning on deprecating the cogl_program and
cogl_shader APIs in favour of a "snippet" framework) but in the
meantime we hope this will handle most practical GLSL and ARBfp
requirements.

Also remember you need to check for either the
%COGL_FEATURE_SHADERS_GLSL or %COGL_FEATURE_SHADERS_ARBFP before
using the cogl_program or cogl_shader API.</doc>
        <source-position filename="cogl-pipeline-state.h" line="670"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="624">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pipeline-state.h"
                 line="625">A #CoglHandle to a linked CoglProgram</doc>
            <type name="Handle" c:type="CoglHandle"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc">
      <doc xml:space="preserve"
           filename="cogl-pipeline-state.h"
           line="308">Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglPipelineAlphaFunc
determines how the comparison is done.</doc>
      <source-position filename="cogl-pipeline-state.h" line="339"/>
      <member name="never"
              value="512"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NEVER">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="310">Never let the fragment through.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LESS">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="311">Let the fragment through if the incoming
  alpha value is less than the reference alpha value</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_EQUAL">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="313">Let the fragment through if the incoming
  alpha value equals the reference alpha value</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LEQUAL">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="315">Let the fragment through if the incoming
  alpha value is less than or equal to the reference alpha value</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GREATER">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="317">Let the fragment through if the incoming
  alpha value is greater than the reference alpha value</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NOTEQUAL">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="319">Let the fragment through if the incoming
  alpha value does not equal the reference alpha value</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GEQUAL">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="321">Let the fragment through if the incoming
  alpha value is greater than or equal to the reference alpha value.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_ALWAYS">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="323">Always let the fragment through.</doc>
      </member>
    </enumeration>
    <enumeration name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode">
      <doc xml:space="preserve"
           filename="cogl-pipeline-state.h"
           line="713">Specifies which faces should be culled. This can be set on a
pipeline using cogl_pipeline_set_cull_face_mode().</doc>
      <source-position filename="cogl-pipeline-state.h" line="730"/>
      <member name="none"
              value="0"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_NONE">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="715">Neither face will be
 culled. This is the default.</doc>
      </member>
      <member name="front"
              value="1"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_FRONT">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="717">Front faces will be culled.</doc>
      </member>
      <member name="back"
              value="2"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BACK">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="718">Back faces will be culled.</doc>
      </member>
      <member name="both"
              value="3"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BOTH">
        <doc xml:space="preserve"
             filename="cogl-pipeline-state.h"
             line="719">All faces will be culled.</doc>
      </member>
    </enumeration>
    <enumeration name="PipelineFilter" c:type="CoglPipelineFilter">
      <doc xml:space="preserve"
           filename="cogl-pipeline-layer-state.h"
           line="47">Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel.</doc>
      <source-position filename="cogl-pipeline-layer-state.h" line="81"/>
      <member name="nearest"
              value="9728"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="49">Measuring in manhatten distance from the,
  current pixel center, use the nearest texture texel</doc>
      </member>
      <member name="linear"
              value="9729"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="51">Use the weighted average of the 4 texels
  nearest the current pixel center</doc>
      </member>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="53">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_NEAREST criterion</doc>
      </member>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="56">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_LINEAR criterion</doc>
      </member>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="59">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_NEAREST criterion on each one and take
  their weighted average</doc>
      </member>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="63">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_LINEAR criterion on each one and take
  their weighted average</doc>
      </member>
    </enumeration>
    <callback name="PipelineLayerCallback"
              c:type="CoglPipelineLayerCallback"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-pipeline.h"
           line="131">The callback prototype used with cogl_pipeline_foreach_layer() for
iterating all the layers of a @pipeline.</doc>
      <source-position filename="cogl-pipeline.h" line="143"/>
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="pipeline" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline.h"
               line="133">The #CoglPipeline whos layers are being iterated</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-pipeline.h"
               line="134">The current layer index</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl-pipeline.h"
               line="135">The private data passed to cogl_pipeline_foreach_layer()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="PipelineWrapMode"
                 version="2.0"
                 c:type="CoglPipelineWrapMode">
      <doc xml:space="preserve"
           filename="cogl-pipeline-layer-state.h"
           line="84">The wrap mode specifies what happens when texture coordinates
outside the range 0→1 are used. Note that if the filter mode is
anything but %COGL_PIPELINE_FILTER_NEAREST then texels outside the
range 0→1 might be used even when the coordinate is exactly 0 or 1
because OpenGL will try to sample neighbouring pixels. For example
if you are trying to render the full texture then you may get
artifacts around the edges when the pixels from the other side are
merged in if the wrap mode is set to repeat.</doc>
      <source-position filename="cogl-pipeline-layer-state.h" line="123"/>
      <member name="repeat"
              value="10497"
              c:identifier="COGL_PIPELINE_WRAP_MODE_REPEAT">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="86">The texture will be repeated. This
  is useful for example to draw a tiled background.</doc>
      </member>
      <member name="mirrored_repeat"
              value="33648"
              c:identifier="COGL_PIPELINE_WRAP_MODE_MIRRORED_REPEAT">
      </member>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="88">The coordinates outside the
  range 0→1 will sample copies of the edge pixels of the
  texture. This is useful to avoid artifacts if only one copy of
  the texture is being rendered.</doc>
      </member>
      <member name="automatic"
              value="519"
              c:identifier="COGL_PIPELINE_WRAP_MODE_AUTOMATIC">
        <doc xml:space="preserve"
             filename="cogl-pipeline-layer-state.h"
             line="92">Cogl will try to automatically
  decide which of the above two to use. For cogl_rectangle(), it
  will use repeat mode if any of the texture coordinates are
  outside the range 0→1, otherwise it will use clamp to edge. For
  cogl_polygon() it will always use repeat mode. For
  cogl_vertex_buffer_draw() it will use repeat mode except for
  layers that have point sprite coordinate generation enabled. This
  is the default value.</doc>
      </member>
    </enumeration>
    <class name="PixelBuffer"
           c:symbol-prefix="pixel_buffer"
           c:type="CoglPixelBuffer"
           parent="Object"
           glib:type-name="CoglPixelBuffer"
           glib:get-type="cogl_pixel_buffer_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_pixel_buffer_new"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-pixel-buffer.h"
             line="66">Declares a new #CoglPixelBuffer of @size bytes to contain arrays of
pixels. Once declared, data can be set using cogl_buffer_set_data()
or by mapping it into the application's address space using
cogl_buffer_map().

If @data isn't %NULL then @size bytes will be read from @data and
immediately copied into the new buffer.</doc>
        <source-position filename="cogl-pixel-buffer.h" line="86"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-pixel-buffer.h"
               line="80">a newly allocated #CoglPixelBuffer</doc>
          <type name="PixelBuffer" c:type="CoglPixelBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pixel-buffer.h"
                 line="68">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-pixel-buffer.h"
                 line="69">The number of bytes to allocate for the pixel data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-pixel-buffer.h"
                 line="70">An optional pointer to vertex data to upload immediately</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <enumeration name="PixelFormat"
                 version="0.8"
                 glib:type-name="CoglPixelFormat"
                 glib:get-type="cogl_pixel_format_get_type"
                 c:type="CoglPixelFormat">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="304">Pixel formats used by Cogl. For the formats with a byte per
component, the order of the components specify the order in
increasing memory addresses. So for example
%COGL_PIXEL_FORMAT_RGB_888 would have the red component in the
lowest address, green in the next address and blue after that
regardless of the endianness of the system.

For the formats with non byte aligned components the component
order specifies the order within a 16-bit or 32-bit number from
most significant bit to least significant. So for
%COGL_PIXEL_FORMAT_RGB_565, the red component would be in bits
11-15, the green component would be in 6-11 and the blue component
would be in 1-5. Therefore the order in memory depends on the
endianness of the system.

When uploading a texture %COGL_PIXEL_FORMAT_ANY can be used as the
internal format. Cogl will try to pick the best format to use
internally and convert the texture data if necessary.</doc>
      <member name="any"
              value="0"
              c:identifier="COGL_PIXEL_FORMAT_ANY"
              glib:nick="any"
              glib:name="COGL_PIXEL_FORMAT_ANY">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="306">Any format</doc>
      </member>
      <member name="a_8"
              value="17"
              c:identifier="COGL_PIXEL_FORMAT_A_8"
              glib:nick="a-8"
              glib:name="COGL_PIXEL_FORMAT_A_8">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="307">8 bits alpha mask</doc>
      </member>
      <member name="rgb_565"
              value="4"
              c:identifier="COGL_PIXEL_FORMAT_RGB_565"
              glib:nick="rgb-565"
              glib:name="COGL_PIXEL_FORMAT_RGB_565">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="311">RGB, 16 bits</doc>
      </member>
      <member name="rgba_4444"
              value="21"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444"
              glib:nick="rgba-4444"
              glib:name="COGL_PIXEL_FORMAT_RGBA_4444">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="312">RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551"
              value="22"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551"
              glib:nick="rgba-5551"
              glib:name="COGL_PIXEL_FORMAT_RGBA_5551">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="313">RGBA, 16 bits</doc>
      </member>
      <member name="yuv"
              value="7"
              c:identifier="COGL_PIXEL_FORMAT_YUV"
              glib:nick="yuv"
              glib:name="COGL_PIXEL_FORMAT_YUV">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="314">Not currently supported</doc>
      </member>
      <member name="g_8"
              value="8"
              c:identifier="COGL_PIXEL_FORMAT_G_8"
              glib:nick="g-8"
              glib:name="COGL_PIXEL_FORMAT_G_8">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="315">Single luminance component</doc>
      </member>
      <member name="rg_88"
              value="9"
              c:identifier="COGL_PIXEL_FORMAT_RG_88"
              glib:nick="rg-88"
              glib:name="COGL_PIXEL_FORMAT_RG_88">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="308">RG, 16 bits. Note that red-green textures
  are only available if %COGL_FEATURE_ID_TEXTURE_RG is advertised.
  See cogl_texture_set_components() for details.</doc>
      </member>
      <member name="rgb_888"
              value="2"
              c:identifier="COGL_PIXEL_FORMAT_RGB_888"
              glib:nick="rgb-888"
              glib:name="COGL_PIXEL_FORMAT_RGB_888">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="316">RGB, 24 bits</doc>
      </member>
      <member name="bgr_888"
              value="34"
              c:identifier="COGL_PIXEL_FORMAT_BGR_888"
              glib:nick="bgr-888"
              glib:name="COGL_PIXEL_FORMAT_BGR_888">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="317">BGR, 24 bits</doc>
      </member>
      <member name="rgba_8888"
              value="19"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888"
              glib:nick="rgba-8888"
              glib:name="COGL_PIXEL_FORMAT_RGBA_8888">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="318">RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888"
              value="51"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888"
              glib:nick="bgra-8888"
              glib:name="COGL_PIXEL_FORMAT_BGRA_8888">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="319">BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888"
              value="83"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888"
              glib:nick="argb-8888"
              glib:name="COGL_PIXEL_FORMAT_ARGB_8888">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="320">ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888"
              value="115"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888"
              glib:nick="abgr-8888"
              glib:name="COGL_PIXEL_FORMAT_ABGR_8888">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="321">ABGR, 32 bits</doc>
      </member>
      <member name="rgba_1010102"
              value="29"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102"
              glib:nick="rgba-1010102"
              glib:name="COGL_PIXEL_FORMAT_RGBA_1010102">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="322">RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102"
              value="61"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102"
              glib:nick="bgra-1010102"
              glib:name="COGL_PIXEL_FORMAT_BGRA_1010102">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="323">BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010"
              value="93"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010"
              glib:nick="argb-2101010"
              glib:name="COGL_PIXEL_FORMAT_ARGB_2101010">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="324">ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010"
              value="125"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010"
              glib:nick="abgr-2101010"
              glib:name="COGL_PIXEL_FORMAT_ABGR_2101010">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="325">ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="rgba_8888_pre"
              value="147"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888_PRE"
              glib:nick="rgba-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="326">Premultiplied RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888_pre"
              value="179"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888_PRE"
              glib:nick="bgra-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_BGRA_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="327">Premultiplied BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888_pre"
              value="211"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888_PRE"
              glib:nick="argb-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_ARGB_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="328">Premultiplied ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888_pre"
              value="243"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888_PRE"
              glib:nick="abgr-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_ABGR_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="329">Premultiplied ABGR, 32 bits</doc>
      </member>
      <member name="rgba_4444_pre"
              value="149"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444_PRE"
              glib:nick="rgba-4444-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_4444_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="330">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551_pre"
              value="150"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551_PRE"
              glib:nick="rgba-5551-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_5551_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="331">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_1010102_pre"
              value="157"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102_PRE"
              glib:nick="rgba-1010102-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_1010102_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="332">Premultiplied RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102_pre"
              value="189"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102_PRE"
              glib:nick="bgra-1010102-pre"
              glib:name="COGL_PIXEL_FORMAT_BGRA_1010102_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="333">Premultiplied BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010_pre"
              value="221"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010_PRE"
              glib:nick="argb-2101010-pre"
              glib:name="COGL_PIXEL_FORMAT_ARGB_2101010_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="334">Premultiplied ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010_pre"
              value="253"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010_PRE"
              glib:nick="abgr-2101010-pre"
              glib:name="COGL_PIXEL_FORMAT_ABGR_2101010_PRE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="335">Premultiplied ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="depth_16"
              value="265"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_16"
              glib:nick="depth-16"
              glib:name="COGL_PIXEL_FORMAT_DEPTH_16">
      </member>
      <member name="depth_32"
              value="259"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_32"
              glib:nick="depth-32"
              glib:name="COGL_PIXEL_FORMAT_DEPTH_32">
      </member>
      <member name="depth_24_stencil_8"
              value="771"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8"
              glib:nick="depth-24-stencil-8"
              glib:name="COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8">
      </member>
    </enumeration>
    <record name="PollFD"
            c:type="CoglPollFD"
            version="1.10"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-poll.h"
           line="87">A struct for describing the state of a file descriptor that Cogl
needs to block on. The @events field contains a bitmask of
#CoglPollFDEvent&lt;!-- --&gt;s that should cause the application to wake
up. After the application is woken up from idle it should pass back
an array of #CoglPollFD&lt;!-- --&gt;s to Cogl and update the @revents
mask to the actual events that occurred on the file descriptor.

Note that CoglPollFD is deliberately exactly the same as struct
pollfd on Unix so that it can simply be cast when calling poll.</doc>
      <source-position filename="cogl-poll.h" line="110"/>
      <field name="fd" writable="1">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="89">The file descriptor to block on</doc>
        <type name="gint" c:type="int"/>
      </field>
      <field name="events" introspectable="0" writable="1">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="90">A bitmask of events to block on</doc>
        <type c:type="short int"/>
      </field>
      <field name="revents" introspectable="0" writable="1">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="91">A bitmask of returned events</doc>
        <type c:type="short int"/>
      </field>
    </record>
    <enumeration name="PollFDEvent"
                 version="1.10"
                 stability="Unstable"
                 c:type="CoglPollFDEvent">
      <doc xml:space="preserve"
           filename="cogl-poll.h"
           line="59">A bitmask of events that Cogl may need to wake on for a file
descriptor. Note that these all have the same values as the
corresponding defines for the poll function call on Unix so they
may be directly passed to poll.</doc>
      <source-position filename="cogl-poll.h" line="85"/>
      <member name="in" value="1" c:identifier="COGL_POLL_FD_EVENT_IN">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="61">there is data to read</doc>
      </member>
      <member name="pri" value="2" c:identifier="COGL_POLL_FD_EVENT_PRI">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="62">data can be written (without blocking)</doc>
      </member>
      <member name="out" value="4" c:identifier="COGL_POLL_FD_EVENT_OUT">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="63">there is urgent data to read.</doc>
      </member>
      <member name="err" value="8" c:identifier="COGL_POLL_FD_EVENT_ERR">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="64">error condition</doc>
      </member>
      <member name="hup" value="16" c:identifier="COGL_POLL_FD_EVENT_HUP">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="65">hung up (the connection has been broken, usually
                         for pipes and sockets).</doc>
      </member>
      <member name="nval" value="32" c:identifier="COGL_POLL_FD_EVENT_NVAL">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="67">invalid request. The file descriptor is not open.</doc>
      </member>
    </enumeration>
    <class name="Primitive"
           c:symbol-prefix="primitive"
           c:type="CoglPrimitive"
           parent="Object"
           glib:type-name="CoglPrimitive"
           glib:get-type="cogl_primitive_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_primitive_new"
                   version="1.6"
                   introspectable="0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="230">Combines a set of #CoglAttribute&lt;!-- --&gt;s with a specific draw @mode
and defines a vertex count so a #CoglPrimitive object can be retained and
drawn later with no addition information required.

The value passed as @n_vertices will simply update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.</doc>
        <source-position filename="cogl-primitive.h" line="251"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="245">A newly allocated #CoglPrimitive object</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="232">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="233">The number of vertices to process when drawing</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="234">A %NULL terminated list of attributes</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p2"
                   c:identifier="cogl_primitive_new_p2"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="282">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
attribute with a #CoglAttribute and upload your data.

For example to draw a convex polygon you can do:
|[
CoglVertexP2 triangle[] =
{
  { 0,   300 },
  { 150, 0,  },
  { 300, 300 }
};
prim = cogl_primitive_new_p2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                              3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="331"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="324">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="284">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="285">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="286">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="288">An array
       of #CoglVertexP2 vertices</doc>
            <array length="2" zero-terminated="0" c:type="const CoglVertexP2*">
              <type name="VertexP2" c:type="CoglVertexP2"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p2c4"
                   c:identifier="cogl_primitive_new_p2c4"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="390">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
and color attributes with #CoglAttribute&lt;!-- --&gt;s and upload
your data.

For example to draw a convex polygon with a linear gradient you
can do:
|[
CoglVertexP2C4 triangle[] =
{
  { 0,   300,  0xff, 0x00, 0x00, 0xff },
  { 150, 0,    0x00, 0xff, 0x00, 0xff },
  { 300, 300,  0xff, 0x00, 0x00, 0xff }
};
prim = cogl_primitive_new_p2c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="441"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="434">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="392">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="393">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="394">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="396">An array
       of #CoglVertexP2C4 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP2C4*">
              <type name="VertexP2C4" c:type="CoglVertexP2C4"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p2t2"
                   c:identifier="cogl_primitive_new_p2t2"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="502">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position and
texture coordinate attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping you can
do:
|[
CoglVertexP2T2 triangle[] =
{
  { 0,   300,  0.0, 1.0},
  { 150, 0,    0.5, 0.0},
  { 300, 300,  1.0, 1.0}
};
prim = cogl_primitive_new_p2t2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="553"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="546">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="504">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="505">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="506">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="508">An array
       of #CoglVertexP2T2 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP2T2*">
              <type name="VertexP2T2" c:type="CoglVertexP2T2"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p2t2c4"
                   c:identifier="cogl_primitive_new_p2t2c4"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="614">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position, texture
coordinate and color attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping and a
linear gradient you can do:
|[
CoglVertexP2T2C4 triangle[] =
{
  { 0,   300,  0.0, 1.0,  0xff, 0x00, 0x00, 0xff},
  { 150, 0,    0.5, 0.0,  0x00, 0xff, 0x00, 0xff},
  { 300, 300,  1.0, 1.0,  0xff, 0x00, 0x00, 0xff}
};
prim = cogl_primitive_new_p2t2c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                  3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="665"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="658">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="616">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="617">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="618">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="620">An
       array of #CoglVertexP2T2C4 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP2T2C4*">
              <type name="VertexP2T2C4" c:type="CoglVertexP2T2C4"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p3"
                   c:identifier="cogl_primitive_new_p3"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="336">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
attribute with a #CoglAttribute and upload your data.

For example to draw a convex polygon you can do:
|[
CoglVertexP3 triangle[] =
{
  { 0,   300, 0 },
  { 150, 0,   0 },
  { 300, 300, 0 }
};
prim = cogl_primitive_new_p3 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                              3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="385"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="378">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="338">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="339">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="340">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="342">An array of
       #CoglVertexP3 vertices</doc>
            <array length="2" zero-terminated="0" c:type="const CoglVertexP3*">
              <type name="VertexP3" c:type="CoglVertexP3"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p3c4"
                   c:identifier="cogl_primitive_new_p3c4"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="446">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
and color attributes with #CoglAttribute&lt;!-- --&gt;s and upload
your data.

For example to draw a convex polygon with a linear gradient you
can do:
|[
CoglVertexP3C4 triangle[] =
{
  { 0,   300, 0,  0xff, 0x00, 0x00, 0xff },
  { 150, 0,   0,  0x00, 0xff, 0x00, 0xff },
  { 300, 300, 0,  0xff, 0x00, 0x00, 0xff }
};
prim = cogl_primitive_new_p3c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="497"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="490">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="448">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="449">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="450">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="452">An array
       of #CoglVertexP3C4 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP3C4*">
              <type name="VertexP3C4" c:type="CoglVertexP3C4"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p3t2"
                   c:identifier="cogl_primitive_new_p3t2"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="558">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position and
texture coordinate attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping you can
do:
|[
CoglVertexP3T2 triangle[] =
{
  { 0,   300, 0,  0.0, 1.0},
  { 150, 0,   0,  0.5, 0.0},
  { 300, 300, 0,  1.0, 1.0}
};
prim = cogl_primitive_new_p3t2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="609"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="602">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="560">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="561">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="562">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="564">An array
       of #CoglVertexP3T2 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP3T2*">
              <type name="VertexP3T2" c:type="CoglVertexP3T2"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p3t2c4"
                   c:identifier="cogl_primitive_new_p3t2c4"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="670">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position, texture
coordinate and color attributes with #CoglAttribute&lt;!-- --&gt;s and
upload your data.

For example to draw a convex polygon with texture mapping and a
linear gradient you can do:
|[
CoglVertexP3T2C4 triangle[] =
{
  { 0,   300, 0,  0.0, 1.0,  0xff, 0x00, 0x00, 0xff},
  { 150, 0,   0,  0.5, 0.0,  0x00, 0xff, 0x00, 0xff},
  { 300, 300, 0,  1.0, 1.0,  0xff, 0x00, 0x00, 0xff}
};
prim = cogl_primitive_new_p3t2c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                  3, triangle);
cogl_primitive_draw (prim);
]|

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

&lt;note&gt;The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). You
should pass the %COGL_TEXTURE_NO_SLICING flag to all textures that
might be used while drawing with this API. If your hardware doesn't
support non-power of two textures (For example you are using GLES
1.1) then you will need to make sure your assets are resized to a
power-of-two size (though they don't have to be square)&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="721"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="714">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using cogl_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="672">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="673">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="674">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="676">An
       array of #CoglVertexP3T2C4 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP3T2C4*">
              <type name="VertexP3T2C4" c:type="CoglVertexP3T2C4"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_attributes"
                   c:identifier="cogl_primitive_new_with_attributes"
                   version="1.6"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="255">Combines a set of #CoglAttribute&lt;!-- --&gt;s with a specific draw @mode
and defines a vertex count so a #CoglPrimitive object can be retained and
drawn later with no addition information required.

The value passed as @n_vertices will simply update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.</doc>
        <source-position filename="cogl-primitive.h" line="277"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="271">A newly allocated #CoglPrimitive object</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="257">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="258">The number of vertices to process when drawing</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="259">An array of CoglAttribute</doc>
            <type name="Attribute" c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="260">The number of attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="texture_set_auto_mipmap"
                c:identifier="cogl_primitive_texture_set_auto_mipmap"
                version="2.0"
                stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive-texture.h"
             line="90">Sets whether the texture will automatically update the smaller
mipmap levels after any part of level 0 is updated. The update will
only occur whenever the texture is used for drawing with a texture
filter that requires the lower mipmap levels. An application should
disable this if it wants to upload its own data for the other
levels. By default auto mipmapping is enabled.</doc>
        <source-position filename="cogl-primitive-texture.h" line="106"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="primitive_texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive-texture.h"
                 line="92">A #CoglPrimitiveTexture</doc>
            <type name="PrimitiveTexture" c:type="CoglPrimitiveTexture*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive-texture.h"
                 line="93">The new value for whether to auto mipmap</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </function>
      <method name="copy"
              c:identifier="cogl_primitive_copy"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="848">Makes a copy of an existing #CoglPrimitive. Note that the primitive
is a shallow copy which means it will use the same attributes and
attribute buffers as the original primitive.</doc>
        <source-position filename="cogl-primitive.h" line="861"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="856">the new primitive</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="850">A primitive copy</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="draw"
              c:identifier="cogl_primitive_draw"
              version="1.16"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="915">Draws the given @primitive geometry to the specified destination
@framebuffer using the graphics processing state described by @pipeline.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D, #CoglTextureRectangle or #CoglTexture3D
are associated with layers of the given @pipeline.</doc>
        <source-position filename="cogl-primitive.h" line="934"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="917">A #CoglPrimitive geometry object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="918">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="919">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_attribute"
              c:identifier="cogl_primitive_foreach_attribute"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="897">Iterates all the attributes of the given #CoglPrimitive.</doc>
        <source-position filename="cogl-primitive.h" line="911"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="899">A #CoglPrimitive object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="900">A #CoglPrimitiveAttributeCallback to be
           called for each attribute</doc>
            <type name="PrimitiveAttributeCallback"
                  c:type="CoglPrimitiveAttributeCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="902">Private data that will be passed to the
            callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_first_vertex"
              c:identifier="cogl_primitive_get_first_vertex">
        <source-position filename="cogl-primitive.h" line="726"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_indices"
              c:identifier="cogl_primitive_get_indices"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-primitive.h" line="846"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="839">the indices that were set with
cogl_primitive_set_indices() or %NULL if no indices were set.</doc>
          <type name="Indices" c:type="CoglIndices*"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="837">A #CoglPrimitive</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_mode" c:identifier="cogl_primitive_get_mode">
        <source-position filename="cogl-primitive.h" line="780"/>
        <return-value transfer-ownership="none">
          <type name="VerticesMode" c:type="CoglVerticesMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_vertices"
              c:identifier="cogl_primitive_get_n_vertices"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="732">Queries the number of vertices to read when drawing the given
@primitive. Usually this value is implicitly set when associating
vertex data or indices with a #CoglPrimitive.

If cogl_primitive_set_indices() has been used to associate a
sequence of #CoglIndices with the given @primitive then the
number of vertices to read can also be phrased as the number
of indices to read.

&lt;note&gt;To be clear; it doesn't refer to the number of vertices - in
terms of data - associated with the primitive it's just the number
of vertices to read and draw.&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="755"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="749">The number of vertices to read when drawing.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="734">A #CoglPrimitive object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_attributes"
              c:identifier="cogl_primitive_set_attributes"
              version="1.6"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="786">Replaces all the attributes of the given #CoglPrimitive object.</doc>
        <source-position filename="cogl-primitive.h" line="798"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="788">A #CoglPrimitive object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="789">an array of #CoglAttribute pointers</doc>
            <type name="Attribute" c:type="CoglAttribute**"/>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="790">the number of elements in @attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_first_vertex"
              c:identifier="cogl_primitive_set_first_vertex">
        <source-position filename="cogl-primitive.h" line="729"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_indices"
              c:identifier="cogl_primitive_set_indices"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="802">Associates a sequence of #CoglIndices with the given @primitive.

#CoglIndices provide a way to virtualize your real vertex data by
providing a sequence of indices that index into your real vertex
data. The GPU will walk though the index values to indirectly
lookup the data for each vertex instead of sequentially walking
through the data directly. This lets you save memory by indexing
shared data multiple times instead of duplicating the data.

The value passed as @n_indices will simply update the
#CoglPrimitive &lt;structfield&gt;n_vertices&lt;/structfield&gt; property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to draw or, put another way, how many
indices should be read from @indices when drawing.

&lt;note&gt;The #CoglPrimitive &lt;structfield&gt;first_vertex&lt;/structfield&gt; property
also affects drawing with indices by defining the first entry of the
indices to start drawing from.&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="831"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="804">A #CoglPrimitive</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="805">A #CoglIndices array</doc>
            <type name="Indices" c:type="CoglIndices*"/>
          </parameter>
          <parameter name="n_indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="806">The number of indices to reference when drawing</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_mode" c:identifier="cogl_primitive_set_mode">
        <source-position filename="cogl-primitive.h" line="783"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_n_vertices"
              c:identifier="cogl_primitive_set_n_vertices"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="757">Specifies how many vertices should be read when drawing the given
@primitive.

Usually this value is set implicitly when associating vertex data
or indices with a #CoglPrimitive.

&lt;note&gt;To be clear; it doesn't refer to the number of vertices - in
terms of data - associated with the primitive it's just the number
of vertices to read and draw.&lt;/note&gt;</doc>
        <source-position filename="cogl-primitive.h" line="776"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="759">A #CoglPrimitive object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-primitive.h"
                 line="760">The number of vertices to read when drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <callback name="PrimitiveAttributeCallback"
              c:type="CoglPrimitiveAttributeCallback"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="878">The callback prototype used with cogl_primitive_foreach_attribute()
for iterating all the attributes of a #CoglPrimitive.

The function should return TRUE to continue iteration or FALSE to
stop.</doc>
      <source-position filename="cogl-primitive.h" line="893"/>
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="primitive" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="880">The #CoglPrimitive whose attributes are being iterated</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </parameter>
        <parameter name="attribute" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="881">The #CoglAttribute</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="882">The private data passed to cogl_primitive_foreach_attribute()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Quaternion"
            c:type="CoglQuaternion"
            glib:type-name="CoglQuaternion"
            glib:get-type="cogl_quaternion_get_gtype"
            c:symbol-prefix="quaternion">
      <doc xml:space="preserve"
           filename="cogl-quaternion.h"
           line="66">A quaternion is comprised of a scalar component and a 3D vector
component. The scalar component is normally referred to as w and the
vector might either be referred to as v or a (for axis) or expanded
with the individual components: (x, y, z) A full quaternion would
then be written as &lt;literal&gt;[w (x, y, z)]&lt;/literal&gt;.

Quaternions can be considered to represent an axis and angle
pair although sadly these numbers are buried somewhat under some
maths...

For the curious you can see here that a given axis (a) and angle (𝜃)
pair are represented in a quaternion as follows:
|[
[w=cos(𝜃/2) ( x=sin(𝜃/2)*a.x, y=sin(𝜃/2)*a.y, z=sin(𝜃/2)*a.x )]
]|

Unit Quaternions:
When using Quaternions to represent spatial orientations for 3D
graphics it's always assumed you have a unit quaternion. The
magnitude of a quaternion is defined as:
|[
sqrt (w² + x² + y² + z²)
]|
and a unit quaternion satisfies this equation:
|[
w² + x² + y² + z² = 1
]|

Thankfully most of the time we don't actually have to worry about
the maths that goes on behind the scenes but if you are curious to
learn more here are some external references:

&lt;itemizedlist&gt;
&lt;listitem&gt;
&lt;ulink url="http://mathworld.wolfram.com/Quaternion.html"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.gamedev.net/reference/articles/article1095.asp"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.cprogramming.com/tutorial/3d/quaternions.html"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.isner.com/tutorials/quatSpells/quaternion_spells_12.htm"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
3D Maths Primer for Graphics and Game Development ISBN-10: 1556229119
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.cs.caltech.edu/courses/cs171/quatut.pdf"/&gt;
&lt;/listitem&gt;
&lt;listitem&gt;
&lt;ulink url="http://www.j3d.org/matrix_faq/matrfaq_latest.html#Q56"/&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
      <source-position filename="cogl-quaternion.h" line="147"/>
      <field name="w" writable="1">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="68">based on the angle of rotation it is cos(𝜃/2)</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="69">based on the angle of rotation and x component of the axis of
    rotation it is sin(𝜃/2)*axis.x</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="71">based on the angle of rotation and y component of the axis of
    rotation it is sin(𝜃/2)*axis.y</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="73">based on the angle of rotation and z component of the axis of
    rotation it is sin(𝜃/2)*axis.z</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding0" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding1" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding2" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="padding3" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <method name="copy" c:identifier="cogl_quaternion_copy" version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="328">Allocates a new #CoglQuaternion on the stack and initializes it with
the same values as @src.</doc>
        <source-position filename="cogl-quaternion.h" line="341"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-quaternion.h"
               line="335">A newly allocated #CoglQuaternion which should be freed
using cogl_quaternion_free()</doc>
          <type name="Quaternion" c:type="CoglQuaternion*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="330">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dot_product"
              c:identifier="cogl_quaternion_dot_product"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="394"/>
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="388">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="389">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_quaternion_free" version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="343">Frees a #CoglQuaternion that was previously allocated via
cogl_quaternion_copy().</doc>
        <source-position filename="cogl-quaternion.h" line="353"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="345">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rotation_angle"
              c:identifier="cogl_quaternion_get_rotation_angle"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="363"/>
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="357">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rotation_axis"
              c:identifier="cogl_quaternion_get_rotation_axis"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="373"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="367">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="vector3"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="368">an allocated 3-float array</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="cogl_quaternion_init" version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="159">Initializes a quaternion that rotates @angle degrees around the
axis vector (@x, @y, @z). The axis vector does not need to be
normalized.</doc>
        <source-position filename="cogl-quaternion.h" line="180"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="161">An uninitialized #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="162">The angle you want to rotate around the given axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="163">The x component of your axis vector about which you want to
rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="165">The y component of your axis vector about which you want to
rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="167">The z component of your axis vector about which you want to
rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_angle_vector"
              c:identifier="cogl_quaternion_init_from_angle_vector"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="186">Initializes a quaternion that rotates @angle degrees around the
given @axis vector. The axis vector does not need to be
normalized.</doc>
        <source-position filename="cogl-quaternion.h" line="202"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="188">An uninitialized #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="189">The angle to rotate around @axis3f</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="axis3f" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="190">your 3 component axis vector about which you want to rotate.</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_array"
              c:identifier="cogl_quaternion_init_from_array"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="222">Initializes a [w (x, y,z)] quaternion directly from an array of 4
floats: [w,x,y,z].</doc>
        <source-position filename="cogl-quaternion.h" line="233"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="224">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="225">An array of 4 floats w,(x,y,z)</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_euler"
              c:identifier="cogl_quaternion_init_from_euler"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="281"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="275">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="276">A #CoglEuler with which to initialize the quaternion</doc>
            <type name="Euler" c:type="const CoglEuler*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_matrix"
              c:identifier="cogl_quaternion_init_from_matrix"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="295">Initializes a quaternion from a rotation matrix.</doc>
        <source-position filename="cogl-quaternion.h" line="306"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="297">A Cogl Quaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="298">A rotation matrix with which to initialize the quaternion</doc>
            <type name="Matrix" c:type="const CoglMatrix*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_quaternion"
              c:identifier="cogl_quaternion_init_from_quaternion"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="292"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="286">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="287">A #CoglQuaternion with which to initialize @quaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_x_rotation"
              c:identifier="cogl_quaternion_init_from_x_rotation"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="236">XXX: check which direction this rotates</doc>
        <source-position filename="cogl-quaternion.h" line="246"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="238">An uninitialized #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="239">The angle to rotate around the x axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_y_rotation"
              c:identifier="cogl_quaternion_init_from_y_rotation"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="258"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="251">An uninitialized #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="252">The angle to rotate around the y axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_from_z_rotation"
              c:identifier="cogl_quaternion_init_from_z_rotation"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="270"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="263">An uninitialized #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="264">The angle to rotate around the z axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_identity"
              c:identifier="cogl_quaternion_init_identity"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="206">Initializes the quaternion with the canonical quaternion identity
[1 (0, 0, 0)] which represents no rotation. Multiplying a
quaternion with this identity leaves the quaternion unchanged.

You might also want to consider using
cogl_get_static_identity_quaternion().</doc>
        <source-position filename="cogl-quaternion.h" line="220"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="208">An uninitialized #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert"
              c:identifier="cogl_quaternion_invert"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="405"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="399">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="multiply"
              c:identifier="cogl_quaternion_multiply"
              version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="407">This combines the rotations of two quaternions into @result. The
operation is not commutative so the order is important because AxB
!= BxA. Cogl follows the standard convention for quaternions here
so the rotations are applied @right to @left. This is similar to the
combining of matrices.

&lt;note&gt;It is possible to multiply the @a quaternion in-place, so
@result can be equal to @a but can't be equal to @b.&lt;/note&gt;</doc>
        <source-position filename="cogl-quaternion.h" line="425"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="409">The destination #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="410">The second #CoglQuaternion rotation to apply</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="411">The first #CoglQuaternion rotation to apply</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="nlerp" c:identifier="cogl_quaternion_nlerp">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="472">Performs a normalized linear interpolation between two quaternions.
That is it does a linear interpolation of the quaternion components
and then normalizes the result. This will follow the shortest arc
between the two orientations (just like the slerp() function) but
will not progress at a constant speed. Unlike slerp() nlerp is
commutative which is useful if you are blending animations
together. (I.e. nlerp (tmp, a, b) followed by nlerp (result, tmp,
d) is the same as nlerp (tmp, a, d) followed by nlerp (result, tmp,
b)). Finally nlerp is cheaper than slerp so it can be a good choice
if you don't need the constant speed property of the slerp() function.

Notable properties:
&lt;itemizedlist&gt;
&lt;listitem&gt;
commutative: Yes
&lt;/listitem&gt;
&lt;listitem&gt;
constant velocity: No
&lt;/listitem&gt;
&lt;listitem&gt;
torque minimal (travels along the surface of the 4-sphere): Yes
&lt;/listitem&gt;
&lt;listitem&gt;
faster than cogl_quaternion_slerp()
&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <source-position filename="cogl-quaternion.h" line="508"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="474">The destination #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="475">The first #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="476">The second #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="477">The factor in the range [0,1] used to interpolate between
quaterion @a and @b.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="normalize"
              c:identifier="cogl_quaternion_normalize"
              version="2.0">
        <source-position filename="cogl-quaternion.h" line="384"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="378">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pow" c:identifier="cogl_quaternion_pow" version="2.0">
        <source-position filename="cogl-quaternion.h" line="438"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="quaternion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="431">A #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="exponent" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="432">the exponent</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="slerp" c:identifier="cogl_quaternion_slerp">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="440">Performs a spherical linear interpolation between two quaternions.

Noteable properties:
&lt;itemizedlist&gt;
&lt;listitem&gt;
commutative: No
&lt;/listitem&gt;
&lt;listitem&gt;
constant velocity: Yes
&lt;/listitem&gt;
&lt;listitem&gt;
torque minimal (travels along the surface of the 4-sphere): Yes
&lt;/listitem&gt;
&lt;listitem&gt;
more expensive than cogl_quaternion_nlerp()
&lt;/listitem&gt;
&lt;/itemizedlist&gt;</doc>
        <source-position filename="cogl-quaternion.h" line="467"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="442">The destination #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="443">The first #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="444">The second #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="445">The factor in the range [0,1] used to interpolate between
quaternion @a and @b.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="squad" c:identifier="cogl_quaternion_squad" version="2.0">
        <source-position filename="cogl-quaternion.h" line="526"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="result" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="514">The destination #CoglQuaternion</doc>
            <type name="Quaternion" c:type="CoglQuaternion*"/>
          </instance-parameter>
          <parameter name="prev" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="515">A #CoglQuaternion used before @a</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="516">The first #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="517">The second #CoglQuaternion</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="next" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="518">A #CoglQuaternion that will be used after @b</doc>
            <type name="Quaternion" c:type="const CoglQuaternion*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="519">The factor in the range [0,1] used to interpolate between
quaternion @a and @b.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <function name="equal"
                c:identifier="cogl_quaternion_equal"
                version="2.0">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="309">Compares that all the components of quaternions @a and @b are
equal.

An epsilon value is not used to compare the float components, but
the == operator is at least used so that 0 and -0 are considered
equal.</doc>
        <source-position filename="cogl-quaternion.h" line="326"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-quaternion.h"
               line="321">%TRUE if the quaternions are equal else %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <parameter name="v1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="311">A #CoglQuaternion</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="v2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-quaternion.h"
                 line="312">A #CoglQuaternion</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="ReadPixelsFlags"
              version="1.0"
              glib:type-name="CoglReadPixelsFlags"
              glib:get-type="cogl_read_pixels_flags_get_type"
              c:type="CoglReadPixelsFlags">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="911">Flags for cogl_framebuffer_read_pixels_into_bitmap()</doc>
      <member name="color_buffer"
              value="1"
              c:identifier="COGL_READ_PIXELS_COLOR_BUFFER"
              glib:nick="color-buffer"
              glib:name="COGL_READ_PIXELS_COLOR_BUFFER">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="913">Read from the color buffer</doc>
      </member>
    </bitfield>
    <class name="Renderer"
           c:symbol-prefix="renderer"
           c:type="CoglRenderer"
           parent="Object"
           glib:type-name="CoglRenderer"
           glib:get-type="cogl_renderer_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_renderer_new"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="114">Instantiates a new (unconnected) #CoglRenderer object. A
#CoglRenderer represents a means to render. It encapsulates the
selection of an underlying driver, such as OpenGL or OpenGL-ES and
a selection of a window system binding API such as GLX, or EGL or
WGL.

While the renderer is unconnected it can be configured so that
applications may specify backend constraints, such as "must use
x11" for example via cogl_renderer_add_constraint().

There are also some platform specific configuration apis such
as cogl_xlib_renderer_set_foreign_display() that may also be
used while the renderer is unconnected.

Once the renderer has been configured, then it may (optionally) be
explicitly connected using cogl_renderer_connect() which allows
errors to be handled gracefully and potentially fallback
configurations can be tried out if there are initial failures.

If a renderer is not explicitly connected then cogl_display_new()
will automatically connect the renderer for you. If you don't
have any code to deal with error/fallback situations then its fine
to just let Cogl do the connection for you.

Once you have setup your renderer then the next step is to create a
#CoglDisplay using cogl_display_new().

&lt;note&gt;Many applications don't need to explicitly use
cogl_renderer_new() or cogl_display_new() and can just jump
straight to cogl_context_new() and pass a %NULL display argument
so Cogl will automatically connect and setup a renderer and
display.&lt;/note&gt;</doc>
        <source-position filename="cogl-renderer.h" line="156"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="150">A newly created #CoglRenderer.</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </return-value>
      </constructor>
      <method name="add_constraint"
              c:identifier="cogl_renderer_add_constraint"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="315">This adds a renderer selection @constraint.

Applications should ideally minimize how many of these constraints they
depend on to ensure maximum portability.</doc>
        <source-position filename="cogl-renderer.h" line="329"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="317">An unconnected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="constraint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="318">A #CoglRendererConstraint to add</doc>
            <type name="RendererConstraint" c:type="CoglRendererConstraint"/>
          </parameter>
        </parameters>
      </method>
      <method name="check_onscreen_template"
              c:identifier="cogl_renderer_check_onscreen_template"
              version="1.10"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="241">Tests if a given @onscreen_template can be supported with the given
@renderer.</doc>
        <source-position filename="cogl-renderer.h" line="256"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="250">%TRUE if the @onscreen_template can be supported,
              else %FALSE.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="243">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="onscreen_template" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="244">A #CoglOnscreenTemplate</doc>
            <type name="OnscreenTemplate" c:type="CoglOnscreenTemplate*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect"
              c:identifier="cogl_renderer_connect"
              version="1.10"
              stability="Unstable"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="262">Connects the configured @renderer. Renderer connection isn't a
very active process, it basically just means validating that
any given constraint criteria can be satisfied and that a
usable driver and window system backend can be found.</doc>
        <source-position filename="cogl-renderer.h" line="278"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="272">%TRUE if there was no error while connecting the
              given @renderer. %FALSE if there was an error.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="264">An unconnected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_output"
              c:identifier="cogl_renderer_foreach_output"
              version="1.14"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="426">Iterates all known display outputs for the given @renderer and
passes a corresponding #CoglOutput pointer to the given @callback
for each one, along with the given @user_data.</doc>
        <source-position filename="cogl-renderer.h" line="441"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="428">A connected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="429">A #CoglOutputCallback to be called for
           each display output</doc>
            <type name="OutputCallback" c:type="CoglOutputCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="431">A user pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_driver"
              c:identifier="cogl_renderer_get_driver"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="397">Queries what underlying driver is being used by Cogl.

This may only be called on a connected #CoglRenderer.</doc>
        <source-position filename="cogl-renderer.h" line="409"/>
        <return-value transfer-ownership="none">
          <type name="Driver" c:type="CoglDriver"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="399">A connected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_fragment_texture_units"
              c:identifier="cogl_renderer_get_n_fragment_texture_units"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="227">Queries how many texture units can be used from fragment programs</doc>
        <source-position filename="cogl-renderer.h" line="239"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="233">the number of texture image units.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="229">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_winsys_id" c:identifier="cogl_renderer_get_winsys_id">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="213">Queries which window system backend Cogl has chosen to use.

This may only be called on a connected #CoglRenderer.</doc>
        <source-position filename="cogl-renderer.h" line="225"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="221">The #CoglWinsysID corresponding to the chosen window
         system backend.</doc>
          <type name="WinsysID" c:type="CoglWinsysID"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="215">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_constraint"
              c:identifier="cogl_renderer_remove_constraint"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="332">This removes a renderer selection @constraint.

Applications should ideally minimize how many of these constraints they
depend on to ensure maximum portability.</doc>
        <source-position filename="cogl-renderer.h" line="346"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="334">An unconnected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="constraint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="335">A #CoglRendererConstraint to remove</doc>
            <type name="RendererConstraint" c:type="CoglRendererConstraint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_driver"
              c:identifier="cogl_renderer_set_driver"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="376">Requests that Cogl should try to use a specific underlying driver
for rendering.

If you select an unsupported driver then cogl_renderer_connect()
will fail and report an error. Most applications should not
explicitly select a driver and should rely on Cogl automatically
choosing the driver.

This may only be called on an un-connected #CoglRenderer.</doc>
        <source-position filename="cogl-renderer.h" line="394"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="378">An unconnected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="driver" transfer-ownership="none">
            <type name="Driver" c:type="CoglDriver"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_winsys_id" c:identifier="cogl_renderer_set_winsys_id">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="196">This allows you to explicitly select a winsys backend to use instead
of letting Cogl automatically select a backend.

if you select an unsupported backend then cogl_renderer_connect()
will fail and report an error.

This may only be called on an un-connected #CoglRenderer.</doc>
        <source-position filename="cogl-renderer.h" line="210"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="198">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="winsys_id" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-renderer.h"
                 line="199">An ID of the winsys you explicitly want to use.</doc>
            <type name="WinsysID" c:type="CoglWinsysID"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <bitfield name="RendererConstraint"
              version="1.10"
              stability="Unstable"
              c:type="CoglRendererConstraint">
      <doc xml:space="preserve"
           filename="cogl-renderer.h"
           line="280">These constraint flags are hard-coded features of the different renderer
backends. Sometimes a platform may support multiple rendering options which
Cogl will usually choose from automatically. Some of these features are
important to higher level applications and frameworks though, such as
whether a renderer is X11 based because an application might only support
X11 based input handling. An application might also need to ensure EGL is
used internally too if they depend on access to an EGLDisplay for some
purpose.

Applications should ideally minimize how many of these constraints
they depend on to ensure maximum portability.</doc>
      <source-position filename="cogl-renderer.h" line="312"/>
      <member name="uses_x11"
              value="1"
              c:identifier="COGL_RENDERER_CONSTRAINT_USES_X11">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="282">Require the renderer to be X11 based</doc>
      </member>
      <member name="uses_xlib"
              value="2"
              c:identifier="COGL_RENDERER_CONSTRAINT_USES_XLIB">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="283">Require the renderer to be X11
                                     based and use Xlib</doc>
      </member>
      <member name="uses_egl"
              value="4"
              c:identifier="COGL_RENDERER_CONSTRAINT_USES_EGL">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="285">Require the renderer to be EGL based</doc>
      </member>
      <member name="supports_cogl_gles2"
              value="8"
              c:identifier="COGL_RENDERER_CONSTRAINT_SUPPORTS_COGL_GLES2">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="286">Require that the
   renderer supports creating a #CoglGLES2Context via
   cogl_gles2_context_new(). This can be used to integrate GLES 2.0
   code into Cogl based applications.</doc>
      </member>
    </bitfield>
    <enumeration name="RendererError"
                 glib:type-name="CoglRendererError"
                 glib:get-type="cogl_renderer_error_get_type"
                 c:type="CoglRendererError">
      <member name="xlib_display_open"
              value="0"
              c:identifier="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN"
              glib:nick="xlib-display-open"
              glib:name="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN">
      </member>
      <member name="bad_constraint"
              value="1"
              c:identifier="COGL_RENDERER_ERROR_BAD_CONSTRAINT"
              glib:nick="bad-constraint"
              glib:name="COGL_RENDERER_ERROR_BAD_CONSTRAINT">
      </member>
      <function name="quark" c:identifier="cogl_renderer_error_quark">
        <source-position filename="cogl-renderer.h" line="88"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <function-macro name="SNIPPET"
                    c:identifier="COGL_SNIPPET"
                    introspectable="0">
      <source-position filename="cogl-snippet.h" line="342"/>
      <parameters>
        <parameter name="OBJECT">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="STENCIL_BIT" value="512" c:type="COGL_STENCIL_BIT">
      <source-position filename="cogl-types.h" line="233"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="STRUCT_SIZE_ASSERT"
                    c:identifier="COGL_STRUCT_SIZE_ASSERT"
                    introspectable="0">
      <source-position filename="cogl-types.h" line="130"/>
      <parameters>
        <parameter name="TYPE">
        </parameter>
        <parameter name="SIZE">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SUB_TEXTURE"
                    c:identifier="COGL_SUB_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl-sub-texture.h" line="52"/>
      <parameters>
        <parameter name="tex">
        </parameter>
      </parameters>
    </function-macro>
    <enumeration name="ShaderType"
                 glib:type-name="CoglShaderType"
                 glib:get-type="cogl_shader_type_get_type"
                 c:type="CoglShaderType">
      <member name="vertex"
              value="0"
              c:identifier="COGL_SHADER_TYPE_VERTEX"
              glib:nick="vertex"
              glib:name="COGL_SHADER_TYPE_VERTEX">
      </member>
      <member name="fragment"
              value="1"
              c:identifier="COGL_SHADER_TYPE_FRAGMENT"
              glib:nick="fragment"
              glib:name="COGL_SHADER_TYPE_FRAGMENT">
      </member>
    </enumeration>
    <class name="Snippet"
           c:symbol-prefix="snippet"
           c:type="CoglSnippet"
           parent="Object"
           glib:type-name="CoglSnippet"
           glib:get-type="cogl_snippet_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_snippet_new"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="679">Allocates and initializes a new snippet with the given source strings.</doc>
        <source-position filename="cogl-snippet.h" line="696"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-snippet.h"
               line="690">a pointer to a new #CoglSnippet</doc>
          <type name="Snippet" c:type="CoglSnippet*"/>
        </return-value>
        <parameters>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="681">The point in the pipeline that this snippet will wrap around
  or replace.</doc>
            <type name="SnippetHook" c:type="CoglSnippetHook"/>
          </parameter>
          <parameter name="declarations" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="683">The source code for the declarations for this
  snippet or %NULL. See cogl_snippet_set_declarations().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="post" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="685">The source code to run after the hook point where this
  shader snippet is attached or %NULL. See cogl_snippet_set_post().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_declarations"
              c:identifier="cogl_snippet_get_declarations"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-snippet.h" line="760"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-snippet.h"
               line="753">the source string that was set with
  cogl_snippet_set_declarations() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="751">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hook"
              c:identifier="cogl_snippet_get_hook"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-snippet.h" line="710"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-snippet.h"
               line="704">the hook that was set when cogl_snippet_new() was
  called.</doc>
          <type name="SnippetHook" c:type="CoglSnippetHook"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="702">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_post"
              c:identifier="cogl_snippet_get_post"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-snippet.h" line="862"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-snippet.h"
               line="855">the source string that was set with
  cogl_snippet_set_post() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="853">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pre"
              c:identifier="cogl_snippet_get_pre"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-snippet.h" line="794"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-snippet.h"
               line="787">the source string that was set with
  cogl_snippet_set_pre() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="785">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_replace"
              c:identifier="cogl_snippet_get_replace"
              version="1.10"
              stability="Unstable">
        <source-position filename="cogl-snippet.h" line="828"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-snippet.h"
               line="821">the source string that was set with
  cogl_snippet_set_replace() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="819">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_declarations"
              c:identifier="cogl_snippet_set_declarations"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="727">Sets a source string that will be inserted in the global scope of
the generated shader when this snippet is used on a pipeline. This
string is typically used to declare uniforms, attributes or
functions that will be used by the other parts of the snippets.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl-snippet.h" line="746"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="729">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="declarations" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="730">The new source string for the declarations section
  of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_post"
              c:identifier="cogl_snippet_set_post"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="830">Sets a source string that will be inserted after the hook point in
the generated shader for the pipeline that this snippet is attached
to. Please see the documentation of each hook point in
#CoglPipeline for a description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl-snippet.h" line="848"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="832">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="post" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="833">The new source string for the post section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pre"
              c:identifier="cogl_snippet_set_pre"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="762">Sets a source string that will be inserted before the hook point in
the generated shader for the pipeline that this snippet is attached
to. Please see the documentation of each hook point in
#CoglPipeline for a description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl-snippet.h" line="780"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="764">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="pre" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="765">The new source string for the pre section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_replace"
              c:identifier="cogl_snippet_set_replace"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="796">Sets a source string that will be used instead of any generated
source code or any previous snippets for this hook point. Please
see the documentation of each hook point in #CoglPipeline for a
description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl-snippet.h" line="814"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="798">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="replace" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-snippet.h"
                 line="799">The new source string for the replace section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="SnippetHook"
                 version="1.10"
                 stability="Unstable"
                 c:type="CoglSnippetHook">
      <doc xml:space="preserve"
           filename="cogl-snippet.h"
           line="355">#CoglSnippetHook is used to specify a location within a
#CoglPipeline where the code of the snippet should be used when it
is attached to a pipeline.

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_VERTEX_GLOBALS&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet at the beginning of the global section of the
shader for the vertex processing. Any declarations here can be
shared with all other snippets that are attached to a vertex hook.
Only the ‘declarations’ string is used and the other strings are
ignored.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_FRAGMENT_GLOBALS&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet at the beginning of the global section of the
shader for the fragment processing. Any declarations here can be
shared with all other snippets that are attached to a fragment
hook. Only the ‘declarations’ string is used and the other strings
are ignored.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_VERTEX&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the vertex processing
stage of the pipeline. This gives a chance for the application to
modify the vertex attributes generated by the shader. Typically the
snippet will modify cogl_color_out or cogl_position_out builtins.
&lt;/para&gt;
&lt;para&gt;
The ‘declarations’ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The ‘pre’ string in @snippet will be inserted at the top of the
main() function before any vertex processing is done.
&lt;/para&gt;
&lt;para&gt;
The ‘replace’ string in @snippet will be used instead of the
generated vertex processing if it is present. This can be used if
the application wants to provide a complete vertex shader and
doesn't need the generated output from Cogl.
&lt;/para&gt;
&lt;para&gt;
The ‘post’ string in @snippet will be inserted after all of the
standard vertex processing is done. This can be used to modify the
outputs.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_VERTEX_TRANSFORM&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the vertex transform stage.
Typically the snippet will use the cogl_modelview_matrix,
cogl_projection_matrix and cogl_modelview_projection_matrix matrices and the
cogl_position_in attribute. The hook must write to cogl_position_out.
The default processing for this hook will multiply cogl_position_in by
the combined modelview-projection matrix and store it on cogl_position_out.
&lt;/para&gt;
&lt;para&gt;
The ‘declarations’ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The ‘pre’ string in @snippet will be inserted at the top of the
main() function before the vertex transform is done.
&lt;/para&gt;
&lt;para&gt;
The ‘replace’ string in @snippet will be used instead of the
generated vertex transform if it is present.
&lt;/para&gt;
&lt;para&gt;
The ‘post’ string in @snippet will be inserted after all of the
standard vertex transformation is done. This can be used to modify the
cogl_position_out in addition to the default processing.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_POINT_SIZE&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the point size
calculation step within the vertex shader stage. The snippet should
write to the builtin cogl_point_size_out with the new point size.
The snippet can either read cogl_point_size_in directly and write a
new value or first read an existing value in cogl_point_size_out
that would be set by a previous snippet. Note that this hook is
only used if cogl_pipeline_set_per_vertex_point_size() is enabled
on the pipeline.
&lt;/para&gt;
&lt;para&gt;
The ‘declarations’ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The ‘pre’ string in @snippet will be inserted just before
calculating the point size.
&lt;/para&gt;
&lt;para&gt;
The ‘replace’ string in @snippet will be used instead of the
generated point size calculation if it is present.
&lt;/para&gt;
&lt;para&gt;
The ‘post’ string in @snippet will be inserted after the
standard point size calculation is done. This can be used to modify
cogl_point_size_out in addition to the default processing.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_FRAGMENT&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the fragment processing
stage of the pipeline. This gives a chance for the application to
modify the fragment color generated by the shader. Typically the
snippet will modify cogl_color_out.
&lt;/para&gt;
&lt;para&gt;
The ‘declarations’ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The ‘pre’ string in @snippet will be inserted at the top of the
main() function before any fragment processing is done.
&lt;/para&gt;
&lt;para&gt;
The ‘replace’ string in @snippet will be used instead of the
generated fragment processing if it is present. This can be used if
the application wants to provide a complete fragment shader and
doesn't need the generated output from Cogl.
&lt;/para&gt;
&lt;para&gt;
The ‘post’ string in @snippet will be inserted after all of the
standard fragment processing is done. At this point the generated
value for the rest of the pipeline state will already be in
cogl_color_out so the application can modify the result by altering
this variable.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM&lt;/glossterm&gt;
   &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the texture coordinate
transformation of a particular layer. This can be used to replace
the processing for a layer or to modify the results.
&lt;/para&gt;
&lt;para&gt;
Within the snippet code for this hook there are two extra
variables. The first is a mat4 called cogl_matrix which represents
the user matrix for this layer. The second is called cogl_tex_coord
and represents the incoming and outgoing texture coordinate. On
entry to the hook, cogl_tex_coord contains the value of the
corresponding texture coordinate attribute for this layer. The hook
is expected to modify this variable. The output will be passed as a
varying to the fragment processing stage. The default code will
just multiply cogl_matrix by cogl_tex_coord and store the result in
cogl_tex_coord.
&lt;/para&gt;
&lt;para&gt;
The ‘declarations’ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The ‘pre’ string in @snippet will be inserted just before the
fragment processing for this layer. At this point cogl_tex_coord
still contains the value of the texture coordinate attribute.
&lt;/para&gt;
&lt;para&gt;
If a ‘replace’ string is given then this will be used instead of
the default fragment processing for this layer. The snippet can
modify cogl_tex_coord or leave it as is to apply no transformation.
&lt;/para&gt;
&lt;para&gt;
The ‘post’ string in @snippet will be inserted just after the
transformation. At this point cogl_tex_coord will contain the
results of the transformation but it can be further modified by the
snippet.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_LAYER_FRAGMENT&lt;/glossterm&gt;
   &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the fragment processing
of a particular layer. This can be used to replace the processing
for a layer or to modify the results.
&lt;/para&gt;
&lt;para&gt;
Within the snippet code for this hook there is an extra vec4
variable called ‘cogl_layer’. This contains the resulting color
that will be used for the layer. This can be modified in the ‘post’
section or it the default processing can be replaced entirely using
the ‘replace’ section.
&lt;/para&gt;
&lt;para&gt;
The ‘declarations’ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The ‘pre’ string in @snippet will be inserted just before the
fragment processing for this layer.
&lt;/para&gt;
&lt;para&gt;
If a ‘replace’ string is given then this will be used instead of
the default fragment processing for this layer. The snippet must write to
the ‘cogl_layer’ variable in that case.
&lt;/para&gt;
&lt;para&gt;
The ‘post’ string in @snippet will be inserted just after the
fragment processing for the layer. The results can be modified by changing
the value of the ‘cogl_layer’ variable.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;%COGL_SNIPPET_HOOK_TEXTURE_LOOKUP&lt;/glossterm&gt;
  &lt;glossdef&gt;
&lt;para&gt;
Adds a shader snippet that will hook on to the texture lookup part
of a given layer. This gives a chance for the application to modify
the coordinates that will be used for the texture lookup or to
alter the returned texel.
&lt;/para&gt;
&lt;para&gt;
Within the snippet code for this hook there are three extra
variables available. ‘cogl_sampler’ is a sampler object
representing the sampler for the layer where the snippet is
attached. ‘cogl_tex_coord’ is a vec4 which contains the texture
coordinates that will be used for the texture lookup. This can be
modified. ‘cogl_texel’ will contain the result of the texture
lookup. This can also be modified.
&lt;/para&gt;
&lt;para&gt;
The ‘declarations’ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.
&lt;/para&gt;
&lt;para&gt;
The ‘pre’ string in @snippet will be inserted at the top of the
main() function before any fragment processing is done. This is a
good place to modify the cogl_tex_coord variable.
&lt;/para&gt;
&lt;para&gt;
If a ‘replace’ string is given then this will be used instead of a
the default texture lookup. The snippet would typically use its own
sampler in this case.
&lt;/para&gt;
&lt;para&gt;
The ‘post’ string in @snippet will be inserted after texture lookup
has been preformed. Here the snippet can modify the cogl_texel
variable to alter the returned texel.
&lt;/para&gt;
  &lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;</doc>
      <source-position filename="cogl-snippet.h" line="677"/>
      <member name="vertex" value="0" c:identifier="COGL_SNIPPET_HOOK_VERTEX">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="363">A hook for the entire vertex processing
  stage of the pipeline.</doc>
      </member>
      <member name="vertex_transform"
              value="1"
              c:identifier="COGL_SNIPPET_HOOK_VERTEX_TRANSFORM">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="365">A hook for the vertex transformation.</doc>
      </member>
      <member name="vertex_globals"
              value="2"
              c:identifier="COGL_SNIPPET_HOOK_VERTEX_GLOBALS">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="357">A hook for declaring global data
  that can be shared with all other snippets that are on a vertex
  hook.</doc>
      </member>
      <member name="point_size"
              value="3"
              c:identifier="COGL_SNIPPET_HOOK_POINT_SIZE">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="366">A hook for manipulating the point
  size of a vertex. This is only used if
  cogl_pipeline_set_per_vertex_point_size() is enabled on the
  pipeline.</doc>
      </member>
      <member name="fragment"
              value="2048"
              c:identifier="COGL_SNIPPET_HOOK_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="370">A hook for the entire fragment
  processing stage of the pipeline.</doc>
      </member>
      <member name="fragment_globals"
              value="2049"
              c:identifier="COGL_SNIPPET_HOOK_FRAGMENT_GLOBALS">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="360">A hook for declaring global
  data wthat can be shared with all other snippets that are on a
  fragment hook.</doc>
      </member>
      <member name="texture_coord_transform"
              value="4096"
              c:identifier="COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="372">A hook for applying the
  layer matrix to a texture coordinate for a layer.</doc>
      </member>
      <member name="layer_fragment"
              value="6144"
              c:identifier="COGL_SNIPPET_HOOK_LAYER_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="374">A hook for the fragment
  processing of a particular layer.</doc>
      </member>
      <member name="texture_lookup"
              value="6145"
              c:identifier="COGL_SNIPPET_HOOK_TEXTURE_LOOKUP">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="376">A hook for the texture lookup
  stage of a given layer in a pipeline.</doc>
      </member>
    </enumeration>
    <enumeration name="StereoMode"
                 glib:type-name="CoglStereoMode"
                 glib:get-type="cogl_stereo_mode_get_type"
                 c:type="CoglStereoMode">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="923">Represents how draw should affect the two buffers
of a stereo framebuffer. See cogl_framebuffer_set_stereo_mode().</doc>
      <member name="both"
              value="0"
              c:identifier="COGL_STEREO_BOTH"
              glib:nick="both"
              glib:name="COGL_STEREO_BOTH">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="925">draw to both stereo buffers</doc>
      </member>
      <member name="left"
              value="1"
              c:identifier="COGL_STEREO_LEFT"
              glib:nick="left"
              glib:name="COGL_STEREO_LEFT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="926">draw only to the left stereo buffer</doc>
      </member>
      <member name="right"
              value="2"
              c:identifier="COGL_STEREO_RIGHT"
              glib:nick="right"
              glib:name="COGL_STEREO_RIGHT">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="927">draw only to the left stereo buffer</doc>
      </member>
    </enumeration>
    <class name="SubTexture"
           c:symbol-prefix="sub_texture"
           c:type="CoglSubTexture"
           parent="Object"
           glib:type-name="CoglSubTexture"
           glib:get-type="cogl_sub_texture_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_sub_texture_new"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-sub-texture.h"
             line="64">Creates a high-level #CoglSubTexture representing a sub-region of
any other #CoglTexture. The sub-region must strictly lye within the
bounds of the @parent_texture. The returned texture implements the
#CoglMetaTexture interface because it's not a low level texture
that hardware can understand natively.

&lt;note&gt;Remember: Unless you are using high level drawing APIs such
as cogl_rectangle() or other APIs documented to understand the
#CoglMetaTexture interface then you need to use the
#CoglMetaTexture interface to resolve a #CoglSubTexture into a
low-level texture before drawing.&lt;/note&gt;</doc>
        <source-position filename="cogl-sub-texture.h" line="96"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-sub-texture.h"
               line="89">A newly allocated #CoglSubTexture
         representing a sub-region of @parent_texture.</doc>
          <type name="SubTexture" c:type="CoglSubTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-sub-texture.h"
                 line="66">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="parent_texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-sub-texture.h"
                 line="67">The full texture containing a sub-region you want
                 to make a #CoglSubTexture from.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
          <parameter name="sub_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-sub-texture.h"
                 line="69">The top-left x coordinate of the parent region to make
        a texture from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-sub-texture.h"
                 line="71">The top-left y coordinate of the parent region to make
        a texture from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-sub-texture.h"
                 line="73">The width of the parent region to make a texture from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-sub-texture.h"
                 line="74">The height of the parent region to make a texture
             from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_parent"
              c:identifier="cogl_sub_texture_get_parent"
              version="1.10"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-sub-texture.h"
             line="103">Retrieves the parent texture that @sub_texture derives its content
from.  This is the texture that was passed to
cogl_sub_texture_new() as the parent_texture argument.</doc>
        <source-position filename="cogl-sub-texture.h" line="117"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-sub-texture.h"
               line="111">The parent texture that @sub_texture
              derives its content from.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sub_texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-sub-texture.h"
                 line="105">A pointer to a #CoglSubTexture</doc>
            <type name="SubTexture" c:type="CoglSubTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="SubpixelOrder"
                 version="1.14"
                 stability="Unstable"
                 c:type="CoglSubpixelOrder">
      <doc xml:space="preserve"
           filename="cogl-output.h"
           line="82">Some output devices (such as LCD panels) display colors
by making each pixel consist of smaller "subpixels"
that each have a particular color. By using knowledge
of the layout of this subpixel components, it is possible
to create image content with higher resolution than the
pixel grid.</doc>
      <source-position filename="cogl-output.h" line="120"/>
      <member name="unknown"
              value="0"
              c:identifier="COGL_SUBPIXEL_ORDER_UNKNOWN">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="84">the layout of subpixel
  components for the device is unknown.</doc>
      </member>
      <member name="none" value="1" c:identifier="COGL_SUBPIXEL_ORDER_NONE">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="86">the device displays colors
  without geometrically-separated subpixel components,
  or the positioning or colors of the components do not
  match any of the values in the enumeration.</doc>
      </member>
      <member name="horizontal_rgb"
              value="2"
              c:identifier="COGL_SUBPIXEL_ORDER_HORIZONTAL_RGB">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="90">the device has
  horizontally arranged components in the order
  red-green-blue from left to right.</doc>
      </member>
      <member name="horizontal_bgr"
              value="3"
              c:identifier="COGL_SUBPIXEL_ORDER_HORIZONTAL_BGR">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="93">the device has
  horizontally arranged  components in the order
  blue-green-red from left to right.</doc>
      </member>
      <member name="vertical_rgb"
              value="4"
              c:identifier="COGL_SUBPIXEL_ORDER_VERTICAL_RGB">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="96">the device has
  vertically arranged components in the order
  red-green-blue from top to bottom.</doc>
      </member>
      <member name="vertical_bgr"
              value="5"
              c:identifier="COGL_SUBPIXEL_ORDER_VERTICAL_BGR">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="99">the device has
  vertically arranged components in the order
  blue-green-red from top to bottom.</doc>
      </member>
    </enumeration>
    <callback name="SwapBuffersNotify" c:type="CoglSwapBuffersNotify">
      <source-position filename="cogl-onscreen.h" line="704"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="framebuffer" transfer-ownership="none">
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="SwapChain"
           c:symbol-prefix="swap_chain"
           c:type="CoglSwapChain"
           parent="Object"
           glib:type-name="CoglSwapChain"
           glib:get-type="cogl_swap_chain_get_gtype"
           glib:fundamental="1">
      <constructor name="new" c:identifier="cogl_swap_chain_new">
        <source-position filename="cogl-swap-chain.h" line="56"/>
        <return-value transfer-ownership="full">
          <type name="SwapChain" c:type="CoglSwapChain*"/>
        </return-value>
      </constructor>
      <method name="set_has_alpha"
              c:identifier="cogl_swap_chain_set_has_alpha">
        <source-position filename="cogl-swap-chain.h" line="59"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="swap_chain" transfer-ownership="none">
            <type name="SwapChain" c:type="CoglSwapChain*"/>
          </instance-parameter>
          <parameter name="has_alpha" transfer-ownership="none">
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_length" c:identifier="cogl_swap_chain_set_length">
        <source-position filename="cogl-swap-chain.h" line="63"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="swap_chain" transfer-ownership="none">
            <type name="SwapChain" c:type="CoglSwapChain*"/>
          </instance-parameter>
          <parameter name="length" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="SystemError"
                 version="1.4"
                 stability="Unstable"
                 glib:type-name="CoglSystemError"
                 glib:get-type="cogl_system_error_get_type"
                 c:type="CoglSystemError">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="632">Error enumeration for Cogl

The @COGL_SYSTEM_ERROR_UNSUPPORTED error can be thrown for a
variety of reasons. For example:

&lt;itemizedlist&gt;
 &lt;listitem&gt;&lt;para&gt;You've tried to use a feature that is not
  advertised by cogl_has_feature(). This could happen if you create
  a 2d texture with a non-power-of-two size when
  %COGL_FEATURE_ID_TEXTURE_NPOT is not advertised.&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The GPU can not handle the configuration you have
  requested. An example might be if you try to use too many texture
  layers in a single #CoglPipeline&lt;/para&gt;&lt;/listitem&gt;
 &lt;listitem&gt;&lt;para&gt;The driver does not support some
  configuration.&lt;/para&gt;&lt;/listiem&gt;
&lt;/itemizedlist&gt;

Currently this is only used by Cogl API marked as experimental so
this enum should also be considered experimental.</doc>
      <member name="cogl_system_error_unsupported"
              value="0"
              c:identifier="COGL_SYSTEM_ERROR_UNSUPPORTED"
              glib:nick="cogl-system-error-unsupported"
              glib:name="COGL_SYSTEM_ERROR_UNSUPPORTED">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="634">You tried to use a feature or
   configuration not currently available.</doc>
      </member>
      <member name="cogl_system_error_no_memory"
              value="1"
              c:identifier="COGL_SYSTEM_ERROR_NO_MEMORY"
              glib:nick="cogl-system-error-no-memory"
              glib:name="COGL_SYSTEM_ERROR_NO_MEMORY">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="636">You tried to allocate a resource
   such as a texture and there wasn't enough memory.</doc>
      </member>
    </enumeration>
    <function-macro name="TEXTURE"
                    c:identifier="COGL_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl-texture.h" line="48"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D"
                    c:identifier="COGL_TEXTURE_2D"
                    introspectable="0">
      <source-position filename="cogl-texture-2d.h" line="62"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_SLICED"
                    c:identifier="COGL_TEXTURE_2D_SLICED"
                    introspectable="0">
      <source-position filename="cogl-texture-2d-sliced.h" line="71"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_3D"
                    c:identifier="COGL_TEXTURE_3D"
                    introspectable="0">
      <source-position filename="cogl-texture-3d.h" line="53"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TEXTURE_MAX_WASTE"
              value="127"
              c:type="COGL_TEXTURE_MAX_WASTE">
      <source-position filename="cogl-texture.h" line="74"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="TEXTURE_PIXMAP_X11"
                    c:identifier="COGL_TEXTURE_PIXMAP_X11"
                    introspectable="0">
      <source-position filename="winsys/cogl-texture-pixmap-x11.h" line="73"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_RECTANGLE"
                    c:identifier="COGL_TEXTURE_RECTANGLE"
                    introspectable="0">
      <source-position filename="cogl-texture-rectangle.h" line="70"/>
      <parameters>
        <parameter name="X">
        </parameter>
      </parameters>
    </function-macro>
    <interface name="Texture"
               c:symbol-prefix="texture"
               glib:type-name="CoglTexture"
               glib:get-type="cogl_texture_get_gtype">
      <prerequisite name="Object"/>
      <method name="allocate" c:identifier="cogl_texture_allocate" throws="1">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="500">Explicitly allocates the storage for the given @texture which
allows you to be sure that there is enough memory for the
texture and if not then the error can be handled gracefully.

&lt;note&gt;Normally applications don't need to use this api directly
since the texture will be implicitly allocated when data is set on
the texture, or if the texture is attached to a #CoglOffscreen
framebuffer and rendered too.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture.h" line="519"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="514">%TRUE if the texture was successfully allocated,
              otherwise %FALSE and @error will be updated if it
              wasn't %NULL.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="502">A #CoglTexture</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_components"
              c:identifier="cogl_texture_get_components"
              version="1.18">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="199">Queries what components the given @texture stores internally as set
via cogl_texture_set_components().

For textures created by the ‘_with_size’ constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.</doc>
        <source-position filename="cogl-texture.h" line="214"/>
        <return-value transfer-ownership="none">
          <type name="TextureComponents" c:type="CoglTextureComponents"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="201">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="cogl_texture_get_data">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="337">Copies the pixel data from a cogl texture to system memory.

&lt;note&gt;Don't pass the value of cogl_texture_get_rowstride() as the
@rowstride argument, the rowstride should be the rowstride you
want for the destination @data buffer not the rowstride of the
source texture&lt;/note&gt;</doc>
        <source-position filename="cogl-texture.h" line="357"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="354">the size of the texture data in bytes</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="339">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="340">the #CoglPixelFormat to store the texture as.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="341">the rowstride of @data in bytes or pass 0 to calculate
            from the bytes-per-pixel of @format multiplied by the
            @texture width.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="344">memory location to write the @texture's contents, or %NULL
to only query the data size through the return value.</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_gl_texture" c:identifier="cogl_texture_get_gl_texture">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="316">Queries the GL handles for a GPU side texture through its #CoglTexture.

If the texture is spliced the data for the first sub texture will be
queried.</doc>
        <source-position filename="cogl-texture.h" line="333"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="329">%TRUE if the handle was successfully retrieved, %FALSE
  if the handle was invalid</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="318">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="out_gl_handle"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="319">pointer to return location for the
  textures GL handle, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
          <parameter name="out_gl_target"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="321">pointer to return location for the
  GL target type, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_texture_get_height">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="280">Queries the height of a cogl texture.</doc>
        <source-position filename="cogl-texture.h" line="289"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="286">the height of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="282">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_waste" c:identifier="cogl_texture_get_max_waste">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="291">Queries the maximum wasted (unused) pixels in one dimension of a GPU side
texture.</doc>
        <source-position filename="cogl-texture.h" line="301"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="298">the maximum waste</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="293">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_premultiplied"
              c:identifier="cogl_texture_get_premultiplied"
              version="1.18">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="251">Queries the pre-multiplied alpha status for internally stored red,
green and blue components for the given @texture as set by
cogl_texture_set_premultiplied().

By default the pre-multipled state is @TRUE.</doc>
        <source-position filename="cogl-texture.h" line="267"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="261">%TRUE if red, green and blue components are
              internally stored pre-multiplied by the alpha
              value or %FALSE if not.</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="253">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_texture_get_width">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="269">Queries the width of a cogl texture.</doc>
        <source-position filename="cogl-texture.h" line="278"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="275">the width of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="271">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_sliced" c:identifier="cogl_texture_is_sliced">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="303">Queries if a texture is sliced (stored as multiple GPU side tecture
objects).</doc>
        <source-position filename="cogl-texture.h" line="314"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="310">%TRUE if the texture is sliced, %FALSE if the texture
  is stored as a single GPU texture</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="305">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_components"
              c:identifier="cogl_texture_set_components"
              version="1.18">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="169">Affects the internal storage format for this texture by specifying
what components will be required for sampling later.

This api affects how data is uploaded to the GPU since unused
components can potentially be discarded from source data.

For textures created by the ‘_with_size’ constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.

Note that the %COGL_TEXTURE_COMPONENTS_RG format is not available
on all drivers. The availability can be determined by checking for
the %COGL_FEATURE_ID_TEXTURE_RG feature. If this format is used on
a driver where it is not available then %COGL_TEXTURE_ERROR_FORMAT
will be raised when the texture is allocated. Even if the feature
is not available then %COGL_PIXEL_FORMAT_RG_88 can still be used as
an image format as long as %COGL_TEXTURE_COMPONENTS_RG isn't used
as the texture's components.</doc>
        <source-position filename="cogl-texture.h" line="196"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="171">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="components" transfer-ownership="none">
            <type name="TextureComponents" c:type="CoglTextureComponents"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="cogl_texture_set_data" throws="1">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="404">@texture a #CoglTexture.
Sets all the pixels for a given mipmap @level by copying the pixel
data pointed to by the @data argument into the given @texture.

@data should point to the first pixel to copy corresponding
to the top left of the mipmap @level being set.

If @rowstride equals 0 then it will be automatically calculated
from the width of the mipmap level and the bytes-per-pixel for the
given @format.

A mipmap @level of 0 corresponds to the largest, base image of a
texture and @level 1 is half the width and height of level 0. If
dividing any dimension of the previous level by two results in a
fraction then round the number down (floor()), but clamp to 1
something like this:

|[
 next_width = MAX (1, floor (prev_width));
]|

You can determine the number of mipmap levels for a given texture
like this:

|[
 n_levels = 1 + floor (log2 (max_dimension));
]|

Where %max_dimension is the larger of cogl_texture_get_width() and
cogl_texture_get_height().

It is an error to pass a @level number &gt;= the number of levels that
@texture can have according to the above calculation.

&lt;note&gt;Since the storage for a #CoglTexture is allocated lazily then
if the given @texture has not previously been allocated then this
api can return %FALSE and throw an exceptional @error if there is
not enough memory to allocate storage for @texture.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture.h" line="457"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="453">%TRUE if the data upload was successful, and
              %FALSE otherwise</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="407">the #CoglPixelFormat used in the source @data buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="408">rowstride of the source @data buffer (computed from
            the texture width and @format if it equals 0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="410">the source data, pointing to the first top-left pixel to set</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="411">The mipmap level to update (Normally 0 for the largest,
        base texture)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_premultiplied"
              c:identifier="cogl_texture_set_premultiplied"
              version="1.18">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="216">Affects the internal storage format for this texture by specifying
whether red, green and blue color components should be stored as
pre-multiplied alpha values.

This api affects how data is uploaded to the GPU since Cogl will
convert source data to have premultiplied or unpremultiplied
components according to this state.

For example if you create a texture via
cogl_texture_2d_new_with_size() and then upload data via
cogl_texture_set_data() passing a source format of
%COGL_PIXEL_FORMAT_RGBA_8888 then Cogl will internally multiply the
red, green and blue components of the source data by the alpha
component, for each pixel so that the internally stored data has
pre-multiplied alpha components. If you instead upload data that
already has pre-multiplied components by passing
%COGL_PIXEL_FORMAT_RGBA_8888_PRE as the source format to
cogl_texture_set_data() then the data can be uploaded without being
converted.

By default the @premultipled state is @TRUE.</doc>
        <source-position filename="cogl-texture.h" line="248"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="218">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="premultiplied" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="219">Whether any internally stored red, green or blue
                components are pre-multiplied by an alpha
                component.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region" c:identifier="cogl_texture_set_region">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="362">Sets the pixels in a rectangular subregion of @texture from an in-memory
buffer containing pixel data.

&lt;note&gt;The region set can't be larger than the source @data&lt;/note&gt;</doc>
        <source-position filename="cogl-texture.h" line="389"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="385">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="364">a #CoglTexture.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="365">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="366">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="367">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="368">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="369">width of destination region to write. (Must be less
  than or equal to @width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="371">height of destination region to write. (Must be less
  than or equal to @height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="373">width of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="374">height of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="375">the #CoglPixelFormat used in the source buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="376">rowstride of source buffer (computed from width if none
specified)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="378">the actual pixel data.</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region_from_bitmap"
              c:identifier="cogl_texture_set_region_from_bitmap"
              version="1.8"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="464">Copies a specified source region from @bitmap to the position
(@src_x, @src_y) of the given destination texture @handle.

&lt;note&gt;The region updated can't be larger than the source
bitmap&lt;/note&gt;</doc>
        <source-position filename="cogl-texture.h" line="490"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="483">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="466">a #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="467">upper left coordinate to use from the source bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="468">upper left coordinate to use from the source bitmap</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="469">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="470">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="471">width of destination region to write. (Must be less
  than or equal to the bitmap width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="473">height of destination region to write. (Must be less
  than or equal to the bitmap height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture.h"
                 line="475">The source bitmap to read from</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
    </interface>
    <class name="Texture2D"
           c:symbol-prefix="texture_2d"
           c:type="CoglTexture2D"
           parent="Object"
           glib:type-name="CoglTexture2D"
           glib:get-type="cogl_texture_2d_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="gl_new_from_foreign"
                   c:identifier="cogl_texture_2d_gl_new_from_foreign"
                   version="2.0">
        <doc xml:space="preserve"
             filename="cogl-texture-2d-gl.h"
             line="45">Wraps an existing GL_TEXTURE_2D texture object as a #CoglTexture2D.
This can be used for integrating Cogl with software using OpenGL
directly.

The texture is still configurable until it has been allocated so
for example you can declare whether the texture is premultiplied
with cogl_texture_set_premultiplied().

&lt;note&gt;The results are undefined for passing an invalid @gl_handle
or if @width or @height don't have the correct texture
geometry.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d-gl.h" line="70"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d-gl.h"
               line="65">A newly allocated #CoglTexture2D</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-gl.h"
                 line="47">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="gl_handle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-gl.h"
                 line="48">A GL handle for a GL_TEXTURE_2D texture object</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-gl.h"
                 line="49">Width of the foreign GL texture</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-gl.h"
                 line="50">Height of the foreign GL texture</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-gl.h"
                 line="51">The format of the texture</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_new_from_bitmap"
                   version="2.0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-texture-2d.h"
             line="201">Creates a low-level #CoglTexture2D texture based on data residing
in a #CoglBitmap.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d.h" line="230"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d.h"
               line="224">A newly allocated #CoglTexture2D</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="203">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_2d_new_from_data"
                   version="2.0"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-texture-2d.h"
             line="154">Creates a low-level #CoglTexture2D texture based on data residing
in memory.

&lt;note&gt;This api will always immediately allocate GPU memory for the
texture and upload the given data so that the @data pointer does
not need to remain valid once this function returns. This means it
is not possible to configure the texture before it is allocated. If
you do need to configure the texture before allocation (to specify
constraints on the internal format for example) then you can
instead create a #CoglBitmap for your data and use
cogl_texture_2d_new_from_bitmap() or use
cogl_texture_2d_new_with_size() and then upload data using
cogl_texture_set_data()&lt;/note&gt;

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d.h" line="193"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d.h"
               line="185">A newly allocated #CoglTexture2D, or if
         the size is not supported (because it is too large or a
         non-power-of-two size that the hardware doesn't support)
         it will return %NULL and set @error.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="156">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="157">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="158">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="159">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="160">the memory offset in bytes between the starts of
   scanlines in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="163">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_texture_2d_new_from_file"
                   version="1.16"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-texture-2d.h"
             line="120">Creates a low-level #CoglTexture2D texture from an image file.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d.h" line="150"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d.h"
               line="144">A newly created #CoglTexture2D or %NULL on failure
              and @error will be updated.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="122">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="123">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_new_with_size"
                   version="2.0">
        <doc xml:space="preserve"
             filename="cogl-texture-2d.h"
             line="86">Creates a low-level #CoglTexture2D texture with a given @width and
@height that your GPU can texture from directly.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;Many GPUs only support power of two sizes for #CoglTexture2D
textures. You can check support for non power of two textures by
checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature via
cogl_has_feature().&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d.h" line="116"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d.h"
               line="111">A new #CoglTexture2D object with no storage yet allocated.</doc>
          <type name="Texture2D" c:type="CoglTexture2D*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="88">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="89">Width of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d.h"
                 line="90">Height of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="Texture2DSliced"
           c:symbol-prefix="texture_2d_sliced"
           c:type="CoglTexture2DSliced"
           parent="Object"
           glib:type-name="CoglTexture2DSliced"
           glib:get-type="cogl_texture_2d_sliced_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_sliced_new_from_bitmap"
                   version="1.16">
        <doc xml:space="preserve"
             filename="cogl-texture-2d-sliced.h"
             line="242">Creates a new #CoglTexture2DSliced texture based on data residing
in a bitmap.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size is
larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d-sliced.h" line="284"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d-sliced.h"
               line="278">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="bmp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="244">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="245">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_2d_sliced_new_from_data"
                   version="1.16"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-texture-2d-sliced.h"
             line="177">Creates a new #CoglTexture2DSliced texture based on data residing
in memory.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

&lt;note&gt;This api will always immediately allocate GPU memory for all
the required texture slices and upload the given data so that the
@data pointer does not need to remain valid once this function
returns. This means it is not possible to configure the texture
before it is allocated. If you do need to configure the texture
before allocation (to specify constraints on the internal format
for example) then you can instead create a #CoglBitmap for your
data and use cogl_texture_2d_sliced_new_from_bitmap() or use
cogl_texture_2d_sliced_new_with_size() and then upload data using
cogl_texture_set_data()&lt;/note&gt;

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
due to impossible slicing constraints if a negative @max_waste
value is given. If the given virtual texture size is larger than is
supported by the hardware but slicing is disabled the texture size
would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d-sliced.h" line="233"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d-sliced.h"
               line="227">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="179">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="180">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="181">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="183">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="182">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="187">the memory offset in bytes between the start of each
   row in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="190">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_file"
                   c:identifier="cogl_texture_2d_sliced_new_from_file"
                   version="1.16"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-texture-2d-sliced.h"
             line="129">Creates a #CoglTexture2DSliced from an image file.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size is
larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d-sliced.h" line="172"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d-sliced.h"
               line="166">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="131">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="132">the file to load</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="133">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_sliced_new_with_size"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-texture-2d-sliced.h"
             line="82">Creates a #CoglTexture2DSliced that may internally be comprised of
1 or more #CoglTexture2D textures depending on GPU limitations.
For example if the GPU only supports power-of-two sized textures
then a sliced texture will turn a non-power-of-two size into a
combination of smaller power-of-two sized textures. If the
requested texture size is larger than is supported by the hardware
then the texture will be sliced into smaller textures that can be
accessed by the hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

&lt;note&gt;It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size size
is larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-2d-sliced.h" line="124"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-2d-sliced.h"
               line="117">A new #CoglTexture2DSliced object with no storage
         allocated yet.</doc>
          <type name="Texture2DSliced" c:type="CoglTexture2DSliced*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="84">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="85">The virtual width of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="86">The virtual height of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-2d-sliced.h"
                 line="87">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <class name="Texture3D"
           c:symbol-prefix="texture_3d"
           c:type="CoglTexture3D"
           parent="Object"
           glib:type-name="CoglTexture3D"
           glib:get-type="cogl_texture_3d_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_3d_new_from_bitmap"
                   version="2.0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-texture-3d.h"
             line="148">Creates a low-level 3D texture and initializes it with the images
in @bitmap. The images are assumed to be packed together after one
another in the increasing y axis. The height of individual image is
given as @height and the number of images is given in @depth. The
actual height of the bitmap can be larger than @height × @depth. In
this case it assumes there is padding between the images.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is going to be used and can optimize how it is
allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;This texture will fail to allocate later if
%COGL_FEATURE_ID_TEXTURE_3D is not advertised. Allocation can also
fail if the requested dimensions are not supported by the
GPU.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-3d.h" line="183"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-3d.h"
               line="178">a newly created #CoglTexture3D</doc>
          <type name="Texture3D" c:type="CoglTexture3D*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="150">A #CoglBitmap object.</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="151">height of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="152">depth of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_3d_new_from_data"
                   version="1.10"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl-texture-3d.h"
             line="101">Creates a low-level 3D texture and initializes it with @data. The
data is assumed to be packed array of @depth images. There can be
padding between the images using @image_stride.

&lt;note&gt;This api will always immediately allocate GPU memory for the
texture and upload the given data so that the @data pointer does
not need to remain valid once this function returns. This means it
is not possible to configure the texture before it is allocated. If
you do need to configure the texture before allocation (to specify
constraints on the internal format for example) then you can
instead create a #CoglBitmap for your data and use
cogl_texture_3d_new_from_bitmap().&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-3d.h" line="138"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-3d.h"
               line="131">the newly created #CoglTexture3D or
              %NULL if there was an error and an exception will be
              returned through @error.</doc>
          <type name="Texture3D" c:type="CoglTexture3D*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="103">a #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="104">width of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="105">height of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="106">depth of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="107">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="108">the memory offset in bytes between the starts of
   scanlines in @data or 0 to infer it from the width and format</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="image_stride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="110">the number of bytes from one image to the next. This
   can be used to add padding between the images in a similar way
   that the rowstride can be used to add padding between
   rows. Alternatively 0 can be passed to infer the @image_stride
   from the @height.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="115">pointer the memory region where the source buffer resides</doc>
            <type name="guint8" c:type="const uint8_t*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_3d_new_with_size"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-texture-3d.h"
             line="64">Creates a low-level #CoglTexture3D texture with the specified
dimensions and pixel format.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is going to be used and can optimize how it is
allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

&lt;note&gt;This texture will fail to allocate later if
%COGL_FEATURE_ID_TEXTURE_3D is not advertised. Allocation can also
fail if the requested dimensions are not supported by the
GPU.&lt;/note&gt;</doc>
        <source-position filename="cogl-texture-3d.h" line="96"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-3d.h"
               line="91">A new #CoglTexture3D object with no storage yet allocated.</doc>
          <type name="Texture3D" c:type="CoglTexture3D*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="66">a #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="67">width of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="68">height of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="depth" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-3d.h"
                 line="69">depth of the texture in pixels.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <enumeration name="TextureComponents"
                 version="1.18"
                 glib:type-name="CoglTextureComponents"
                 glib:get-type="cogl_texture_components_get_type"
                 c:type="CoglTextureComponents">
      <doc xml:space="preserve"
           filename="cogl-texture.h"
           line="146">See cogl_texture_set_components().</doc>
      <member name="a"
              value="1"
              c:identifier="COGL_TEXTURE_COMPONENTS_A"
              glib:nick="a"
              glib:name="COGL_TEXTURE_COMPONENTS_A">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="148">Only the alpha component</doc>
      </member>
      <member name="rg"
              value="2"
              c:identifier="COGL_TEXTURE_COMPONENTS_RG"
              glib:nick="rg"
              glib:name="COGL_TEXTURE_COMPONENTS_RG">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="149">Red and green components. Note that
  this can only be used if the %COGL_FEATURE_ID_TEXTURE_RG feature
  is advertised.</doc>
      </member>
      <member name="rgb"
              value="3"
              c:identifier="COGL_TEXTURE_COMPONENTS_RGB"
              glib:nick="rgb"
              glib:name="COGL_TEXTURE_COMPONENTS_RGB">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="152">Red, green and blue components</doc>
      </member>
      <member name="rgba"
              value="4"
              c:identifier="COGL_TEXTURE_COMPONENTS_RGBA"
              glib:nick="rgba"
              glib:name="COGL_TEXTURE_COMPONENTS_RGBA">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="153">Red, green, blue and alpha components</doc>
      </member>
      <member name="depth"
              value="5"
              c:identifier="COGL_TEXTURE_COMPONENTS_DEPTH"
              glib:nick="depth"
              glib:name="COGL_TEXTURE_COMPONENTS_DEPTH">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="154">Only a depth component</doc>
      </member>
    </enumeration>
    <enumeration name="TextureError"
                 version="1.8"
                 stability="Unstable"
                 glib:type-name="CoglTextureError"
                 glib:get-type="cogl_texture_error_get_type"
                 c:type="CoglTextureError">
      <doc xml:space="preserve"
           filename="cogl-texture.h"
           line="95">Error codes that can be thrown when allocating textures.</doc>
      <member name="size"
              value="0"
              c:identifier="COGL_TEXTURE_ERROR_SIZE"
              glib:nick="size"
              glib:name="COGL_TEXTURE_ERROR_SIZE">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="97">Unsupported size</doc>
      </member>
      <member name="format"
              value="1"
              c:identifier="COGL_TEXTURE_ERROR_FORMAT"
              glib:nick="format"
              glib:name="COGL_TEXTURE_ERROR_FORMAT">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="98">Unsupported format</doc>
      </member>
      <member name="bad_parameter"
              value="2"
              c:identifier="COGL_TEXTURE_ERROR_BAD_PARAMETER"
              glib:nick="bad-parameter"
              glib:name="COGL_TEXTURE_ERROR_BAD_PARAMETER">
      </member>
      <member name="type"
              value="3"
              c:identifier="COGL_TEXTURE_ERROR_TYPE"
              glib:nick="type"
              glib:name="COGL_TEXTURE_ERROR_TYPE">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="99">A primitive texture type that is
  unsupported by the driver was used</doc>
      </member>
      <function name="quark" c:identifier="cogl_texture_error_quark">
        <source-position filename="cogl-texture.h" line="132"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <bitfield name="TextureFlags"
              version="1.0"
              glib:type-name="CoglTextureFlags"
              glib:get-type="cogl_texture_flags_get_type"
              c:type="CoglTextureFlags">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="542">Flags to pass to the cogl_texture_new_* family of functions.</doc>
      <member name="none"
              value="0"
              c:identifier="COGL_TEXTURE_NONE"
              glib:nick="none"
              glib:name="COGL_TEXTURE_NONE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="544">No flags specified</doc>
      </member>
      <member name="no_auto_mipmap"
              value="1"
              c:identifier="COGL_TEXTURE_NO_AUTO_MIPMAP"
              glib:nick="no-auto-mipmap"
              glib:name="COGL_TEXTURE_NO_AUTO_MIPMAP">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="545">Disables the automatic generation of
  the mipmap pyramid from the base level image whenever it is
  updated. The mipmaps are only generated when the texture is
  rendered with a mipmap filter so it should be free to leave out
  this flag when using other filtering modes</doc>
      </member>
      <member name="no_slicing"
              value="2"
              c:identifier="COGL_TEXTURE_NO_SLICING"
              glib:nick="no-slicing"
              glib:name="COGL_TEXTURE_NO_SLICING">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="550">Disables the slicing of the texture</doc>
      </member>
      <member name="no_atlas"
              value="4"
              c:identifier="COGL_TEXTURE_NO_ATLAS"
              glib:nick="no-atlas"
              glib:name="COGL_TEXTURE_NO_ATLAS">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="551">Disables the insertion of the texture inside
  the texture atlas used by Cogl</doc>
      </member>
    </bitfield>
    <class name="TexturePixmapX11"
           c:symbol-prefix="texture_pixmap_x11"
           c:type="CoglTexturePixmapX11"
           parent="Object"
           glib:type-name="CoglTexturePixmapX11"
           glib:get-type="cogl_texture_pixmap_x11_get_gtype"
           glib:fundamental="1">
      <constructor name="new"
                   c:identifier="cogl_texture_pixmap_x11_new"
                   version="1.10"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="116">Creates a texture that contains the contents of @pixmap. If
@automatic_updates is %TRUE then Cogl will attempt to listen for
damage events on the pixmap and automatically update the texture
when it changes.</doc>
        <source-position filename="winsys/cogl-texture-pixmap-x11.h"
                         line="135"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="winsys/cogl-texture-pixmap-x11.h"
               line="129">a new #CoglTexturePixmapX11 instance</doc>
          <type name="TexturePixmapX11" c:type="CoglTexturePixmapX11*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="118">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="pixmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="119">A X11 pixmap ID</doc>
            <type name="guint32" c:type="uint32_t"/>
          </parameter>
          <parameter name="automatic_updates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="120">Whether to automatically copy the contents of
the pixmap to the texture.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_left"
                   c:identifier="cogl_texture_pixmap_x11_new_left"
                   version="1.20"
                   stability="Unstable"
                   throws="1">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="140">Creates one of a pair of textures to contain the contents of @pixmap,
which has stereo content. (Different images for the right and left eyes.)
The left image is drawn using this texture; the right image is drawn
using a texture created by calling
cogl_texture_pixmap_x11_new_right() and passing in this texture as an
argument.

In general, you should not use this function unless you have
queried the %GLX_STEREO_TREE_EXT attribute of the corresponding
window using glXQueryDrawable() and determined that the window is
stereo. Note that this attribute can change over time and
notification is also provided through events defined in the
EXT_stereo_tree GLX extension. As long as the system has support for
stereo content, drawing using the left and right pixmaps will not
produce an error even if the window doesn't have stereo
content any more, but drawing with the right pixmap will produce
undefined output, so you need to listen for these events and
re-render to avoid race conditions. (Recreating a non-stereo
pixmap is not necessary, but may save resources.)</doc>
        <source-position filename="winsys/cogl-texture-pixmap-x11.h"
                         line="174"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="winsys/cogl-texture-pixmap-x11.h"
               line="168">a new #CoglTexturePixmapX11 instance</doc>
          <type name="TexturePixmapX11" c:type="CoglTexturePixmapX11*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="142">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="pixmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="143">A X11 pixmap ID</doc>
            <type name="guint32" c:type="uint32_t"/>
          </parameter>
          <parameter name="automatic_updates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="144">Whether to automatically copy the contents of
the pixmap to the texture.</doc>
            <type name="Bool" c:type="CoglBool"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="error_quark"
                c:identifier="cogl_texture_pixmap_x11_error_quark">
        <source-position filename="winsys/cogl-texture-pixmap-x11.h"
                         line="114"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <method name="is_using_tfp_extension"
              c:identifier="cogl_texture_pixmap_x11_is_using_tfp_extension"
              version="1.4"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="218">Checks whether the given @texture is using the
GLX_EXT_texture_from_pixmap or similar extension to copy the
contents of the pixmap to the texture.  This extension is usually
implemented as zero-copy operation so it implies the updates are
working efficiently.</doc>
        <source-position filename="winsys/cogl-texture-pixmap-x11.h"
                         line="235"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="winsys/cogl-texture-pixmap-x11.h"
               line="228">%TRUE if the texture is using an efficient extension
  and %FALSE otherwise</doc>
          <type name="Bool" c:type="CoglBool"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="220">A #CoglTexturePixmapX11 instance</doc>
            <type name="TexturePixmapX11" c:type="CoglTexturePixmapX11*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_right"
              c:identifier="cogl_texture_pixmap_x11_new_right"
              version="1.20"
              introspectable="0"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="179">Creates a texture object that corresponds to the right-eye image
of a pixmap with stereo content. @left_texture must have been
created using cogl_texture_pixmap_x11_new_left().</doc>
        <source-position filename="winsys/cogl-texture-pixmap-x11.h"
                         line="194"/>
        <return-value>
          <doc xml:space="preserve"
               filename="winsys/cogl-texture-pixmap-x11.h"
               line="188">a new #CoglTexturePixmapX11 instance</doc>
          <type name="TexturePixmapX11" c:type="CoglTexturePixmapX11*"/>
        </return-value>
        <parameters>
          <instance-parameter name="left_texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="181">A #CoglTexturePixmapX11 instance created with
               cogl_texture_pixmap_x11_new_left().</doc>
            <type name="TexturePixmapX11" c:type="CoglTexturePixmapX11*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_damage_object"
              c:identifier="cogl_texture_pixmap_x11_set_damage_object"
              version="1.4"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="237">Sets the damage object that will be used to track automatic updates
to the @texture. Damage tracking can be disabled by passing 0 for
@damage. Otherwise this damage will replace the one used if %TRUE
was passed for automatic_updates to cogl_texture_pixmap_x11_new().

Note that Cogl will subtract from the damage region as it processes
damage events.</doc>
        <source-position filename="winsys/cogl-texture-pixmap-x11.h"
                         line="257"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="239">A #CoglTexturePixmapX11 instance</doc>
            <type name="TexturePixmapX11" c:type="CoglTexturePixmapX11*"/>
          </instance-parameter>
          <parameter name="damage" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="240">A X11 Damage object or 0</doc>
            <type name="guint32" c:type="uint32_t"/>
          </parameter>
          <parameter name="report_level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="241">The report level which describes how to interpret
  the damage events. This should match the level that the damage
  object was created with.</doc>
            <type name="TexturePixmapX11ReportLevel"
                  c:type="CoglTexturePixmapX11ReportLevel"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_area"
              c:identifier="cogl_texture_pixmap_x11_update_area"
              version="1.4"
              stability="Unstable">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="196">Forces an update of the given @texture so that it is refreshed with
the contents of the pixmap that was given to
cogl_texture_pixmap_x11_new().</doc>
        <source-position filename="winsys/cogl-texture-pixmap-x11.h"
                         line="212"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="198">A #CoglTexturePixmapX11 instance</doc>
            <type name="TexturePixmapX11" c:type="CoglTexturePixmapX11*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="199">x coordinate of the area to update</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="200">y coordinate of the area to update</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="201">width of the area to update</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="winsys/cogl-texture-pixmap-x11.h"
                 line="202">height of the area to update</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="TexturePixmapX11Error"
                 version="1.10"
                 c:type="CoglTexturePixmapX11Error">
      <doc xml:space="preserve"
           filename="winsys/cogl-texture-pixmap-x11.h"
           line="101">Error codes that can be thrown when performing texture-pixmap-x11
operations.</doc>
      <source-position filename="winsys/cogl-texture-pixmap-x11.h" line="112"/>
      <member name="texture_pixmap_x11_error_x11"
              value="0"
              c:identifier="COGL_TEXTURE_PIXMAP_X11_ERROR_X11">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="103">An X11 protocol error</doc>
      </member>
    </enumeration>
    <enumeration name="TexturePixmapX11ReportLevel"
                 c:type="CoglTexturePixmapX11ReportLevel">
      <source-position filename="winsys/cogl-texture-pixmap-x11.h" line="90"/>
      <member name="raw_rectangles"
              value="0"
              c:identifier="COGL_TEXTURE_PIXMAP_X11_DAMAGE_RAW_RECTANGLES">
      </member>
      <member name="delta_rectangles"
              value="1"
              c:identifier="COGL_TEXTURE_PIXMAP_X11_DAMAGE_DELTA_RECTANGLES">
      </member>
      <member name="bounding_box"
              value="2"
              c:identifier="COGL_TEXTURE_PIXMAP_X11_DAMAGE_BOUNDING_BOX">
      </member>
      <member name="non_empty"
              value="3"
              c:identifier="COGL_TEXTURE_PIXMAP_X11_DAMAGE_NON_EMPTY">
      </member>
    </enumeration>
    <class name="TextureRectangle"
           c:symbol-prefix="texture_rectangle"
           c:type="CoglTextureRectangle"
           parent="Object"
           glib:type-name="CoglTextureRectangle"
           glib:get-type="cogl_texture_rectangle_get_gtype"
           glib:fundamental="1">
      <implements name="Texture"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_rectangle_new_from_bitmap"
                   version="2.0"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-texture-rectangle.h"
             line="136">Allocates a new #CoglTextureRectangle texture which will be
initialized with the pixel data from @bitmap. This texture is a
low-level texture that the GPU can sample from directly unlike
high-level textures such as #CoglTexture2DSliced and
#CoglAtlasTexture.

&lt;note&gt;Unlike for #CoglTexture2D textures, coordinates for
#CoglTextureRectangle textures should not be normalized. So instead
of using the coordinate (1, 1) to sample the bottom right corner of
a rectangle texture you would use (@width, @height) where @width
and @height are the width and height of the texture.&lt;/note&gt;

&lt;note&gt;If you want to sample from a rectangle texture from GLSL you
should use the sampler2DRect sampler type.&lt;/note&gt;

&lt;note&gt;Applications wanting to use #CoglTextureRectangle should
first check for the %COGL_FEATURE_ID_TEXTURE_RECTANGLE feature
using cogl_has_feature().&lt;/note&gt;

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is going to be used and can optimize how it is
allocated.</doc>
        <source-position filename="cogl-texture-rectangle.h" line="172"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-rectangle.h"
               line="166">A pointer to a new
              #CoglTextureRectangle texture.</doc>
          <type name="TextureRectangle" c:type="CoglTextureRectangle*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="138">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_foreign"
                   c:identifier="cogl_texture_rectangle_new_from_foreign">
        <doc xml:space="preserve"
             filename="cogl-texture-rectangle.h"
             line="174">Wraps an existing GL_TEXTURE_RECTANGLE texture object as a
#CoglTextureRectangle.  This can be used for integrating Cogl with
software using OpenGL directly.

&lt;note&gt;Unlike for #CoglTexture2D textures, coordinates for
#CoglTextureRectangle textures should not be normalized. So instead
of using the coordinate (1, 1) to sample the bottom right corner of
a rectangle texture you would use (@width, @height) where @width
and @height are the width and height of the texture.&lt;/note&gt;

&lt;note&gt;The results are undefined for passing an invalid @gl_handle
or if @width or @height don't have the correct texture
geometry.&lt;/note&gt;

&lt;note&gt;If you want to sample from a rectangle texture from GLSL you
should use the sampler2DRect sampler type.&lt;/note&gt;

&lt;note&gt;Applications wanting to use #CoglTextureRectangle should
first check for the %COGL_FEATURE_ID_TEXTURE_RECTANGLE feature
using cogl_has_feature().&lt;/note&gt;

The texture is still configurable until it has been allocated so
for example you can declare whether the texture is premultiplied
with cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl-texture-rectangle.h" line="210"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-rectangle.h"
               line="207">A new #CoglTextureRectangle texture</doc>
          <type name="TextureRectangle" c:type="CoglTextureRectangle*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="176">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="gl_handle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="177">A GL handle for a GL_TEXTURE_RECTANGLE texture object</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="178">Width of the foreign GL texture</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="179">Height of the foreign GL texture</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="180">The format of the texture</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_rectangle_new_with_size"
                   version="1.10"
                   stability="Unstable">
        <doc xml:space="preserve"
             filename="cogl-texture-rectangle.h"
             line="94">Creates a new #CoglTextureRectangle texture with a given @width,
and @height. This texture is a low-level texture that the GPU can
sample from directly unlike high-level textures such as
#CoglTexture2DSliced and #CoglAtlasTexture.

&lt;note&gt;Unlike for #CoglTexture2D textures, coordinates for
#CoglTextureRectangle textures should not be normalized. So instead
of using the coordinate (1, 1) to sample the bottom right corner of
a rectangle texture you would use (@width, @height) where @width
and @height are the width and height of the texture.&lt;/note&gt;

&lt;note&gt;If you want to sample from a rectangle texture from GLSL you
should use the sampler2DRect sampler type.&lt;/note&gt;

&lt;note&gt;Applications wanting to use #CoglTextureRectangle should
first check for the %COGL_FEATURE_ID_TEXTURE_RECTANGLE feature
using cogl_has_feature().&lt;/note&gt;

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is going to be used and can optimize how it is
allocated.</doc>
        <source-position filename="cogl-texture-rectangle.h" line="132"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl-texture-rectangle.h"
               line="125">A pointer to a new #CoglTextureRectangle
         object with no storage allocated yet.</doc>
          <type name="TextureRectangle" c:type="CoglTextureRectangle*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="96">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="97">The texture width to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl-texture-rectangle.h"
                 line="98">The texture height to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <enumeration name="TextureType"
                 version="1.10"
                 stability="Unstable"
                 glib:type-name="CoglTextureType"
                 glib:get-type="cogl_texture_type_get_type"
                 c:type="CoglTextureType">
      <doc xml:space="preserve"
           filename="cogl-texture.h"
           line="114">Constants representing the underlying hardware texture type of a
#CoglTexture.</doc>
      <member name="2d"
              value="0"
              c:identifier="COGL_TEXTURE_TYPE_2D"
              glib:nick="2d"
              glib:name="COGL_TEXTURE_TYPE_2D">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="116">A #CoglTexture2D</doc>
      </member>
      <member name="3d"
              value="1"
              c:identifier="COGL_TEXTURE_TYPE_3D"
              glib:nick="3d"
              glib:name="COGL_TEXTURE_TYPE_3D">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="117">A #CoglTexture3D</doc>
      </member>
      <member name="rectangle"
              value="2"
              c:identifier="COGL_TEXTURE_TYPE_RECTANGLE"
              glib:nick="rectangle"
              glib:name="COGL_TEXTURE_TYPE_RECTANGLE">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="118">A #CoglTextureRectangle</doc>
      </member>
    </enumeration>
    <record name="TextureVertex" c:type="CoglTextureVertex">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="521">Used to specify vertex information when calling cogl_polygon()</doc>
      <source-position filename="cogl-types.h" line="539"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="523">Model x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="524">Model y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="525">Model z-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="tx" writable="1">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="526">Texture x-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="ty" writable="1">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="527">Texture y-coordinate</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="color" writable="1">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="528">The color to use at this vertex. This is ignored if
  use_color is %FALSE when calling cogl_polygon()</doc>
        <type name="Color" c:type="CoglColor"/>
      </field>
    </record>
    <function-macro name="UNAVAILABLE"
                    c:identifier="COGL_UNAVAILABLE"
                    introspectable="0">
      <source-position filename="cogl-macros.h" line="48"/>
      <parameters>
        <parameter name="maj">
        </parameter>
        <parameter name="min">
        </parameter>
      </parameters>
    </function-macro>
    <record name="UserDataKey" c:type="CoglUserDataKey" version="1.4">
      <doc xml:space="preserve"
           filename="cogl-object.h"
           line="85">A #CoglUserDataKey is used to declare a key for attaching data to a
#CoglObject using cogl_object_set_user_data. The typedef only exists as a
formality to make code self documenting since only the unique address of a
#CoglUserDataKey is used.

Typically you would declare a static #CoglUserDataKey and set private data
on an object something like this:

|[
static CoglUserDataKey path_private_key;

static void
destroy_path_private_cb (void *data)
{
  g_free (data);
}

static void
my_path_set_data (CoglPath *path, void *data)
{
  cogl_object_set_user_data (COGL_OBJECT (path),
                             &amp;private_key,
                             data,
                             destroy_path_private_cb);
}
]|</doc>
      <source-position filename="cogl-object.h" line="120"/>
      <field name="unused" writable="1">
        <doc xml:space="preserve"
             filename="cogl-object.h"
             line="87">ignored.</doc>
        <type name="gint" c:type="int"/>
      </field>
    </record>
    <function-macro name="VERSION_CHECK"
                    c:identifier="COGL_VERSION_CHECK"
                    version="1.12.0"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl-version.h"
           line="196">A convenient macro to check whether the Cogl version being compiled
against is at least the given version number. For example if the
function cogl_pipeline_frobnicate was added in version 2.0.1 and
you want to conditionally use that function when it is available,
you could write the following:

|[
#if COGL_VERSION_CHECK (2, 0, 1)
cogl_pipeline_frobnicate (pipeline);
#else
/&lt;!-- --&gt;* Frobnication is not supported. Use a red color instead *&lt;!-- --&gt;/
cogl_pipeline_set_color_4f (pipeline, 1.0f, 0.0f, 0.0f, 1.0f);
#endif
]|</doc>
      <source-position filename="cogl-version.h" line="217"/>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="198">The major part of a version number</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="199">The minor part of a version number</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="200">The micro part of a version number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VERSION_COMPONENT_BITS"
              value="10"
              c:type="COGL_VERSION_COMPONENT_BITS">
      <source-position filename="cogl-version.h" line="118"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="VERSION_ENCODE"
                    c:identifier="COGL_VERSION_ENCODE"
                    version="1.12.0"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl-version.h"
           line="136">Encodes a 3 part version number into a single integer. This can be
used to compare the Cogl version. For example if there is a known
bug in Cogl versions between 1.3.2 and 1.3.4 you could use the
following code to provide a workaround:

|[
#if COGL_VERSION &gt;= COGL_VERSION_ENCODE (1, 3, 2) &amp;&amp;  *     COGL_VERSION &lt;= COGL_VERSION_ENCODE (1, 3, 4)
)
  /&lt;!-- --&gt;* Do the workaround *&lt;!-- --&gt;/
#endif
]|</doc>
      <source-position filename="cogl-version.h" line="152"/>
      <parameters>
        <parameter name="major">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="138">The major part of a version number</doc>
        </parameter>
        <parameter name="minor">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="139">The minor part of a version number</doc>
        </parameter>
        <parameter name="micro">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="140">The micro part of a version number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VERSION_GET_MAJOR"
                    c:identifier="COGL_VERSION_GET_MAJOR"
                    version="1.12.0"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl-version.h"
           line="161">Extracts the major part of an encoded version number.</doc>
      <source-position filename="cogl-version.h" line="165"/>
      <parameters>
        <parameter name="version">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="163">An encoded version number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VERSION_GET_MICRO"
                    c:identifier="COGL_VERSION_GET_MICRO"
                    version="1.12.0"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl-version.h"
           line="185">Extracts the micro part of an encoded version number.</doc>
      <source-position filename="cogl-version.h" line="189"/>
      <parameters>
        <parameter name="version">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="187">An encoded version number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="VERSION_GET_MINOR"
                    c:identifier="COGL_VERSION_GET_MINOR"
                    version="1.12.0"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl-version.h"
           line="173">Extracts the minor part of an encoded version number.</doc>
      <source-position filename="cogl-version.h" line="177"/>
      <parameters>
        <parameter name="version">
          <doc xml:space="preserve"
               filename="cogl-version.h"
               line="175">An encoded version number</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="VERSION_MAX_COMPONENT_VALUE"
              value="0"
              c:type="COGL_VERSION_MAX_COMPONENT_VALUE">
      <source-position filename="cogl-version.h" line="119"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="VertexP2"
            c:type="CoglVertexP2"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="73">A convenience vertex definition that can be used with
cogl_primitive_new_p2().</doc>
      <source-position filename="cogl-primitive.h" line="86"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="75">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="76">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP2C4"
            c:type="CoglVertexP2C4"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="104">A convenience vertex definition that can be used with
cogl_primitive_new_p2c4().</doc>
      <source-position filename="cogl-primitive.h" line="122"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="106">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="107">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="108">The red component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="g" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="110">The blue component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="b" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="109">The green component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="a" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="111">The alpha component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
    </record>
    <record name="VertexP2T2"
            c:type="CoglVertexP2T2"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="145">A convenience vertex definition that can be used with
cogl_primitive_new_p2t2().</doc>
      <source-position filename="cogl-primitive.h" line="161"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="147">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="148">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="149">The s component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="150">The t component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP2T2C4"
            c:type="CoglVertexP2T2C4"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="183">A convenience vertex definition that can be used with
cogl_primitive_new_p3t2c4().</doc>
      <source-position filename="cogl-primitive.h" line="204"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="185">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="186">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="187">The s component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="188">The t component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="189">The red component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="g" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="191">The blue component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="b" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="190">The green component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="a" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="192">The alpha component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
    </record>
    <record name="VertexP3"
            c:type="CoglVertexP3"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="88">A convenience vertex definition that can be used with
cogl_primitive_new_p3().</doc>
      <source-position filename="cogl-primitive.h" line="102"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="90">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="91">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="92">The z component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP3C4"
            c:type="CoglVertexP3C4"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="124">A convenience vertex definition that can be used with
cogl_primitive_new_p3c4().</doc>
      <source-position filename="cogl-primitive.h" line="143"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="126">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="127">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="128">The z component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="129">The red component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="g" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="131">The blue component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="b" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="130">The green component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="a" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="132">The alpha component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
    </record>
    <record name="VertexP3T2"
            c:type="CoglVertexP3T2"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="163">A convenience vertex definition that can be used with
cogl_primitive_new_p3t2().</doc>
      <source-position filename="cogl-primitive.h" line="180"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="165">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="166">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="167">The z component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="168">The s component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="169">The t component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP3T2C4"
            c:type="CoglVertexP3T2C4"
            version="1.6"
            stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="206">A convenience vertex definition that can be used with
cogl_primitive_new_p3t2c4().</doc>
      <source-position filename="cogl-primitive.h" line="228"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="208">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="209">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="210">The z component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="211">The s component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="212">The t component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="213">The red component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="g" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="215">The blue component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="b" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="214">The green component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="a" writable="1">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="216">The alpha component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
    </record>
    <enumeration name="VerticesMode"
                 version="1.0"
                 glib:type-name="CoglVerticesMode"
                 glib:get-type="cogl_vertices_mode_get_type"
                 c:type="CoglVerticesMode">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="714">Different ways of interpreting vertices when drawing.</doc>
      <member name="points"
              value="0"
              c:identifier="COGL_VERTICES_MODE_POINTS"
              glib:nick="points"
              glib:name="COGL_VERTICES_MODE_POINTS">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="716">FIXME, equivalent to
&lt;constant&gt;GL_POINTS&lt;/constant&gt;</doc>
      </member>
      <member name="lines"
              value="1"
              c:identifier="COGL_VERTICES_MODE_LINES"
              glib:nick="lines"
              glib:name="COGL_VERTICES_MODE_LINES">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="718">FIXME, equivalent to &lt;constant&gt;GL_LINES&lt;/constant&gt;</doc>
      </member>
      <member name="line_loop"
              value="2"
              c:identifier="COGL_VERTICES_MODE_LINE_LOOP"
              glib:nick="line-loop"
              glib:name="COGL_VERTICES_MODE_LINE_LOOP">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="719">FIXME, equivalent to
&lt;constant&gt;GL_LINE_LOOP&lt;/constant&gt;</doc>
      </member>
      <member name="line_strip"
              value="3"
              c:identifier="COGL_VERTICES_MODE_LINE_STRIP"
              glib:nick="line-strip"
              glib:name="COGL_VERTICES_MODE_LINE_STRIP">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="721">FIXME, equivalent to
&lt;constant&gt;GL_LINE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangles"
              value="4"
              c:identifier="COGL_VERTICES_MODE_TRIANGLES"
              glib:nick="triangles"
              glib:name="COGL_VERTICES_MODE_TRIANGLES">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="723">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLES&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_strip"
              value="5"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_STRIP"
              glib:nick="triangle-strip"
              glib:name="COGL_VERTICES_MODE_TRIANGLE_STRIP">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="725">FIXME, equivalent to
&lt;constant&gt;GL_TRIANGLE_STRIP&lt;/constant&gt;</doc>
      </member>
      <member name="triangle_fan"
              value="6"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_FAN"
              glib:nick="triangle-fan"
              glib:name="COGL_VERTICES_MODE_TRIANGLE_FAN">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="727">FIXME, equivalent to &lt;constant&gt;GL_TRIANGLE_FAN&lt;/constant&gt;</doc>
      </member>
    </enumeration>
    <enumeration name="Winding"
                 glib:type-name="CoglWinding"
                 glib:get-type="cogl_winding_get_type"
                 c:type="CoglWinding">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="880">Enum used to represent the two directions of rotation. This can be
used to set the front face for culling by calling
cogl_pipeline_set_front_face_winding().</doc>
      <member name="clockwise"
              value="0"
              c:identifier="COGL_WINDING_CLOCKWISE"
              glib:nick="clockwise"
              glib:name="COGL_WINDING_CLOCKWISE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="882">Vertices are in a clockwise order</doc>
      </member>
      <member name="counter_clockwise"
              value="1"
              c:identifier="COGL_WINDING_COUNTER_CLOCKWISE"
              glib:nick="counter-clockwise"
              glib:name="COGL_WINDING_COUNTER_CLOCKWISE">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="883">Vertices are in a counter-clockwise order</doc>
      </member>
    </enumeration>
    <enumeration name="WinsysFeature"
                 glib:type-name="CoglWinsysFeature"
                 glib:get-type="cogl_winsys_feature_get_type"
                 c:type="CoglWinsysFeature">
      <member name="multiple_onscreen"
              value="0"
              c:identifier="COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN"
              glib:nick="multiple-onscreen"
              glib:name="COGL_WINSYS_FEATURE_MULTIPLE_ONSCREEN">
      </member>
      <member name="swap_throttle"
              value="1"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_THROTTLE"
              glib:nick="swap-throttle"
              glib:name="COGL_WINSYS_FEATURE_SWAP_THROTTLE">
      </member>
      <member name="vblank_counter"
              value="2"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_COUNTER"
              glib:nick="vblank-counter"
              glib:name="COGL_WINSYS_FEATURE_VBLANK_COUNTER">
      </member>
      <member name="vblank_wait"
              value="3"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_WAIT"
              glib:nick="vblank-wait"
              glib:name="COGL_WINSYS_FEATURE_VBLANK_WAIT">
      </member>
      <member name="texture_from_pixmap"
              value="4"
              c:identifier="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP"
              glib:nick="texture-from-pixmap"
              glib:name="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP">
      </member>
      <member name="swap_buffers_event"
              value="5"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT"
              glib:nick="swap-buffers-event"
              glib:name="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT">
      </member>
      <member name="swap_region"
              value="6"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION"
              glib:nick="swap-region"
              glib:name="COGL_WINSYS_FEATURE_SWAP_REGION">
      </member>
      <member name="swap_region_throttle"
              value="7"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE"
              glib:nick="swap-region-throttle"
              glib:name="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE">
      </member>
      <member name="swap_region_synchronized"
              value="8"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED"
              glib:nick="swap-region-synchronized"
              glib:name="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED">
      </member>
      <member name="buffer_age"
              value="9"
              c:identifier="COGL_WINSYS_FEATURE_BUFFER_AGE"
              glib:nick="buffer-age"
              glib:name="COGL_WINSYS_FEATURE_BUFFER_AGE">
      </member>
      <member name="sync_and_complete_event"
              value="10"
              c:identifier="COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT"
              glib:nick="sync-and-complete-event"
              glib:name="COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT">
      </member>
      <member name="n_features"
              value="11"
              c:identifier="COGL_WINSYS_FEATURE_N_FEATURES"
              glib:nick="n-features"
              glib:name="COGL_WINSYS_FEATURE_N_FEATURES">
      </member>
    </enumeration>
    <enumeration name="WinsysID" c:type="CoglWinsysID">
      <doc xml:space="preserve"
           filename="cogl-renderer.h"
           line="160">Identifies specific window system backends that Cogl supports.

These can be used to query what backend Cogl is using or to try and
explicitly select a backend to use.</doc>
      <source-position filename="cogl-renderer.h" line="194"/>
      <member name="any" value="0" c:identifier="COGL_WINSYS_ID_ANY">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="162">Implies no preference for which backend is used</doc>
      </member>
      <member name="stub" value="1" c:identifier="COGL_WINSYS_ID_STUB">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="163">Use the no-op stub backend</doc>
      </member>
      <member name="glx" value="2" c:identifier="COGL_WINSYS_ID_GLX">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="164">Use the GLX window system binding API</doc>
      </member>
      <member name="egl_xlib" value="3" c:identifier="COGL_WINSYS_ID_EGL_XLIB">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="165">Use EGL with the X window system via XLib</doc>
      </member>
      <member name="egl_null" value="4" c:identifier="COGL_WINSYS_ID_EGL_NULL">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="166">Use EGL with the PowerVR NULL window system</doc>
      </member>
      <member name="egl_gdl" value="5" c:identifier="COGL_WINSYS_ID_EGL_GDL">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="167">Use EGL with the GDL platform</doc>
      </member>
      <member name="egl_wayland"
              value="6"
              c:identifier="COGL_WINSYS_ID_EGL_WAYLAND">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="168">Use EGL with the Wayland window system</doc>
      </member>
      <member name="egl_kms" value="7" c:identifier="COGL_WINSYS_ID_EGL_KMS">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="169">Use EGL with the KMS platform</doc>
      </member>
      <member name="egl_android"
              value="8"
              c:identifier="COGL_WINSYS_ID_EGL_ANDROID">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="170">Use EGL with the Android platform</doc>
      </member>
      <member name="egl_mir" value="9" c:identifier="COGL_WINSYS_ID_EGL_MIR">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="171">Use EGL with the Mir server</doc>
      </member>
      <member name="wgl" value="10" c:identifier="COGL_WINSYS_ID_WGL">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="172">Use the Microsoft Windows WGL binding API</doc>
      </member>
      <member name="sdl" value="11" c:identifier="COGL_WINSYS_ID_SDL">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="173">Use the SDL window system</doc>
      </member>
    </enumeration>
    <record name="_ColorSizeCheck" c:type="_CoglColorSizeCheck">
      <source-position filename="cogl-types.h" line="519"/>
      <field name="compile_time_assert_CoglColor_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_EulerSizeCheck" c:type="_CoglEulerSizeCheck">
      <source-position filename="cogl-euler.h" line="167"/>
      <field name="compile_time_assert_CoglEuler_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_MatrixSizeCheck" c:type="_CoglMatrixSizeCheck">
      <source-position filename="cogl-matrix.h" line="127"/>
      <field name="compile_time_assert_CoglMatrix_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_QuaternionSizeCheck" c:type="_CoglQuaternionSizeCheck">
      <source-position filename="cogl-quaternion.h" line="148"/>
      <field name="compile_time_assert_CoglQuaternion_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <record name="_TextureVertexSizeCheck"
            c:type="_CoglTextureVertexSizeCheck">
      <source-position filename="cogl-types.h" line="540"/>
      <field name="compile_time_assert_CoglTextureVertex_size" writable="1">
        <array zero-terminated="0" fixed-size="-1">
          <type name="gchar" c:type="char"/>
        </array>
      </field>
    </record>
    <function name="bitmap_error_quark"
              c:identifier="cogl_bitmap_error_quark"
              moved-to="BitmapError.quark">
      <source-position filename="cogl-bitmap.h" line="332"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="blend_string_error_quark"
              c:identifier="cogl_blend_string_error_quark"
              moved-to="BlendStringError.quark">
      <source-position filename="cogl-types.h" line="628"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="buffer_get_size"
              c:identifier="cogl_buffer_get_size"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="112">Retrieves the size of buffer</doc>
      <source-position filename="cogl-buffer.h" line="124"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="118">the size of the buffer in bytes</doc>
        <type name="guint" c:type="unsigned int"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="114">a buffer object</doc>
          <type name="Buffer" c:type="CoglBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_get_update_hint"
              c:identifier="cogl_buffer_get_update_hint"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="160">Retrieves the update hints set using cogl_buffer_set_update_hint()</doc>
      <source-position filename="cogl-buffer.h" line="172"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="166">the #CoglBufferUpdateHint currently used by the buffer</doc>
        <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="162">a buffer object</doc>
          <type name="Buffer" c:type="CoglBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_map"
              c:identifier="cogl_buffer_map"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="215">Maps the buffer into the application address space for direct
access. This is equivalent to calling cogl_buffer_map_range() with
zero as the offset and the size of the entire buffer as the size.

It is strongly recommended that you pass
%COGL_BUFFER_MAP_HINT_DISCARD as a hint if you are going to replace
all the buffer's data. This way if the buffer is currently being
used by the GPU then the driver won't have to stall the CPU and
wait for the hardware to finish because it can instead allocate a
new buffer to map.

The behaviour is undefined if you access the buffer in a way
conflicting with the @access mask you pass. It is also an error to
release your last reference while the buffer is mapped.</doc>
      <source-position filename="cogl-buffer.h" line="244"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="237">A pointer to the mapped memory or
       %NULL is the call fails</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="217">a buffer object</doc>
          <type name="Buffer" c:type="CoglBuffer*"/>
        </parameter>
        <parameter name="access" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="218">how the mapped buffer will be used by the application</doc>
          <type name="BufferAccess" c:type="CoglBufferAccess"/>
        </parameter>
        <parameter name="hints" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="219">A mask of #CoglBufferMapHint&lt;!-- --&gt;s that tell Cogl how
  the data will be modified once mapped.</doc>
          <type name="BufferMapHint" c:type="CoglBufferMapHint"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_map_range"
              c:identifier="cogl_buffer_map_range"
              version="2.0"
              stability="Unstable"
              throws="1">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="248">Maps a sub-region of the buffer into the application's address space
for direct access.

It is strongly recommended that you pass
%COGL_BUFFER_MAP_HINT_DISCARD as a hint if you are going to replace
all the buffer's data. This way if the buffer is currently being
used by the GPU then the driver won't have to stall the CPU and
wait for the hardware to finish because it can instead allocate a
new buffer to map. You can pass
%COGL_BUFFER_MAP_HINT_DISCARD_RANGE instead if you want the
regions outside of the mapping to be retained.

The behaviour is undefined if you access the buffer in a way
conflicting with the @access mask you pass. It is also an error to
release your last reference while the buffer is mapped.</doc>
      <source-position filename="cogl-buffer.h" line="281"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="274">A pointer to the mapped memory or
       %NULL is the call fails</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="250">a buffer object</doc>
          <type name="Buffer" c:type="CoglBuffer*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="251">Offset within the buffer to start the mapping</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="252">The size of data to map</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="access" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="253">how the mapped buffer will be used by the application</doc>
          <type name="BufferAccess" c:type="CoglBufferAccess"/>
        </parameter>
        <parameter name="hints" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="254">A mask of #CoglBufferMapHint&lt;!-- --&gt;s that tell Cogl how
  the data will be modified once mapped.</doc>
          <type name="BufferMapHint" c:type="CoglBufferMapHint"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_data"
              c:identifier="cogl_buffer_set_data"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="300">Updates part of the buffer with new data from @data. Where to put this new
data is controlled by @offset and @offset + @data should be less than the
buffer size.</doc>
      <source-position filename="cogl-buffer.h" line="317"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="311">%TRUE is the operation succeeded, %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="302">a buffer object</doc>
          <type name="Buffer" c:type="CoglBuffer*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="303">destination offset (in bytes) in the buffer</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="304">a pointer to the data to be copied into the buffer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="305">number of bytes to copy</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_set_update_hint"
              c:identifier="cogl_buffer_set_update_hint"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="145">Sets the update hint on a buffer. See #CoglBufferUpdateHint for a description
of the available hints.</doc>
      <source-position filename="cogl-buffer.h" line="157"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="147">a buffer object</doc>
          <type name="Buffer" c:type="CoglBuffer*"/>
        </parameter>
        <parameter name="hint" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="148">the new hint</doc>
          <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_unmap"
              c:identifier="cogl_buffer_unmap"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="288">Unmaps a buffer previously mapped by cogl_buffer_map().</doc>
      <source-position filename="cogl-buffer.h" line="298"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="290">a buffer object</doc>
          <type name="Buffer" c:type="CoglBuffer*"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="cogl-atlas-texture">
      <doc xml:space="preserve"
           filename="cogl-atlas-texture.h"
           line="46">A texture atlas is a texture that contains many smaller images that
an application is interested in. These are packed together as a way
of optimizing drawing with those images by avoiding the costs of
repeatedly telling the hardware to change what texture it should
sample from.  This can enable more geometry to be batched together
into few draw calls.

Each #CoglContext has an shared, pool of texture atlases that are
are managed by Cogl.

This api lets applications upload texture data into one of Cogl's
shared texture atlases using a high-level #CoglAtlasTexture which
represents a sub-region of one of these atlases.

&lt;note&gt;A #CoglAtlasTexture is a high-level meta texture which has
some limitations to be aware of. Please see the documentation for
#CoglMetaTexture for more details.&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cogl-attribute">
      <doc xml:space="preserve"
           filename="cogl-attribute.h"
           line="55">FIXME</doc>
    </docsection>
    <docsection name="cogl-attribute-buffer">
      <doc xml:space="preserve"
           filename="cogl-attribute-buffer.h"
           line="54">FIXME</doc>
    </docsection>
    <docsection name="cogl-bitmap">
      <doc xml:space="preserve"
           filename="cogl-bitmap.h"
           line="66">Cogl allows loading image data into memory as CoglBitmaps without
loading them immediately into GPU textures.

#CoglBitmap is available since Cogl 1.0</doc>
    </docsection>
    <docsection name="cogl-buffer">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="47">The CoglBuffer API provides a common interface to manipulate
buffers that have been allocated either via cogl_pixel_buffer_new()
or cogl_attribute_buffer_new(). The API allows you to upload data
to these buffers and define usage hints that help Cogl manage your
buffer optimally.

Data can either be uploaded by supplying a pointer and size so Cogl
can copy your data, or you can mmap() a CoglBuffer and then you can
copy data to the buffer directly.

One of the most common uses for CoglBuffers is to upload texture
data asynchronously since the ability to mmap the buffers into
the CPU makes it possible for another thread to handle the IO
of loading an image file and unpacking it into the mapped buffer
without blocking other Cogl operations.</doc>
    </docsection>
    <docsection name="cogl-color">
      <doc xml:space="preserve"
           filename="cogl-color.h"
           line="38">#CoglColor is a simple structure holding the definition of a color such
that it can be efficiently used by GL</doc>
    </docsection>
    <docsection name="cogl-context">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="58">A #CoglContext is the top most sandbox of Cogl state for an
application or toolkit. Its main purpose is to act as a sandbox
for the memory management of state objects. Normally an application
will only create a single context since there is no way to share
resources between contexts.

For those familiar with OpenGL or perhaps Cairo it should be
understood that unlike these APIs a Cogl context isn't a rendering
context as such. In other words Cogl doesn't aim to provide a state
machine style model for configuring rendering parameters. Most
rendering state in Cogl is directly associated with user managed
objects called pipelines and geometry is drawn with a specific
pipeline object to a framebuffer object and those 3 things fully
define the state for drawing. This is an important part of Cogl's
design since it helps you write orthogonal rendering components
that can all access the same GPU without having to worry about
what state other components have left you with.

&lt;note&gt;&lt;para&gt;Cogl does not maintain internal references to the context for
resources that depend on the context so applications. This is to
help applications control the lifetime a context without us needing to
introduce special api to handle the breakup of internal circular
references due to internal resources and caches associated with the
context.

One a context has been destroyed then all directly or indirectly
dependant resources will be in an inconsistent state and should not
be manipulated or queried in any way.

For applications that rely on the operating system to clean up
resources this policy shouldn't affect them, but for applications
that need to carefully destroy and re-create Cogl contexts multiple
times throughout their lifetime (such as Android applications) they
should be careful to destroy all context dependant resources, such as
framebuffers or textures etc before unrefing and destroying the
context.&lt;/para&gt;&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cogl-display">
      <doc xml:space="preserve"
           filename="cogl-display.h"
           line="53">The basic intention for this object is to let the application
configure common display preferences before creating a context, and
there are a few different aspects to this...

Firstly there are options directly relating to the physical display
pipeline that is currently being used including the digital to
analogue conversion hardware and the screens the user sees.

Another aspect is that display options may constrain or affect how
onscreen framebuffers should later be configured. The original
rationale for the display object in fact was to let us handle GLX
and EGLs requirements that framebuffers must be "compatible" with
the config associated with the current context meaning we have to
force the user to describe how they would like to create their
onscreen windows before we can choose a suitable fbconfig and
create a GLContext.</doc>
    </docsection>
    <docsection name="cogl-error">
      <doc xml:space="preserve"
           filename="cogl-error.h"
           line="40">As a general rule Cogl shields non-recoverable errors from
developers, such as most heap allocation failures (unless for
exceptionally large resources which we might reasonably expect to
fail) and this reduces the burden on developers.

There are some Cogl apis though that can fail for exceptional
reasons that can also potentially be recovered from at runtime
and for these apis we use a standard convention for reporting
runtime recoverable errors.

As an example if we look at the cogl_context_new() api which
takes an error argument:
|[
  CoglContext *
  cogl_context_new (CoglDisplay *display, CoglError **error);
]|

A caller interested in catching any runtime error when creating a
new #CoglContext would pass the address of a #CoglError pointer
that has first been initialized to %NULL as follows:

|[
  CoglError *error = NULL;
  CoglContext *context;

  context = cogl_context_new (NULL, &amp;error);
]|

The return status should usually be enough to determine if there
was an error set (in this example we can check if context == %NULL)
but if it's not possible to tell from the function's return status
you can instead look directly at the error pointer which you
initialized to %NULL. In this example we now check the error,
report any error to the user, free the error and then simply
abort without attempting to recover.

|[
  if (context == NULL)
    {
      fprintf (stderr, "Failed to create a Cogl context: %s\n",
               error-&gt;message);
      cogl_error_free (error);
      abort ();
    }
]|

All Cogl APIs that accept an error argument can also be passed a
%NULL pointer. In this case if an exceptional error condition is hit
then Cogl will simply log the error message and abort the
application. This can be compared to language execeptions where the
developer has not attempted to catch the exception. This means the
above example is essentially redundant because it's what Cogl would
have done automatically and so, similarly, if your application has
no way to recover from a particular error you might just as well
pass a %NULL #CoglError pointer to save a bit of typing.

&lt;note&gt;If you are used to using the GLib API you will probably
recognize that #CoglError is just like a #GError. In fact if Cogl
has been built with --enable-glib then it is safe to cast a
#CoglError to a #GError.&lt;/note&gt;

&lt;note&gt;An important detail to be aware of if you are used to using
GLib's GError API is that Cogl deviates from the GLib GError
conventions in one noteable way which is that a %NULL error pointer
does not mean you want to ignore the details of an error, it means
you are not trying to catch any exceptional errors the function might
throw which will result in the program aborting with a log message
if an error is thrown.&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cogl-euler">
      <doc xml:space="preserve"
           filename="cogl-euler.h"
           line="47">Euler angles are a simple representation of a 3 dimensional
rotation; comprised of 3 ordered heading, pitch and roll rotations.
An important thing to understand is that the axis of rotation
belong to the object being rotated and so they also rotate as each
of the heading, pitch and roll rotations are applied.

One way to consider euler angles is to imagine controlling an
aeroplane, where you first choose a heading (Such as flying south
east), then you set the pitch (such as 30 degrees to take off) and
then you might set a roll, by dipping the left, wing as you prepare
to turn.

They have some advantages and limitations that it helps to be
aware of:

Advantages:
&lt;itemizedlist&gt;
&lt;listitem&gt;
Easy to understand and use, compared to quaternions and matrices,
so may be a good choice for a user interface.
&lt;/listitem&gt;
&lt;listitem&gt;
Efficient storage, needing only 3 components any rotation can be
represented.
&lt;note&gt;Actually the #CoglEuler type isn't optimized for size because
we may cache the equivalent #CoglQuaternion along with a euler
rotation, but it would be trivial for an application to track the
components of euler rotations in a packed float array if optimizing
for size was important. The values could be passed to Cogl only when
manipulation is necessary.&lt;/note&gt;
&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Disadvantages:
&lt;itemizedlist&gt;
&lt;listitem&gt;
Aliasing: it's possible to represent some rotations with multiple
different heading, pitch and roll rotations.
&lt;/listitem&gt;
&lt;listitem&gt;
They can suffer from a problem called Gimbal Lock. A good
explanation of this can be seen on wikipedia here:
http://en.wikipedia.org/wiki/Gimbal_lock but basically two
of the axis of rotation may become aligned and so you loose a
degree of freedom. For example a pitch of +-90° would mean that
heading and bank rotate around the same axis.
&lt;/listitem&gt;
&lt;listitem&gt;
If you use euler angles to orient something in 3D space and try to
transition between orientations by interpolating the component
angles you probably wont get the transitions you expect as they may
not follow the shortest path between the two orientations.
&lt;/listitem&gt;
&lt;listitem&gt;
There's no standard to what order the component axis rotations are
applied. The most common convention seems to be what we do in Cogl
with heading (y-axis), pitch (x-axis) and then roll (z-axis), but
other software might apply x-axis, y-axis then z-axis or any other
order so you need to consider this if you are accepting euler
rotations from some other software. Other software may also use
slightly different aeronautical terms, such as "yaw" instead of
"heading" or "bank" instead of "roll".
&lt;/listitem&gt;
&lt;/itemizedlist&gt;

To minimize the aliasing issue we may refer to "Canonical Euler"
angles where heading and roll are restricted to +- 180° and pitch is
restricted to +- 90°. If pitch is +- 90° bank is set to 0°.

Quaternions don't suffer from Gimbal Lock and they can be nicely
interpolated between, their disadvantage is that they don't have an
intuitive representation.

A common practice is to accept angles in the intuitive Euler form
and convert them to quaternions internally to avoid Gimbal Lock and
handle interpolations. See cogl_quaternion_init_from_euler().</doc>
    </docsection>
    <docsection name="cogl-fence">
      <doc xml:space="preserve"
           filename="cogl-fence.h"
           line="41">Cogl allows notification of GPU command completion; users may mark
points in the GPU command stream and receive notification when the GPU
has executed to that point.</doc>
    </docsection>
    <docsection name="cogl-framebuffer">
      <doc xml:space="preserve"
           filename="cogl-framebuffer.h"
           line="68">Framebuffers are a collection of buffers that can be rendered too.
A framebuffer may be comprised of one or more color buffers, an
optional depth buffer and an optional stencil buffer. Other
configuration parameters are associated with framebuffers too such
as whether the framebuffer supports multi-sampling (an anti-aliasing
technique) or dithering.

There are two kinds of framebuffer in Cogl, #CoglOnscreen
framebuffers and #CoglOffscreen framebuffers. As the names imply
offscreen framebuffers are for rendering something offscreen
(perhaps to a texture which is bound as one of the color buffers).
The exact semantics of onscreen framebuffers depends on the window
system backend that you are using, but typically you can expect
rendering to a #CoglOnscreen framebuffer will be immediately
visible to the user.

If you want to create a new framebuffer then you should start by
looking at the #CoglOnscreen and #CoglOffscreen constructor
functions, such as cogl_offscreen_new_with_texture() or
cogl_onscreen_new(). The #CoglFramebuffer interface deals with
all aspects that are common between those two types of framebuffer.

Setup of a new CoglFramebuffer happens in two stages. There is a
configuration stage where you specify all the options and ancillary
buffers you want associated with your framebuffer and then when you
are happy with the configuration you can "allocate" the framebuffer
using cogl_framebuffer_allocate(). Technically explicitly calling
cogl_framebuffer_allocate() is optional for convenience and the
framebuffer will automatically be allocated when you first try to
draw to it, but if you do the allocation manually then you can
also catch any possible errors that may arise from your
configuration.</doc>
    </docsection>
    <docsection name="cogl-gles2">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="76">Cogl provides portable access to the OpenGLES api through a single
library that is able to smooth over inconsistencies between the
different vendor drivers for OpenGLES in a single place.

The api is designed to allow Cogl to transparently implement the
api on top of other drivers, such as OpenGL, D3D or on Cogl's own
drawing api so even if your platform doesn't come with an
OpenGLES 2.0 api Cogl may still be able to expose the api to your
application.

Since Cogl is a library and not an api specification it is possible
to add OpenGLES 2.0 api features to Cogl which can immidiately
benefit developers regardless of what platform they are running on.

With this api it's possible to re-use existing OpenGLES 2.0 code
within applications that are rendering with the Cogl API and also
it's possible for applications that render using OpenGLES 2.0 to
incorporate content rendered with Cogl.

Applications can check for OpenGLES 2.0 api support by checking for
%COGL_FEATURE_ID_GLES2_CONTEXT support with cogl_has_feature().</doc>
    </docsection>
    <docsection name="cogl-index-buffer">
      <doc xml:space="preserve"
           filename="cogl-index-buffer.h"
           line="49">FIXME</doc>
    </docsection>
    <docsection name="cogl-indices">
      <doc xml:space="preserve"
           filename="cogl-indices.h"
           line="54">Indices allow you to avoid duplicating vertices in your vertex data
by virtualizing your data and instead providing a sequence of index
values that tell the GPU which data should be used for each vertex.

If the GPU is given a sequence of indices it doesn't simply walk
through each vertex of your data in order it will instead walk
through the indices which can provide random access to the
underlying data.

Since it's very common to have duplicate vertices when describing a
shape as a list of triangles it can often be a significant space
saving to describe geometry using indices. Reducing the size of
your models can make it cheaper to map them into the GPU by
reducing the demand on memory bandwidth and may help to make better
use of your GPUs internal vertex caching.

For example, to describe a quadrilateral as 2 triangles for the GPU
you could either provide data with 6 vertices or instead with
indices you can provide vertex data for just 4 vertices and an
index buffer that specfies the 6 vertices by indexing the shared
vertices multiple times.

|[
  CoglVertex2f quad_vertices[] = {
    {x0, y0}, //0 = top left
    {x1, y1}, //1 = bottom left
    {x2, y2}, //2 = bottom right
    {x3, y3}, //3 = top right
  };
  //tell the gpu how to interpret the quad as 2 triangles...
  unsigned char indices[] = {0, 1, 2, 0, 2, 3};
]|

Even in the above illustration we see a saving of 10bytes for one
quad compared to having data for 6 vertices and no indices but if
you need to draw 100s or 1000s of quads then its really quite
significant.

Something else to consider is that often indices can be defined
once and remain static while the vertex data may change for
animations perhaps. That means you may be able to ignore the
negligable cost of mapping your indices into the GPU if they don't
ever change.

The above illustration is actually a good example of static indices
because it's really common that developers have quad mesh data that
they need to display and we know exactly what that indices array
needs to look like depending on the number of quads that need to be
drawn. It doesn't matter how the quads might be animated and
changed the indices will remain the same. Cogl even has a utility
(cogl_get_rectangle_indices()) to get access to re-useable indices
for drawing quads as above.</doc>
    </docsection>
    <docsection name="cogl-matrix">
      <doc xml:space="preserve"
           filename="cogl-matrix.h"
           line="55">Matrices are used in Cogl to describe affine model-view transforms, texture
transforms, and projective transforms. This exposes a utility API that can
be used for direct manipulation of these matrices.</doc>
    </docsection>
    <docsection name="cogl-matrix-stack">
      <doc xml:space="preserve"
           filename="cogl-matrix-stack.h"
           line="46">Matrices can be used (for example) to describe the model-view
transforms of objects, texture transforms, and projective
transforms.

The #CoglMatrix api provides a good way to manipulate individual
matrices representing a single transformation but if you need to
track many-many such transformations for many objects that are
organized in a scenegraph for example then using a separate
#CoglMatrix for each object may not be the most efficient way.

A #CoglMatrixStack enables applications to track lots of
transformations that are related to each other in some kind of
hierarchy.  In a scenegraph for example if you want to know how to
transform a particular node then you usually have to walk up
through the ancestors and accumulate their transforms before
finally applying the transform of the node itself. In this model
things are grouped together spatially according to their ancestry
and all siblings with the same parent share the same initial
transformation. The #CoglMatrixStack API is suited to tracking lots
of transformations that fit this kind of model.

Compared to using the #CoglMatrix api directly to track many
related transforms, these can be some advantages to using a
#CoglMatrixStack:
&lt;itemizedlist&gt;
  &lt;listitem&gt;Faster equality comparisons of transformations&lt;/listitem&gt;
  &lt;listitem&gt;Efficient comparisons of the differences between arbitrary
  transformations&lt;/listitem&gt;
  &lt;listitem&gt;Avoid redundant arithmetic related to common transforms
  &lt;/listitem&gt;
  &lt;listitem&gt;Can be more space efficient (not always though)&lt;/listitem&gt;
&lt;/itemizedlist&gt;

For reference (to give an idea of when a #CoglMatrixStack can
provide a space saving) a #CoglMatrix can be expected to take 72
bytes whereas a single #CoglMatrixEntry in a #CoglMatrixStack is
currently around 32 bytes on a 32bit CPU or 36 bytes on a 64bit
CPU. An entry is needed for each individual operation applied to
the stack (such as rotate, scale, translate) so if most of your
leaf node transformations only need one or two simple operations
relative to their parent then a matrix stack will likely take less
space than having a #CoglMatrix for each node.

Even without any space saving though the ability to perform fast
comparisons and avoid redundant arithmetic (especially sine and
cosine calculations for rotations) can make using a matrix stack
worthwhile.</doc>
    </docsection>
    <docsection name="cogl-meta-texture">
      <doc xml:space="preserve"
           filename="cogl-meta-texture.h"
           line="42">Cogl helps to make it easy to deal with high level textures such
as #CoglAtlasTexture&lt;!-- --&gt;s, #CoglSubTexture&lt;!-- --&gt;s,
#CoglTexturePixmapX11 textures and #CoglTexture2DSliced textures
consistently.

A #CoglMetaTexture is a texture that might internally be
represented by one or more low-level #CoglTexture&lt;!-- --&gt;s
such as #CoglTexture2D or #CoglTexture3D. These low-level textures
are the only ones that a GPU really understands but because
applications often want more high-level texture abstractions
(such as storing multiple textures inside one larger "atlas"
texture) it's desirable to be able to deal with these
using a common interface.

For example the GPU is not able to automatically handle repeating a
texture that is part of a larger atlas texture but if you use
%COGL_PIPELINE_WRAP_MODE_REPEAT with an atlas texture when drawing
with cogl_rectangle() you should see that it "Just Works™" - at
least if you don't use multi-texturing. The reason this works is
because cogl_rectangle() internally understands the #CoglMetaTexture
interface and is able to manually resolve the low-level textures
using this interface and by making multiple draw calls it can
emulate the texture repeat modes.

Cogl doesn't aim to pretend that meta-textures are just like real
textures because it would get extremely complex to try and emulate
low-level GPU semantics transparently for these textures.  The low
level drawing APIs of Cogl, such as cogl_primitive_draw() don't
actually know anything about the #CoglMetaTexture interface and its
the developer's responsibility to resolve all textures referenced
by a #CoglPipeline to low-level textures before drawing.

If you want to develop custom primitive APIs like
cogl_framebuffer_draw_rectangle() and you want to support drawing
with #CoglAtlasTexture&lt;!-- --&gt;s or #CoglSubTexture&lt;!-- --&gt;s for
example, then you will need to use this #CoglMetaTexture interface
to be able to resolve high-level textures into low-level textures
before drawing with Cogl's low-level drawing APIs such as
cogl_primitive_draw().

&lt;note&gt;Most developers won't need to use this interface directly
but still it is worth understanding the distinction between
low-level and meta textures because you may find other references
in the documentation that detail limitations of using
meta-textures.&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cogl-output">
      <doc xml:space="preserve"
           filename="cogl-output.h"
           line="48">The #CoglOutput object holds information about an output device
such as a monitor or laptop display. It can be queried to find
out the position of the output with respect to the screen
coordinate system and other information such as the resolution
and refresh rate of the device.

There can be any number of outputs which may overlap: the
same area of the screen may be displayed by multiple output
devices.

XXX: though it's possible to query the position of the output
with respect to screen coordinates, there is currently no way
of finding out the position of a #CoglOnscreen in screen
coordinates, at least without using windowing-system specific
API's, so it's not easy to get the output positions relative
to the #CoglOnscreen.</doc>
    </docsection>
    <docsection name="cogl-pipeline">
      <doc xml:space="preserve"
           filename="cogl-pipeline.h"
           line="55">Cogl allows creating and manipulating objects representing the full
configuration of the GPU pipeline. In simplified terms the GPU
pipeline takes primitive geometry as the input, it first performs
vertex processing, allowing you to deform your geometry, then
rasterizes that (turning it from pure geometry into fragments) then
performs fragment processing including depth testing and texture
mapping. Finally it blends the result with the framebuffer.</doc>
    </docsection>
    <docsection name="cogl-poll">
      <doc xml:space="preserve"
           filename="cogl-poll.h"
           line="45">Cogl needs to integrate with the application's main loop so that it
can internally handle some events from the driver. All Cogl
applications must use these functions. They provide enough
information to describe the state that Cogl will need to wake up
on. An application using the GLib main loop can instead use
cogl_glib_source_new() which provides a #GSource ready to be added
to the main loop.</doc>
    </docsection>
    <docsection name="cogl-primitive">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="56">FIXME</doc>
    </docsection>
    <docsection name="cogl-primitive-texture">
      <doc xml:space="preserve"
           filename="cogl-primitive-texture.h"
           line="42">A #CoglPrimitiveTexture is a texture that is directly represented
by a single texture on the GPU. For example these could be a
#CoglTexture2D, #CoglTexture3D or #CoglTextureRectangle. This is
opposed to high level meta textures which may be composed of
multiple primitive textures or a sub-region of another texture such
as #CoglAtlasTexture and #CoglTexture2DSliced.

A texture that implements this interface can be directly used with
the low level cogl_primitive_draw() API. Other types of textures
need to be first resolved to primitive textures using the
#CoglMetaTexture interface.

&lt;note&gt;Most developers won't need to use this interface directly but
still it is worth understanding the distinction between high-level
and primitive textures because you may find other references in the
documentation that detail limitations of using
primitive textures.&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cogl-quaternion">
      <doc xml:space="preserve"
           filename="cogl-quaternion.h"
           line="44">Quaternions have become a standard form for representing 3D
rotations and have some nice properties when compared with other
representation such as (roll,pitch,yaw) Euler angles. They can be
used to interpolate between different rotations and they don't
suffer from a problem called
&lt;ulink url="http://en.wikipedia.org/wiki/Gimbal_lock"&gt;"Gimbal lock"&lt;/ulink&gt;
where two of the axis of rotation may become aligned and you loose a
degree of freedom.
.</doc>
    </docsection>
    <docsection name="cogl-renderer">
      <doc xml:space="preserve"
           filename="cogl-renderer.h"
           line="47">A #CoglRenderer represents a means to render. It encapsulates the
selection of an underlying driver, such as OpenGL or OpenGL-ES and
a selection of a window system binding API such as GLX, or EGL or
WGL.

A #CoglRenderer has two states, "unconnected" and "connected". When
a renderer is first instantiated using cogl_renderer_new() it is
unconnected so that it can be configured and constraints can be
specified for how the backend driver and window system should be
chosen.

After configuration a #CoglRenderer can (optionally) be explicitly
connected using cogl_renderer_connect() which allows for the
handling of connection errors so that fallback configurations can
be tried if necessary. Applications that don't support any
fallbacks though can skip using cogl_renderer_connect() and leave
Cogl to automatically connect the renderer.

Once you have a configured #CoglRenderer it can be used to create a
#CoglDisplay object using cogl_display_new().

&lt;note&gt;Many applications don't need to explicitly use
cogl_renderer_new() or cogl_display_new() and can just jump
straight to cogl_context_new() and pass a %NULL display argument so
Cogl will automatically connect and setup a renderer and
display.&lt;/note&gt;</doc>
    </docsection>
    <docsection name="cogl-snippet">
      <doc xml:space="preserve"
           filename="cogl-snippet.h"
           line="43">#CoglSnippet&lt;!-- --&gt;s are used to modify or replace parts of a
#CoglPipeline using GLSL. GLSL is a programming language supported
by OpenGL on programmable hardware to provide a more flexible
description of what should be rendered. A description of GLSL
itself is outside the scope of this documentation but any good
OpenGL book should help to describe it.

Unlike in OpenGL, when using GLSL with Cogl it is possible to write
short snippets to replace small sections of the pipeline instead of
having to replace the whole of either the vertex or fragment
pipelines. Of course it is also possible to replace the whole of
the pipeline if needed.

Each snippet is a standalone chunk of code which would attach to
the pipeline at a particular point. The code is split into four
separate strings (all of which are optional):

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;declarations&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
The code in this string will be inserted outside of any function in
the global scope of the shader. This can be used to declare
uniforms, attributes, varyings and functions to be used by the
snippet.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;pre&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
The code in this string will be inserted before the hook point.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;post&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
The code in this string will be inserted after the hook point. This
can be used to modify the results of the builtin generated code for
that hook point.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;replace&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
If present the code in this string will replace the generated code
for the hook point.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

All of the strings apart from the declarations string of a pipeline
are generated in a single function so they can share variables
declared from one string in another. The scope of the code is
limited to each snippet so local variables declared in the snippet
will not collide with variables declared in another
snippet. However, code in the 'declarations' string is global to
the shader so it is the application's responsibility to ensure that
variables declared here will not collide with those from other
snippets.

The snippets can be added to a pipeline with
cogl_pipeline_add_snippet() or
cogl_pipeline_add_layer_snippet(). Which function to use depends on
which hook the snippet is targetting. The snippets are all
generated in the order they are added to the pipeline. That is, the
post strings are executed in the order they are added to the
pipeline and the pre strings are executed in reverse order. If any
replace strings are given for a snippet then any other snippets
with the same hook added before that snippet will be ignored. The
different hooks are documented under #CoglSnippetHook.

For portability with GLES2, it is recommended not to use the GLSL
builtin names such as gl_FragColor. Instead there are replacement
names under the cogl_* namespace which can be used instead. These
are:

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_modelview_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The current modelview matrix. This is equivalent to
   #gl_ModelViewMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_projection_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The current projection matrix. This is equivalent to
   #gl_ProjectionMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_modelview_projection_matrix&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The combined modelview and projection matrix. A vertex shader
   would typically use this to transform the incoming vertex
   position. The separate modelview and projection matrices are
   usually only needed for lighting calculations. This is
   equivalent to #gl_ModelViewProjectionMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;uniform mat4
        &lt;emphasis&gt;cogl_texture_matrix&lt;/emphasis&gt;[]&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An array of matrices for transforming the texture
   coordinates. This is equivalent to #gl_TextureMatrix.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

In a vertex shader, the following are also available:

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_position_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming vertex position. This is equivalent to #gl_Vertex.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_color_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming vertex color. This is equivalent to #gl_Color.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_tex_coord_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for layer 0. This is an alternative name
   for #cogl_tex_coord0_in.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec4
        &lt;emphasis&gt;cogl_tex_coord0_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for the layer 0. This is equivalent to
   #gl_MultiTexCoord0. There will also be #cogl_tex_coord1_in and
   so on if more layers are added to the pipeline.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;attribute vec3
        &lt;emphasis&gt;cogl_normal_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The normal of the vertex. This is equivalent to #gl_Normal.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec4
        &lt;emphasis&gt;cogl_position_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated position of the vertex. This must be written to
   in all vertex shaders. This is equivalent to #gl_Position.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float
        &lt;emphasis&gt;cogl_point_size_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The incoming point size from the cogl_point_size_in attribute.
   This is only available if
   cogl_pipeline_set_per_vertex_point_size() is set on the
   pipeline.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float
        &lt;emphasis&gt;cogl_point_size_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated size of a point. This is equivalent to #gl_PointSize.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
        &lt;emphasis&gt;cogl_color_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
        &lt;emphasis&gt;cogl_tex_coord0_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated texture coordinate for layer 0 of the pipeline.
   This is equivalent to #gl_TexCoord[0]. There will also be
   #cogl_tex_coord1_out and so on if more layers are added to the
   pipeline. In the fragment shader, this varying is called
   #cogl_tex_coord0_in.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

In a fragment shader, the following are also available:

&lt;glosslist&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4 &lt;emphasis&gt;cogl_color_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;varying vec4
             &lt;emphasis&gt;cogl_tex_coord0_in&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The texture coordinate for layer 0. This is equivalent to
   #gl_TexCoord[0]. There will also be #cogl_tex_coord1_in and so
   on if more layers are added to the pipeline.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec4 &lt;emphasis&gt;cogl_color_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   The final calculated color of the fragment. All fragment shaders
   must write to this variable. This is equivalent to
   #gl_FrontColor.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;float &lt;emphasis&gt;cogl_depth_out&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   An optional output variable specifying the depth value to use
   for this fragment. This is equivalent to #gl_FragDepth.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;bool &lt;emphasis&gt;cogl_front_facing&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   A readonly variable that will be true if the current primitive
   is front facing. This can be used to implement two-sided
   coloring algorithms. This is equivalent to #gl_FrontFacing.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
 &lt;glossentry&gt;
  &lt;glossterm&gt;vec2 &lt;emphasis&gt;cogl_point_coord&lt;/emphasis&gt;&lt;/glossterm&gt;
  &lt;glossdef&gt;&lt;para&gt;
   When rendering points, this will contain a vec2 which represents
   the position within the point of the current fragment.
   vec2(0.0,0.0) will be the topleft of the point and vec2(1.0,1.0)
   will be the bottom right. Note that there is currently a bug in
   Cogl where when rendering to an offscreen buffer these
   coordinates will be upside-down. The value is undefined when not
   rendering points. This builtin can only be used if the
   %COGL_FEATURE_ID_POINT_SPRITE feature is available.
  &lt;/para&gt;&lt;/glossdef&gt;
 &lt;/glossentry&gt;
&lt;/glosslist&gt;

Here is an example of using a snippet to add a desaturate effect to the
generated color on a pipeline.

&lt;programlisting&gt;
  CoglPipeline *pipeline = cogl_pipeline_new ();

  /&lt;!-- --&gt;* Set up the pipeline here, ie by adding a texture or other
     layers *&lt;!-- --&gt;/

  /&lt;!-- --&gt;* Create the snippet. The first string is the declarations which
     we will use to add a uniform. The second is the 'post' string which
     will contain the code to perform the desaturation. *&lt;!-- --&gt;/
  CoglSnippet *snippet =
    cogl_snippet_new (COGL_SNIPPET_HOOK_FRAGMENT,
                      "uniform float factor;",
                      "float gray = dot (vec3 (0.299, 0.587, 0.114), "
                      "                  cogl_color_out.rgb);"
                      "cogl_color_out.rgb = mix (vec3 (gray),"
                      "                          cogl_color_out.rgb,"
                      "                          factor);");

  /&lt;!-- --&gt;* Add it to the pipeline *&lt;!-- --&gt;/
  cogl_pipeline_add_snippet (pipeline, snippet);
  /&lt;!-- --&gt;* The pipeline keeps a reference to the snippet
     so we don't need to *&lt;!-- --&gt;/
  cogl_object_unref (snippet);

  /&lt;!-- --&gt;* Update the custom uniform on the pipeline *&lt;!-- --&gt;/
  int location = cogl_pipeline_get_uniform_location (pipeline, "factor");
  cogl_pipeline_set_uniform_1f (pipeline, location, 0.5f);

  /&lt;!-- --&gt;* Now we can render with the snippet as usual *&lt;!-- --&gt;/
  cogl_push_source (pipeline);
  cogl_rectangle (0, 0, 10, 10);
  cogl_pop_source ();
&lt;/programlisting&gt;</doc>
    </docsection>
    <docsection name="cogl-sub-texture">
      <doc xml:space="preserve"
           filename="cogl-sub-texture.h"
           line="41">These functions allow high-level textures to be created that
represent a sub-region of another texture. For example these
can be used to implement custom texture atlasing schemes.</doc>
    </docsection>
    <docsection name="cogl-texture">
      <doc xml:space="preserve"
           filename="cogl-texture.h"
           line="65">Cogl allows creating and manipulating textures using a uniform
API that tries to hide all the various complexities of creating,
loading and manipulating textures.</doc>
    </docsection>
    <docsection name="cogl-texture-2d">
      <doc xml:space="preserve"
           filename="cogl-texture-2d.h"
           line="45">These functions allow low-level 2D textures to be allocated. These
differ from sliced textures for example which may internally be
made up of multiple 2D textures, or atlas textures where Cogl must
internally modify user texture coordinates before they can be used
by the GPU.

You should be aware that many GPUs only support power of two sizes
for #CoglTexture2D textures. You can check support for non power of
two textures by checking for the %COGL_FEATURE_ID_TEXTURE_NPOT feature
via cogl_has_feature().</doc>
    </docsection>
    <docsection name="cogl-texture-2d-sliced">
      <doc xml:space="preserve"
           filename="cogl-texture-2d-sliced.h"
           line="39">These functions allow high-level meta textures (See the
#CoglMetaTexture interface) to be allocated that may internally be
comprised of multiple 2D texture "slices" with power-of-two sizes.

This API can be useful when working with GPUs that don't have
native support for non-power-of-two textures or if you want to load
a texture that is larger than the GPUs maximum texture size limits.

The algorithm for slicing works by first trying to map a virtual
size to the next larger power-of-two size and then seeing how many
wasted pixels that would result in. For example if you have a
virtual texture that's 259 texels wide, the next pot size = 512 and
the amount of waste would be 253 texels. If the amount of waste is
above a max-waste threshold then we would next slice that texture
into one that's 256 texels and then looking at how many more texels
remain unallocated after that we choose the next power-of-two size.
For the example of a 259 texel image that would mean having a 256
texel wide texture, leaving 3 texels unallocated so we'd then
create a 4 texel wide texture - now there is only one texel of
waste. The algorithm continues to slice the right most textures
until the amount of waste is less than or equal to a specfied
max-waste threshold. The same logic for slicing from left to right
is also applied from top to bottom.</doc>
    </docsection>
    <docsection name="cogl-texture-3d">
      <doc xml:space="preserve"
           filename="cogl-texture-3d.h"
           line="41">These functions allow 3D textures to be used. 3D textures can be
thought of as layers of 2D images arranged into a cuboid
shape. When choosing a texel from the texture, Cogl will take into
account the 'r' texture coordinate to select one of the images.</doc>
    </docsection>
    <docsection name="cogl-texture-pixmap-x11">
      <doc xml:space="preserve"
           filename="winsys/cogl-texture-pixmap-x11.h"
           line="61">These functions allow high-level meta textures (See the
#CoglMetaTexture interface) that derive their contents from an X11
pixmap.</doc>
    </docsection>
    <docsection name="cogl-texture-rectangle">
      <doc xml:space="preserve"
           filename="cogl-texture-rectangle.h"
           line="40">These functions allow low-level "rectangle" textures to be allocated.
These textures are never constrained to power-of-two sizes but they
also don't support having a mipmap and can only be wrapped with
%COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE.

The most notable difference between rectangle textures and 2D
textures is that rectangle textures are sampled using un-normalized
texture coordinates, so instead of using coordinates (0,0) and
(1,1) to map to the top-left and bottom right corners of the
texture you would instead use (0,0) and (width,height).

The use of non-normalized coordinates can be particularly
convenient when writing glsl shaders that use a texture as a lookup
table since you don't need to upload separate uniforms to map
normalized coordinates to texels.

If you want to sample from a rectangle texture from GLSL you should
use the sampler2DRect sampler type.

Applications wanting to use #CoglTextureRectangle should first check
for the %COGL_FEATURE_ID_TEXTURE_RECTANGLE feature using
cogl_has_feature().</doc>
    </docsection>
    <docsection name="cogl-types">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="58">General types used by various Cogl functions.</doc>
    </docsection>
    <docsection name="cogl-vector">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="41">This exposes a utility API that can be used for basic manipulation of 3
component float vectors.</doc>
    </docsection>
    <docsection name="cogl-version">
      <doc xml:space="preserve"
           filename="cogl-version.h"
           line="36">Cogl offers a set of macros for checking the version of the library
at compile time.

Cogl adds version information to both API deprecations and additions;
by definining the macros %COGL_VERSION_MIN_REQUIRED and
%COGL_VERSION_MAX_ALLOWED, you can specify the range of Cogl versions
whose API you want to use. Functions that were deprecated before, or
introduced after, this range will trigger compiler warnings. For instance,
if we define the following symbols:

|[
  COGL_VERSION_MIN_REQUIRED = COGL_VERSION_1_6
  COGL_VERSION_MAX_ALLOWED  = COGL_VERSION_1_8
]|

and we have the following functions annotated in the Cogl headers:

|[
  COGL_DEPRECATED_IN_1_4 void cogl_function_A (void);
  COGL_DEPRECATED_IN_1_6 void cogl_function_B (void);
  COGL_AVAILABLE_IN_1_8 void cogl_function_C (void);
  COGL_AVAILABLE_IN_1_10 void cogl_function_D (void);
]|

then any application code using the functions above will get the output:

|[
  cogl_function_A: deprecation warning
  cogl_function_B: no warning
  cogl_function_C: no warning
  cogl_function_D: symbol not available warning
]|

It is possible to disable the compiler warnings by defining the macro
%COGL_DISABLE_DEPRECATION_WARNINGS before including the cogl.h
header.</doc>
    </docsection>
    <function name="color_equal"
              c:identifier="cogl_color_equal"
              moved-to="Color.equal"
              version="1.0">
      <doc xml:space="preserve"
           filename="cogl-color.h"
           line="547">Compares two #CoglColor&lt;!-- --&gt;s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using #CoglColor&lt;!-- --&gt;s as keys in a #GHashTable.</doc>
      <source-position filename="cogl-color.h" line="562"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-color.h"
             line="557">%TRUE if the two colors are the same.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="549">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="550">a #CoglColor</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_init_from_hsl"
              c:identifier="cogl_color_init_from_hsl"
              moved-to="Color.init_from_hsl"
              version="1.16">
      <doc xml:space="preserve"
           filename="cogl-color.h"
           line="584">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
      <source-position filename="cogl-color.h" line="597"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="586">return location for a #CoglColor</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="hue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="587">hue value, in the 0 .. 360 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="saturation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="588">saturation value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="luminance" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-color.h"
               line="589">luminance value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_matrix_entry_print"
              c:identifier="cogl_debug_matrix_entry_print">
      <doc xml:space="preserve"
           filename="cogl-matrix-stack.h"
           line="610">Allows visualizing the operations that build up the given @entry
for debugging purposes by printing to stdout.</doc>
      <source-position filename="cogl-matrix-stack.h" line="618"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="entry" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="612">A #CoglMatrixEntry</doc>
          <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_matrix_print"
              c:identifier="cogl_debug_matrix_print"
              version="2.0">
      <doc xml:space="preserve"
           filename="cogl-matrix.h"
           line="783">Prints the contents of a #CoglMatrix to stdout.</doc>
      <source-position filename="cogl-matrix.h" line="792"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-matrix.h"
               line="785">A #CoglMatrix</doc>
          <type name="Matrix" c:type="const CoglMatrix*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_object_foreach_type"
              c:identifier="cogl_debug_object_foreach_type"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-object.h"
           line="215">Invokes @func once for each type of object that Cogl uses and
passes a count of the number of objects for that type. This is
intended to be used solely for debugging purposes to track down
issues with objects leaking.</doc>
      <source-position filename="cogl-object.h" line="229"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="func"
                   transfer-ownership="none"
                   scope="call"
                   closure="1">
          <doc xml:space="preserve"
               filename="cogl-object.h"
               line="217">A callback function for each type</doc>
          <type name="DebugObjectForeachTypeCallback"
                c:type="CoglDebugObjectForeachTypeCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-object.h"
               line="218">A pointer to pass to @func</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="debug_object_print_instances"
              c:identifier="cogl_debug_object_print_instances"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-object.h"
           line="232">Prints a list of all the object types that Cogl uses along with the
number of objects of that type that are currently in use. This is
intended to be used solely for debugging purposes to track down
issues with objects leaking.</doc>
      <source-position filename="cogl-object.h" line="244"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="egl_context_get_egl_context"
              c:identifier="cogl_egl_context_get_egl_context"
              version="1.18"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-egl.h"
           line="82">If you have done a runtime check to determine that Cogl is using
EGL internally then this API can be used to retrieve the EGLContext
handle that was setup internally. The result is undefined if Cogl
is not using EGL.

Note: The current window system backend can be checked using
cogl_renderer_get_winsys_id().</doc>
      <source-position filename="cogl-egl.h" line="99"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cogl-egl.h"
             line="94">The internally setup EGLDisplay handle.</doc>
        <type c:type="EGLContext"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-egl.h"
               line="84">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="egl_context_get_egl_display"
              c:identifier="cogl_egl_context_get_egl_display"
              version="1.8"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-egl.h"
           line="63">If you have done a runtime check to determine that Cogl is using
EGL internally then this API can be used to retrieve the EGLDisplay
handle that was setup internally. The result is undefined if Cogl
is not using EGL.

Note: The current window system backend can be checked using
cogl_renderer_get_winsys_id().</doc>
      <source-position filename="cogl-egl.h" line="80"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cogl-egl.h"
             line="75">The internally setup EGLDisplay handle.</doc>
        <type c:type="EGLDisplay"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-egl.h"
               line="65">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_copy" c:identifier="cogl_error_copy">
      <doc xml:space="preserve"
           filename="cogl-error.h"
           line="139">Makes a copy of @error which can later be freed using
cogl_error_free().</doc>
      <source-position filename="cogl-error.h" line="150"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cogl-error.h"
             line="146">A newly allocated #CoglError initialized to match the
              contents of @error.</doc>
        <type name="GLib.Error" c:type="GError*"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-error.h"
               line="141">A #CoglError thrown by the Cogl api</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_free" c:identifier="cogl_error_free">
      <doc xml:space="preserve"
           filename="cogl-error.h"
           line="130">Frees a #CoglError and associated resources.</doc>
      <source-position filename="cogl-error.h" line="137"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-error.h"
               line="132">A #CoglError thrown by the Cogl api</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_matches" c:identifier="cogl_error_matches">
      <doc xml:space="preserve"
           filename="cogl-error.h"
           line="152">Returns %TRUE if error matches @domain and @code, %FALSE otherwise.
In particular, when error is %NULL, FALSE will be returned.</doc>
      <source-position filename="cogl-error.h" line="165"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-error.h"
             line="161">whether the @error corresponds to the given @domain
              and @code.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="error" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-error.h"
               line="154">A #CoglError thrown by the Cogl api or %NULL</doc>
          <type name="GLib.Error" c:type="GError*"/>
        </parameter>
        <parameter name="domain" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-error.h"
               line="155">The error domain</doc>
          <type name="guint32" c:type="uint32_t"/>
        </parameter>
        <parameter name="code" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-error.h"
               line="156">The error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="euler_equal"
              c:identifier="cogl_euler_equal"
              moved-to="Euler.equal"
              version="2.0">
      <doc xml:space="preserve"
           filename="cogl-euler.h"
           line="222">Compares the two given euler angles @v1 and @v1 and it they are
equal returns %TRUE else %FALSE.

&lt;note&gt;This function only checks that all three components rotations
are numerically equal, it does not consider that some rotations
can be represented with different component rotations&lt;/note&gt;</doc>
      <source-position filename="cogl-euler.h" line="238"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-euler.h"
             line="234">%TRUE if @v1 and @v2 are equal else %FALSE.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-euler.h"
               line="224">The first euler angle to compare</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-euler.h"
               line="225">The second euler angle to compare</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="foreach_feature"
              c:identifier="cogl_foreach_feature"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="355">Iterates through all the context level features currently supported
for a given @context and for each feature @callback is called.</doc>
      <source-position filename="cogl-context.h" line="369"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="357">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="callback"
                   transfer-ownership="none"
                   scope="call"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="358">A #CoglFeatureCallback called for each
           supported feature</doc>
          <type name="FeatureCallback" c:type="CoglFeatureCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="360">Private data to pass to the callback</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="framebuffer_error_quark"
              c:identifier="cogl_framebuffer_error_quark"
              moved-to="Framebuffer.error_quark">
      <source-position filename="cogl-framebuffer.h" line="1841"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="get_clock_time"
              c:identifier="cogl_get_clock_time"
              version="1.14"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="373">Returns the current time value from Cogl's internal clock. This
clock is used for measuring times such as the presentation time
in a #CoglFrameInfo.

This method is meant for converting timestamps retrieved from Cogl
to other time systems, and is not meant to be used as a standalone
timing system. For that reason, if this function is called without
having retrieved a valid (non-zero) timestamp from Cogl first, it
may return 0 to indicate that Cogl has no active internal clock.</doc>
      <source-position filename="cogl-context.h" line="394"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="387">the time value for the Cogl clock, in nanoseconds
 from an arbitrary point in time, or 0 if Cogl doesn't have an
 active internal clock.</doc>
        <type name="gint64" c:type="int64_t"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="375">a #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_draw_framebuffer"
              c:identifier="cogl_get_draw_framebuffer"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-framebuffer.h"
           line="1822">Gets the current #CoglFramebuffer as set using
cogl_push_framebuffer()</doc>
      <source-position filename="cogl-framebuffer.h" line="1833"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1828">The current #CoglFramebuffer</doc>
        <type name="Framebuffer" c:type="CoglFramebuffer*"/>
      </return-value>
    </function>
    <function name="get_rectangle_indices"
              c:identifier="cogl_get_rectangle_indices"
              introspectable="0">
      <source-position filename="cogl-indices.h" line="146"/>
      <return-value>
        <type name="Indices" c:type="CoglIndices*"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="n_rectangles" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_static_identity_quaternion"
              c:identifier="cogl_get_static_identity_quaternion"
              version="2.0">
      <doc xml:space="preserve"
           filename="cogl-quaternion.h"
           line="533">Returns a pointer to a singleton quaternion constant describing the
canonical identity [1 (0, 0, 0)] which represents no rotation.

If you multiply a quaternion with the identity quaternion you will
get back the same value as the original quaternion.</doc>
      <source-position filename="cogl-quaternion.h" line="547"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="542">A pointer to an identity quaternion</doc>
        <type name="Quaternion" c:type="const CoglQuaternion*"/>
      </return-value>
    </function>
    <function name="get_static_zero_quaternion"
              c:identifier="cogl_get_static_zero_quaternion"
              version="2.0">
      <source-position filename="cogl-quaternion.h" line="559"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="552">a pointer to a singleton quaternion constant describing a
         rotation of 180 degrees around a degenerate axis:
         [0 (0, 0, 0)]</doc>
        <type name="Quaternion" c:type="const CoglQuaternion*"/>
      </return-value>
    </function>
    <function name="gles2_get_current_vtable"
              c:identifier="cogl_gles2_get_current_vtable"
              version="2.0"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="299">Returns the OpenGL ES 2.0 api vtable for the currently pushed
#CoglGLES2Context (last pushed with cogl_push_gles2_context()) or
%NULL if no #CoglGLES2Context has been pushed.</doc>
      <source-position filename="cogl-gles2.h" line="312"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="306">The #CoglGLES2Vtable for the currently pushed
              #CoglGLES2Context or %NULL if none has been pushed.</doc>
        <type name="GLES2Vtable" c:type="CoglGLES2Vtable*"/>
      </return-value>
    </function>
    <function name="gles2_texture_2d_new_from_handle"
              c:identifier="cogl_gles2_texture_2d_new_from_handle"
              version="2.0"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="314">Creates a #CoglTexture2D from an OpenGL ES 2.0 texture handle that
was created within the given @gles2_ctx via glGenTextures(). The
texture needs to have been associated with the GL_TEXTURE_2D target.

&lt;note&gt;This interface is only intended for sharing textures to read
from.  The behaviour is undefined if the texture is modified using
the Cogl api.&lt;/note&gt;

&lt;note&gt;Applications should only pass this function handles that were
created via a #CoglGLES2Vtable or via libcogl-gles2 and not pass
handles created directly using the system's native libGLESv2
api.&lt;/note&gt;</doc>
      <source-position filename="cogl-gles2.h" line="342"/>
      <return-value>
        <type name="Texture2D" c:type="CoglTexture2D*"/>
      </return-value>
      <parameters>
        <parameter name="ctx" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="316">A #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="gles2_ctx" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="317">A #CoglGLES2Context allocated with
            cogl_gles2_context_new()</doc>
          <type name="GLES2Context" c:type="CoglGLES2Context*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="319">An OpenGL ES 2.0 texture handle created with
         glGenTextures()</doc>
          <type name="guint" c:type="unsigned int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="321">Width of the texture to allocate</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="322">Height of the texture to allocate</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="323">The format of the texture</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="gles2_texture_get_handle"
              c:identifier="cogl_gles2_texture_get_handle"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="349">Gets an OpenGL ES 2.0 texture handle for a #CoglTexture that can
then be referenced by a #CoglGLES2Context. As well as returning
a texture handle the texture's target (such as GL_TEXTURE_2D) is
also returned.

If the #CoglTexture can not be shared with a #CoglGLES2Context then
this function will return %FALSE.

This api does not affect the lifetime of the CoglTexture and you
must take care not to reference the returned handle after the
original texture has been freed.

&lt;note&gt;This interface is only intended for sharing textures to read
from.  The behaviour is undefined if the texture is modified by a
GLES2 context.&lt;/note&gt;

&lt;note&gt;This function will only return %TRUE for low-level
#CoglTexture&lt;!-- --&gt;s such as #CoglTexture2D or #CoglTexture3D but
not for high level meta textures such as
#CoglTexture2DSliced&lt;/note&gt;

&lt;note&gt;The handle returned should not be passed directly to a system
OpenGL ES 2.0 library, the handle is only intended to be used via
a #CoglGLES2Vtable or via libcogl-gles2.&lt;/note&gt;</doc>
      <source-position filename="cogl-gles2.h" line="386"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="380">%TRUE if a handle and target could be returned
              otherwise %FALSE is returned.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="351">A #CoglTexture</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="352">A return location for an OpenGL ES 2.0 texture handle</doc>
          <type name="guint" c:type="unsigned int*"/>
        </parameter>
        <parameter name="target" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="353">A return location for an OpenGL ES 2.0 texture target</doc>
          <type name="guint" c:type="unsigned int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="glib_renderer_source_new"
              c:identifier="cogl_glib_renderer_source_new"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-glib-source.h"
           line="74">Creates a #GSource which handles Cogl's internal system event
processing. This can be used as a convenience instead of
cogl_poll_renderer_get_info() and cogl_poll_renderer_dispatch() in
applications that are already using the GLib main loop. After this
is called the #GSource should be attached to the main loop using
g_source_attach().</doc>
      <source-position filename="cogl-glib-source.h" line="92"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cogl-glib-source.h"
             line="86">a new #GSource</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-glib-source.h"
               line="76">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-glib-source.h"
               line="77">The priority of the #GSource</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="glib_source_new"
              c:identifier="cogl_glib_source_new"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-glib-source.h"
           line="43">Creates a #GSource which handles Cogl's internal system event
processing. This can be used as a convenience instead of
cogl_poll_renderer_get_info() and cogl_poll_renderer_dispatch() in
applications that are already using the GLib main loop. After this
is called the #GSource should be attached to the main loop using
g_source_attach().

Applications that manually connect to a #CoglRenderer before they
create a #CoglContext should instead use
cogl_glib_renderer_source_new() so that events may be dispatched
before a context has been created. In that case you don't need to
use this api in addition later, it is simply enough to use
cogl_glib_renderer_source_new() instead.

&lt;note&gt;This api is actually just a thin convenience wrapper around
cogl_glib_renderer_source_new()&lt;/note&gt;</doc>
      <source-position filename="cogl-glib-source.h" line="71"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cogl-glib-source.h"
             line="65">a new #GSource</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-glib-source.h"
               line="45">A #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-glib-source.h"
               line="46">The priority of the #GSource</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="glx_context_get_glx_context"
              c:identifier="cogl_glx_context_get_glx_context"
              version="1.18"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-glx.h"
           line="63">If you have done a runtime check to determine that Cogl is using
GLX internally then this API can be used to retrieve the GLXContext
handle that was setup internally. The result is undefined if Cogl
is not using GLX.</doc>
      <source-position filename="cogl-glx.h" line="77"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cogl-glx.h"
             line="72">The internally setup GLXContext handle.</doc>
        <type c:type="GLXContext"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-glx.h"
               line="65">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="gtype_matrix_get_type"
              c:identifier="cogl_gtype_matrix_get_type"
              deprecated="1"
              deprecated-version="1.18">
      <doc-deprecated xml:space="preserve">Use cogl_matrix_get_gtype() instead.</doc-deprecated>
      <source-position filename="cogl-matrix.h" line="815"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-matrix.h"
             line="808">the GType for the registered "CoglMatrix" boxed type. This
can be used for example to define GObject properties that accept a
#CoglMatrix value.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="handle_get_type" c:identifier="cogl_handle_get_type">
      <source-position filename="cogl-types.h" line="157"/>
      <return-value transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </return-value>
    </function>
    <function name="handle_ref" c:identifier="cogl_handle_ref">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="161">Increases the reference count of @handle by 1</doc>
      <source-position filename="cogl-types.h" line="170"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-types.h"
             line="167">the handle, with its reference count increased</doc>
        <type name="Handle" c:type="CoglHandle"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-types.h"
               line="163">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="handle_unref" c:identifier="cogl_handle_unref">
      <doc xml:space="preserve"
           filename="cogl-types.h"
           line="172">Drecreases the reference count of @handle by 1; if the reference
count reaches 0, the resources allocated by @handle will be freed</doc>
      <source-position filename="cogl-types.h" line="180"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="handle" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-types.h"
               line="174">a #CoglHandle</doc>
          <type name="Handle" c:type="CoglHandle"/>
        </parameter>
      </parameters>
    </function>
    <function name="has_feature"
              c:identifier="cogl_has_feature"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="301">Checks if a given @feature is currently available

Cogl does not aim to be a lowest common denominator API, it aims to
expose all the interesting features of GPUs to application which
means applications have some responsibility to explicitly check
that certain features are available before depending on them.</doc>
      <source-position filename="cogl-context.h" line="320"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="313">%TRUE if the @feature is currently supported or %FALSE if
not.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="303">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="feature" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="304">A #CoglFeatureID</doc>
          <type name="FeatureID" c:type="CoglFeatureID"/>
        </parameter>
      </parameters>
    </function>
    <function name="has_features"
              c:identifier="cogl_has_features"
              version="1.10"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="322">Checks if a list of features are all currently available.

This checks all of the listed features using cogl_has_feature() and
returns %TRUE if all the features are available or %FALSE
otherwise.</doc>
      <source-position filename="cogl-context.h" line="340"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="333">%TRUE if all the features are available, %FALSE
otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="context" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="324">A #CoglContext pointer</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="325">A 0 terminated list of CoglFeatureID&lt;!-- --&gt;s</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="is_atlas_texture"
              c:identifier="cogl_is_atlas_texture"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-atlas-texture.h"
           line="241">Checks whether the given object references a #CoglAtlasTexture</doc>
      <source-position filename="cogl-atlas-texture.h" line="254"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-atlas-texture.h"
             line="247">%TRUE if the passed object represents an atlas
  texture and %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-atlas-texture.h"
               line="243">a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_attribute" c:identifier="cogl_is_attribute">
      <doc xml:space="preserve"
           filename="cogl-attribute.h"
           line="543">Gets whether the given object references a #CoglAttribute.</doc>
      <source-position filename="cogl-attribute.h" line="553"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-attribute.h"
             line="549">%TRUE if the @object references a #CoglAttribute,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-attribute.h"
               line="545">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_attribute_buffer"
              c:identifier="cogl_is_attribute_buffer"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-attribute-buffer.h"
           line="134">Gets whether the given object references a #CoglAttributeBuffer.</doc>
      <source-position filename="cogl-attribute-buffer.h" line="147"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-attribute-buffer.h"
             line="140">%TRUE if @object references a #CoglAttributeBuffer,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-attribute-buffer.h"
               line="136">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_bitmap" c:identifier="cogl_is_bitmap" version="1.0">
      <doc xml:space="preserve"
           filename="cogl-bitmap.h"
           line="288">Checks whether @object is a #CoglBitmap</doc>
      <source-position filename="cogl-bitmap.h" line="300"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-bitmap.h"
             line="294">%TRUE if the passed @object represents a bitmap,
  and %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-bitmap.h"
               line="290">a #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_buffer"
              c:identifier="cogl_is_buffer"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-buffer.h"
           line="98">Checks whether @buffer is a buffer object.</doc>
      <source-position filename="cogl-buffer.h" line="110"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-buffer.h"
             line="104">%TRUE if the handle is a CoglBuffer, and %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-buffer.h"
               line="100">a buffer object</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_context"
              c:identifier="cogl_is_context"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-context.h"
           line="183">Gets whether the given object references an existing context object.</doc>
      <source-position filename="cogl-context.h" line="196"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-context.h"
             line="189">%TRUE if the @object references a #CoglContext,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-context.h"
               line="185">An object or %NULL</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_display"
              c:identifier="cogl_is_display"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-display.h"
           line="217">Gets whether the given object references a #CoglDisplay.</doc>
      <source-position filename="cogl-display.h" line="229"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-display.h"
             line="223">%TRUE if the object references a #CoglDisplay
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-display.h"
               line="219">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_frame_info"
              c:identifier="cogl_is_frame_info"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-frame-info.h"
           line="62">Gets whether the given object references a #CoglFrameInfo.</doc>
      <source-position filename="cogl-frame-info.h" line="74"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-frame-info.h"
             line="68">%TRUE if the object references a #CoglFrameInfo
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-frame-info.h"
               line="64">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_framebuffer"
              c:identifier="cogl_is_framebuffer"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-framebuffer.h"
           line="1854">Gets whether the given object references a #CoglFramebuffer.</doc>
      <source-position filename="cogl-framebuffer.h" line="1866"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-framebuffer.h"
             line="1860">%TRUE if the object references a #CoglFramebuffer
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-framebuffer.h"
               line="1856">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_gles2_context"
              c:identifier="cogl_is_gles2_context"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="390">Gets whether the given object references a #CoglGLES2Context.</doc>
      <source-position filename="cogl-gles2.h" line="402"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="396">%TRUE if the object references a #CoglGLES2Context
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="392">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_index_buffer"
              c:identifier="cogl_is_index_buffer"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-index-buffer.h"
           line="89">Gets whether the given object references a #CoglIndexBuffer.</doc>
      <source-position filename="cogl-index-buffer.h" line="102"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-index-buffer.h"
             line="95">%TRUE if the @object references a #CoglIndexBuffer,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-index-buffer.h"
               line="91">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_indices"
              c:identifier="cogl_is_indices"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-indices.h"
           line="148">Gets whether the given object references a #CoglIndices.</doc>
      <source-position filename="cogl-indices.h" line="160"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-indices.h"
             line="154">%TRUE if the object references a #CoglIndices
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-indices.h"
               line="150">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_matrix_stack" c:identifier="cogl_is_matrix_stack">
      <doc xml:space="preserve"
           filename="cogl-matrix-stack.h"
           line="536">Determines if the given #CoglObject refers to a #CoglMatrixStack.</doc>
      <source-position filename="cogl-matrix-stack.h" line="546"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-matrix-stack.h"
             line="542">%TRUE if @object is a #CoglMatrixStack, otherwise
              %FALSE.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-matrix-stack.h"
               line="538">a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_onscreen"
              c:identifier="cogl_is_onscreen"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="1040">Gets whether the given object references a #CoglOnscreen.</doc>
      <source-position filename="cogl-onscreen.h" line="1052"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-onscreen.h"
             line="1046">%TRUE if the object references a #CoglOnscreen
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="1042">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_onscreen_template"
              c:identifier="cogl_is_onscreen_template"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen-template.h"
           line="127">Gets whether the given object references a #CoglOnscreenTemplate.</doc>
      <source-position filename="cogl-onscreen-template.h" line="139"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-onscreen-template.h"
             line="133">%TRUE if the object references a #CoglOnscreenTemplate
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-onscreen-template.h"
               line="129">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_output"
              c:identifier="cogl_is_output"
              version="1.14"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-output.h"
           line="122">Gets whether the given object references a #CoglOutput.</doc>
      <source-position filename="cogl-output.h" line="134"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-output.h"
             line="128">%TRUE if the object references a #CoglOutput
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-output.h"
               line="124">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_pipeline"
              c:identifier="cogl_is_pipeline"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-pipeline.h"
           line="116">Gets whether the given @object references an existing pipeline object.</doc>
      <source-position filename="cogl-pipeline.h" line="129"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-pipeline.h"
             line="122">%TRUE if the @object references a #CoglPipeline,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-pipeline.h"
               line="118">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_pixel_buffer"
              c:identifier="cogl_is_pixel_buffer"
              version="1.2"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-pixel-buffer.h"
           line="90">Checks whether @object is a pixel buffer.</doc>
      <source-position filename="cogl-pixel-buffer.h" line="103"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-pixel-buffer.h"
             line="96">%TRUE if the @object is a pixel buffer, and %FALSE
  otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-pixel-buffer.h"
               line="92">a #CoglObject to test</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_primitive"
              c:identifier="cogl_is_primitive"
              version="1.6"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive.h"
           line="863">Gets whether the given object references a #CoglPrimitive.</doc>
      <source-position filename="cogl-primitive.h" line="876"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-primitive.h"
             line="869">%TRUE if the @object references a #CoglPrimitive,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-primitive.h"
               line="865">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_primitive_texture"
              c:identifier="cogl_is_primitive_texture"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-primitive-texture.h"
           line="76">Gets whether the given object references a primitive texture object.</doc>
      <source-position filename="cogl-primitive-texture.h" line="88"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-primitive-texture.h"
             line="82">%TRUE if the pointer references a primitive texture, and
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-primitive-texture.h"
               line="78">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_renderer"
              c:identifier="cogl_is_renderer"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-renderer.h"
           line="101">Determines if the given @object is a #CoglRenderer</doc>
      <source-position filename="cogl-renderer.h" line="112"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-renderer.h"
             line="107">%TRUE if @object is a #CoglRenderer, else %FALSE.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-renderer.h"
               line="103">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_snippet"
              c:identifier="cogl_is_snippet"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-snippet.h"
           line="712">Gets whether the given @object references an existing snippet object.</doc>
      <source-position filename="cogl-snippet.h" line="725"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-snippet.h"
             line="718">%TRUE if the @object references a #CoglSnippet,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-snippet.h"
               line="714">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_sub_texture"
              c:identifier="cogl_is_sub_texture"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-sub-texture.h"
           line="119">Checks whether @object is a #CoglSubTexture.</doc>
      <source-position filename="cogl-sub-texture.h" line="132"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-sub-texture.h"
             line="125">%TRUE if the passed @object represents a
              #CoglSubTexture and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-sub-texture.h"
               line="121">a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_swap_chain" c:identifier="cogl_is_swap_chain">
      <source-position filename="cogl-swap-chain.h" line="67"/>
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture" c:identifier="cogl_is_texture">
      <doc xml:space="preserve"
           filename="cogl-texture.h"
           line="134">Gets whether the given object references a texture object.</doc>
      <source-position filename="cogl-texture.h" line="144"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-texture.h"
             line="140">%TRUE if the @object references a texture, and
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-texture.h"
               line="136">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_2d" c:identifier="cogl_is_texture_2d">
      <doc xml:space="preserve"
           filename="cogl-texture-2d.h"
           line="73">Gets whether the given object references an existing #CoglTexture2D
object.</doc>
      <source-position filename="cogl-texture-2d.h" line="84"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-texture-2d.h"
             line="80">%TRUE if the object references a #CoglTexture2D,
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-texture-2d.h"
               line="75">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_2d_sliced"
              c:identifier="cogl_is_texture_2d_sliced"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-texture-2d-sliced.h"
           line="287">Gets whether the given object references a #CoglTexture2DSliced.</doc>
      <source-position filename="cogl-texture-2d-sliced.h" line="299"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-texture-2d-sliced.h"
             line="293">%TRUE if the object references a #CoglTexture2DSliced
  and %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-texture-2d-sliced.h"
               line="289">A #CoglObject pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_3d"
              c:identifier="cogl_is_texture_3d"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-texture-3d.h"
           line="187">Checks whether the given object references a #CoglTexture3D</doc>
      <source-position filename="cogl-texture-3d.h" line="200"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-texture-3d.h"
             line="193">%TRUE if the passed object represents a 3D texture
  and %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-texture-3d.h"
               line="189">a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_pixmap_x11"
              c:identifier="cogl_is_texture_pixmap_x11"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="winsys/cogl-texture-pixmap-x11.h"
           line="262">Checks whether @object points to a #CoglTexturePixmapX11 instance.</doc>
      <source-position filename="winsys/cogl-texture-pixmap-x11.h" line="275"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="winsys/cogl-texture-pixmap-x11.h"
             line="268">%TRUE if the object is a #CoglTexturePixmapX11, and
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="winsys/cogl-texture-pixmap-x11.h"
               line="264">A pointer to a #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="is_texture_rectangle"
              c:identifier="cogl_is_texture_rectangle">
      <doc xml:space="preserve"
           filename="cogl-texture-rectangle.h"
           line="81">Gets whether the given object references an existing
#CoglTextureRectangle object.</doc>
      <source-position filename="cogl-texture-rectangle.h" line="92"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-texture-rectangle.h"
             line="88">%TRUE if the object references a
              #CoglTextureRectangle, %FALSE otherwise.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-texture-rectangle.h"
               line="83">A #CoglObject</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="kms_display_queue_modes_reset"
              c:identifier="cogl_kms_display_queue_modes_reset"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-kms-display.h"
           line="43">Asks Cogl to explicitly reset the crtc output modes at the next
#CoglOnscreen swap_buffers request. For applications that support
VT switching they may want to re-assert the output modes when
switching back to the applications VT since the modes are often not
correctly restored automatically.

&lt;note&gt;The @display must have been either explicitly setup via
cogl_display_setup() or implicitily setup by having created a
context using the @display&lt;/note&gt;</doc>
      <source-position filename="cogl-kms-display.h" line="61"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="display" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-display.h"
               line="45">A #CoglDisplay</doc>
          <type name="Display" c:type="CoglDisplay*"/>
        </parameter>
      </parameters>
    </function>
    <function name="kms_display_set_ignore_crtc"
              c:identifier="cogl_kms_display_set_ignore_crtc"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-kms-display.h"
           line="103">Tells cogl to ignore (or stop ignoring) a ctrc which means
it never flips buffers at this crtc.</doc>
      <source-position filename="cogl-kms-display.h" line="115"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="display" transfer-ownership="none">
          <type name="Display" c:type="CoglDisplay*"/>
        </parameter>
        <parameter name="id" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-display.h"
               line="106">KMS output id</doc>
          <type name="guint32" c:type="uint32_t"/>
        </parameter>
        <parameter name="ignore" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-display.h"
               line="107">Ignore ouput or not</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
      </parameters>
    </function>
    <function name="kms_display_set_layout"
              c:identifier="cogl_kms_display_set_layout"
              stability="Unstable"
              throws="1">
      <doc xml:space="preserve"
           filename="cogl-kms-display.h"
           line="74">Configures @display to use a framebuffer sized @width x @height, covering
the CRTCS in @crtcs.
@width and @height must be within the driver framebuffer limits, and @crtcs
must be valid KMS API IDs.

Calling this function overrides the automatic mode setting done by Cogl,
and for this reason must be called before the first call to cogl_onscreen_swap_buffers().

If you want to restore the default behaviour, you can call this function
with @width and @height set to -1.</doc>
      <source-position filename="cogl-kms-display.h" line="95"/>
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="display" transfer-ownership="none">
          <type name="Display" c:type="CoglDisplay*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-display.h"
               line="77">the framebuffer width</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-display.h"
               line="78">the framebuffer height</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="crtcs" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-display.h"
               line="79">the array of #CoglKmsCrtc structure with the desired CRTC layout</doc>
          <type name="KmsCrtc" c:type="CoglKmsCrtc**"/>
        </parameter>
        <parameter name="n_crtcs" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="kms_renderer_get_gbm"
              c:identifier="cogl_kms_renderer_get_gbm">
      <source-position filename="cogl-kms-renderer.h" line="72"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gbm_device*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="kms_renderer_get_kms_fd"
              c:identifier="cogl_kms_renderer_get_kms_fd"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-kms-renderer.h"
           line="57">Queries the file descriptor Cogl is using internally for
communicating with the kms driver.</doc>
      <source-position filename="cogl-kms-renderer.h" line="69"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-kms-renderer.h"
             line="64">The kms file descriptor or -1 if no kms file
              desriptor has been opened by Cogl.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-renderer.h"
               line="59">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="kms_renderer_set_kms_fd"
              c:identifier="cogl_kms_renderer_set_kms_fd"
              version="1.18"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-kms-renderer.h"
           line="41">Sets the file descriptor Cogl should use to communicate
to the kms driver. If -1 (the default), then Cogl will
open its own FD by trying to open "/dev/dri/card0".</doc>
      <source-position filename="cogl-kms-renderer.h" line="54"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-renderer.h"
               line="43">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-kms-renderer.h"
               line="44">The fd to kms to use</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="matrix_equal"
              c:identifier="cogl_matrix_equal"
              moved-to="Matrix.equal"
              version="1.4">
      <doc xml:space="preserve"
           filename="cogl-matrix.h"
           line="555">Compares two matrices to see if they represent the same
transformation. Although internally the matrices may have different
annotations associated with them and may potentially have a cached
inverse matrix these are not considered in the comparison.</doc>
      <source-position filename="cogl-matrix.h" line="568"/>
      <return-value transfer-ownership="none">
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-matrix.h"
               line="557">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-matrix.h"
               line="558">A 4x4 transformation matrix</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="meta_texture_foreach_in_region"
              c:identifier="cogl_meta_texture_foreach_in_region"
              version="1.10"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-meta-texture.h"
           line="137">Allows you to manually iterate the low-level textures that define a
given region of a high-level #CoglMetaTexture.

For example cogl_texture_2d_sliced_new_with_size() can be used to
create a meta texture that may slice a large image into multiple,
smaller power-of-two sized textures. These high level textures are
not directly understood by a GPU and so this API must be used to
manually resolve the underlying textures for drawing.

All high level textures (#CoglAtlasTexture, #CoglSubTexture,
#CoglTexturePixmapX11, and #CoglTexture2DSliced) can be handled
consistently using this interface which greately simplifies
implementing primitives that support all texture types.

For example if you use the cogl_rectangle() API then Cogl will
internally use this API to resolve the low level textures of any
meta textures you have associated with CoglPipeline layers.

&lt;note&gt;The low level drawing APIs such as cogl_primitive_draw()
don't understand the #CoglMetaTexture interface and so it is your
responsibility to use this API to resolve all CoglPipeline textures
into low-level textures before drawing.&lt;/note&gt;

For each low-level texture that makes up part of the given region
of the @meta_texture, @callback is called specifying how the
low-level texture maps to the original region.</doc>
      <source-position filename="cogl-meta-texture.h" line="182"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="meta_texture" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="139">An object implementing the #CoglMetaTexture
               interface.</doc>
          <type name="MetaTexture" c:type="CoglMetaTexture*"/>
        </parameter>
        <parameter name="tx_1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="141">The top-left x coordinate of the region to iterate</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty_1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="142">The top-left y coordinate of the region to iterate</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="tx_2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="143">The bottom-right x coordinate of the region to iterate</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="ty_2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="144">The bottom-right y coordinate of the region to iterate</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="wrap_s" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="145">The wrap mode for the x-axis</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </parameter>
        <parameter name="wrap_t" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="146">The wrap mode for the y-axis</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </parameter>
        <parameter name="callback" transfer-ownership="none" closure="8">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="147">A #CoglMetaTextureCallback pointer to be called
           for each low-level texture within the specified region.</doc>
          <type name="MetaTextureCallback" c:type="CoglMetaTextureCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-meta-texture.h"
               line="149">A private pointer that is passed to @callback.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_renderer_dispatch"
              c:identifier="cogl_poll_renderer_dispatch"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-poll.h"
           line="171">This should be called whenever an application is woken up from
going idle in its main loop. The @poll_fds array should contain a
list of file descriptors matched with the events that occurred in
revents. The events field is ignored. It is safe to pass in extra
file descriptors that Cogl didn't request when calling
cogl_poll_renderer_get_info() or a shorter array missing some file
descriptors that Cogl requested.

&lt;note&gt;If your application didn't originally create a #CoglRenderer
manually then you can easily get a #CoglRenderer pointer by calling
cogl_get_renderer().&lt;/note&gt;</doc>
      <source-position filename="cogl-poll.h" line="194"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-poll.h"
               line="173">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="poll_fds" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-poll.h"
               line="174">An array of #CoglPollFD&lt;!-- --&gt;s describing the events
           that have occurred since the application went idle.</doc>
          <type name="PollFD" c:type="const CoglPollFD*"/>
        </parameter>
        <parameter name="n_poll_fds" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-poll.h"
               line="176">The length of the @poll_fds array.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="poll_renderer_get_info"
              c:identifier="cogl_poll_renderer_get_info"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-poll.h"
           line="112">Is used to integrate Cogl with an application mainloop that is based
on the unix poll(2) api (or select() or something equivalent). This
api should be called whenever an application is about to go idle so
that Cogl has a chance to describe what file descriptor events it
needs to be woken up for.

&lt;note&gt;If your application is using the Glib mainloop then you
should jump to the cogl_glib_source_new() api as a more convenient
way of integrating Cogl with the mainloop.&lt;/note&gt;

After the function is called *@poll_fds will contain a pointer to
an array of #CoglPollFD structs describing the file descriptors
that Cogl expects. The fd and events members will be updated
accordingly. After the application has completed its idle it is
expected to either update the revents members directly in this
array or to create a copy of the array and update them
there.

When the application mainloop returns from calling poll(2) (or its
equivalent) then it should call cogl_poll_renderer_dispatch()
passing a pointer the array of CoglPollFD&lt;!-- --&gt;s with updated
revent values.

When using the %COGL_WINSYS_ID_WGL winsys (where file descriptors
don't make any sense) or %COGL_WINSYS_ID_SDL (where the event
handling functions of SDL don't allow blocking on a file
descriptor) *n_poll_fds is guaranteed to be zero.

@timeout will contain a maximum amount of time to wait in
microseconds before the application should wake up or -1 if the
application should wait indefinitely. This can also be 0 if
Cogl needs to be woken up immediately.</doc>
      <source-position filename="cogl-poll.h" line="166"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-poll.h"
             line="154">A "poll fd state age" that changes whenever the set
              of poll_fds has changed. If this API is being used to
              integrate with another system mainloop api then
              knowing if the set of file descriptors and events has
              really changed can help avoid redundant work
              depending the api. The age isn't guaranteed to change
              when the timeout changes.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-poll.h"
               line="114">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="poll_fds" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-poll.h"
               line="115">A return location for a pointer to an array
           of #CoglPollFD&lt;!-- --&gt;s</doc>
          <type name="PollFD" c:type="CoglPollFD**"/>
        </parameter>
        <parameter name="n_poll_fds" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-poll.h"
               line="117">A return location for the number of entries in *@poll_fds</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="timeout" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-poll.h"
               line="118">A return location for the maximum length of time to wait
          in microseconds, or -1 to wait indefinitely.</doc>
          <type name="gint64" c:type="int64_t*"/>
        </parameter>
      </parameters>
    </function>
    <function name="pop_gles2_context"
              c:identifier="cogl_pop_gles2_context"
              version="2.0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="280">Restores the previously active #CoglGLES2Context if there
were nested calls to cogl_push_gles2_context() or otherwise
restores the ability to render with the Cogl api instead
of OpenGLES 2.0.

The behaviour is undefined if calls to cogl_pop_gles2_context()
are not balenced with the number of corresponding calls to
cogl_push_gles2_context().</doc>
      <source-position filename="cogl-gles2.h" line="297"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ctx" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="282">A #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
      </parameters>
    </function>
    <function name="push_gles2_context"
              c:identifier="cogl_push_gles2_context"
              version="2.0"
              stability="Unstable"
              throws="1">
      <doc xml:space="preserve"
           filename="cogl-gles2.h"
           line="243">Pushes the given @gles2_ctx onto a stack associated with @ctx so
that the OpenGLES 2.0 api can be used instead of the Cogl
rendering apis to read and write to the specified framebuffers.

Usage of the api available through a #CoglGLES2Vtable is only
allowed between cogl_push_gles2_context() and
cogl_pop_gles2_context() calls.

If there is a runtime problem with switching over to the given
@gles2_ctx then this function will return %FALSE and return
an error through @error.</doc>
      <source-position filename="cogl-gles2.h" line="274"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-gles2.h"
             line="269">%TRUE if operation was successfull or %FALSE
              otherwise and @error will be updated.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="ctx" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="245">A #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="gles2_ctx" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="246">A #CoglGLES2Context allocated with
            cogl_gles2_context_new()</doc>
          <type name="GLES2Context" c:type="CoglGLES2Context*"/>
        </parameter>
        <parameter name="read_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="248">A #CoglFramebuffer to access to read operations
              such as glReadPixels. (must be a #CoglOffscreen
              framebuffer currently)</doc>
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
        <parameter name="write_buffer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-gles2.h"
               line="251">A #CoglFramebuffer to access for drawing operations
               such as glDrawArrays. (must be a #CoglOffscreen
              framebuffer currently)</doc>
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="quaternion_equal"
              c:identifier="cogl_quaternion_equal"
              moved-to="Quaternion.equal"
              version="2.0">
      <doc xml:space="preserve"
           filename="cogl-quaternion.h"
           line="309">Compares that all the components of quaternions @a and @b are
equal.

An epsilon value is not used to compare the float components, but
the == operator is at least used so that 0 and -0 are considered
equal.</doc>
      <source-position filename="cogl-quaternion.h" line="326"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-quaternion.h"
             line="321">%TRUE if the quaternions are equal else %FALSE.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-quaternion.h"
               line="311">A #CoglQuaternion</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-quaternion.h"
               line="312">A #CoglQuaternion</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="renderer_error_quark"
              c:identifier="cogl_renderer_error_quark"
              moved-to="RendererError.quark">
      <source-position filename="cogl-renderer.h" line="88"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="texture_error_quark"
              c:identifier="cogl_texture_error_quark"
              moved-to="TextureError.quark">
      <source-position filename="cogl-texture.h" line="132"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="vector3_add"
              c:identifier="cogl_vector3_add"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="170">Adds each of the corresponding components in vectors @a and @b
storing the results in @result.</doc>
      <source-position filename="cogl-vector.h" line="183"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="172">Where you want the result written</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="173">The first vector operand</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="174">The second vector operand</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_copy"
              c:identifier="cogl_vector3_copy"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="128">Allocates a new 3 component float vector on the heap initializing
the components from the given @vector and returns a pointer to the
newly allocated vector. You should free the memory using
cogl_vector3_free()</doc>
      <source-position filename="cogl-vector.h" line="143"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-vector.h"
             line="137">A newly allocated 3 component float vector</doc>
        <type name="gfloat" c:type="float*"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="130">The 3 component vector you want to copy</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_cross_product"
              c:identifier="cogl_vector3_cross_product"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="263">Calculates the cross product between the two vectors @u and @v.

The cross product is a vector perpendicular to both @u and @v. This
can be useful for calculating the normal of a polygon by creating
two vectors in its plane using the polygons vertices and taking
their cross product.

If the two vectors are parallel then the cross product is 0.

You can use a right hand rule to determine which direction the
perpendicular vector will point: If you place the two vectors tail,
to tail and imagine grabbing the perpendicular line that extends
through the common tail with your right hand such that you fingers
rotate in the direction from @u to @v then the resulting vector
points along your extended thumb.</doc>
      <source-position filename="cogl-vector.h" line="291"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="265">Where you want the result written</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="u" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="266">Your first 3 component vector</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="v" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="267">Your second 3 component vector</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_distance"
              c:identifier="cogl_vector3_distance"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="336">If you consider the two given vectors as (x,y,z) points instead
then this will compute the distance between those two points.</doc>
      <source-position filename="cogl-vector.h" line="351"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-vector.h"
             line="344">The distance between two points given as 3 component
         vectors.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="338">The first point</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="339">The second point</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_divide_scalar"
              c:identifier="cogl_vector3_divide_scalar"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="218">Divides each of the @vector components by the given scalar.</doc>
      <source-position filename="cogl-vector.h" line="229"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="220">The 3 component vector you want to manipulate</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="scalar" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="221">The scalar you want to divide the vector components by</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_dot_product"
              c:identifier="cogl_vector3_dot_product"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="295">Calculates the dot product of the two 3 component vectors. This
can be used to determine the magnitude of one vector projected onto
another. (for example a surface normal)

For example if you have a polygon with a given normal vector and
some other point for which you want to calculate its distance from
the polygon, you can create a vector between one of the polygon
vertices and that point and use the dot product to calculate the
magnitude for that vector but projected onto the normal of the
polygon. This way you don't just get the distance from the point to
the edge of the polygon you get the distance from the point to the
nearest part of the polygon.

&lt;note&gt;If you don't use a unit length normal in the above example
then you would then also have to divide the result by the magnitude
of the normal&lt;/note&gt;

The dot product is calculated as:
|[
 (a-&gt;x * b-&gt;x + a-&gt;y * b-&gt;y + a-&gt;z * b-&gt;z)
]|

For reference, the dot product can also be calculated from the
angle between two vectors as:
|[
 |a||b|cos𝜃
]|</doc>
      <source-position filename="cogl-vector.h" line="334"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-vector.h"
             line="328">The dot product of two vectors.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="297">Your first 3 component vector</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="298">Your second 3 component vector</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_equal"
              c:identifier="cogl_vector3_equal"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="80">Compares the components of two vectors and returns TRUE if they are
the same.

The comparison of the components is done with the '==' operator
such that -0 is considered equal to 0, but otherwise there is no
fuzziness such as an epsilon to consider vectors that are
essentially identical except for some minor precision error
differences due to the way they have been manipulated.</doc>
      <source-position filename="cogl-vector.h" line="100"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-vector.h"
             line="94">TRUE if the vectors are equal else FALSE.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="v1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="82">The first 3 component vector you want to compare</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="v2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="83">The second 3 component vector you want to compare</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_equal_with_epsilon"
              c:identifier="cogl_vector3_equal_with_epsilon"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="102">Compares the components of two vectors using the given epsilon and
returns TRUE if they are the same, using an internal epsilon for
comparing the floats.

Each component is compared against the epsilon value in this way:
|[
  if (fabsf (vector0-&gt;x - vector1-&gt;x) &lt; epsilon)
]|</doc>
      <source-position filename="cogl-vector.h" line="124"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-vector.h"
             line="118">TRUE if the vectors are equal else FALSE.</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="vector0" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="104">The first 3 component vector you want to compare</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="vector1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="105">The second 3 component vector you want to compare</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="epsilon" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="106">The allowable difference between components to still be
          considered equal</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_free"
              c:identifier="cogl_vector3_free"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="145">Frees a 3 component vector that was previously allocated with
cogl_vector3_copy()</doc>
      <source-position filename="cogl-vector.h" line="156"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="147">The 3 component you want to free</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_init"
              c:identifier="cogl_vector3_init"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="50">Initializes a 3 component, single precision float vector which can
then be manipulated with the cogl_vector convenience APIs. Vectors
can also be used in places where a "point" is often desired.</doc>
      <source-position filename="cogl-vector.h" line="65"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="52">The 3 component vector you want to initialize</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="53">The x component</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="54">The y component</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="55">The z component</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_init_zero"
              c:identifier="cogl_vector3_init_zero"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="67">Initializes a 3 component, single precision float vector with zero
for each component.</doc>
      <source-position filename="cogl-vector.h" line="78"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="69">The 3 component vector you want to initialize</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_invert"
              c:identifier="cogl_vector3_invert"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="158">Inverts/negates all the components of the given @vector.</doc>
      <source-position filename="cogl-vector.h" line="168"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="160">The 3 component vector you want to manipulate</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_magnitude"
              c:identifier="cogl_vector3_magnitude"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="249">Calculates the scalar magnitude or length of @vector.</doc>
      <source-position filename="cogl-vector.h" line="261"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-vector.h"
             line="255">The magnitude of @vector.</doc>
        <type name="gfloat" c:type="float"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="251">The 3 component vector you want the magnitude for</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_multiply_scalar"
              c:identifier="cogl_vector3_multiply_scalar"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="204">Multiplies each of the @vector components by the given scalar.</doc>
      <source-position filename="cogl-vector.h" line="215"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="206">The 3 component vector you want to manipulate</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="scalar" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="207">The scalar you want to multiply the vector components by</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_normalize"
              c:identifier="cogl_vector3_normalize"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="232">Updates the vector so it is a "unit vector" such that the
@vector&lt;!-- --&gt;s magnitude or length is equal to 1.

&lt;note&gt;It's safe to use this function with the [0, 0, 0] vector, it will not
try to divide components by 0 (its norm) and will leave the vector
untouched.&lt;/note&gt;</doc>
      <source-position filename="cogl-vector.h" line="247"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="vector" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="234">The 3 component vector you want to manipulate</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vector3_subtract"
              c:identifier="cogl_vector3_subtract"
              version="1.4"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-vector.h"
           line="187">Subtracts each of the corresponding components in vector @b from
@a storing the results in @result.</doc>
      <source-position filename="cogl-vector.h" line="200"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="result" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="189">Where you want the result written</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="a" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="190">The first vector operand</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="b" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-vector.h"
               line="191">The second vector operand</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_display_set_compositor_display"
              c:identifier="cogl_wayland_display_set_compositor_display"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-wayland-server.h"
           line="57">Informs Cogl of a compositor's Wayland display pointer. This
enables Cogl to register private wayland extensions required to
pass buffers between the clients and compositor.</doc>
      <source-position filename="cogl-wayland-server.h" line="70"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="display" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="59">a #CoglDisplay</doc>
          <type name="Display" c:type="CoglDisplay*"/>
        </parameter>
        <parameter name="wayland_display"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="60">A compositor's Wayland display pointer</doc>
          <type name="gpointer" c:type="wl_display*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_onscreen_get_shell_surface"
              c:identifier="cogl_wayland_onscreen_get_shell_surface">
      <source-position filename="cogl-onscreen.h" line="207"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="wl_shell_surface*"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_onscreen_get_surface"
              c:identifier="cogl_wayland_onscreen_get_surface">
      <source-position filename="cogl-onscreen.h" line="205"/>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="wl_surface*"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_onscreen_resize"
              c:identifier="cogl_wayland_onscreen_resize"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="228">Resizes the backbuffer of the given @onscreen framebuffer to the
given size. Since a buffer is usually conceptually scaled with a
center point the @offset_x and @offset_y arguments allow the newly
allocated buffer to be positioned relative to the old buffer size.

For example a buffer that is being resized by moving the bottom right
corner, and the top left corner is remaining static would use x and y
offsets of (0, 0) since the top-left of the new buffer should have the same
position as the old buffer. If the center of the old buffer is being zoomed
into then all the corners of the new buffer move out from the center and the x
and y offsets would be (-half_x_size_increase, -half_y_size_increase) where
x/y_size_increase is how many pixels bigger the buffer is on the x and y
axis.

Note that if some drawing commands have been applied to the
framebuffer since the last swap buffers then the resize will be
queued and will only take effect in the next swap buffers.

If multiple calls to cogl_wayland_onscreen_resize() get queued
before the next swap buffers request then the relative x and y
offsets accumulate instead of being replaced. The @width and
@height values superseed the old values.</doc>
      <source-position filename="cogl-onscreen.h" line="263"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="230">A #CoglOnscreen framebuffer</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="231">The desired width of the framebuffer</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="232">The desired height of the framebuffer</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="offset_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="233">A relative x offset for the new framebuffer</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="offset_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="234">A relative y offset for the new framebuffer</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_onscreen_set_foreign_surface"
              c:identifier="cogl_wayland_onscreen_set_foreign_surface"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="209">Allows you to explicitly notify Cogl of an existing Wayland surface to use,
which prevents Cogl from allocating a surface and shell surface for the
@onscreen. An allocated surface will not be destroyed when the @onscreen is
freed.

This function must be called before @onscreen is allocated.</doc>
      <source-position filename="cogl-onscreen.h" line="225"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="211">An unallocated framebuffer.
@surface A Wayland surface to associate with the @onscreen.</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="surface"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="wl_surface*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_renderer_get_display"
              c:identifier="cogl_wayland_renderer_get_display"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-wayland-renderer.h"
           line="81">Retrieves the Wayland display that Cogl is using. If a foreign
display has been specified using
cogl_wayland_renderer_set_foreign_display() then that display will
be returned. If no foreign display has been specified then the
display that Cogl creates internally will be returned unless the
renderer has not yet been connected (either implicitly or explicitly by
calling cogl_renderer_connect()) in which case %NULL is returned.</doc>
      <source-position filename="cogl-wayland-renderer.h" line="101"/>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve"
             filename="cogl-wayland-renderer.h"
             line="93">The wayland display currently associated with @renderer,
         or %NULL if the renderer hasn't yet been connected and no
         foreign display has been specified.</doc>
        <type name="gpointer" c:type="wl_display*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-renderer.h"
               line="83">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_renderer_set_event_dispatch_enabled"
              c:identifier="cogl_wayland_renderer_set_event_dispatch_enabled"
              version="1.16"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-wayland-renderer.h"
           line="59">Sets whether Cogl should handle calling wl_display_dispatch() and
wl_display_flush() as part of its main loop integration via
cogl_poll_renderer_get_info() and cogl_poll_renderer_dispatch().
The default value is %TRUE. When it is enabled the application can
register listeners for Wayland interfaces and the callbacks will be
invoked during cogl_poll_renderer_dispatch(). If the application
wants to integrate with its own code that is already handling
reading from the Wayland display socket, it should disable this to
avoid having competing code read from the socket.</doc>
      <source-position filename="cogl-wayland-renderer.h" line="78"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-renderer.h"
               line="61">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="enable" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-renderer.h"
               line="62">The new value</doc>
          <type name="Bool" c:type="CoglBool"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_renderer_set_foreign_display"
              c:identifier="cogl_wayland_renderer_set_foreign_display"
              version="1.8"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-wayland-renderer.h"
           line="43">Allows you to explicitly control what Wayland display you want Cogl
to work with instead of leaving Cogl to automatically connect to a
wayland compositor.</doc>
      <source-position filename="cogl-wayland-renderer.h" line="56"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-renderer.h"
               line="45">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="display"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-wayland-renderer.h"
               line="46">A Wayland display</doc>
          <type name="gpointer" c:type="wl_display*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_texture_2d_new_from_buffer"
              c:identifier="cogl_wayland_texture_2d_new_from_buffer"
              version="1.10"
              introspectable="0"
              stability="Unstable"
              throws="1">
      <doc xml:space="preserve"
           filename="cogl-wayland-server.h"
           line="73">Uploads the @buffer referenced by the given Wayland resource to a
#CoglTexture2D. The buffer resource may refer to a wl_buffer or a
wl_shm_buffer.

&lt;note&gt;The results are undefined for passing an invalid @buffer
pointer&lt;/note&gt;
&lt;note&gt;It is undefined if future updates to @buffer outside the
control of Cogl will affect the allocated #CoglTexture2D. In some
cases the contents of the buffer are copied (such as shm buffers),
and in other cases the underlying storage is re-used directly (such
as drm buffers)&lt;/note&gt;</doc>
      <source-position filename="cogl-wayland-server.h" line="100"/>
      <return-value>
        <doc xml:space="preserve"
             filename="cogl-wayland-server.h"
             line="91">A newly allocated #CoglTexture2D, or if Cogl could not
         validate the @buffer in some way (perhaps because of
         an unsupported format) it will return %NULL and set
         @error.</doc>
        <type name="Texture2D" c:type="CoglTexture2D*"/>
      </return-value>
      <parameters>
        <parameter name="ctx" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="75">A #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </parameter>
        <parameter name="buffer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="76">A Wayland resource for a buffer</doc>
          <type name="gpointer" c:type="wl_resource*"/>
        </parameter>
      </parameters>
    </function>
    <function name="wayland_texture_set_region_from_shm_buffer"
              c:identifier="cogl_wayland_texture_set_region_from_shm_buffer"
              version="1.18"
              stability="Unstable"
              throws="1">
      <doc xml:space="preserve"
           filename="cogl-wayland-server.h"
           line="104">Sets the pixels in a rectangular subregion of @texture from a
Wayland SHM buffer. Generally this would be used in response to
wl_surface.damage event in a compositor in order to update the
texture with the damaged region. This is just a convenience wrapper
around getting the SHM buffer pointer and calling
cogl_texture_set_region(). See that function for a description of
the level parameter.

&lt;note&gt;Since the storage for a #CoglTexture is allocated lazily then
if the given @texture has not previously been allocated then this
api can return %FALSE and throw an exceptional @error if there is
not enough memory to allocate storage for @texture.&lt;/note&gt;</doc>
      <source-position filename="cogl-wayland-server.h" line="136"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl-wayland-server.h"
             line="130">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
        <type name="Bool" c:type="CoglBool"/>
      </return-value>
      <parameters>
        <parameter name="texture" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="106">a #CoglTexture</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
        <parameter name="src_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="110">The X offset within the source bufer to copy from</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="src_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="111">The Y offset within the source bufer to copy from</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="107">The width of the region to copy</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="108">The height of the region to copy</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="shm_buffer"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="109">The source buffer</doc>
          <type name="gpointer" c:type="wl_shm_buffer*"/>
        </parameter>
        <parameter name="dst_x" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="112">The X offset within the texture to copy to</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="dst_y" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="113">The Y offset within the texture to copy to</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="level" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-wayland-server.h"
               line="114">The mipmap level of the texture to copy to</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_get_visual_xid"
              c:identifier="cogl_x11_onscreen_get_visual_xid">
      <source-position filename="cogl-onscreen.h" line="166"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_get_window_xid"
              c:identifier="cogl_x11_onscreen_get_window_xid"
              version="1.10"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="143">Assuming you know the given @onscreen framebuffer is based on an x11 window
this queries the XID of that window. If
cogl_x11_onscreen_set_foreign_window_xid() was previously called then it
will return that same XID otherwise it will be the XID of a window Cogl
created internally. If the window has not been allocated yet and a foreign
xid has not been set then it's undefined what value will be returned.

It's undefined what this function does if called when not using an x11 based
renderer.</doc>
      <source-position filename="cogl-onscreen.h" line="161"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="145">A #CoglOnscreen framebuffer</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
      </parameters>
    </function>
    <function name="x11_onscreen_set_foreign_window_xid"
              c:identifier="cogl_x11_onscreen_set_foreign_window_xid"
              version="2.0"
              introspectable="0"
              stability="Unstable">
      <doc xml:space="preserve"
           filename="cogl-onscreen.h"
           line="86">Ideally we would recommend that you let Cogl be responsible for
creating any X window required to back an onscreen framebuffer but
if you really need to target a window created manually this
function can be called before @onscreen has been allocated to set a
foreign XID for your existing X window.

Since Cogl needs, for example, to track changes to the size of an X
window it requires that certain events be selected for via the core
X protocol. This requirement may also be changed asynchronously so
you must pass in an @update callback to inform you of Cogl's
required event mask.

For example if you are using Xlib you could use this API roughly
as follows:
[{
static void
my_update_cogl_x11_event_mask (CoglOnscreen *onscreen,
                               uint32_t event_mask,
                               void *user_data)
{
  XSetWindowAttributes attrs;
  MyData *data = user_data;
  attrs.event_mask = event_mask | data-&gt;my_event_mask;
  XChangeWindowAttributes (data-&gt;xdpy,
                           data-&gt;xwin,
                           CWEventMask,
                           &amp;attrs);
}

{
  *snip*
  cogl_x11_onscreen_set_foreign_window_xid (onscreen,
                                            data-&gt;xwin,
                                            my_update_cogl_x11_event_mask,
                                            data);
  *snip*
}
}]</doc>
      <source-position filename="cogl-onscreen.h" line="138"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="88">The unallocated framebuffer to associated with an X
           window.</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="xid" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="90">The XID of an existing X window</doc>
          <type name="guint32" c:type="uint32_t"/>
        </parameter>
        <parameter name="update" transfer-ownership="none" closure="3">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="91">A callback that notifies of updates to what Cogl requires
         to be in the core X protocol event mask.</doc>
          <type name="OnscreenX11MaskCallback"
                c:type="CoglOnscreenX11MaskCallback"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl-onscreen.h"
               line="93">user data passed to @update</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_get_display"
              c:identifier="cogl_xlib_get_display"
              introspectable="0">
      <source-position filename="cogl-xlib.h" line="76"/>
      <return-value>
        <type c:type="Display*"/>
      </return-value>
    </function>
    <function name="xlib_handle_event"
              c:identifier="cogl_xlib_handle_event"
              introspectable="0">
      <source-position filename="cogl-xlib.h" line="113"/>
      <return-value transfer-ownership="none">
        <type name="FilterReturn" c:type="CoglFilterReturn"/>
      </return-value>
      <parameters>
        <parameter name="xevent" transfer-ownership="none">
          <type c:type="XEvent*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_set_display"
              c:identifier="cogl_xlib_set_display"
              introspectable="0">
      <source-position filename="cogl-xlib.h" line="91"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="display" transfer-ownership="none">
          <type c:type="Display*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
