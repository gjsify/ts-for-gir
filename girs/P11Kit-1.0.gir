<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <package name="p11-kit-1"/>
  <c:include name="p11-kit.h"/>
  <c:include name="pin.h"/>
  <c:include name="pkcs11.h"/>
  <c:include name="uri.h"/>
  <namespace name="P11Kit"
             version="1.0"
             shared-library="libp11-kit.so.0"
             c:identifier-prefixes="P11Kit"
             c:symbol-prefixes="p11_kit">
    <constant name="PIN_FALLBACK" value="" c:type="P11_KIT_PIN_FALLBACK">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="Pin" c:type="P11KitPin" disguised="1">
      <doc xml:whitespace="preserve">A structure representing a PKCS\#11 PIN. There are no public fields
visible in this structure. Use the various accessor functions.</doc>
      <method name="get_length" c:identifier="p11_kit_pin_get_length">
        <doc xml:whitespace="preserve">Get the length of the PIN value from a P11KitPin.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the length of the PIN value.</doc>
          <type name="gulong" c:type="size_t"/>
        </return-value>
      </method>
      <method name="get_value" c:identifier="p11_kit_pin_get_value">
        <doc xml:whitespace="preserve">Get the PIN value from a P11KitPin. @length will be set to the
length of the value.

The value returned is owned by the P11KitPin and should not be modified.
It remains valid as long as a reference to the PIN is held. The PIN value
will not contain an extra null-terminator character.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">the value for the PIN.</doc>
          <type name="guint8" c:type="const unsigned char*"/>
        </return-value>
        <parameters>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">a location to return the value length</doc>
            <type name="gulong" c:type="size_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="p11_kit_pin_ref" introspectable="0">
        <doc xml:whitespace="preserve">Add a reference to a P11KitPin. This should be matched with a later call
to p11_kit_pin_unref(). As long as at least one reference is held, the PIN
will remain valid and in memory.</doc>
        <return-value>
          <doc xml:whitespace="preserve">the @pin pointer, for convenience sake.</doc>
          <type name="Pin" c:type="P11KitPin*"/>
        </return-value>
      </method>
      <method name="unref" c:identifier="p11_kit_pin_unref">
        <doc xml:whitespace="preserve">Remove a reference from a P11KitPin. When all references have been removed
then the PIN will be freed and will no longer be in memory.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <function name="file_callback"
                c:identifier="p11_kit_pin_file_callback"
                introspectable="0">
        <doc xml:whitespace="preserve">This is a PIN callback function that looks up the 'pin-source' attribute in
a file with that name. This can be used to enable the normal PKCS\#11 URI
behavior described in the RFC.

If @pin_flags contains the %P11_KIT_PIN_FLAGS_RETRY flag, then this
callback will always return %NULL. This is to prevent endless loops
where an application is expecting to interact with a prompter, but
instead is interacting with this callback reading a file over and over.

This callback fail on larger than 4 Kilobytes.

This callback is not registered by default. To register it use code like
the following:

&lt;informalexample&gt;&lt;programlisting&gt;
p11_kit_pin_register_callback (P11_KIT_PIN_FALLBACK, p11_kit_pin_file_callback,
                               NULL, NULL);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value>
          <doc xml:whitespace="preserve">a referenced PIN with the pinfile contents, or %NULL if the file could not be read</doc>
          <type name="Pin" c:type="P11KitPin*"/>
        </return-value>
        <parameters>
          <parameter name="pin_source" transfer-ownership="none">
            <doc xml:whitespace="preserve">a 'pin-source' attribute string</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pin_uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a PKCS\#11 URI that the PIN is for, or %NULL</doc>
            <type name="Uri" c:type="P11KitUri*"/>
          </parameter>
          <parameter name="pin_description" transfer-ownership="none">
            <doc xml:whitespace="preserve">a descrption of what the PIN is for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pin_flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">flags describing the PIN request</doc>
            <type name="PinFlags" c:type="P11KitPinFlags"/>
          </parameter>
          <parameter name="callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">unused, should be %NULL</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="p11_kit_pin_new" introspectable="0">
        <doc xml:whitespace="preserve">Create a new P11KitPin with the given PIN value. This function is
usually used from within registered PIN callbacks.

Exactly @length bytes from @value are used. Null terminated strings,
or encodings are not considered. A copy of the @value will be made.</doc>
        <return-value>
          <doc xml:whitespace="preserve">The newly allocated P11KitPin, which should be freed with p11_kit_pin_unref() when no longer needed.</doc>
          <type name="Pin" c:type="P11KitPin*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the PIN</doc>
            <type name="guint8" c:type="const unsigned char*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of @value</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_buffer"
                c:identifier="p11_kit_pin_new_for_buffer"
                introspectable="0">
        <doc xml:whitespace="preserve">Create a new P11KitPin which will use @buffer for the PIN value.
This function is usually used from within registered PIN callbacks.

The buffer will not be copied. String encodings and null characters
are not considered.

When the last reference to this PIN is lost, then the @destroy callback
function will be called passing @buffer as an argument. This allows the
caller to use a buffer as a PIN without copying it.

&lt;informalexample&gt;&lt;programlisting&gt;
char *buffer = malloc (128);
P11KitPin *pin;
 ....
pin = p11_kit_pin_new_for_buffer (buffer, 128, free);
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
        <return-value>
          <doc xml:whitespace="preserve">The newly allocated P11KitPin, which should be freed with p11_kit_pin_unref() when no longer needed.</doc>
          <type name="Pin" c:type="P11KitPin*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the PIN</doc>
            <type name="guint8" c:type="unsigned char*"/>
          </parameter>
          <parameter name="length" transfer-ownership="none">
            <doc xml:whitespace="preserve">the length of @buffer</doc>
            <type name="gulong" c:type="size_t"/>
          </parameter>
          <parameter name="destroy" transfer-ownership="none">
            <doc xml:whitespace="preserve">if not %NULL, then called when PIN is destroyed.</doc>
            <type c:type="p11_kit_pin_destroy_func"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_string"
                c:identifier="p11_kit_pin_new_for_string"
                introspectable="0">
        <doc xml:whitespace="preserve">Create a new P11KitPin for the given null-terminated string, such as a
password. This function is usually used from within registered
PIN callbacks.

The PIN will consist of the string not including the null terminator.
String encoding is not considered. A copy of the @value will be made.</doc>
        <return-value>
          <doc xml:whitespace="preserve">The newly allocated P11KitPin, which should be freed with p11_kit_pin_unref() when no longer needed.</doc>
          <type name="Pin" c:type="P11KitPin*"/>
        </return-value>
        <parameters>
          <parameter name="value" transfer-ownership="none">
            <doc xml:whitespace="preserve">the value of the PIN</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="register_callback"
                c:identifier="p11_kit_pin_register_callback"
                introspectable="0">
        <doc xml:whitespace="preserve">Register a callback to handle PIN requests for a given 'pin-source' attribute.
If @pin_source is set to P11_KIT_PIN_FALLBACK then this will be a fallback
callback and will be called for requests for which no other callback has
been specifically registered.

If multiple callbacks are registered for the same @pin_source value, then
the last registered callback will be the first to be called.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">Returns negative if registering fails.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="pin_source" transfer-ownership="none">
            <doc xml:whitespace="preserve">the 'pin-source' attribute this this callback is for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback function</doc>
            <type c:type="p11_kit_pin_callback"/>
          </parameter>
          <parameter name="callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data that will be passed to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="callback_destroy" transfer-ownership="none">
            <doc xml:whitespace="preserve">a function that will be called with @callback_data when the callback is unregistered.</doc>
            <type c:type="p11_kit_pin_destroy_func"/>
          </parameter>
        </parameters>
      </function>
      <function name="request"
                c:identifier="p11_kit_pin_request"
                introspectable="0">
        <doc xml:whitespace="preserve">Request a PIN for a given 'pin-source' attribute. The result depends on the
registered callbacks.

If not %NULL, then the @pin_uri attribute should point to the thing that the
PIN is being requested for. In most use cases this should be a PKCS\#11 URI
pointing to a token.

The @pin_description should always be specified. It is a string describing
what the PIN is for. For example this would be the token label, if the PIN
is for a token.

If more than one callback is registered for the @pin_source, then the latest
registered one will be called first. If that callback does not return a
PIN, then the next will be called in turn.

If no callback is registered for @pin_source, then the fallback callbacks will
be invoked in the same way. The fallback callbacks will not be called if any
callback has been registered specifically for @pin_source.

The PIN returned should be released with p11_kit_pin_unref().</doc>
        <return-value>
          <doc xml:whitespace="preserve">the PIN which should be released with p11_kit_pin_unref(), or %NULL if no callback was registered or could proivde a PIN</doc>
          <type name="Pin" c:type="P11KitPin*"/>
        </return-value>
        <parameters>
          <parameter name="pin_source" transfer-ownership="none">
            <doc xml:whitespace="preserve">the 'pin-source' attribute that is being requested</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pin_uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">a PKCS\#11 URI that the PIN is being requested for, optionally %NULL.</doc>
            <type name="Uri" c:type="P11KitUri*"/>
          </parameter>
          <parameter name="pin_description" transfer-ownership="none">
            <doc xml:whitespace="preserve">a description of what the PIN is for, must not be %NULL.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="pin_flags" transfer-ownership="none">
            <doc xml:whitespace="preserve">various flags for this request</doc>
            <type name="PinFlags" c:type="P11KitPinFlags"/>
          </parameter>
        </parameters>
      </function>
      <function name="unregister_callback"
                c:identifier="p11_kit_pin_unregister_callback"
                introspectable="0">
        <doc xml:whitespace="preserve">Unregister a callback that was previously registered with the
p11_kit_pin_register_callback() function. If more than one registered
callback matches the given arguments, then only one of those will be
removed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pin_source" transfer-ownership="none">
            <doc xml:whitespace="preserve">the 'pin-source' attribute the callback was registered for</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none">
            <doc xml:whitespace="preserve">the callback function that was registered</doc>
            <type c:type="p11_kit_pin_callback"/>
          </parameter>
          <parameter name="callback_data" transfer-ownership="none">
            <doc xml:whitespace="preserve">data that was registered for the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <bitfield name="PinFlags" c:type="P11KitPinFlags">
      <doc xml:whitespace="preserve">Flags that are passed to p11_kit_pin_request() and registered callbacks.</doc>
      <member name="user_login"
              value="1"
              c:identifier="P11_KIT_PIN_FLAGS_USER_LOGIN"/>
      <member name="so_login"
              value="2"
              c:identifier="P11_KIT_PIN_FLAGS_SO_LOGIN"/>
      <member name="context_login"
              value="4"
              c:identifier="P11_KIT_PIN_FLAGS_CONTEXT_LOGIN"/>
      <member name="retry" value="8" c:identifier="P11_KIT_PIN_FLAGS_RETRY"/>
      <member name="many_tries"
              value="16"
              c:identifier="P11_KIT_PIN_FLAGS_MANY_TRIES"/>
      <member name="final_try"
              value="32"
              c:identifier="P11_KIT_PIN_FLAGS_FINAL_TRY"/>
    </bitfield>
    <constant name="URI_SCHEME" value="pkcs11" c:type="P11_KIT_URI_SCHEME">
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="URI_SCHEME_LEN" value="6" c:type="P11_KIT_URI_SCHEME_LEN">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Uri" c:type="P11KitUri" disguised="1">
      <doc xml:whitespace="preserve">A structure representing a PKCS\#11 URI. There are no public fields
visible in this structure. Use the various accessor functions.</doc>
      <method name="any_unrecognized"
              c:identifier="p11_kit_uri_any_unrecognized">
        <doc xml:whitespace="preserve">Get the unrecognized flag for this URI.

The unrecognized flag is automatically set to 1 when during parsing any part
of the URI is unrecognized. If the unrecognized flag is set to 1, then
matching against this URI will always fail.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">1 if unrecognized flag is set, 0 otherwise.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
      </method>
      <method name="clear_attribute"
              c:identifier="p11_kit_uri_clear_attribute"
              introspectable="0">
        <doc xml:whitespace="preserve">Clear an attribute on the URI.

Only attributes that map to parts in a PKCS\#11 URI will be accepted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%P11_KIT_URI_OK if the attribute was successfully cleared. %P11_KIT_URI_NOT_FOUND if the attribute was not valid for a URI.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of the attribute to clear</doc>
            <type c:type="CK_ATTRIBUTE_TYPE"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear_attributes"
              c:identifier="p11_kit_uri_clear_attributes">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="format" c:identifier="p11_kit_uri_format">
        <doc xml:whitespace="preserve">Format a PKCS\#11 URI into a string.

Fields which are zeroed out will not be included in the resulting string.
Attributes which are not present will also not be included.

The uri_type of URI specified limits the different parts of the resulting
URI. To format a URI containing all possible information use
%P11_KIT_URI_FOR_ANY

The resulting string should be freed with free().</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%P11_KIT_URI_OK if the URI was formatted successfully. %P11_KIT_URI_NO_MEMORY if memory allocation failed.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="uri_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of URI that should be produced.</doc>
            <type name="UriType" c:type="P11KitUriType"/>
          </parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:whitespace="preserve">Location to store a newly allocated string.</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="p11_kit_uri_free">
        <doc xml:whitespace="preserve">Free a PKCS\#11 URI.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </method>
      <method name="get_attribute"
              c:identifier="p11_kit_uri_get_attribute"
              introspectable="0">
        <doc xml:whitespace="preserve">Get a pointer to an attribute present in this URI.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A pointer to the attribute, or &lt;code&gt;NULL&lt;/code&gt; if not present. The attribute is owned by the URI and should not be freed.</doc>
          <type c:type="CK_ATTRIBUTE_PTR"/>
        </return-value>
        <parameters>
          <parameter name="attr_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The attribute type</doc>
            <type c:type="CK_ATTRIBUTE_TYPE"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attributes"
              c:identifier="p11_kit_uri_get_attributes"
              introspectable="0">
        <return-value>
          <type c:type="CK_ATTRIBUTE_PTR"/>
        </return-value>
        <parameters>
          <parameter name="n_attrs" transfer-ownership="none">
            <type c:type="CK_ULONG*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_module_info"
              c:identifier="p11_kit_uri_get_module_info"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the &lt;code&gt;CK_INFO&lt;/code&gt; structure associated with this URI.

If this is a parsed URI, then the fields corresponding to library parts of
the URI will be filled in. Any library URI parts that were missing will have
their fields filled with zeros.

If the caller wishes to setup information for building a URI, then relevant
fields should be filled in. Fields that should not appear as parts in the
resulting URI should be filled with zeros.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A pointer to the &lt;code&gt;CK_INFO&lt;/code&gt; structure.</doc>
          <type c:type="CK_INFO_PTR"/>
        </return-value>
      </method>
      <method name="get_pin_source" c:identifier="p11_kit_uri_get_pin_source">
        <doc xml:whitespace="preserve">Get the 'pin-source' part of the URI. This is used by some applications to
lookup a PIN for logging into a PKCS\#11 token.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The pin-source or %NULL if not present.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
      </method>
      <method name="get_pinfile"
              c:identifier="p11_kit_uri_get_pinfile"
              deprecated="use p11_kit_uri_get_pin_source().">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
      </method>
      <method name="get_token_info"
              c:identifier="p11_kit_uri_get_token_info"
              introspectable="0">
        <doc xml:whitespace="preserve">Get the &lt;code&gt;CK_TOKEN_INFO&lt;/code&gt; structure associated with this URI.

If this is a parsed URI, then the fields corresponding to token parts of
the URI will be filled in. Any token URI parts that were missing will have
their fields filled with zeros.

If the caller wishes to setup information for building a URI, then relevant
fields should be filled in. Fields that should not appear as parts in the
resulting URI should be filled with zeros.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A pointer to the &lt;code&gt;CK_INFO&lt;/code&gt; structure.</doc>
          <type c:type="CK_TOKEN_INFO_PTR"/>
        </return-value>
      </method>
      <method name="match_attributes"
              c:identifier="p11_kit_uri_match_attributes"
              introspectable="0">
        <doc xml:whitespace="preserve">Match a attributes against the object parts of this URI.

Only the attributes that are valid for use in a URI will be matched. A URI
part that was not specified in the URI will match any attribute value. If
during the URI parsing any unrecognized parts were encountered then this
match will fail.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">1 if the URI matches, 0 if not.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="attrs" transfer-ownership="none">
            <doc xml:whitespace="preserve">The attributes to match</doc>
            <type c:type="CK_ATTRIBUTE_PTR"/>
          </parameter>
          <parameter name="n_attrs" transfer-ownership="none">
            <doc xml:whitespace="preserve">The number of attributes</doc>
            <type c:type="CK_ULONG"/>
          </parameter>
        </parameters>
      </method>
      <method name="match_module_info"
              c:identifier="p11_kit_uri_match_module_info"
              introspectable="0">
        <doc xml:whitespace="preserve">Match a &lt;code&gt;CK_INFO&lt;/code&gt; structure against the library parts of this URI.

Only the fields of the &lt;code&gt;CK_INFO&lt;/code&gt; structure that are valid for use
in a URI will be matched. A URI part that was not specified in the URI will
match any value in the structure. If during the URI parsing any unrecognized
parts were encountered then this match will fail.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">1 if the URI matches, 0 if not.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:whitespace="preserve">the structure to match against the URI</doc>
            <type c:type="CK_INFO_PTR"/>
          </parameter>
        </parameters>
      </method>
      <method name="match_token_info"
              c:identifier="p11_kit_uri_match_token_info"
              introspectable="0">
        <doc xml:whitespace="preserve">Match a &lt;code&gt;CK_TOKEN_INFO&lt;/code&gt; structure against the token parts of this
URI.

Only the fields of the &lt;code&gt;CK_TOKEN_INFO&lt;/code&gt; structure that are valid
for use in a URI will be matched. A URI part that was not specified in the
URI will match any value in the structure. If during the URI parsing any
unrecognized parts were encountered then this match will fail.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">1 if the URI matches, 0 if not.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="token_info" transfer-ownership="none">
            <doc xml:whitespace="preserve">the structure to match against the URI</doc>
            <type c:type="CK_TOKEN_INFO_PTR"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attribute"
              c:identifier="p11_kit_uri_set_attribute"
              introspectable="0">
        <doc xml:whitespace="preserve">Set an attribute on the URI.

Only attributes that map to parts in a PKCS\#11 URI will be accepted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%P11_KIT_URI_OK if the attribute was successfully set. %P11_KIT_URI_NOT_FOUND if the attribute was not valid for a URI. %P11_KIT_URI_NO_MEMORY if allocation failed.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="attr" transfer-ownership="none">
            <doc xml:whitespace="preserve">The attribute to set</doc>
            <type c:type="CK_ATTRIBUTE_PTR"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_attributes"
              c:identifier="p11_kit_uri_set_attributes"
              introspectable="0">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="attrs" transfer-ownership="none">
            <type c:type="CK_ATTRIBUTE_PTR"/>
          </parameter>
          <parameter name="n_attrs" transfer-ownership="none">
            <type c:type="CK_ULONG"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pin_source" c:identifier="p11_kit_uri_set_pin_source">
        <doc xml:whitespace="preserve">Set the 'pin-source' part of the URI. This is used by some applications to
lookup a PIN for logging into a PKCS\#11 token.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pin_source" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new pin-source</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pinfile"
              c:identifier="p11_kit_uri_set_pinfile"
              deprecated="use p11_kit_uri_set_pin_source().">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pinfile" transfer-ownership="none">
            <doc xml:whitespace="preserve">The pinfile</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_unrecognized"
              c:identifier="p11_kit_uri_set_unrecognized">
        <doc xml:whitespace="preserve">Set the unrecognized flag on this URI.

The unrecognized flag is automatically set to 1 when during parsing any part
of the URI is unrecognized. If the unrecognized flag is set to 1, then
matching against this URI will always fail.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="unrecognized" transfer-ownership="none">
            <doc xml:whitespace="preserve">The new unregognized flag value</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <function name="message" c:identifier="p11_kit_uri_message">
        <doc xml:whitespace="preserve">Lookup a message for the uri error code. These codes are the P11_KIT_URI_XXX
error codes that can be returned from p11_kit_uri_parse() or
p11_kit_uri_format(). As a special case %NULL, will be returned for
%P11_KIT_URI_OK.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">The message for the error code. This string is owned by the p11-kit library.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="code" transfer-ownership="none">
            <doc xml:whitespace="preserve">The error code</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="new" c:identifier="p11_kit_uri_new" introspectable="0">
        <doc xml:whitespace="preserve">Create a new blank PKCS\#11 URI.

The new URI is in the right state to parse a string into. All relevant fields
are zeroed out. Formatting this URI will produce a valid but empty URI.</doc>
        <return-value>
          <doc xml:whitespace="preserve">A newly allocated URI. This should be freed with p11_kit_uri_free().</doc>
          <type name="Uri" c:type="P11KitUri*"/>
        </return-value>
      </function>
      <function name="parse" c:identifier="p11_kit_uri_parse">
        <doc xml:whitespace="preserve">Parse a PKCS\#11 URI string.

PKCS\#11 URIs can represent tokens, objects or modules. The uri_type argument
allows the caller to specify what type of URI is expected and the sorts of
things the URI should match. %P11_KIT_URI_FOR_ANY can be used to parse a URI
for any context. It's then up to the caller to make sense of the way that
it is used.

If the PKCS\#11 URI contains unrecognized URI parts or parts not applicable
to the specified context, then the unrecognized flag will be set. This will
prevent the URI from matching using the various match functions.</doc>
        <return-value transfer-ownership="none">
          <doc xml:whitespace="preserve">%P11_KIT_URI_OK if the URI was parsed successfully. %P11_KIT_URI_BAD_SCHEME if this was not a PKCS\#11 URI. %P11_KIT_URI_BAD_SYNTAX if the URI syntax was bad. %P11_KIT_URI_NO_MEMORY if memory allocation failed. %P11_KIT_URI_BAD_VERSION if a version number was bad. %P11_KIT_URI_BAD_ENCODING if the URI encoding was invalid.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:whitespace="preserve">The string to parse</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="uri_type" transfer-ownership="none">
            <doc xml:whitespace="preserve">The type of URI that is expected</doc>
            <type name="UriType" c:type="P11KitUriType"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:whitespace="preserve">The blank URI to parse the values into</doc>
            <type name="Uri" c:type="P11KitUri*"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="UriResult" c:type="P11KitUriResult">
      <doc xml:whitespace="preserve">Error codes returned by various functions. The functions each clearly state
which error codes they are capable of returning.</doc>
      <member name="ok" value="0" c:identifier="P11_KIT_URI_OK"/>
      <member name="unexpected"
              value="-1"
              c:identifier="P11_KIT_URI_UNEXPECTED"/>
      <member name="bad_scheme"
              value="-2"
              c:identifier="P11_KIT_URI_BAD_SCHEME"/>
      <member name="bad_encoding"
              value="-3"
              c:identifier="P11_KIT_URI_BAD_ENCODING"/>
      <member name="bad_syntax"
              value="-4"
              c:identifier="P11_KIT_URI_BAD_SYNTAX"/>
      <member name="bad_version"
              value="-5"
              c:identifier="P11_KIT_URI_BAD_VERSION"/>
      <member name="not_found"
              value="-6"
              c:identifier="P11_KIT_URI_NOT_FOUND"/>
    </enumeration>
    <bitfield name="UriType" c:type="P11KitUriType">
      <doc xml:whitespace="preserve">A PKCS\#11 URI can represent different kinds of things. This flag is used by
p11_kit_uri_parse() to denote in what context the URI will be used.

The various types can be combined.</doc>
      <member name="object" value="2" c:identifier="P11_KIT_URI_FOR_OBJECT"/>
      <member name="token" value="4" c:identifier="P11_KIT_URI_FOR_TOKEN"/>
      <member name="module" value="8" c:identifier="P11_KIT_URI_FOR_MODULE"/>
      <member name="module_with_version"
              value="24"
              c:identifier="P11_KIT_URI_FOR_MODULE_WITH_VERSION"/>
      <member name="object_on_token"
              value="6"
              c:identifier="P11_KIT_URI_FOR_OBJECT_ON_TOKEN"/>
      <member name="object_on_token_and_module"
              value="14"
              c:identifier="P11_KIT_URI_FOR_OBJECT_ON_TOKEN_AND_MODULE"/>
      <member name="any" value="65535" c:identifier="P11_KIT_URI_FOR_ANY"/>
    </bitfield>
    <function name="finalize_module"
              c:identifier="p11_kit_finalize_module"
              introspectable="0">
      <doc xml:whitespace="preserve">Finalize an arbitrary PKCS\#11 module. The module must have been initialized
using p11_kit_initialize_module(). In most cases callers will want to use
p11_kit_finalize_registered() instead of this function.

Using this function to finalize modules allows coordination between
multiple users of the same module in a single process. The caller should
call the module's &lt;code&gt;C_Finalize&lt;/code&gt; method. This function will call
&lt;code&gt;C_Finalize&lt;/code&gt; as necessary.

If the module was initialized more than once, then this function will
decrement an initialization count for the module. When the count reaches zero
the module will be truly finalized. It is safe (although usually unnecessary)
to use this function on registered modules if (and only if) they were
initialized using p11_kit_initialize_module() for some reason.

If this function fails, then an error message will be available via the
p11_kit_message() function.</doc>
      <return-value>
        <doc xml:whitespace="preserve">CKR_OK if the finalization was successful.</doc>
        <type c:type="CK_RV"/>
      </return-value>
      <parameters>
        <parameter name="module" transfer-ownership="none">
          <doc xml:whitespace="preserve">loaded module to finalize.</doc>
          <type c:type="CK_FUNCTION_LIST_PTR"/>
        </parameter>
      </parameters>
    </function>
    <function name="finalize_registered"
              c:identifier="p11_kit_finalize_registered"
              introspectable="0">
      <doc xml:whitespace="preserve">Finalize all the registered PKCS\#11 modules. These should have been
initialized with p11_kit_initialize_registered().

If p11_kit_initialize_registered() has been called more than once in this
process, then this function must be called the same number of times before
actual finalization will occur.

If this function fails, then an error message will be available via the
p11_kit_message() function.</doc>
      <return-value>
        <doc xml:whitespace="preserve">CKR_OK if the finalization succeeded, or an error code.</doc>
        <type c:type="CK_RV"/>
      </return-value>
    </function>
    <function name="initialize_module"
              c:identifier="p11_kit_initialize_module"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize an arbitrary PKCS\#11 module. Normally using the
p11_kit_initialize_registered() is preferred.

Using this function to initialize modules allows coordination between
multiple users of the same module in a single process. It should be called
on modules that have been loaded (with dlopen() for example) but not yet
initialized. The caller should not yet have called the module's
&lt;code&gt;C_Initialize&lt;/code&gt; method. This function will call
&lt;code&gt;C_Initialize&lt;/code&gt; as necessary.

Subsequent calls to this function for the same module will result in an
initialization count being incremented for the module. It is safe (although
usually unnecessary) to use this function on registered modules.

The module must be finalized with p11_kit_finalize_module() instead of
calling its &lt;code&gt;C_Finalize&lt;/code&gt; method directly.

This function does not accept a &lt;code&gt;CK_C_INITIALIZE_ARGS&lt;/code&gt; argument.
Custom initialization arguments cannot be supported when multiple consumers
load the same module.

If this function fails, then an error message will be available via the
p11_kit_message() function.</doc>
      <return-value>
        <doc xml:whitespace="preserve">CKR_OK if the initialization was successful.</doc>
        <type c:type="CK_RV"/>
      </return-value>
      <parameters>
        <parameter name="module" transfer-ownership="none">
          <doc xml:whitespace="preserve">loaded module to initialize.</doc>
          <type c:type="CK_FUNCTION_LIST_PTR"/>
        </parameter>
      </parameters>
    </function>
    <function name="initialize_registered"
              c:identifier="p11_kit_initialize_registered"
              introspectable="0">
      <doc xml:whitespace="preserve">Initialize all the registered PKCS\#11 modules.

If this is the first time this function is called multiple times
consecutively within a single process, then it merely increments an
initialization reference count for each of these modules.

Use p11_kit_finalize_registered() to finalize these registered modules once
the caller is done with them.

If this function fails, then an error message will be available via the
p11_kit_message() function.</doc>
      <return-value>
        <doc xml:whitespace="preserve">CKR_OK if the initialization succeeded, or an error code.</doc>
        <type c:type="CK_RV"/>
      </return-value>
    </function>
    <function name="load_initialize_module"
              c:identifier="p11_kit_load_initialize_module"
              introspectable="0">
      <doc xml:whitespace="preserve">Load an arbitrary PKCS\#11 module from a dynamic library file, and
initialize it. Normally using the p11_kit_initialize_registered() function
is preferred.

Using this function to load and initialize modules allows coordination between
multiple users of the same module in a single process. The caller should not
call the module's &lt;code&gt;C_Initialize&lt;/code&gt; method. This function will call
&lt;code&gt;C_Initialize&lt;/code&gt; as necessary.

If a module has already been loaded, then use of this function is unnecesasry.
Instead use the p11_kit_initialize_module() function to initialize it.

Subsequent calls to this function for the same module will result in an
initialization count being incremented for the module. It is safe (although
usually unnecessary) to use this function on registered modules.

The module must be finalized with p11_kit_finalize_module() instead of
calling its &lt;code&gt;C_Finalize&lt;/code&gt; method directly.

This function does not accept a &lt;code&gt;CK_C_INITIALIZE_ARGS&lt;/code&gt; argument.
Custom initialization arguments cannot be supported when multiple consumers
load the same module.

If this function fails, then an error message will be available via the
p11_kit_message() function.</doc>
      <return-value>
        <doc xml:whitespace="preserve">CKR_OK if the initialization was successful.</doc>
        <type c:type="CK_RV"/>
      </return-value>
      <parameters>
        <parameter name="module_path" transfer-ownership="none">
          <doc xml:whitespace="preserve">full file path of module library</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="module" transfer-ownership="none">
          <doc xml:whitespace="preserve">location to place loaded module pointer</doc>
          <type c:type="CK_FUNCTION_LIST_PTR*"/>
        </parameter>
      </parameters>
    </function>
    <callback name="pin_callback"
              c:type="p11_kit_pin_callback"
              introspectable="0">
      <doc xml:whitespace="preserve">Represents a PIN callback function.

The various arguments are the same as the ones passed to
p11_kit_pin_request(). The @callback_data argument was the one passed to
p11_kit_pin_register_callback() when registering this callback.

The function should return %NULL if it could not provide a PIN, either
because of an error or a user cancellation.

If a PIN is returned, it will be unreferenced by the caller. So it should be
either newly allocated, or referenced before returning.</doc>
      <return-value>
        <doc xml:whitespace="preserve">A PIN or %NULL</doc>
        <type name="Pin" c:type="P11KitPin*"/>
      </return-value>
      <parameters>
        <parameter name="pin_source" transfer-ownership="none">
          <doc xml:whitespace="preserve">a 'pin-source' attribute string</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="pin_uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">a PKCS\#11 URI that the PIN is for, or %NULL</doc>
          <type name="Uri" c:type="P11KitUri*"/>
        </parameter>
        <parameter name="pin_description" transfer-ownership="none">
          <doc xml:whitespace="preserve">a descrption of what the PIN is for</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="pin_flags" transfer-ownership="none">
          <doc xml:whitespace="preserve">flags describing the PIN request</doc>
          <type name="PinFlags" c:type="P11KitPinFlags"/>
        </parameter>
        <parameter name="callback_data" transfer-ownership="none">
          <doc xml:whitespace="preserve">data that was provided when registering this callback</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="pin_destroy_func" c:type="p11_kit_pin_destroy_func">
      <doc xml:whitespace="preserve">A function called to free or cleanup @data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:whitespace="preserve">the data to destroy</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <function name="registered_module_to_name"
              c:identifier="p11_kit_registered_module_to_name"
              introspectable="0">
      <doc xml:whitespace="preserve">Get the name of a registered PKCS\#11 module.

You can use p11_kit_registered_modules() to get a list of all the registered
modules. This name is specified by the registered module configuration.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A newly allocated string containing the module name, or &lt;code&gt;NULL&lt;/code&gt; if no such registered module exists. Use free() to free this string.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="module" transfer-ownership="none">
          <doc xml:whitespace="preserve">pointer to a registered module</doc>
          <type c:type="CK_FUNCTION_LIST_PTR"/>
        </parameter>
      </parameters>
    </function>
    <function name="registered_modules"
              c:identifier="p11_kit_registered_modules"
              introspectable="0">
      <doc xml:whitespace="preserve">Get a list of all the registered PKCS\#11 modules. This list will be valid
once the p11_kit_initialize_registered() function has been called.

The returned value is a &lt;code&gt;NULL&lt;/code&gt; terminated array of
&lt;code&gt;CK_FUNCTION_LIST_PTR&lt;/code&gt; pointers.</doc>
      <return-value>
        <doc xml:whitespace="preserve">A list of all the registered modules. Use the free() function to free the list.</doc>
        <type c:type="CK_FUNCTION_LIST_PTR*"/>
      </return-value>
    </function>
    <function name="registered_name_to_module"
              c:identifier="p11_kit_registered_name_to_module"
              introspectable="0">
      <doc xml:whitespace="preserve">Lookup a registered PKCS\#11 module by its name. This name is specified by
the registered module configuration.</doc>
      <return-value>
        <doc xml:whitespace="preserve">a pointer to a PKCS\#11 module, or &lt;code&gt;NULL&lt;/code&gt; if this name was not found.</doc>
        <type c:type="CK_FUNCTION_LIST_PTR"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:whitespace="preserve">name of a registered module</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="registered_option"
              c:identifier="p11_kit_registered_option"
              introspectable="0">
      <doc xml:whitespace="preserve">Lookup a configured option for a registered PKCS\#11 module. If a
&lt;code&gt;NULL&lt;/code&gt; module argument is specified, then this will lookup
the configuration option in the global config file.</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">A newly allocated string containing the option value, or &lt;code&gt;NULL&lt;/code&gt; if the registered module or the option were not found. Use free() to free the returned string.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="module" transfer-ownership="none">
          <doc xml:whitespace="preserve">a pointer to a registered module</doc>
          <type c:type="CK_FUNCTION_LIST_PTR"/>
        </parameter>
        <parameter name="field" transfer-ownership="none">
          <doc xml:whitespace="preserve">the name of the option to lookup.</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="space_strdup" c:identifier="p11_kit_space_strdup">
      <doc xml:whitespace="preserve">In PKCS\#11 structures many strings are encoded in a strange way. The string
is placed in a fixed length buffer and then padded with spaces.

This function copies the space padded string into a normal null-terminated
string. The result is owned by the caller.

&lt;informalexample&gt;&lt;programlisting&gt;
CK_INFO info;
char *description;
   ...
description = p11_kit_space_strdup (info-&gt;libraryDescription, sizeof (info-&gt;libraryDescription));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="full">
        <doc xml:whitespace="preserve">The newly allocated string, or %NULL if memory could not be allocated.</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">Pointer to string block</doc>
          <type name="guint8" c:type="const unsigned char*"/>
        </parameter>
        <parameter name="max_length" transfer-ownership="none">
          <doc xml:whitespace="preserve">Maximum length of string block</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="space_strlen" c:identifier="p11_kit_space_strlen">
      <doc xml:whitespace="preserve">In PKCS\#11 structures many strings are encoded in a strange way. The string
is placed in a fixed length buffer and then padded with spaces.

This function determines the actual length of the string. Since the string
is not null-terminated you need to pass in the size of buffer as max_length.
The string will never be longer than this buffer.

&lt;informalexample&gt;&lt;programlisting&gt;
CK_INFO info;
size_t length;
   ...
length = p11_kit_space_strlen (info-&gt;libraryDescription, sizeof (info-&gt;libraryDescription));
&lt;/programlisting&gt;&lt;/informalexample&gt;</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The length of the space padded string.</doc>
        <type name="gulong" c:type="size_t"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">Pointer to string block</doc>
          <type name="guint8" c:type="const unsigned char*"/>
        </parameter>
        <parameter name="max_length" transfer-ownership="none">
          <doc xml:whitespace="preserve">Maximum length of string block</doc>
          <type name="gulong" c:type="size_t"/>
        </parameter>
      </parameters>
    </function>
    <function name="strerror"
              c:identifier="p11_kit_strerror"
              introspectable="0">
      <doc xml:whitespace="preserve">Get a message for a PKCS\#11 return value or error code. Do not
pass CKR_OK or other such non errors to this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The user readable and localized message.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="rv" transfer-ownership="none">
          <doc xml:whitespace="preserve">The code to get a message for.</doc>
          <type c:type="CK_RV"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_message"
              c:identifier="p11_kit_uri_message"
              moved-to="Uri.message">
      <doc xml:whitespace="preserve">Lookup a message for the uri error code. These codes are the P11_KIT_URI_XXX
error codes that can be returned from p11_kit_uri_parse() or
p11_kit_uri_format(). As a special case %NULL, will be returned for
%P11_KIT_URI_OK.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">The message for the error code. This string is owned by the p11-kit library.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="code" transfer-ownership="none">
          <doc xml:whitespace="preserve">The error code</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="uri_parse"
              c:identifier="p11_kit_uri_parse"
              moved-to="Uri.parse">
      <doc xml:whitespace="preserve">Parse a PKCS\#11 URI string.

PKCS\#11 URIs can represent tokens, objects or modules. The uri_type argument
allows the caller to specify what type of URI is expected and the sorts of
things the URI should match. %P11_KIT_URI_FOR_ANY can be used to parse a URI
for any context. It's then up to the caller to make sense of the way that
it is used.

If the PKCS\#11 URI contains unrecognized URI parts or parts not applicable
to the specified context, then the unrecognized flag will be set. This will
prevent the URI from matching using the various match functions.</doc>
      <return-value transfer-ownership="none">
        <doc xml:whitespace="preserve">%P11_KIT_URI_OK if the URI was parsed successfully. %P11_KIT_URI_BAD_SCHEME if this was not a PKCS\#11 URI. %P11_KIT_URI_BAD_SYNTAX if the URI syntax was bad. %P11_KIT_URI_NO_MEMORY if memory allocation failed. %P11_KIT_URI_BAD_VERSION if a version number was bad. %P11_KIT_URI_BAD_ENCODING if the URI encoding was invalid.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="string" transfer-ownership="none">
          <doc xml:whitespace="preserve">The string to parse</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="uri_type" transfer-ownership="none">
          <doc xml:whitespace="preserve">The type of URI that is expected</doc>
          <type name="UriType" c:type="P11KitUriType"/>
        </parameter>
        <parameter name="uri" transfer-ownership="none">
          <doc xml:whitespace="preserve">The blank URI to parse the values into</doc>
          <type name="Uri" c:type="P11KitUri*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
