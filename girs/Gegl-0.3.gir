<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <namespace name="Gegl"
             version="0.3"
             shared-library="libgegl-0.3.so.0"
             c:identifier-prefixes="Gegl"
             c:symbol-prefixes="gegl">
    <constant name="AUTO_ROWSTRIDE" value="0" c:type="GEGL_AUTO_ROWSTRIDE">
      <type name="gint" c:type="gint"/>
    </constant>
    <enumeration name="AbyssPolicy"
                 glib:type-name="GeglAbyssPolicy"
                 glib:get-type="gegl_abyss_policy_get_type"
                 c:type="GeglAbyssPolicy">
      <member name="none" value="0" c:identifier="None" glib:nick="none">
      </member>
      <member name="clamp" value="1" c:identifier="Clamp" glib:nick="clamp">
      </member>
      <member name="loop" value="2" c:identifier="Loop" glib:nick="loop">
      </member>
      <member name="black" value="3" c:identifier="Black" glib:nick="black">
      </member>
      <member name="white" value="4" c:identifier="White" glib:nick="white">
      </member>
    </enumeration>
    <bitfield name="AccessMode"
              glib:type-name="GeglAccessMode"
              glib:get-type="gegl_access_mode_get_type"
              c:type="GeglAccessMode">
      <member name="read" value="1" c:identifier="Read" glib:nick="read">
      </member>
      <member name="write" value="2" c:identifier="Write" glib:nick="write">
      </member>
      <member name="readwrite"
              value="3"
              c:identifier="Read/Write"
              glib:nick="readwrite">
      </member>
    </bitfield>
    <class name="AudioFragment"
           c:symbol-prefix="audio_fragment"
           c:type="GeglAudioFragment"
           parent="GObject.Object"
           glib:type-name="GeglAudioFragment"
           glib:get-type="gegl_audio_fragment_get_type"
           glib:type-struct="AudioFragmentClass">
      <constructor name="new" c:identifier="gegl_audio_fragment_new">
        <return-value transfer-ownership="full">
          <type name="AudioFragment" c:type="GeglAudioFragment*"/>
        </return-value>
        <parameters>
          <parameter name="sample_rate" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="channels" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="channel_layout" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_samples" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_channel_layout"
              c:identifier="gegl_audio_fragment_get_channel_layout">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_channels"
              c:identifier="gegl_audio_fragment_get_channels">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_samples"
              c:identifier="gegl_audio_fragment_get_max_samples">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pos" c:identifier="gegl_audio_fragment_get_pos">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sample_count"
              c:identifier="gegl_audio_fragment_get_sample_count">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sample_rate"
              c:identifier="gegl_audio_fragment_get_sample_rate">
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_channel_layout"
              c:identifier="gegl_audio_fragment_set_channel_layout">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="channel_layout" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_channels"
              c:identifier="gegl_audio_fragment_set_channels">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="channels" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_samples"
              c:identifier="gegl_audio_fragment_set_max_samples">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="max_samples" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos" c:identifier="gegl_audio_fragment_set_pos">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample_count"
              c:identifier="gegl_audio_fragment_set_sample_count">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="sample_count" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sample_rate"
              c:identifier="gegl_audio_fragment_set_sample_rate">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="audio" transfer-ownership="none">
            <type name="AudioFragment" c:type="GeglAudioFragment*"/>
          </instance-parameter>
          <parameter name="sample_rate" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <property name="string" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="data">
        <array zero-terminated="0" c:type="float" fixed-size="8">
          <type name="gfloat" c:type="float*"/>
        </array>
      </field>
      <field name="priv">
        <type name="AudioFragmentPrivate" c:type="GeglAudioFragmentPrivate*"/>
      </field>
    </class>
    <record name="AudioFragmentClass"
            c:type="GeglAudioFragmentClass"
            glib:is-gtype-struct-for="AudioFragment">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="AudioFragmentPrivate"
            c:type="GeglAudioFragmentPrivate"
            disguised="1">
    </record>
    <constant name="BUFFER_MAX_ITERATORS"
              value="6"
              c:type="GEGL_BUFFER_MAX_ITERATORS">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="BlitFlags" c:type="GeglBlitFlags">
      <member name="default" value="0" c:identifier="GEGL_BLIT_DEFAULT">
      </member>
      <member name="cache" value="1" c:identifier="GEGL_BLIT_CACHE">
      </member>
      <member name="dirty" value="2" c:identifier="GEGL_BLIT_DIRTY">
      </member>
    </bitfield>
    <class name="Buffer"
           c:symbol-prefix="buffer"
           c:type="GeglBuffer"
           parent="TileHandler"
           glib:type-name="GeglBuffer"
           glib:get-type="gegl_buffer_get_type">
      <constructor name="introspectable_new"
                   c:identifier="gegl_buffer_introspectable_new"
                   shadows="new">
        <doc xml:space="preserve">Create a new GeglBuffer with the given format and dimensions.</doc>
        <return-value transfer-ownership="full">
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="format_name" transfer-ownership="none">
            <doc xml:space="preserve">The Babl format name for this buffer, e.g. "RGBA float"</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x origin of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y origin of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height of the buffer's extent</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="linear_new"
                   c:identifier="gegl_buffer_linear_new"
                   introspectable="0">
        <doc xml:space="preserve">Creates a GeglBuffer backed by a linear memory buffer, of the given
@extent in the specified @format. babl_format ("R'G'B'A u8") for instance
to make a normal 8bit buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GeglBuffer that can be used as any other GeglBuffer.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve">dimensions of buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">desired pixel format.</doc>
            <type c:type="const Babl*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="linear_new_from_data"
                   c:identifier="gegl_buffer_linear_new_from_data"
                   introspectable="0">
        <doc xml:space="preserve">Creates a GeglBuffer backed by a linear memory buffer that already exists,
of the given @extent in the specified @format. babl_format ("R'G'B'A u8")
for instance to make a normal 8bit buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GeglBuffer that can be used as any other GeglBuffer.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a pointer to a linear buffer in memory.</doc>
            <type name="gpointer" c:type="const gpointer"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format of the data in memory</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve">the dimensions (and upper left coordinates) of linear buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve">the number of bytes between rowstarts in memory (or 0 to
            autodetect)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="destroy_fn" transfer-ownership="none" scope="async">
            <doc xml:space="preserve">function to call to free data or NULL if memory should not be
             freed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
          <parameter name="destroy_fn_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">extra argument to be passed to void destroy(ptr, data) type
             function.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new"
                   c:identifier="gegl_buffer_new"
                   shadowed-by="introspectable_new"
                   introspectable="0">
        <doc xml:space="preserve">Create a new GeglBuffer of a given format with a given extent. It is
possible to pass in NULL for both extent and format, a NULL extent creates
an empty buffer and a NULL format makes the buffer default to "RGBA float".</doc>
        <return-value transfer-ownership="full">
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve">the geometry of the buffer (origin, width and height) a
GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the Babl pixel format to be used, create one with babl_format("RGBA
u8") and similar.</doc>
            <type c:type="const Babl*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_for_backend"
                   c:identifier="gegl_buffer_new_for_backend">
        <doc xml:space="preserve">Create a new GeglBuffer from a backend, if NULL is passed in the extent of
the buffer will be inherited from the extent of the backend.

returns a GeglBuffer, that holds a reference to the provided backend.</doc>
        <return-value transfer-ownership="full">
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve">the geometry of the buffer (origin, width and height) a
GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="backend" transfer-ownership="none">
            <doc xml:space="preserve">an instance of a GeglTileBackend subclass.</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="load" c:identifier="gegl_buffer_load">
        <doc xml:space="preserve">Loads an existing GeglBuffer from disk, if it has previously been saved with
gegl_buffer_save it should be possible to open through any GIO transport, buffers
that have been used as swap needs random access to be opened.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GeglBuffer object.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to a gegl buffer on disk.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="open" c:identifier="gegl_buffer_open">
        <doc xml:space="preserve">Open an existing on-disk GeglBuffer, this buffer is opened in a monitored
state so multiple instances of gegl can share the same buffer. Sets on
one buffer are reflected in the other.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GeglBuffer object.</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to a gegl buffer on disk.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="add_handler" c:identifier="gegl_buffer_add_handler">
        <doc xml:space="preserve">Add a new tile handler in the existing chain of tile handler of a GeglBuffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GeglTileHandler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gegl_buffer_clear">
        <doc xml:space="preserve">Clears the provided rectangular region by setting all the associated memory
to 0.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve">a rectangular region</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gegl_buffer_copy">
        <doc xml:space="preserve">Copy a region from source buffer to destination buffer.

If the babl_formats of the buffers are the same, and the tile boundaries
align, this will create copy-on-write tiles in the destination buffer.

This function never does any scaling. When src_rect and dst_rect do not have
the same width and height, the size of src_rect is used.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">source buffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="src_rect" transfer-ownership="none">
            <doc xml:space="preserve">source rectangle (or NULL to copy entire source buffer)</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve">the abyss policy to be using if src_rect is outside src's extent.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
          <parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve">destination buffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="dst_rect" transfer-ownership="none">
            <doc xml:space="preserve">position of upper left destination pixel, or NULL for top
left coordinates of the buffer extents.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_sub_buffer"
              c:identifier="gegl_buffer_create_sub_buffer">
        <doc xml:space="preserve">Create a new sub GeglBuffer, that is a view on a larger buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new sub buffer</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">parent buffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve">coordinates of new buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="gegl_buffer_dup">
        <doc xml:space="preserve">Duplicate a buffer (internally uses gegl_buffer_copy). Aligned tiles
will create copy-on-write clones in the new buffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new buffer</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the GeglBuffer to duplicate.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gegl_buffer_flush">
        <doc xml:space="preserve">Flushes all unsaved data to disk, this is not necessary for shared
geglbuffers opened with gegl_buffer_open since they auto-sync on writes.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get"
              c:identifier="gegl_buffer_get"
              shadowed-by="introspectable_get"
              introspectable="0">
        <doc xml:space="preserve">Fetch a rectangular linear buffer of pixel data from the GeglBuffer, the
data is converted to the desired BablFormat, if the BablFormat stored and
fetched is the same this amounts to a series of memcpy's aligned to demux
the tile structure into a linear buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to retrieve data from.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates we want to retrieve data from, and width/height of
destination buffer, if NULL equal to the extent of the buffer. The
coordinates and dimensions are after scale has been applied.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">sampling scale, 1.0 = pixel for pixel 2.0 = magnify, 0.5 scale down.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the BablFormat to store in the linear buffer @dest.</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the memory destination for a linear buffer for the pixels, the size needed
depends on the requested BablFormat.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve">rowstride in bytes, or GEGL_AUTO_ROWSTRIDE to compute the
rowstride based on the width and bytes per pixel for the specified format.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle)
this argument also takes a GEGL_BUFFER_FILTER value or'ed into it, allowing
to specify trade-off of performance/quality, valid values are:
GEGL_BUFFER_FILTER_NEAREST, GEGL_BUFFER_FILTER_BILINEAR,
GEGL_BUFFER_FILTER_BOX and GEGL_BUFFER_FILTER_AUTO.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_abyss" c:identifier="gegl_buffer_get_abyss">
        <doc xml:space="preserve">Return the abyss extent of a buffer, this expands out to the parents extent in
subbuffers.</doc>
        <return-value transfer-ownership="none">
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_extent" c:identifier="gegl_buffer_get_extent">
        <doc xml:space="preserve">Returns a pointer to a GeglRectangle structure defining the geometry of a
specific GeglBuffer, this is also the default width/height of buffers passed
in to gegl_buffer_set and gegl_buffer_get (with a scale of 1.0 at least).</doc>
        <return-value transfer-ownership="none">
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to operate on.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format"
              c:identifier="gegl_buffer_get_format"
              introspectable="0">
        <doc xml:space="preserve">Get the babl format of the buffer, this might not be the format the buffer
was originally created with, you need to use gegl_buffer_set_format (buf,
NULL); to retrieve the original format (potentially having saved away the
original format of the buffer to re-set it.)</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the babl format used for storing pixels in the buffer.</doc>
          <type c:type="const Babl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile"
              c:identifier="gegl_buffer_get_tile"
              introspectable="0">
        <return-value>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="introspectable_get"
              c:identifier="gegl_buffer_introspectable_get"
              shadows="get">
        <doc xml:space="preserve">Fetch a rectangular linear buffer of pixel data from the GeglBuffer.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A copy of the requested data</doc>
          <array length="4" zero-terminated="0" c:type="guchar*">
            <type name="guint8" c:type="guchar"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to retrieve data from.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates we want to retrieve data from.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">sampling scale, 1.0 = pixel for pixel 2.0 = magnify, 0.5 scale down.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="format_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the format to store data in, if NULL the format of the buffer is used.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
          <parameter name="data_length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The length of the returned buffer</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="introspectable_set"
              c:identifier="gegl_buffer_introspectable_set"
              shadows="set">
        <doc xml:space="preserve">Store a linear raster buffer into the GeglBuffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to modify.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to write.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format_name" transfer-ownership="none">
            <doc xml:space="preserve">the format of the input data.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">pixel data to write to @buffer.</doc>
            <array length="3" zero-terminated="0" c:type="guchar*">
              <type name="guint8" c:type="guchar"/>
            </array>
          </parameter>
          <parameter name="src_length" transfer-ownership="none">
            <doc xml:space="preserve">the lenght of src in bytes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="iterator_new"
              c:identifier="gegl_buffer_iterator_new"
              introspectable="0">
        <doc xml:space="preserve">Create a new buffer iterator, this buffer will be iterated through
in linear chunks, some chunks might be full tiles the coordinates, see
the documentation of gegl_buffer_iterator_next for how to use it and
destroy it.</doc>
        <return-value>
          <doc xml:space="preserve">a new buffer iterator that can be used to iterate through the
buffers pixels.</doc>
          <type name="BufferIterator" c:type="GeglBufferIterator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to iterate over</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the level at which we are iterating, the roi will indicate the
extent at 1:1, x,y,width and height are/(2^level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format we want to process this buffers data in, pass 0 to use the buffers format.</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="access_mode" transfer-ownership="none">
            <doc xml:space="preserve">whether we need reading or writing to this buffer one of GEGL_BUFFER_READ, GEGL_BUFFER_WRITE and GEGL_BUFFER_READWRITE.</doc>
            <type name="AccessMode" c:type="GeglAccessMode"/>
          </parameter>
          <parameter name="abyss_policy" transfer-ownership="none">
            <doc xml:space="preserve">how request outside the buffer extent are handled.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="linear_close" c:identifier="gegl_buffer_linear_close">
        <doc xml:space="preserve">This function makes sure GeglBuffer and underlying code is aware of changes
being made to the linear buffer. If the request was not a compatible one
it is written back to the buffer. Multiple concurrent users can be handed
the same buffer (both raw access and converted).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="linear"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a previously returned buffer.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="linear_open"
              c:identifier="gegl_buffer_linear_open"
              introspectable="0">
        <doc xml:space="preserve">Raw direct random access to the full data of a buffer in linear memory.</doc>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">a pointer to a linear memory region describing the buffer, if the
request is compatible with the underlying data storage direct access
to the underlying data is provided. Otherwise, it returns a copy of the data.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve">region to open, pass NULL for entire buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve">return location for rowstride.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">desired format or NULL to use buffers format.</doc>
            <type c:type="const Babl*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_handler" c:identifier="gegl_buffer_remove_handler">
        <doc xml:space="preserve">Remove the provided tile handler in the existing chain of tile handler of a GeglBuffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="handler"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GeglTileHandler</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sample"
              c:identifier="gegl_buffer_sample"
              introspectable="0">
        <doc xml:space="preserve">Query interpolate pixel values at a given coordinate using a specified form
of interpolation. The samplers used cache for a small neighbourhood of the
buffer for more efficient access.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the GeglBuffer to sample from</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">a matrix that indicates scaling factors, see
gegl_sampler_compute_scale the same.</doc>
            <type name="Matrix2" c:type="GeglMatrix2*"/>
          </parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">buffer capable of storing one pixel in @format.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format to store the sampled color in.</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve">the sampler type to use,
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="sample_at_level"
              c:identifier="gegl_buffer_sample_at_level"
              introspectable="0">
        <doc xml:space="preserve">Query interpolate pixel values at a given coordinate using a specified form
of interpolation. The samplers used cache for a small neighbourhood of the
buffer for more efficient access.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the GeglBuffer to sample from</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate to sample in buffer coordinates</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">a matrix that indicates scaling factors, see
gegl_sampler_compute_scale the same.</doc>
            <type name="Matrix2" c:type="GeglMatrix2*"/>
          </parameter>
          <parameter name="dest"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">buffer capable of storing one pixel in @format.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format to store the sampled color in.</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">mipmap level to sample from (@x and @y are level 0 coordinates)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve">the sampler type to use,
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="sample_cleanup" c:identifier="gegl_buffer_sample_cleanup">
        <doc xml:space="preserve">Clean up resources used by sampling framework of buffer (will be freed
automatically later when the buffer is destroyed, for long lived buffers
cleaning up the sampling infrastructure when it has been used for its
purpose will sometimes be more efficient).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the GeglBuffer to sample from</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sampler_new"
              c:identifier="gegl_buffer_sampler_new"
              introspectable="0">
        <doc xml:space="preserve">Create a new sampler, when you are done with the sampler, g_object_unref
it.

Samplers only hold weak references to buffers, so if its buffer is freed
the sampler will become invalid.</doc>
        <return-value>
          <type name="Sampler" c:type="GeglSampler*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">buffer to create a new sampler for</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format we want data back in</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve">the sampler type to use,
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
        </parameters>
      </method>
      <method name="sampler_new_at_level"
              c:identifier="gegl_buffer_sampler_new_at_level"
              introspectable="0">
        <doc xml:space="preserve">Create a new sampler, when you are done with the sampler, g_object_unref
it.

Samplers only hold weak references to buffers, so if its buffer is freed
the sampler will become invalid.</doc>
        <return-value>
          <type name="Sampler" c:type="GeglSampler*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">buffer to create a new sampler for</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">format we want data back in</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="sampler_type" transfer-ownership="none">
            <doc xml:space="preserve">the sampler type to use,</doc>
            <type name="SamplerType" c:type="GeglSamplerType"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the mipmap level to create a sampler for
to be ported from working code. Valid values: GEGL_SAMPLER_NEAREST,
GEGL_SAMPLER_LINEAR, GEGL_SAMPLER_CUBIC, GEGL_SAMPLER_NOHALO and
GEGL_SAMPLER_LOHALO</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="save" c:identifier="gegl_buffer_save">
        <doc xml:space="preserve">Write a GeglBuffer to a file.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path where the gegl buffer will be saved, any writable GIO uri is valid.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve">the region of interest to write, this is the tiles that will be collected and
written to disk.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set"
              c:identifier="gegl_buffer_set"
              shadowed-by="introspectable_set"
              introspectable="0">
        <doc xml:space="preserve">Store a linear raster buffer into the GeglBuffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to modify.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the coordinates we want to change the data of and the width/height of
the linear buffer being set.
the data when setting.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="mipmap_level" transfer-ownership="none">
            <doc xml:space="preserve">the scale level being set, 0 = 1:1 = default = base mipmap level,
1 = 1:2, 2=1:4, 3=1:8 ..</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the babl_format the linear buffer @src.</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="src"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">linear buffer of image data to be stored in @buffer.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve">rowstride in bytes, or GEGL_AUTO_ROWSTRIDE to compute the
rowstride based on the width and bytes per pixel for the specified format.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_abyss" c:identifier="gegl_buffer_set_abyss">
        <doc xml:space="preserve">Changes the size and position of the abyss rectangle of a buffer.

Returns TRUE if the change of abyss was successful.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to operate on.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="abyss" transfer-ownership="none">
            <doc xml:space="preserve">new abyss.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color" c:identifier="gegl_buffer_set_color">
        <doc xml:space="preserve">Sets the region covered by rect to the specified color.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">a rectangular region to fill with a color.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the GeglColor to fill with.</doc>
            <type name="Color" c:type="GeglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_extent" c:identifier="gegl_buffer_set_extent">
        <doc xml:space="preserve">Changes the size and position that is considered active in a buffer, this
operation is valid on any buffer, reads on subbuffers outside the master
buffer's extent are at the moment undefined.

Returns TRUE if the change of extent was successful.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the buffer to operate on.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="extent" transfer-ownership="none">
            <doc xml:space="preserve">new extent.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_format"
              c:identifier="gegl_buffer_set_format"
              introspectable="0">
        <doc xml:space="preserve">Set the babl format of the buffer, setting the babl format of the buffer
requires the new format to have exactly the same bytes per pixel as the
original format. If NULL is passed in the format of the buffer is reset to
the original format.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the new babl format or NULL if the passed-in buffer was
incompatible (then the original format is still used).</doc>
          <type c:type="const Babl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the new babl format, must have same bpp as original format.</doc>
            <type c:type="const Babl*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pattern" c:identifier="gegl_buffer_set_pattern">
        <doc xml:space="preserve">Fill a region with a repeating pattern. Offsets parameters are
relative to the origin (0, 0) and not to the rectangle. So be carefull
about the origin of @pattern and @buffer extents.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <doc xml:space="preserve">the region of @buffer to fill</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer to be repeated as a pattern</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="x_offset" transfer-ownership="none">
            <doc xml:space="preserve">where the pattern starts horizontally</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y_offset" transfer-ownership="none">
            <doc xml:space="preserve">where the pattern starts vertical</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="signal_connect" c:identifier="gegl_buffer_signal_connect">
        <doc xml:space="preserve">This function should be used instead of g_signal_connect when connecting to
the GeglBuffer::changed signal handler, GeglBuffer contains additional
machinery to avoid the overhead of changes when no signal handler have been
connected, if regular g_signal_connect is used; then no signals will be
emitted.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an handle like g_signal_connect.</doc>
          <type name="glong" c:type="glong"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </instance-parameter>
          <parameter name="detailed_signal" transfer-ownership="none">
            <doc xml:space="preserve">only "changed" expected for now</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="c_handler"
                     transfer-ownership="none"
                     scope="async"
                     closure="2">
            <doc xml:space="preserve">c function callback</doc>
            <type name="GObject.Callback" c:type="GCallback"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data:</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <property name="abyss-height"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="abyss-width"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="abyss-x"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="abyss-y"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="backend"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="TileBackend"/>
      </property>
      <property name="format"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="height"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="pixels" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="px-size" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="shift-x"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="shift-y"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-height"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-width"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="width"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="x" writable="1" construct="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="y" writable="1" construct="1" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <glib:signal name="changed" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Rectangle"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="BufferIterator" c:type="GeglBufferIterator">
      <field name="length" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="data" writable="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="roi" writable="1">
        <array zero-terminated="0" c:type="GeglRectangle" fixed-size="6">
          <type name="Rectangle" c:type="GeglRectangle"/>
        </array>
      </field>
      <field name="priv" writable="1">
        <type name="BufferIteratorPriv" c:type="GeglBufferIteratorPriv*"/>
      </field>
      <method name="add"
              c:identifier="gegl_buffer_iterator_add"
              introspectable="0">
        <doc xml:space="preserve">Adds an additional buffer iterator that will be processed in sync with
the original one, if the buffer doesn't align with the other for tile access
the corresponding scans and regions will be serialized automatically using
gegl_buffer_get.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">an integer handle refering to the indice in the iterator structure
of the added buffer.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="iterator" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBufferIterator</doc>
            <type name="BufferIterator" c:type="GeglBufferIterator*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBuffer</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to iterate over</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">the level at which we are iterating, the roi will indicate the
extent at 1:1, x,y,width and height are/(2^level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the format we want to process this buffers data in, pass 0 to use the buffers format.</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="access_mode" transfer-ownership="none">
            <doc xml:space="preserve">whether we need reading or writing to this buffer.</doc>
            <type name="AccessMode" c:type="GeglAccessMode"/>
          </parameter>
          <parameter name="abyss_policy" transfer-ownership="none">
            <doc xml:space="preserve">how request outside the buffer extent are handled.</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="next"
              c:identifier="gegl_buffer_iterator_next"
              introspectable="0">
        <doc xml:space="preserve">Do an iteration, this causes a new set of iterator-&gt;data[] to become
available if there is more data to process. Changed data from a previous
iteration step will also be saved now. When there is no more data to
be processed FALSE will be returned (and the iterator handle is no longer
valid).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if there is more work FALSE if iteration is complete.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="iterator" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglBufferIterator</doc>
            <type name="BufferIterator" c:type="GeglBufferIterator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop"
              c:identifier="gegl_buffer_iterator_stop"
              introspectable="0">
        <doc xml:space="preserve">Cancels the current iteration, freeing up any temporary resources. The
iterator handle is no longer valid after invoking this function.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="iterator" transfer-ownership="none">
            <doc xml:space="preserve">a GeglBufferIterator</doc>
            <type name="BufferIterator" c:type="GeglBufferIterator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="empty_new"
                c:identifier="gegl_buffer_iterator_empty_new"
                introspectable="0">
        <doc xml:space="preserve">Create a new buffer iterator without adding any buffers.</doc>
        <return-value>
          <doc xml:space="preserve">a new buffer iterator.</doc>
          <type name="BufferIterator" c:type="GeglBufferIterator*"/>
        </return-value>
      </function>
    </record>
    <record name="BufferIteratorPriv"
            c:type="GeglBufferIteratorPriv"
            disguised="1">
    </record>
    <constant name="CH_BACK_CENTER" value="256" c:type="GEGL_CH_BACK_CENTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_BACK_LEFT" value="16" c:type="GEGL_CH_BACK_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_BACK_RIGHT" value="32" c:type="GEGL_CH_BACK_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_CENTER" value="4" c:type="GEGL_CH_FRONT_CENTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_LEFT" value="1" c:type="GEGL_CH_FRONT_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_LEFT_OF_CENTER"
              value="64"
              c:type="GEGL_CH_FRONT_LEFT_OF_CENTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_RIGHT" value="2" c:type="GEGL_CH_FRONT_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_FRONT_RIGHT_OF_CENTER"
              value="128"
              c:type="GEGL_CH_FRONT_RIGHT_OF_CENTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_2POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_2POINT1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_2_1" value="0" c:type="GEGL_CH_LAYOUT_2_1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_2_2" value="0" c:type="GEGL_CH_LAYOUT_2_2">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_3POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_3POINT1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_4POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_4POINT0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_4POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_4POINT1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT0_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT0_BACK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_5POINT1_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_5POINT1_BACK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT0_FRONT"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT0_FRONT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT1_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT1_BACK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_6POINT1_FRONT"
              value="0"
              c:type="GEGL_CH_LAYOUT_6POINT1_FRONT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT0"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT0">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT0_FRONT"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT0_FRONT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT1"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT1">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT1_WIDE"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT1_WIDE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_7POINT1_WIDE_BACK"
              value="0"
              c:type="GEGL_CH_LAYOUT_7POINT1_WIDE_BACK">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_HEXADECAGONAL"
              value="0"
              c:type="GEGL_CH_LAYOUT_HEXADECAGONAL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_HEXAGONAL"
              value="0"
              c:type="GEGL_CH_LAYOUT_HEXAGONAL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_NATIVE"
              value="9223372036854775808"
              c:type="GEGL_CH_LAYOUT_NATIVE">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_OCTAGONAL"
              value="0"
              c:type="GEGL_CH_LAYOUT_OCTAGONAL">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_QUAD" value="0" c:type="GEGL_CH_LAYOUT_QUAD">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_STEREO" value="0" c:type="GEGL_CH_LAYOUT_STEREO">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_STEREO_DOWNMIX"
              value="0"
              c:type="GEGL_CH_LAYOUT_STEREO_DOWNMIX">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LAYOUT_SURROUND"
              value="0"
              c:type="GEGL_CH_LAYOUT_SURROUND">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LOW_FREQUENCY" value="8" c:type="GEGL_CH_LOW_FREQUENCY">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_LOW_FREQUENCY_2"
              value="34359738368"
              c:type="GEGL_CH_LOW_FREQUENCY_2">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SIDE_LEFT" value="512" c:type="GEGL_CH_SIDE_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SIDE_RIGHT" value="1024" c:type="GEGL_CH_SIDE_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_STEREO_LEFT"
              value="536870912"
              c:type="GEGL_CH_STEREO_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_STEREO_RIGHT"
              value="1073741824"
              c:type="GEGL_CH_STEREO_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SURROUND_DIRECT_LEFT"
              value="8589934592"
              c:type="GEGL_CH_SURROUND_DIRECT_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_SURROUND_DIRECT_RIGHT"
              value="17179869184"
              c:type="GEGL_CH_SURROUND_DIRECT_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_BACK_CENTER"
              value="65536"
              c:type="GEGL_CH_TOP_BACK_CENTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_BACK_LEFT"
              value="32768"
              c:type="GEGL_CH_TOP_BACK_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_BACK_RIGHT"
              value="131072"
              c:type="GEGL_CH_TOP_BACK_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_CENTER" value="2048" c:type="GEGL_CH_TOP_CENTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_FRONT_CENTER"
              value="8192"
              c:type="GEGL_CH_TOP_FRONT_CENTER">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_FRONT_LEFT"
              value="4096"
              c:type="GEGL_CH_TOP_FRONT_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_TOP_FRONT_RIGHT"
              value="16384"
              c:type="GEGL_CH_TOP_FRONT_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_WIDE_LEFT"
              value="2147483648"
              c:type="GEGL_CH_WIDE_LEFT">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CH_WIDE_RIGHT"
              value="4294967296"
              c:type="GEGL_CH_WIDE_RIGHT">
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Color"
           c:symbol-prefix="color"
           c:type="GeglColor"
           parent="GObject.Object"
           glib:type-name="GeglColor"
           glib:get-type="gegl_color_get_type"
           glib:type-struct="ColorClass">
      <constructor name="new" c:identifier="gegl_color_new">
        <doc xml:space="preserve">Creates a new #GeglColor.

Returns the newly created #GeglColor.</doc>
        <return-value transfer-ownership="full">
          <type name="Color" c:type="GeglColor*"/>
        </return-value>
        <parameters>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string describing the color to be created.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="duplicate" c:identifier="gegl_color_duplicate">
        <doc xml:space="preserve">Creates a copy of @color.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new copy of @color.</doc>
          <type name="Color" c:type="GeglColor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">the color to duplicate.</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_components" c:identifier="gegl_color_get_components">
        <doc xml:space="preserve">Get the component values of the color in @format.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The color components</doc>
          <array length="1" zero-terminated="0" c:type="gdouble*">
            <type name="gdouble" c:type="gdouble"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">A Babl pointer</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="components_length"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">The length of the returned buffer</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pixel"
              c:identifier="gegl_color_get_pixel"
              introspectable="0">
        <doc xml:space="preserve">Store the color in a pixel in the given format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a babl pixel format</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="pixel"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to a pixel</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_rgba" c:identifier="gegl_color_get_rgba">
        <doc xml:space="preserve">Retrieves the current set color as linear light non premultipled RGBA data,
any of the return pointers can be omitted.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="red"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">red return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="green"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">green return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="blue"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">blue return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="alpha"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">alpha return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_components" c:identifier="gegl_color_set_components">
        <doc xml:space="preserve">Set the color using the component values as @format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">A Babl pointer</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
          <parameter name="components" transfer-ownership="none">
            <doc xml:space="preserve">The color components.</doc>
            <array length="2" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
          <parameter name="components_length" transfer-ownership="none">
            <doc xml:space="preserve">The length of the components array</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pixel"
              c:identifier="gegl_color_set_pixel"
              introspectable="0">
        <doc xml:space="preserve">Set a GeglColor from a pointer to a pixel and it's babl format.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">a babl pixel format</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="pixel"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">pointer to a pixel</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rgba" c:identifier="gegl_color_set_rgba">
        <doc xml:space="preserve">Retrieves the current set color as linear light non premultipled RGBA data</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglColor</doc>
            <type name="Color" c:type="GeglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve">red value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve">green value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve">blue value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve">alpha value</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <property name="string" writable="1" transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ColorPrivate" c:type="GeglColorPrivate*"/>
      </field>
    </class>
    <record name="ColorClass"
            c:type="GeglColorClass"
            glib:is-gtype-struct-for="Color">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ColorPrivate" c:type="GeglColorPrivate" disguised="1">
    </record>
    <class name="Config"
           c:symbol-prefix="config"
           c:type="GeglConfig"
           parent="GObject.Object"
           glib:type-name="GeglConfig"
           glib:get-type="gegl_config_get_type">
      <property name="application-license"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="chunk-size"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="quality"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="queue-size"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="swap"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="threads"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-cache-size"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-height"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-width"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="use-opencl"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
    </class>
    <class name="Curve"
           c:symbol-prefix="curve"
           c:type="GeglCurve"
           parent="GObject.Object"
           glib:type-name="GeglCurve"
           glib:get-type="gegl_curve_get_type"
           glib:type-struct="CurveClass">
      <constructor name="new" c:identifier="gegl_curve_new">
        <doc xml:space="preserve">Create a #GeglCurve that can store a curve with values between @y_min and
@y_max.

Returns the newly created #GeglCurve.</doc>
        <return-value transfer-ownership="full">
          <type name="Curve" c:type="GeglCurve*"/>
        </return-value>
        <parameters>
          <parameter name="y_min" transfer-ownership="none">
            <doc xml:space="preserve">minimum y value for curve.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y_max" transfer-ownership="none">
            <doc xml:space="preserve">maximum y value for curve.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_default" c:identifier="gegl_curve_new_default">
        <doc xml:space="preserve">Create a default #GeglCurve with an identify mapping of
(0.0..1.0) -&gt; (0.0..1.0).

Returns the newly created default #GeglCurve.</doc>
        <return-value transfer-ownership="full">
          <type name="Curve" c:type="GeglCurve*"/>
        </return-value>
      </constructor>
      <method name="add_point" c:identifier="gegl_curve_add_point">
        <doc xml:space="preserve">Add a point to the curve at @x @y (replacing the value exactly for @x if it
already exists.</doc>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="calc_value" c:identifier="gegl_curve_calc_value">
        <doc xml:space="preserve">Retrieve the number of points in the curve.

Returns the number of points for the coordinates in the curve.</doc>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="calc_values"
              c:identifier="gegl_curve_calc_values"
              introspectable="0">
        <doc xml:space="preserve">Compute a set (lookup table) of coordinates.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="x_min" transfer-ownership="none">
            <doc xml:space="preserve">the minimum value to compute for</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="x_max" transfer-ownership="none">
            <doc xml:space="preserve">the maximum value to compute for</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="num_samples" transfer-ownership="none">
            <doc xml:space="preserve">number of samples to calculate</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="xs" transfer-ownership="none">
            <doc xml:space="preserve">return location for the x coordinates</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="ys" transfer-ownership="none">
            <doc xml:space="preserve">return location for the y coordinates</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="duplicate" c:identifier="gegl_curve_duplicate">
        <doc xml:space="preserve">Create a copy of @curve.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new copy of @curve.</doc>
          <type name="Curve" c:type="GeglCurve*"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">the curve to duplicate.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point" c:identifier="gegl_curve_get_point">
        <doc xml:space="preserve">Retrive the coordinates for an index.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">the position of the value number to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">x coordinate return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">y coordinate return location.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_y_bounds" c:identifier="gegl_curve_get_y_bounds">
        <doc xml:space="preserve">Get the bounds on the values of the curve and store the values in
the return locaitons provided in @min_y and @max_y.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="min_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for minimal value.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="max_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for maximal value.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="num_points" c:identifier="gegl_curve_num_points">
        <doc xml:space="preserve">Retrieve the number of points in the curve.

Returns the number of points for the coordinates in the curve.</doc>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_point" c:identifier="gegl_curve_set_point">
        <doc xml:space="preserve">Replace an existing point in a curve.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="curve" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglCurve.</doc>
            <type name="Curve" c:type="GeglCurve*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">the position of the value number to retrieve.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <record name="CurveClass"
            c:type="GeglCurveClass"
            glib:is-gtype-struct-for="Curve">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="DistanceMetric"
                 glib:type-name="GeglDistanceMetric"
                 glib:get-type="gegl_distance_metric_get_type"
                 c:type="GeglDistanceMetric">
      <member name="euclidean"
              value="0"
              c:identifier="Euclidean"
              glib:nick="euclidean">
      </member>
      <member name="manhattan"
              value="1"
              c:identifier="Manhattan"
              glib:nick="manhattan">
      </member>
      <member name="chebyshev"
              value="2"
              c:identifier="Chebyshev"
              glib:nick="chebyshev">
      </member>
    </enumeration>
    <enumeration name="DitherMethod"
                 glib:type-name="GeglDitherMethod"
                 glib:get-type="gegl_dither_method_get_type"
                 c:type="GeglDitherMethod">
      <member name="none" value="0" c:identifier="None" glib:nick="none">
      </member>
      <member name="floyd_steinberg"
              value="1"
              c:identifier="Floyd-Steinberg"
              glib:nick="floyd-steinberg">
      </member>
      <member name="bayer" value="2" c:identifier="Bayer" glib:nick="bayer">
      </member>
      <member name="random" value="3" c:identifier="Random" glib:nick="random">
      </member>
      <member name="random_covariant"
              value="4"
              c:identifier="Random Covariant"
              glib:nick="random-covariant">
      </member>
      <member name="add"
              value="5"
              c:identifier="Arithmetic add"
              glib:nick="add">
      </member>
      <member name="add_covariant"
              value="6"
              c:identifier="Arithmetic add covariant"
              glib:nick="add-covariant">
      </member>
      <member name="xor"
              value="7"
              c:identifier="Arithmetic xor"
              glib:nick="xor">
      </member>
      <member name="xor_covariant"
              value="8"
              c:identifier="Arithmetic xor covariant"
              glib:nick="xor-covariant">
      </member>
    </enumeration>
    <constant name="FLOAT_EPSILON"
              value="0.000010"
              c:type="GEGL_FLOAT_EPSILON">
      <type name="gdouble" c:type="gdouble"/>
    </constant>
    <callback name="FlattenerFunc"
              c:type="GeglFlattenerFunc"
              introspectable="0">
      <return-value>
        <type name="PathList" c:type="GeglPathList*"/>
      </return-value>
      <parameters>
        <parameter name="original" transfer-ownership="none">
          <type name="PathList" c:type="GeglPathList*"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="LOOKUP_MAX_ENTRIES"
              value="819200"
              c:type="GEGL_LOOKUP_MAX_ENTRIES">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Lookup" c:type="GeglLookup">
      <field name="function" writable="1">
        <type name="LookupFunction" c:type="GeglLookupFunction"/>
      </field>
      <field name="data" writable="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="shift" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="positive_min" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="positive_max" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="negative_min" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="negative_max" writable="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="bitmask" writable="1">
        <array zero-terminated="0" c:type="guint32" fixed-size="25600">
          <type name="guint32" c:type="guint32"/>
        </array>
      </field>
      <field name="table" writable="1">
        <array zero-terminated="0" c:type="gfloat">
          <type name="gfloat" c:type="gfloat"/>
        </array>
      </field>
      <method name="free" c:identifier="gegl_lookup_free" introspectable="0">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="lookup" transfer-ownership="none">
            <doc xml:space="preserve">#GeglLookup to free</doc>
            <type name="Lookup" c:type="GeglLookup*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new" c:identifier="gegl_lookup_new" introspectable="0">
        <return-value>
          <doc xml:space="preserve">a #GeglLookup</doc>
          <type name="Lookup" c:type="GeglLookup*"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">The function to build a lookup for</doc>
            <type name="LookupFunction" c:type="GeglLookupFunction"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A user data pointer passed to lookup calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_full"
                c:identifier="gegl_lookup_new_full"
                introspectable="0">
        <return-value>
          <doc xml:space="preserve">a #GeglLookup</doc>
          <type name="Lookup" c:type="GeglLookup*"/>
        </return-value>
        <parameters>
          <parameter name="function" transfer-ownership="none" closure="1">
            <doc xml:space="preserve">The function to build a lookup for</doc>
            <type name="LookupFunction" c:type="GeglLookupFunction"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A user data pointer passed to lookup calls</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve">Lower bound of the lookup</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">Upper bound of the lookup</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="precision" transfer-ownership="none">
            <doc xml:space="preserve">The precision of the lookup table</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="LookupFunction" c:type="GeglLookupFunction">
      <return-value transfer-ownership="none">
        <type name="gfloat" c:type="gfloat"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <constant name="MAJOR_VERSION" value="0" c:type="GEGL_MAJOR_VERSION">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MAX_AUDIO_CHANNELS"
              value="8"
              c:type="GEGL_MAX_AUDIO_CHANNELS">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MICRO_VERSION" value="35" c:type="GEGL_MICRO_VERSION">
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="MINOR_VERSION" value="3" c:type="GEGL_MINOR_VERSION">
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Matrix2" c:type="GeglMatrix2">
      <field name="coeff" writable="1">
        <array zero-terminated="0" c:type="gdouble" fixed-size="2">
          <type name="gdouble" c:type="gdouble"/>
        </array>
      </field>
      <method name="determinant" c:identifier="gegl_matrix2_determinant">
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <type name="Matrix2" c:type="GeglMatrix2*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_scale" c:identifier="gegl_matrix2_is_scale">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <type name="Matrix2" c:type="GeglMatrix2*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="Matrix3"
            c:type="GeglMatrix3"
            glib:type-name="GeglMatrix3"
            glib:get-type="gegl_matrix3_get_type"
            c:symbol-prefix="matrix3">
      <field name="coeff" writable="1">
        <array zero-terminated="0" c:type="gdouble" fixed-size="3">
          <type name="gdouble" c:type="gdouble"/>
        </array>
      </field>
      <constructor name="new" c:identifier="gegl_matrix3_new">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #GeglMatrix3</doc>
          <type name="Matrix3" c:type="GeglMatrix3*"/>
        </return-value>
      </constructor>
      <method name="copy" c:identifier="gegl_matrix3_copy">
        <doc xml:space="preserve">Returns a copy of @src.</doc>
        <return-value transfer-ownership="full">
          <type name="Matrix3" c:type="GeglMatrix3*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy_into" c:identifier="gegl_matrix3_copy_into">
        <doc xml:space="preserve">Copies the matrix in @src into @dst.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="determinant" c:identifier="gegl_matrix3_determinant">
        <doc xml:space="preserve">Returns the determinant for the matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gegl_matrix3_equal">
        <doc xml:space="preserve">Check if two matrices are equal.

Returns TRUE if the matrices are equal.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix1" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="matrix2" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="identity" c:identifier="gegl_matrix3_identity">
        <doc xml:space="preserve">Set the provided @matrix to the identity matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="invert" c:identifier="gegl_matrix3_invert">
        <doc xml:space="preserve">Inverts @matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_identity" c:identifier="gegl_matrix3_is_identity">
        <doc xml:space="preserve">Check if a matrix is the identity matrix.

Returns TRUE if the matrix is the identity matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_scale" c:identifier="gegl_matrix3_is_scale">
        <doc xml:space="preserve">Check if a matrix only does scaling.

Returns TRUE if the matrix only does scaling.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_translate" c:identifier="gegl_matrix3_is_translate">
        <doc xml:space="preserve">Check if a matrix only does translation.

Returns TRUE if the matrix only does trasnlation.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="gegl_matrix3_multiply">
        <doc xml:space="preserve">Multiples @product = @left · @right</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
          <parameter name="product" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3 to store the result in.</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="originate" c:identifier="gegl_matrix3_originate">
        <doc xml:space="preserve">Shift the origin of the transformation specified by @matrix
to (@x, @y). In other words, calculate the matrix that:

1. Translates the input by (-@x, -@y).

2. Transforms the result using the original @matrix.

3. Translates the result by (@x, @y).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate of new origin</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate of new origin.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_string" c:identifier="gegl_matrix3_parse_string">
        <doc xml:space="preserve">Parse a transofmation matrix from a string.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="string" transfer-ownership="none">
            <doc xml:space="preserve">a string describing the matrix (right now a small subset of the
transform strings allowed by SVG)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gegl_matrix3_to_string">
        <doc xml:space="preserve">Serialize a #GeglMatrix3 to a string.

Returns a freshly allocated string representing that #GeglMatrix3, the
returned string should be g_free()'d.</doc>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="transform_point"
              c:identifier="gegl_matrix3_transform_point">
        <doc xml:space="preserve">transforms the coordinates provided in @x and @y and changes to the
coordinates gotten when the transformed with the matrix.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">pointer to an x coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">pointer to an y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="Node"
           c:symbol-prefix="node"
           c:type="GeglNode"
           parent="GObject.Object"
           glib:type-name="GeglNode"
           glib:get-type="gegl_node_get_type">
      <constructor name="new" c:identifier="gegl_node_new">
        <doc xml:space="preserve">Create a new graph that can contain further processing nodes.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new top level #GeglNode (which can be used as a graph). When you
are done using this graph instance it should be unreferenced with g_object_unref.
This will also free any sub nodes created from this node.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_file" c:identifier="gegl_node_new_from_file">
        <doc xml:space="preserve">The #GeglNode returned contains the graph described by the tree of stacks
in the XML document. The tree is connected to the "output" pad of the
returned node and thus can be used directly for processing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GeglNode containing the parsed XML as a subgraph.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path to a file on the local file system to be parsed.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_serialized"
                   c:identifier="gegl_node_new_from_serialized">
        <return-value transfer-ownership="full">
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <parameter name="chaindata" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path_root" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_xml" c:identifier="gegl_node_new_from_xml">
        <doc xml:space="preserve">The #GeglNode returned contains the graph described by the tree of stacks
in the XML document. The tree is connected to the "output" pad of the
returned node and thus can be used directly for processing.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a GeglNode containing the parsed XML as a subgraph.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <parameter name="xmldata" transfer-ownership="none">
            <doc xml:space="preserve">a \0 terminated string containing XML data to be parsed.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path_root" transfer-ownership="none">
            <doc xml:space="preserve">a file system path that relative paths in the XML will be
resolved in relation to.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_child" c:identifier="gegl_node_add_child">
        <doc xml:space="preserve">Make the GeglNode @graph, take a reference on child. This reference
will be dropped when the reference count on the graph reaches zero.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="graph" transfer-ownership="none">
            <doc xml:space="preserve">a GeglNode (graph)</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">a GeglNode.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="blit" c:identifier="gegl_node_blit" introspectable="0">
        <doc xml:space="preserve">Render a rectangular region from a node.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">the scale to render at 1.0 is default, other values changes the
width/height of the sampled region.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="roi" transfer-ownership="none">
            <doc xml:space="preserve">the rectangle to render from the node, the coordinate system used is
coordinates after scale has been applied.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve">the #BablFormat desired.</doc>
            <type c:type="const Babl*"/>
          </parameter>
          <parameter name="destination_buf"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a memory buffer large enough to contain the data, can be
left as NULL when forcing a rendering of a region.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve">rowstride in bytes, or GEGL_AUTO_ROWSTRIDE to compute the
rowstride based on the width and bytes per pixel for the specified format.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">an or'ed combination of GEGL_BLIT_DEFAULT, GEGL_BLIT_CACHE and
GEGL_BLIT_DIRTY. if cache is enabled, a cache will be set up for subsequent
requests of image data from this node. By passing in GEGL_BLIT_DIRTY the
function will return with the latest rendered results in the cache without
regard to wheter the regions has been rendered or not.</doc>
            <type name="BlitFlags" c:type="GeglBlitFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="blit_buffer" c:identifier="gegl_node_blit_buffer">
        <doc xml:space="preserve">Render a rectangular region from a node to the given buffer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="buffer"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the #GeglBuffer to render to.</doc>
            <type name="Buffer" c:type="GeglBuffer*"/>
          </parameter>
          <parameter name="roi"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the rectangle to render.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve">mipmap level to render (0 for all)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="abyss_policy" transfer-ownership="none">
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_from" c:identifier="gegl_node_connect_from">
        <doc xml:space="preserve">Makes a connection between the pads of two nodes.

Returns TRUE if the connection was successfully made.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">the node we're connecting an input to</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="input_pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the input pad we are connecting to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the node producing data we want to connect.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="output_pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the output pad we want to use on the source.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="connect_to" c:identifier="gegl_node_connect_to">
        <doc xml:space="preserve">Makes a connection between the pads of two nodes.

Returns TRUE if the connection was successfully made.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the node producing data we want to connect.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="output_pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the output pad we want to use on the source.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">the node we're connecting an input to</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="input_pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the input pad we are connecting to</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_child" c:identifier="gegl_node_create_child">
        <doc xml:space="preserve">Creates a new processing node that performs the specified operation.
All properties of the operation will have their default values. This
is included as an addition to #gegl_node_new_child in the public API to have
a non varargs entry point for bindings as well as sometimes simpler more
readable code.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a newly created node. The node will be destroyed by the parent.
Calling g_object_unref on a node will cause the node to be dropped by the
parent. (You may also add additional references using
g_object_ref/g_object_unref, but in general relying on the parents reference
counting is easiest.)</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="operation" transfer-ownership="none">
            <doc xml:space="preserve">the type of node to create.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="detect" c:identifier="gegl_node_detect">
        <doc xml:space="preserve">Performs hit detection by returning the node providing data at a given
coordinate pair. Currently operates only on bounding boxes and not
pixel data.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the GeglNode providing the
data ending up at @x,@y in the output of @node.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="disconnect" c:identifier="gegl_node_disconnect">
        <doc xml:space="preserve">Disconnects node connected to @input_pad of @node (if any).

Returns TRUE if a connection was broken.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="input_pad" transfer-ownership="none">
            <doc xml:space="preserve">the input pad to disconnect.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_property" c:identifier="gegl_node_find_property">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the GParamSpec of property or NULL
if no such property exists.</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to lookup a paramspec on</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to get a paramspec for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="gegl_node_get" introspectable="0">
        <doc xml:space="preserve">Gets properties of a #GeglNode.
---
double level;
char  *path;

gegl_node_get (png_save, "path", &amp;path, NULL);
gegl_node_get (threshold, "level", &amp;level, NULL);</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to get.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">return location for the first property, followed optionally by more
name/value pairs, followed by NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bounding_box"
              c:identifier="gegl_node_get_bounding_box"
              shadowed-by="introspectable_get_bounding_box"
              introspectable="0">
        <doc xml:space="preserve">Returns the position and dimensions of a rectangle spanning the area
defined by a node.</doc>
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_children" c:identifier="gegl_node_get_children">
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">a list
of the nodes contained within a GeglNode that is a subgraph.
Use g_list_free () on the list when done.</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="Node"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to retrieve the children of.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_consumers" c:identifier="gegl_node_get_consumers">
        <doc xml:space="preserve">Retrieve which pads on which nodes are connected to a named output_pad,
and the number of connections. Both the location for the generated
nodes array and pads array can be left as NULL. If they are non NULL
both should be freed with g_free. The arrays are NULL terminated.

Returns the number of consumers connected to this output_pad.</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node we are querying.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="output_pad" transfer-ownership="none">
            <doc xml:space="preserve">the output pad we want to know who uses.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="nodes"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">optional return location for array of nodes.</doc>
            <array c:type="GeglNode***">
              <type name="Node" c:type="GeglNode**"/>
            </array>
          </parameter>
          <parameter name="pads"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve">optional return location for array of pad names.</doc>
            <array c:type="gchar***">
              <type name="utf8" c:type="gchar**"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_gegl_operation"
              c:identifier="gegl_node_get_gegl_operation">
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve">The operation object
associated with this node or NULL if there is no op associated.</doc>
          <type name="Operation" c:type="GeglOperation*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_input_proxy" c:identifier="gegl_node_get_input_proxy">
        <doc xml:space="preserve">Proxies are used to route between nodes of a subgraph contained within
a node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Returns an input proxy for the named pad.
If no input proxy exists with this name a new one will be created.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_operation" c:identifier="gegl_node_get_operation">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The type of processing operation associated with this
node, or NULL if there is no op associated. The special name
"GraphNode" is returned if the node is the container of a subgraph.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="const GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_output_proxy"
              c:identifier="gegl_node_get_output_proxy">
        <doc xml:space="preserve">Proxies are used to route between nodes of a subgraph contained within
a node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Returns a output proxy for the named pad.
If no output proxy exists with this name a new one will be created.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the pad.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_parent" c:identifier="gegl_node_get_parent">
        <doc xml:space="preserve">Returns a GeglNode that keeps a reference on a child.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the parent of a node or NULL.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_passthrough" c:identifier="gegl_node_get_passthrough">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_producer" c:identifier="gegl_node_get_producer">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the node providing data
or NULL if no node is connected to the input_pad.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="input_pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the input pad we want to get the producer for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="output_pad_name"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">optional pointer to a location where we can store a
                  freshly allocated string with the name of the output pad.</doc>
            <type name="utf8" c:type="gchar**"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_property"
              c:identifier="gegl_node_get_property"
              shadowed-by="introspectable_get_property"
              introspectable="0">
        <doc xml:space="preserve">This is mainly included for language bindings. Using #gegl_node_get is
more convenient when programming in C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to get a property from</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">pointer to a GValue where the value of the property should be stored</doc>
            <type name="GObject.Value" c:type="GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_valist"
              c:identifier="gegl_node_get_valist"
              introspectable="0">
        <doc xml:space="preserve">valist version of #gegl_node_get</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to get.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">return location for the first property, followed optionally by more
name/value pairs, followed by NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_pad" c:identifier="gegl_node_has_pad">
        <doc xml:space="preserve">Returns TRUE if the node has a pad with the specified name</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="pad_name" transfer-ownership="none">
            <doc xml:space="preserve">the pad name we are looking for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="introspectable_get_bounding_box"
              c:identifier="gegl_node_introspectable_get_bounding_box"
              shadows="get_bounding_box">
        <doc xml:space="preserve">Returns the position and dimensions of a rectangle spanning the area
defined by a node.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">pointer a #GeglRectangle</doc>
          <type name="Rectangle" c:type="GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="introspectable_get_property"
              c:identifier="gegl_node_introspectable_get_property"
              shadows="get_property">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">pointer to a GValue containing the value of the property</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node to get a property from</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to get</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link" c:identifier="gegl_node_link">
        <doc xml:space="preserve">Synthetic sugar for linking the "output" pad of @source to the "input"
pad of @sink.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the producer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve">the consumer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link_many"
              c:identifier="gegl_node_link_many"
              introspectable="0">
        <doc xml:space="preserve">Synthetic sugar for linking a chain of nodes with "input"-&gt;"output". The
list is NULL terminated.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">the producer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_sink" transfer-ownership="none">
            <doc xml:space="preserve">the first consumer of data.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">NULL, or optionally more consumers followed by NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="list_input_pads" c:identifier="gegl_node_list_input_pads">
        <doc xml:space="preserve">If the node has any input pads this function returns a null terminated
array of pad names, otherwise it returns NULL. The return value can be
freed with g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="list_output_pads"
              c:identifier="gegl_node_list_output_pads">
        <doc xml:space="preserve">If the node has any output pads this function returns a null terminated
array of pad names, otherwise it returns NULL. The return value can be
freed with g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">the node we are querying</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_child"
              c:identifier="gegl_node_new_child"
              introspectable="0">
        <doc xml:space="preserve">Creates a new processing node that performs the specified operation with
a NULL terminated list of key/value pairs for initial parameter values
configuring the operation. Usually the first pair should be "operation"
and the type of operation to be associated. If no operation is provided
the node doesn't have an initial operation and can be used to construct
a subgraph with special middle-man routing nodes created with
#gegl_node_get_output_proxy and #gegl_node_get_input_proxy.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">A newly created #GeglNode. The node will be destroyed by the parent.
Calling g_object_unref on a node will cause the node to be dropped by the
parent. (You may also add additional references using
g_object_ref/g_object_unref, but in general relying on the parents reference
counting is easiest.)</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">the first property name</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">first property value, optionally followed by more key/value pairs,
terminated with NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="new_processor" c:identifier="gegl_node_new_processor">
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GeglProcessor.</doc>
          <type name="Processor" c:type="GeglProcessor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">the #GeglRectangle to work on or NULL to work on all available
data.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="process" c:identifier="gegl_node_process">
        <doc xml:space="preserve">Render a composition. This can be used for instance on a node with a "png-save"
operation to render all necessary data, and make it be written to file. This
function wraps the usage of a GeglProcessor in a single blocking function
call. If you need a non-blocking operation, then make a direct use of
#gegl_processor_work. See #GeglProcessor.

---
GeglNode      *gegl;
GeglRectangle  roi;
GeglNode      *png_save;
unsigned char *buffer;

gegl = gegl_parse_xml (xml_data);
roi      = gegl_node_get_bounding_box (gegl);
# create png_save from the graph, the parent/child relationship
# only mean anything when it comes to memory management.
png_save = gegl_node_new_child (gegl,
                                "operation", "gegl:png-save",
                                "path",      "output.png",
                                NULL);

gegl_node_link (gegl, png_save);
gegl_node_process (png_save);

buffer = malloc (roi.w*roi.h*4);
gegl_node_blit (gegl,
                1.0,
                &amp;roi,
                babl_format("R'G'B'A u8"),
                buffer,
                GEGL_AUTO_ROWSTRIDE,
                GEGL_BLIT_DEFAULT);</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink_node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode without outputs.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="progress" c:identifier="gegl_node_progress">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="progress" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="message" transfer-ownership="none">
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_child" c:identifier="gegl_node_remove_child">
        <doc xml:space="preserve">Removes a child from a GeglNode. The reference previously held will be
dropped so increase the reference count before removing when reparenting
a child between two graphs.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the child.</doc>
          <type name="Node" c:type="GeglNode*"/>
        </return-value>
        <parameters>
          <instance-parameter name="graph" transfer-ownership="none">
            <doc xml:space="preserve">a GeglNode (graph)</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">a GeglNode.</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gegl_node_set" introspectable="0">
        <doc xml:space="preserve">Set properties on a node, possible properties to be set are the properties
of the currently set operations as well as &lt;em&gt;"name"&lt;/em&gt; and
&lt;em&gt;"operation"&lt;/em&gt;. &lt;em&gt;"operation"&lt;/em&gt; changes the current operations
set for the node, &lt;em&gt;"name"&lt;/em&gt; doesn't have any role internally in
GEGL.
---
gegl_node_set (node, "brightness", -0.2,
                     "contrast",   2.0,
                     NULL);</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">value for the first property, followed optionally by more name/value
pairs, followed by NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="set_passthrough" c:identifier="gegl_node_set_passthrough">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="passthrough" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_property" c:identifier="gegl_node_set_property">
        <doc xml:space="preserve">This is mainly included for language bindings. Using #gegl_node_set is
more convenient when programming in C.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">a GValue containing the value to be set in the property.</doc>
            <type name="GObject.Value" c:type="const GValue*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_valist"
              c:identifier="gegl_node_set_valist"
              introspectable="0">
        <doc xml:space="preserve">valist version of #gegl_node_set</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">name of the first property to set</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <doc xml:space="preserve">value for the first property, followed optionally by more name/value
pairs, followed by NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_xml" c:identifier="gegl_node_to_xml">
        <doc xml:space="preserve">Returns a freshly allocated \0 terminated string containing a XML
serialization of the composition produced by a node (and thus also
the nodes contributing data to the specified node). To export a
gegl graph, connect the internal output node to an output proxy (see
#gegl_node_get_output_proxy.) and use the proxy node as the basis
for the serialization.</doc>
        <return-value transfer-ownership="full">
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="path_root" transfer-ownership="none">
            <doc xml:space="preserve">filesystem path to construct relative paths from.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_xml_full" c:identifier="gegl_node_to_xml_full">
        <doc xml:space="preserve">Returns a freshly allocated \0 terminated string containing a XML
serialization of a segment of a graph from @head to @tail nodes.
If @tail is %NULL then this behaves just like #gegl_node_to_xml.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">XML serialization of a graph segment.</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="head" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </instance-parameter>
          <parameter name="tail"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GeglNode</doc>
            <type name="Node" c:type="GeglNode*"/>
          </parameter>
          <parameter name="path_root" transfer-ownership="none">
            <doc xml:space="preserve">filesystem path to construct relative paths from.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <property name="dont-cache"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="gegl-operation"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Operation"/>
      </property>
      <property name="name"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="operation"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="passthrough"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="use-opencl"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <glib:signal name="computed" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Rectangle"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="invalidated" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Rectangle"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="progress" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <callback name="NodeFunction" c:type="GeglNodeFunction">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <type name="PathItem" c:type="const GeglPathItem*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Operation"
           c:symbol-prefix="operation"
           c:type="GeglOperation"
           parent="GObject.Object"
           glib:type-name="GeglOperation"
           glib:get-type="gegl_operation_get_type">
      <function name="find_property"
                c:identifier="gegl_operation_find_property">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The paramspec of the matching property - or
NULL if there as no match.</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve">the name of the operation type we want to locate a property on.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the name of the property we seek.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_key" c:identifier="gegl_operation_get_key">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="key_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_op_version"
                c:identifier="gegl_operation_get_op_version">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="op_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_property_key"
                c:identifier="gegl_operation_get_property_key">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">NULL or a string with the meta-data value for the operation
key.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve">the name of the operation type we want to query to property keys for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the property to query a key for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_key_name" transfer-ownership="none">
            <doc xml:space="preserve">the property mata data key to query</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_keys" c:identifier="gegl_operation_list_keys">
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">An allocated NULL
terminated array of operation-key names. The list should be freed with g_free after use.</doc>
          <array length="1" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve">the name of the operation type we want to query to property keys for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_keys"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for number of property keys.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_properties"
                c:identifier="gegl_operation_list_properties">
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">An allocated array of #GParamSpecs describing the properties
of the operation available when a node has operation_type set. The list should be freed with g_free after use.</doc>
          <array length="1" zero-terminated="0" c:type="GParamSpec**">
            <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve">the name of the operation type we want to query to properties of.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_properties_p"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for number of properties.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_property_keys"
                c:identifier="gegl_operation_list_property_keys">
        <return-value transfer-ownership="container">
          <doc xml:space="preserve">An allocated NULL terminated array of property-key names. The list should be freed with g_free after use.</doc>
          <array length="2" zero-terminated="0" c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="operation_type" transfer-ownership="none">
            <doc xml:space="preserve">the name of the operation type we want to query to property keys for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="property_name" transfer-ownership="none">
            <doc xml:space="preserve">the property to query a key for.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="n_keys"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for number of property
keys.</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <record name="OperationContext"
            c:type="GeglOperationContext"
            disguised="1">
    </record>
    <enumeration name="Orientation"
                 glib:type-name="GeglOrientation"
                 glib:get-type="gegl_orientation_get_type"
                 c:type="GeglOrientation">
      <member name="horizontal"
              value="0"
              c:identifier="Horizontal"
              glib:nick="horizontal">
      </member>
      <member name="vertical"
              value="1"
              c:identifier="Vertical"
              glib:nick="vertical">
      </member>
    </enumeration>
    <constant name="PARAM_NO_VALIDATE"
              value="64"
              c:type="GEGL_PARAM_NO_VALIDATE">
      <type name="gint" c:type="gint"/>
    </constant>
    <bitfield name="PadType" c:type="GeglPadType">
      <member name="output" value="256" c:identifier="GEGL_PARAM_PAD_OUTPUT">
      </member>
      <member name="input" value="512" c:identifier="GEGL_PARAM_PAD_INPUT">
      </member>
    </bitfield>
    <class name="ParamAudioFragment"
           c:symbol-prefix="param_audio_fragment"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamAudioFragment"
           glib:get-type="gegl_param_audio_fragment_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamColor"
           c:symbol-prefix="param_color"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamColor"
           glib:get-type="gegl_param_color_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamCurve"
           c:symbol-prefix="param_curve"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamCurve"
           glib:get-type="gegl_param_curve_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamDouble"
           c:symbol-prefix="param_double"
           parent="GObject.ParamSpecDouble"
           glib:type-name="GeglParamDouble"
           glib:get-type="gegl_param_double_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamEnum"
           c:symbol-prefix="param_enum"
           parent="GObject.ParamSpecEnum"
           glib:type-name="GeglParamEnum"
           glib:get-type="gegl_param_enum_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamFilePath"
           c:symbol-prefix="param_file_path"
           parent="GObject.ParamSpecString"
           glib:type-name="GeglParamFilePath"
           glib:get-type="gegl_param_file_path_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamFormat"
           c:symbol-prefix="param_format"
           parent="GObject.ParamSpecPointer"
           glib:type-name="GeglParamFormat"
           glib:get-type="gegl_param_format_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamInt"
           c:symbol-prefix="param_int"
           parent="GObject.ParamSpecInt"
           glib:type-name="GeglParamInt"
           glib:get-type="gegl_param_int_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamPath"
           c:symbol-prefix="param_path"
           parent="GObject.ParamSpec"
           glib:type-name="GeglParamPath"
           glib:get-type="gegl_param_path_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamSeed"
           c:symbol-prefix="param_seed"
           parent="GObject.ParamSpecUInt"
           glib:type-name="GeglParamSeed"
           glib:get-type="gegl_param_seed_get_type"
           glib:fundamental="1">
    </class>
    <record name="ParamSpecDouble" c:type="GeglParamSpecDouble">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecDouble" c:type="GParamSpecDouble"/>
      </field>
      <field name="ui_minimum" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_maximum" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_gamma" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_step_small" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_step_big" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_digits" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="set_digits"
              c:identifier="gegl_param_spec_double_set_digits">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpecDouble" c:type="GeglParamSpecDouble*"/>
          </instance-parameter>
          <parameter name="digits" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_steps" c:identifier="gegl_param_spec_double_set_steps">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpecDouble" c:type="GeglParamSpecDouble*"/>
          </instance-parameter>
          <parameter name="small_step" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="big_step" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ParamSpecEnum" c:type="GeglParamSpecEnum">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecEnum" c:type="GParamSpecEnum"/>
      </field>
      <field name="excluded_values" writable="1">
        <type name="GLib.SList" c:type="GSList*">
          <type name="gpointer" c:type="gpointer"/>
        </type>
      </field>
      <method name="exclude_value"
              c:identifier="gegl_param_spec_enum_exclude_value">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="espec" transfer-ownership="none">
            <type name="ParamSpecEnum" c:type="GeglParamSpecEnum*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ParamSpecFilePath" c:type="GeglParamSpecFilePath">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecString" c:type="GParamSpecString"/>
      </field>
      <field name="no_validate" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="null_ok" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecFormat" c:type="GeglParamSpecFormat">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecPointer" c:type="GParamSpecPointer"/>
      </field>
    </record>
    <record name="ParamSpecInt" c:type="GeglParamSpecInt">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecInt" c:type="GParamSpecInt"/>
      </field>
      <field name="ui_minimum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="ui_maximum" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="ui_gamma" writable="1">
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="ui_step_small" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="ui_step_big" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <method name="set_steps" c:identifier="gegl_param_spec_int_set_steps">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pspec" transfer-ownership="none">
            <type name="ParamSpecInt" c:type="GeglParamSpecInt*"/>
          </instance-parameter>
          <parameter name="small_step" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="big_step" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="ParamSpecSeed" c:type="GeglParamSpecSeed">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecUInt" c:type="GParamSpecUInt"/>
      </field>
      <field name="ui_minimum" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="ui_maximum" writable="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecString" c:type="GeglParamSpecString">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecString" c:type="GParamSpecString"/>
      </field>
      <field name="no_validate" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="null_ok" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <record name="ParamSpecUri" c:type="GeglParamSpecUri">
      <field name="parent_instance" writable="1">
        <type name="GObject.ParamSpecString" c:type="GParamSpecString"/>
      </field>
      <field name="no_validate" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="null_ok" writable="1" bits="1">
        <type name="guint" c:type="guint"/>
      </field>
    </record>
    <class name="ParamString"
           c:symbol-prefix="param_string"
           parent="GObject.ParamSpecString"
           glib:type-name="GeglParamString"
           glib:get-type="gegl_param_string_get_type"
           glib:fundamental="1">
    </class>
    <class name="ParamUri"
           c:symbol-prefix="param_uri"
           parent="GObject.ParamSpecString"
           glib:type-name="GeglParamUri"
           glib:get-type="gegl_param_uri_get_type"
           glib:fundamental="1">
    </class>
    <class name="Path"
           c:symbol-prefix="path"
           c:type="GeglPath"
           parent="GObject.Object"
           glib:type-name="GeglPath"
           glib:get-type="gegl_path_get_type"
           glib:type-struct="PathClass">
      <constructor name="new" c:identifier="gegl_path_new">
        <doc xml:space="preserve">Creates a new #GeglPath with no nodes.

Returns the newly created #GeglPath</doc>
        <return-value transfer-ownership="full">
          <type name="Path" c:type="GeglPath*"/>
        </return-value>
      </constructor>
      <constructor name="new_from_string"
                   c:identifier="gegl_path_new_from_string">
        <doc xml:space="preserve">Creates a new #GeglPath with the nodes described in the string
@instructions. See gegl_path_parse_string() for details of the
format of the string.

Returns the newly created #GeglPath</doc>
        <return-value transfer-ownership="full">
          <type name="Path" c:type="GeglPath*"/>
        </return-value>
        <parameters>
          <parameter name="instructions" transfer-ownership="none">
            <doc xml:space="preserve">a string describing the path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="add_flattener"
                c:identifier="gegl_path_add_flattener"
                introspectable="0">
        <doc xml:space="preserve">Add a new flattener, the flattener should produce a type of path that
GeglPath already understands, if the flattener is unable to flatten
the incoming path (doesn't understand the instructions), the original
path should be returned.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="func" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglFlattenerFunc</doc>
            <type name="FlattenerFunc" c:type="GeglFlattenerFunc"/>
          </parameter>
        </parameters>
      </function>
      <function name="add_type" c:identifier="gegl_path_add_type">
        <doc xml:space="preserve">Adds a new type to the path system, FIXME this should probably
return something on registration conflicts, for now it expects
all registered paths to be aware of each other.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">a gchar to recognize in path descriptions.</doc>
            <type name="gchar" c:type="gchar"/>
          </parameter>
          <parameter name="items" transfer-ownership="none">
            <doc xml:space="preserve">the number of floating point data items the instruction takes</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="description" transfer-ownership="none">
            <doc xml:space="preserve">a human readable description of this entry</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="append" c:identifier="gegl_path_append" introspectable="0">
        <doc xml:space="preserve">Use as follows: gegl_path_append (path, 'M', 0.0, 0.0);
and gegl_path_append (path, 'C', 10.0, 10.0, 50.0, 10.0, 60.0, 0.0) the
number of arguments are determined from the instruction provided.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">first instruction.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="calc" c:identifier="gegl_path_calc">
        <doc xml:space="preserve">Compute the coordinates of the path at the @position (length measured from
start of path, not including discontinuities).</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">how far along the path.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for x coordinate.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="calc_values"
              c:identifier="gegl_path_calc_values"
              introspectable="0">
        <doc xml:space="preserve">Compute @num_samples for a path into the provided arrays @xs and @ys
the returned values include the start and end positions of the path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="num_samples"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">number of samples to compute</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="xs"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for x coordinates</doc>
            <array length="0" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
          <parameter name="ys"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">return location for y coordinates</doc>
            <array length="0" zero-terminated="0" c:type="gdouble*">
              <type name="gdouble" c:type="gdouble"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="calc_y_for_x" c:identifier="gegl_path_calc_y_for_x">
        <doc xml:space="preserve">Compute a corresponding y coordinate for a given x input coordinate,
returns 0 if computed correctly and -1 if the path doesn't exist for the
specified x coordinate.</doc>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate to compute for</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gegl_path_clear">
        <doc xml:space="preserve">Remove all nods from a @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="closest_point" c:identifier="gegl_path_closest_point">
        <doc xml:space="preserve">Figure out what and where on a path is closest to arbitrary coordinates.

Returns the length along the path where the closest point was encountered.</doc>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate.</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="on_path_x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for x coordinate on the path that was closest</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="on_path_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for y coordinate on the path that was closest</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="node_pos_before"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">the node position interpreted before this position
was deemed the closest coordinate.</doc>
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach" c:identifier="gegl_path_foreach">
        <doc xml:space="preserve">Execute a provided function for every node in the path (useful for
drawing and otherwise traversing a path.)</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="each_item"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a function to call for each node in the path.</doc>
            <type name="NodeFunction" c:type="GeglNodeFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to the function (in addition to the GeglPathItem).</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="foreach_flat" c:identifier="gegl_path_foreach_flat">
        <doc xml:space="preserve">Execute a provided function for the segments of a poly line approximating
the path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="each_item"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">a function to call for each node in the path.</doc>
            <type name="NodeFunction" c:type="GeglNodeFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">user data to pass to a node.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="freeze" c:identifier="gegl_path_freeze">
        <doc xml:space="preserve">Make the @GeglPath stop firing signals as it changes must be paired with a
gegl_path_thaw() for the signals to start again.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a @GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bounds" c:identifier="gegl_path_get_bounds">
        <doc xml:space="preserve">Compute the bounding box of a path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath.</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="min_x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for minimum x coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="max_x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for maximum x coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="min_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for minimum y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
          <parameter name="max_y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">return location for maximum y coordinate</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_flat_path"
              c:identifier="gegl_path_get_flat_path"
              introspectable="0">
        <doc xml:space="preserve">Return a polyline version of @path</doc>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length" c:identifier="gegl_path_get_length">
        <doc xml:space="preserve">Returns the total length of the path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the length of the path.</doc>
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_matrix" c:identifier="gegl_path_get_matrix">
        <doc xml:space="preserve">Get the transformation matrix of the path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3 to copy the matrix into</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_nodes" c:identifier="gegl_path_get_n_nodes">
        <doc xml:space="preserve">Retrieves the number of nodes in the path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the number of nodes in the path.</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_node" c:identifier="gegl_path_get_node">
        <doc xml:space="preserve">Retrieve the node of the path at position @pos.

Returns TRUE if the node was successfully retrieved.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">the node number to retrieve</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="node"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">a pointer to a #GeglPathItem record to be written.</doc>
            <type name="PathItem" c:type="GeglPathItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_path"
              c:identifier="gegl_path_get_path"
              introspectable="0">
        <doc xml:space="preserve">Return the internal untouched #GeglPathList</doc>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="insert_node" c:identifier="gegl_path_insert_node">
        <doc xml:space="preserve">Insert the new node @node at position @pos in @path.
if @pos = -1, the node is added in the last position.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position we want the new node to have.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a structure describing the GeglPathItem we want to store</doc>
            <type name="PathItem" c:type="const GeglPathItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="gegl_path_is_empty">
        <doc xml:space="preserve">Check if the path contains any nodes.

Returns TRUE if the path has no nodes.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_string" c:identifier="gegl_path_parse_string">
        <doc xml:space="preserve">Parses @instructions and appends corresponding nodes to path (call
gegl_path_clean() first if you want to replace the existing path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="instructions" transfer-ownership="none">
            <doc xml:space="preserve">a string describing a path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_node" c:identifier="gegl_path_remove_node">
        <doc xml:space="preserve">Removes the node number @pos in @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">a node in the path.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="replace_node" c:identifier="gegl_path_replace_node">
        <doc xml:space="preserve">Replaces the exiting node at position @pos in @path.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve">the position we want the new node to have.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="node" transfer-ownership="none">
            <doc xml:space="preserve">pointer to a structure describing the GeglPathItem we want to store.</doc>
            <type name="PathItem" c:type="const GeglPathItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_matrix" c:identifier="gegl_path_set_matrix">
        <doc xml:space="preserve">Set the transformation matrix of the path.

The path is transformed through this matrix when being evaluated,
causing the calculated positions and length to be changed by the transform.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglMatrix3 to copy the matrix from</doc>
            <type name="Matrix3" c:type="GeglMatrix3*"/>
          </parameter>
        </parameters>
      </method>
      <method name="thaw" c:identifier="gegl_path_thaw">
        <doc xml:space="preserve">Restart firing signals (unless the path has been frozen multiple times).</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a @GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="gegl_path_to_string">
        <doc xml:space="preserve">Serialize the paths nodes to a string.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">return a string with instructions describing the string you
need to free this with g_free().</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPath</doc>
            <type name="Path" c:type="GeglPath*"/>
          </instance-parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="changed" when="last" no-recurse="1" no-hooks="1">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="PathClass"
            c:type="GeglPathClass"
            disguised="1"
            glib:is-gtype-struct-for="Path">
    </record>
    <record name="PathItem" c:type="GeglPathItem">
      <field name="type" writable="1">
        <type name="gchar" c:type="gchar"/>
      </field>
      <field name="point" writable="1">
        <array zero-terminated="0" c:type="GeglPathPoint" fixed-size="4">
          <type name="PathPoint" c:type="GeglPathPoint"/>
        </array>
      </field>
    </record>
    <record name="PathList" c:type="GeglPathList">
      <field name="next" writable="1">
        <type name="gpointer" c:type="GeglPathList*"/>
      </field>
      <field name="d" writable="1">
        <type name="PathItem" c:type="GeglPathItem"/>
      </field>
      <method name="append"
              c:identifier="gegl_path_list_append"
              introspectable="0">
        <doc xml:space="preserve">Appends to path list, if head is NULL a new list is created</doc>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="head" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglPathList</doc>
            <type name="PathList" c:type="GeglPathList*"/>
          </instance-parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">additional #GeglPathList items to append</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="gegl_path_list_destroy"
              introspectable="0">
        <doc xml:space="preserve">Frees up a path list</doc>
        <return-value>
          <type name="PathList" c:type="GeglPathList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">A #GeglPathList</doc>
            <type name="PathList" c:type="GeglPathList*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <record name="PathPoint" c:type="GeglPathPoint">
      <field name="x" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="y" writable="1">
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <method name="dist"
              c:identifier="gegl_path_point_dist"
              introspectable="0">
        <doc xml:space="preserve">Compute the distance between #GeglPathPoint @a and @b</doc>
        <return-value transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </return-value>
        <parameters>
          <instance-parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">an arbitrary GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </instance-parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">an arbitrary GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </parameter>
        </parameters>
      </method>
      <method name="lerp"
              c:identifier="gegl_path_point_lerp"
              introspectable="0">
        <doc xml:space="preserve">linear interpolation between two #GeglPathPoint</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">return location for the result</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </instance-parameter>
          <parameter name="a" transfer-ownership="none">
            <doc xml:space="preserve">origin GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </parameter>
          <parameter name="b" transfer-ownership="none">
            <doc xml:space="preserve">destination GeglPathPoint</doc>
            <type name="PathPoint" c:type="GeglPathPoint*"/>
          </parameter>
          <parameter name="t" transfer-ownership="none">
            <doc xml:space="preserve">ratio between @a and @b</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <class name="Processor"
           c:symbol-prefix="processor"
           c:type="GeglProcessor"
           parent="GObject.Object"
           glib:type-name="GeglProcessor"
           glib:get-type="gegl_processor_get_type">
      <method name="set_level" c:identifier="gegl_processor_set_level">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="level" transfer-ownership="none">
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_rectangle" c:identifier="gegl_processor_set_rectangle">
        <doc xml:space="preserve">Change the rectangle a #GeglProcessor is working on.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglProcessor</doc>
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">the new #GeglRectangle the processor shold work on or NULL
to make it work on all data in the buffer.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_scale" c:identifier="gegl_processor_set_scale">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="scale" transfer-ownership="none">
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="work" c:identifier="gegl_processor_work">
        <doc xml:space="preserve">Do an iteration of work for the processor.

Returns TRUE if there is more work to be done.

---
GeglProcessor *processor = gegl_node_new_processor (node, &amp;roi);
double         progress;

while (gegl_processor_work (processor, &amp;progress))
  g_warning ("%f%% complete", progress);
g_object_unref (processor);</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="processor" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglProcessor</doc>
            <type name="Processor" c:type="GeglProcessor*"/>
          </instance-parameter>
          <parameter name="progress"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve">a location to store the (estimated) percentage complete.</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <property name="chunksize"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="node"
                readable="0"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="Node"/>
      </property>
      <property name="progress" writable="1" transfer-ownership="none">
        <type name="gdouble" c:type="gdouble"/>
      </property>
      <property name="rectangle" writable="1" transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
    </class>
    <record name="Random"
            c:type="GeglRandom"
            glib:type-name="GeglRandom"
            glib:get-type="gegl_random_get_type"
            c:symbol-prefix="random">
      <constructor name="new" c:identifier="gegl_random_new">
        <doc xml:space="preserve">Creates a new random number generator initialized with a random seed.
This structure needs to be freed by the user with gegl_random_free();</doc>
        <return-value transfer-ownership="full">
          <type name="Random" c:type="GeglRandom*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_seed"
                   c:identifier="gegl_random_new_with_seed">
        <doc xml:space="preserve">Return an opaque structure associated to the seed.
This structure needs to be freed by the user with gegl_random_free();</doc>
        <return-value transfer-ownership="full">
          <type name="Random" c:type="GeglRandom*"/>
        </return-value>
        <parameters>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve">an integer seed, change for different permutation.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="duplicate" c:identifier="gegl_random_duplicate">
        <doc xml:space="preserve">Return a new copy of an existing GeglRandom</doc>
        <return-value transfer-ownership="full">
          <type name="Random" c:type="GeglRandom*"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve">The GeglRandom to duplicate</doc>
            <type name="Random" c:type="GeglRandom*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="float" c:identifier="gegl_random_float">
        <doc xml:space="preserve">Return a random floating point number in range 0.0 .. 1.0.</doc>
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="float_range" c:identifier="gegl_random_float_range">
        <doc xml:space="preserve">Return a random floating point number in the range specified,
for the given x,y coordinates and GeglRandom provided, if multiple different
numbers are needed pass in incrementing n's.</doc>
        <return-value transfer-ownership="none">
          <type name="gfloat" c:type="gfloat"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve">minimum value</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve">maximum value</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gegl_random_free">
        <doc xml:space="preserve">Free a GeglRandom structure created with gegl_random_new() or
gegl_random_new_with_seed()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve">The GeglRandom structure to free</doc>
            <type name="Random" c:type="GeglRandom*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="int" c:identifier="gegl_random_int">
        <doc xml:space="preserve">Return a random integer number in range 0 .. MAX_UINT</doc>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="guint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="int_range" c:identifier="gegl_random_int_range">
        <doc xml:space="preserve">Return a random integer point number in the range specified,
for the given x,y coordinates and GeglRandom provided, if multiple different
numbers are needed pass in incrementing n's.</doc>
        <return-value transfer-ownership="none">
          <type name="gint32" c:type="gint32"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve">a GeglRandom</doc>
            <type name="Random" c:type="const GeglRandom*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">z coordinate (mipmap level)</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="n" transfer-ownership="none">
            <doc xml:space="preserve">number no (each x,y coordinate provides its own sequence of
numbers</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="min" transfer-ownership="none">
            <doc xml:space="preserve">minimum value</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="max" transfer-ownership="none">
            <doc xml:space="preserve">maximum value+1</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_seed" c:identifier="gegl_random_set_seed">
        <doc xml:space="preserve">Change the seed of an existing GeglRandom.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rand" transfer-ownership="none">
            <doc xml:space="preserve">The GeglRandom to set</doc>
            <type name="Random" c:type="GeglRandom*"/>
          </instance-parameter>
          <parameter name="seed" transfer-ownership="none">
            <doc xml:space="preserve">an integer seed, change for different permutation.</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <record name="Rectangle"
            c:type="GeglRectangle"
            glib:type-name="GeglRectangle"
            glib:get-type="gegl_rectangle_get_type"
            c:symbol-prefix="rectangle">
      <field name="x" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="y" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="width" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="height" writable="1">
        <type name="gint" c:type="gint"/>
      </field>
      <constructor name="new" c:identifier="gegl_rectangle_new">
        <doc xml:space="preserve">Creates a new rectangle set with the values from @x, @y, @width and @height.</doc>
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle*"/>
        </return-value>
        <parameters>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">upper left x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">upper left y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="bounding_box" c:identifier="gegl_rectangle_bounding_box">
        <doc xml:space="preserve">Computes the bounding box of the rectangles @source1 and @source2 and stores the
resulting bounding box in @destination.

@destination may point to the same object as @source1 or @source2.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="source1" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="source2" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="contains" c:identifier="gegl_rectangle_contains">
        <doc xml:space="preserve">Checks if the #GeglRectangle @child is fully contained within @parent.

Returns TRUE if the @child is fully contained in @parent.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parent" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
          <parameter name="child" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="gegl_rectangle_copy">
        <doc xml:space="preserve">Copies the rectangle information stored in @source over the information in
@destination.

@destination may point to the same object as @source.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dump" c:identifier="gegl_rectangle_dump">
        <doc xml:space="preserve">For debugging purposes, not stable API.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">A GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dup" c:identifier="gegl_rectangle_dup">
        <doc xml:space="preserve">Create a new copy of @rectangle.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a #GeglRectangle</doc>
          <type name="Rectangle" c:type="GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">the #GeglRectangle to duplicate</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="gegl_rectangle_equal">
        <doc xml:space="preserve">Check if two #GeglRectangles are equal.

Returns TRUE if @rectangle and @rectangle2 are equal.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle1" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
          <parameter name="rectangle2" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="equal_coords" c:identifier="gegl_rectangle_equal_coords">
        <doc xml:space="preserve">Check if a rectangle is equal to a set of parameters.

Returns TRUE if @rectangle and @x,@y @width x @height are equal.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">X coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">Y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width of rectangle</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height of rectangle</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="intersect" c:identifier="gegl_rectangle_intersect">
        <doc xml:space="preserve">Calculates the intersection of two rectangles. If the rectangles do not
intersect, dest's width and height are set to 0 and its x and y values
are undefined.

@dest may point to the same object as @src1 or @src2.

Returns TRUE if the rectangles intersect.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dest" transfer-ownership="none">
            <doc xml:space="preserve">return location for the intersection of @src1 and @src2, or NULL.</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="src1" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="src2" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty" c:identifier="gegl_rectangle_is_empty">
        <doc xml:space="preserve">Check if a rectangle has zero area.

Returns TRUE if @rectangle height and width are both zero.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_infinite_plane"
              c:identifier="gegl_rectangle_is_infinite_plane">
        <doc xml:space="preserve">Returns TRUE if the GeglRectangle represents an infininte plane,
FALSE otherwise.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">A GeglRectangle.</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="gegl_rectangle_set">
        <doc xml:space="preserve">Sets the @x, @y, @width and @height on @rectangle.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">upper left x coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">upper left y coordinate</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve">width in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve">height in pixels.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="subtract_bounding_box"
              c:identifier="gegl_rectangle_subtract_bounding_box">
        <doc xml:space="preserve">Computes the bounding box of the area formed by subtracting @subtrahend
from @minuend, and stores the result in @destination.

@destination may point to the same object as @minuend or @subtrahend.

Returns TRUE if the result is not empty.</doc>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="destination" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="GeglRectangle*"/>
          </instance-parameter>
          <parameter name="minuend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
          <parameter name="subtrahend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglRectangle</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <function name="infinite_plane"
                c:identifier="gegl_rectangle_infinite_plane">
        <doc xml:space="preserve">Returns a GeglRectangle that represents an infininte plane.</doc>
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle"/>
        </return-value>
      </function>
    </record>
    <record name="Sampler" c:type="GeglSampler" disguised="1">
      <method name="get" c:identifier="gegl_sampler_get">
        <doc xml:space="preserve">Perform a sampling with the provided @sampler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sampler" transfer-ownership="none">
            <doc xml:space="preserve">a GeglSampler gotten from gegl_buffer_sampler_new</doc>
            <type name="Sampler" c:type="GeglSampler*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">x coordinate to sample</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">y coordinate to sample</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="scale" transfer-ownership="none">
            <doc xml:space="preserve">matrix representing extent of sampling area in source buffer.</doc>
            <type name="Matrix2" c:type="GeglMatrix2*"/>
          </parameter>
          <parameter name="output"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">memory location for output data.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="repeat_mode" transfer-ownership="none">
            <doc xml:space="preserve">how requests outside the buffer extent are handled.
Valid values: GEGL_ABYSS_NONE (abyss pixels are zeroed), GEGL_ABYSS_WHITE
(abyss pixels are white), GEGL_ABYSS_BLACK (abyss pixels are black),
GEGL_ABYSS_CLAMP (coordinates are clamped to the abyss rectangle),
GEGL_ABYSS_LOOP (buffer contents are tiled if outside of the abyss rectangle).</doc>
            <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_context_rect"
              c:identifier="gegl_sampler_get_context_rect">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The context rectangle of the given @sampler.</doc>
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sampler" transfer-ownership="none">
            <doc xml:space="preserve">a GeglSampler gotten from gegl_buffer_sampler_new</doc>
            <type name="Sampler" c:type="GeglSampler*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fun"
              c:identifier="gegl_sampler_get_fun"
              introspectable="0">
        <doc xml:space="preserve">Get the raw sampler function, the raw sampler function does not do
additional NaN / inifinity checks on passed in coordinates.</doc>
        <return-value>
          <type name="SamplerGetFun" c:type="GeglSamplerGetFun"/>
        </return-value>
        <parameters>
          <instance-parameter name="sampler" transfer-ownership="none">
            <type name="Sampler" c:type="GeglSampler*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <callback name="SamplerGetFun" c:type="GeglSamplerGetFun">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <type name="Sampler" c:type="GeglSampler*"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="scale" transfer-ownership="none">
          <type name="Matrix2" c:type="GeglMatrix2*"/>
        </parameter>
        <parameter name="output"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="repeat_mode" transfer-ownership="none">
          <type name="AbyssPolicy" c:type="GeglAbyssPolicy"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="SamplerType"
                 glib:type-name="GeglSamplerType"
                 glib:get-type="gegl_sampler_type_get_type"
                 c:type="GeglSamplerType">
      <member name="nearest"
              value="0"
              c:identifier="Nearest"
              glib:nick="nearest">
      </member>
      <member name="linear" value="1" c:identifier="Linear" glib:nick="linear">
      </member>
      <member name="cubic" value="2" c:identifier="Cubic" glib:nick="cubic">
      </member>
      <member name="nohalo" value="3" c:identifier="NoHalo" glib:nick="nohalo">
      </member>
      <member name="lohalo" value="4" c:identifier="LoHalo" glib:nick="lohalo">
      </member>
    </enumeration>
    <bitfield name="SerializeFlag" c:type="GeglSerializeFlag">
      <member name="trim_defaults"
              value="1"
              c:identifier="GEGL_SERIALIZE_TRIM_DEFAULTS">
      </member>
      <member name="version" value="2" c:identifier="GEGL_SERIALIZE_VERSION">
      </member>
      <member name="indent" value="4" c:identifier="GEGL_SERIALIZE_INDENT">
      </member>
    </bitfield>
    <enumeration name="SplitStrategy" c:type="GeglSplitStrategy">
      <member name="auto" value="0" c:identifier="GEGL_SPLIT_STRATEGY_AUTO">
      </member>
      <member name="horizontal"
              value="1"
              c:identifier="GEGL_SPLIT_STRATEGY_HORIZONTAL">
      </member>
      <member name="vertical"
              value="2"
              c:identifier="GEGL_SPLIT_STRATEGY_VERTICAL">
      </member>
    </enumeration>
    <class name="Stats"
           c:symbol-prefix="stats"
           c:type="GeglStats"
           parent="GObject.Object"
           glib:type-name="GeglStats"
           glib:get-type="gegl_stats_get_type">
      <property name="swap-busy" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="swap-file-size" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="swap-total" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-cache-hits" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-cache-misses" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-cache-total" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-cache-total-max" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="tile-cache-total-uncloned" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="zoom-total" transfer-ownership="none">
        <type name="guint64" c:type="guint64"/>
      </property>
    </class>
    <record name="Tile" c:type="GeglTile" disguised="1">
    </record>
    <class name="TileBackend"
           c:symbol-prefix="tile_backend"
           c:type="GeglTileBackend"
           parent="TileSource"
           glib:type-name="GeglTileBackend"
           glib:get-type="gegl_tile_backend_get_type"
           glib:type-struct="TileBackendClass">
      <function name="unlink_swap"
                c:identifier="gegl_tile_backend_unlink_swap">
        <doc xml:space="preserve">Delete a swap file from disk. This must be used by tile backends which may
swap to disk under certain circonstances.

For safety, this function will check that the swap file is in the swap
directory before deletion but it won't perform any other check.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">the path where the gegl tile backend has swapped.</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </function>
      <method name="get_extent" c:identifier="gegl_tile_backend_get_extent">
        <return-value transfer-ownership="full">
          <type name="Rectangle" c:type="GeglRectangle"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_flush_on_destroy"
              c:identifier="gegl_tile_backend_get_flush_on_destroy">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format"
              c:identifier="gegl_tile_backend_get_format"
              introspectable="0">
        <doc xml:space="preserve">Gets pixel format of @tile_backend</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #Babl format</doc>
          <type c:type="const Babl*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile_height"
              c:identifier="gegl_tile_backend_get_tile_height">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the height of tile from this backend</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile_size"
              c:identifier="gegl_tile_backend_get_tile_size">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the size in bytes for a tile from this backend</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_tile_width"
              c:identifier="gegl_tile_backend_get_tile_width">
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the width of tile from this backend</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_storage"
              c:identifier="gegl_tile_backend_peek_storage">
        <doc xml:space="preserve">Gets a pointer to the GeglTileStorage that uses the backend</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GeglTileStorage</doc>
          <type name="TileSource" c:type="GeglTileSource*"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_extent" c:identifier="gegl_tile_backend_set_extent">
        <doc xml:space="preserve">Specify the extent of the backend, can be used to pre-prime the
backend with the width/height information when constructing proxy
GeglBuffers to interact with other systems</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
          <parameter name="rectangle" transfer-ownership="none">
            <doc xml:space="preserve">the new extent</doc>
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flush_on_destroy"
              c:identifier="gegl_tile_backend_set_flush_on_destroy">
        <doc xml:space="preserve">Control whether cached data will be written to the backend before it
is destroyed. If false unwritten data will be discarded.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="tile_backend" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileBackend</doc>
            <type name="TileBackend" c:type="GeglTileBackend*"/>
          </instance-parameter>
          <parameter name="flush_on_destroy" transfer-ownership="none">
            <doc xml:space="preserve">true if the backend needs to be flushed</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="flush-on-destroy" writable="1" transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="format"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="px-size" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-height"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-size" transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="tile-width"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="TileSource" c:type="GeglTileSource"/>
      </field>
      <field name="priv">
        <type name="TileBackendPrivate" c:type="GeglTileBackendPrivate*"/>
      </field>
    </class>
    <record name="TileBackendClass"
            c:type="GeglTileBackendClass"
            glib:is-gtype-struct-for="TileBackend">
      <field name="parent_class">
        <type name="TileSourceClass" c:type="GeglTileSourceClass"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TileBackendPrivate"
            c:type="GeglTileBackendPrivate"
            disguised="1">
    </record>
    <callback name="TileCallback" c:type="GeglTileCallback">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="tile" transfer-ownership="none">
          <type name="Tile" c:type="GeglTile*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="TileCommand" c:type="GeglTileCommand">
      <member name="idle" value="0" c:identifier="GEGL_TILE_IDLE">
      </member>
      <member name="set" value="1" c:identifier="GEGL_TILE_SET">
      </member>
      <member name="get" value="2" c:identifier="GEGL_TILE_GET">
      </member>
      <member name="is_cached" value="3" c:identifier="GEGL_TILE_IS_CACHED">
      </member>
      <member name="exist" value="4" c:identifier="GEGL_TILE_EXIST">
      </member>
      <member name="void" value="5" c:identifier="GEGL_TILE_VOID">
      </member>
      <member name="flush" value="6" c:identifier="GEGL_TILE_FLUSH">
      </member>
      <member name="refetch" value="7" c:identifier="GEGL_TILE_REFETCH">
      </member>
      <member name="reinit" value="8" c:identifier="GEGL_TILE_REINIT">
      </member>
      <member name="last_command"
              value="9"
              c:identifier="GEGL_TILE_LAST_COMMAND">
      </member>
    </enumeration>
    <class name="TileHandler"
           c:symbol-prefix="tile_handler"
           c:type="GeglTileHandler"
           parent="TileSource"
           glib:type-name="GeglTileHandler"
           glib:get-type="gegl_tile_handler_get_type"
           glib:type-struct="TileHandlerClass">
      <method name="create_tile"
              c:identifier="gegl_tile_handler_create_tile"
              introspectable="0">
        <doc xml:space="preserve">Create a new tile associated with this tile handler.</doc>
        <return-value>
          <doc xml:space="preserve">the new tile</doc>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileHandler</doc>
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">The tile space x coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">The tile space y coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">The tile space z coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="damage_rect" c:identifier="gegl_tile_handler_damage_rect">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <type name="Rectangle" c:type="const GeglRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="dup_tile"
              c:identifier="gegl_tile_handler_dup_tile"
              introspectable="0">
        <doc xml:space="preserve">Create a duplicate of @tile, associated with this tile handler.</doc>
        <return-value>
          <doc xml:space="preserve">the new tile</doc>
          <type name="Tile" c:type="GeglTile*"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <doc xml:space="preserve">a #GeglTileHandler</doc>
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="tile" transfer-ownership="none">
            <doc xml:space="preserve">the #GeglTile to copy</doc>
            <type name="Tile" c:type="GeglTile*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve">The tile space x coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve">The tile space y coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve">The tile space z coordinate for the tile</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_source" c:identifier="gegl_tile_handler_set_source">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="handler" transfer-ownership="none">
            <type name="TileHandler" c:type="GeglTileHandler*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <type name="TileSource" c:type="GeglTileSource*"/>
          </parameter>
        </parameters>
      </method>
      <property name="source"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <type name="GObject.Object"/>
      </property>
      <field name="parent_instance">
        <type name="TileSource" c:type="GeglTileSource"/>
      </field>
      <field name="source">
        <type name="TileSource" c:type="GeglTileSource*"/>
      </field>
      <field name="priv">
        <type name="TileHandlerPrivate" c:type="GeglTileHandlerPrivate*"/>
      </field>
    </class>
    <record name="TileHandlerClass"
            c:type="GeglTileHandlerClass"
            glib:is-gtype-struct-for="TileHandler">
      <field name="parent_class">
        <type name="TileSourceClass" c:type="GeglTileSourceClass"/>
      </field>
    </record>
    <record name="TileHandlerPrivate"
            c:type="GeglTileHandlerPrivate"
            disguised="1">
    </record>
    <class name="TileSource"
           c:symbol-prefix="tile_source"
           c:type="GeglTileSource"
           parent="GObject.Object"
           glib:type-name="GeglTileSource"
           glib:get-type="gegl_tile_source_get_type"
           glib:type-struct="TileSourceClass">
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="command">
        <type name="TileSourceCommand" c:type="GeglTileSourceCommand"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="TileSourceClass"
            c:type="GeglTileSourceClass"
            glib:is-gtype-struct-for="TileSource">
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="TileSourceCommand" c:type="GeglTileSourceCommand">
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="gegl_tile_source" transfer-ownership="none">
          <type name="TileSource" c:type="GeglTileSource*"/>
        </parameter>
        <parameter name="command" transfer-ownership="none">
          <type name="TileCommand" c:type="GeglTileCommand"/>
        </parameter>
        <parameter name="x" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="y" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="z" transfer-ownership="none">
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <function name="apply_op" c:identifier="gegl_apply_op" introspectable="0">
      <doc xml:space="preserve">Apply the operation to buffer, overwritting the contents of buffer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">the #GeglBuffer to apply onto</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="apply_op_valist"
              c:identifier="gegl_apply_op_valist"
              introspectable="0">
      <doc xml:space="preserve">Apply the operation to buffer, overwritting the contents of buffer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="buffer" transfer-ownership="none">
          <doc xml:space="preserve">the #GeglBuffer to apply onto</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:space="preserve">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="buffer_iterator_empty_new"
              c:identifier="gegl_buffer_iterator_empty_new"
              moved-to="BufferIterator.empty_new"
              introspectable="0">
      <doc xml:space="preserve">Create a new buffer iterator without adding any buffers.</doc>
      <return-value>
        <doc xml:space="preserve">a new buffer iterator.</doc>
        <type name="BufferIterator" c:type="GeglBufferIterator*"/>
      </return-value>
    </function>
    <function name="calloc" c:identifier="gegl_calloc" introspectable="0">
      <doc xml:space="preserve">allocated 0'd memory.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve">size of items to allocate</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="n_memb" transfer-ownership="none">
          <doc xml:space="preserve">number of members</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="cl_disable" c:identifier="gegl_cl_disable">
      <doc xml:space="preserve">Disable OpenCL</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="cl_init" c:identifier="gegl_cl_init" throws="1">
      <doc xml:space="preserve">Initialize and enable OpenCL, calling this function again
will re-enable OpenCL if it has been disabled.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">True if OpenCL was initialized</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="cl_is_accelerated" c:identifier="gegl_cl_is_accelerated">
      <doc xml:space="preserve">Check if OpenCL is enabled.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">True if OpenCL is initialized and enabled</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="config" c:identifier="gegl_config">
      <doc xml:space="preserve">Returns a GeglConfig object with properties that can be manipulated to control
GEGLs behavior.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GeglConfig</doc>
        <type name="Config" c:type="GeglConfig*"/>
      </return-value>
    </function>
    <function name="create_chain" c:identifier="gegl_create_chain" throws="1">
      <doc xml:space="preserve">Create a node chain from an unparsed commandline string.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ops" transfer-ownership="none">
          <doc xml:space="preserve">an argv style, NULL terminated array of arguments</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="op_start" transfer-ownership="none">
          <doc xml:space="preserve">node to pass in as input of chain</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="op_end" transfer-ownership="none">
          <doc xml:space="preserve">node to get processed data</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:space="preserve">the time to use for interpolatino of keyframed values</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="rel_dim" transfer-ownership="none">
          <doc xml:space="preserve">relative dimension to scale rel suffixed values by</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="path_root" transfer-ownership="none">
          <doc xml:space="preserve">path in filesystem to use as relative root</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="create_chain_argv"
              c:identifier="gegl_create_chain_argv"
              throws="1">
      <doc xml:space="preserve">Create a node chain from argv style list of op data.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="ops" transfer-ownership="none">
          <doc xml:space="preserve">an argv style, NULL terminated array of arguments</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="op_start" transfer-ownership="none">
          <doc xml:space="preserve">node to pass in as input of chain</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="op_end" transfer-ownership="none">
          <doc xml:space="preserve">node to get processed data</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:space="preserve">the time to use for interpolatino of keyframed values</doc>
          <type name="gdouble" c:type="double"/>
        </parameter>
        <parameter name="rel_dim" transfer-ownership="none">
          <doc xml:space="preserve">relative dimension to scale rel suffixed values by</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="path_root" transfer-ownership="none">
          <doc xml:space="preserve">path in filesystem to use as relative root</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="exit" c:identifier="gegl_exit">
      <doc xml:space="preserve">Call this function when you're done using GEGL. It will clean up
caches and write/dump debug information if the correct debug flags
are set.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="filter_op"
              c:identifier="gegl_filter_op"
              introspectable="0">
      <doc xml:space="preserve">Apply the operation to source_buffer, returning the result in a new buffer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the result of the filter</doc>
        <type name="Buffer" c:type="GeglBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="filter_op_valist"
              c:identifier="gegl_filter_op_valist"
              introspectable="0">
      <doc xml:space="preserve">Apply the operation to source_buffer, returning the result in a new buffer.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the result of the filter</doc>
        <type name="Buffer" c:type="GeglBuffer*"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:space="preserve">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="format" c:identifier="gegl_format">
      <doc xml:space="preserve">Returns a value sutable to pass to the GeglBuffer constructor
or any other property that expects a Babl format.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the format pointer</doc>
        <type name="GObject.Value" c:type="GValue*"/>
      </return-value>
      <parameters>
        <parameter name="format_name" transfer-ownership="none">
          <doc xml:space="preserve">A Babl format name, e.g. "RGBA float"</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="format_get_name" c:identifier="gegl_format_get_name">
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">the format name</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve">A Babl pointer</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="free" c:identifier="gegl_free" introspectable="0">
      <doc xml:space="preserve">Frees the memory pointed to by @mem, if @mem is NULL it will warn and abort.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="mem"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">the memory to free.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_option_group"
              c:identifier="gegl_get_option_group"
              introspectable="0">
      <doc xml:space="preserve">Returns a GOptionGroup for the commandline arguments recognized
by GEGL. You should add this group to your GOptionContext
with g_option_context_add_group() if you are using
g_option_context_parse() to parse your commandline arguments.</doc>
      <return-value transfer-ownership="full">
        <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
      </return-value>
    </function>
    <function name="get_version" c:identifier="gegl_get_version">
      <doc xml:space="preserve">This function fetches the version of the GEGL library being used by
the running process.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="major"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">a pointer to a int where the major version number will be stored</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="minor"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">ditto for the minor version number</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="micro"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">ditto for the micro version number</doc>
          <type name="gint" c:type="int*"/>
        </parameter>
      </parameters>
    </function>
    <function name="graph_dump_outputs" c:identifier="gegl_graph_dump_outputs">
      <doc xml:space="preserve">Dump the bounds and format of each node in the graph to stdout.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">The final node of the graph</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
      </parameters>
    </function>
    <function name="graph_dump_request" c:identifier="gegl_graph_dump_request">
      <doc xml:space="preserve">Dump the region that will be rendered for each node to fulfill
the request.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="node" transfer-ownership="none">
          <doc xml:space="preserve">The final node of the graph</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="roi" transfer-ownership="none">
          <doc xml:space="preserve">The request rectangle</doc>
          <type name="Rectangle" c:type="const GeglRectangle*"/>
        </parameter>
      </parameters>
    </function>
    <function name="has_operation" c:identifier="gegl_has_operation">
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">A boolean telling whether the operation is present or not. This
also returns true for any compat-name registered by operations.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="operation_type" transfer-ownership="none">
          <doc xml:space="preserve">the name of the operation</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="init" c:identifier="gegl_init">
      <doc xml:space="preserve">Call this function before using any other GEGL functions. It will
initialize everything needed to operate GEGL and parses some
standard command line options.  @argc and @argv are adjusted
accordingly so your own code will never see those standard
arguments.

Note that there is an alternative way to initialize GEGL: if you
are calling g_option_context_parse() with the option group returned
by #gegl_get_option_group(), you don't have to call #gegl_init().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="argc"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">a pointer to the number of command line arguments.</doc>
          <type name="gint" c:type="gint*"/>
        </parameter>
        <parameter name="argv"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a pointer to the array of command line arguments.</doc>
          <array length="0" zero-terminated="0" c:type="gchar***">
            <type name="utf8" c:type="gchar**"/>
          </array>
        </parameter>
      </parameters>
    </function>
    <function name="is_main_thread" c:identifier="gegl_is_main_thread">
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
    </function>
    <function name="list_operations" c:identifier="gegl_list_operations">
      <return-value transfer-ownership="container">
        <doc xml:space="preserve">An
alphabetically sorted array of available operation names. This excludes any
compat-name registered by operations. The list should be freed with g_free
after use.
---
gchar **operations;
guint   n_operations;
gint i;

operations = gegl_list_operations (&amp;n_operations);
g_print ("Available operations:\n");
for (i=0; i &lt; n_operations; i++)
  {
    g_print ("\t%s\n", operations[i]);
  }
g_free (operations);</doc>
        <array length="0" zero-terminated="0" c:type="gchar**">
          <type name="utf8"/>
        </array>
      </return-value>
      <parameters>
        <parameter name="n_operations_p"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="full">
          <doc xml:space="preserve">return location for number of operations.</doc>
          <type name="guint" c:type="guint*"/>
        </parameter>
      </parameters>
    </function>
    <function name="load_module_directory"
              c:identifier="gegl_load_module_directory">
      <doc xml:space="preserve">Load all gegl modules found in the given directory.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="path" transfer-ownership="none">
          <doc xml:space="preserve">the directory to load modules from</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="lookup_new"
              c:identifier="gegl_lookup_new"
              moved-to="Lookup.new"
              introspectable="0">
      <return-value>
        <doc xml:space="preserve">a #GeglLookup</doc>
        <type name="Lookup" c:type="GeglLookup*"/>
      </return-value>
      <parameters>
        <parameter name="function" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">The function to build a lookup for</doc>
          <type name="LookupFunction" c:type="GeglLookupFunction"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A user data pointer passed to lookup calls</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="lookup_new_full"
              c:identifier="gegl_lookup_new_full"
              moved-to="Lookup.new_full"
              introspectable="0">
      <return-value>
        <doc xml:space="preserve">a #GeglLookup</doc>
        <type name="Lookup" c:type="GeglLookup*"/>
      </return-value>
      <parameters>
        <parameter name="function" transfer-ownership="none" closure="1">
          <doc xml:space="preserve">The function to build a lookup for</doc>
          <type name="LookupFunction" c:type="GeglLookupFunction"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A user data pointer passed to lookup calls</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">Lower bound of the lookup</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">Upper bound of the lookup</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
        <parameter name="precision" transfer-ownership="none">
          <doc xml:space="preserve">The precision of the lookup table</doc>
          <type name="gfloat" c:type="gfloat"/>
        </parameter>
      </parameters>
    </function>
    <function name="malloc" c:identifier="gegl_malloc" introspectable="0">
      <doc xml:space="preserve">Allocates @n_bytes of memory. If n_bytes is 0 it returns NULL.

Returns a pointer to the allocated memory.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="n_bytes" transfer-ownership="none">
          <doc xml:space="preserve">the number of bytes to allocte.</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="memset_pattern"
              c:identifier="gegl_memset_pattern"
              introspectable="0">
      <doc xml:space="preserve">Fill @dst_ptr with @count copies of the bytes in @src_ptr.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="dst_ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to copy to</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="src_ptr"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to copy from</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="pattern_size" transfer-ownership="none">
          <doc xml:space="preserve">the length of @src_ptr</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="count" transfer-ownership="none">
          <doc xml:space="preserve">number of copies</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_audio_fragment"
              c:identifier="gegl_param_spec_audio_fragment">
      <doc xml:space="preserve">Creates a new #GParamSpec instance specifying a #GeglAudioFragment property.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_color" c:identifier="gegl_param_spec_color">
      <doc xml:space="preserve">Creates a new #GParamSpec instance specifying a #GeglColor property.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_color" transfer-ownership="none">
          <doc xml:space="preserve">the default value for the property specified</doc>
          <type name="Color" c:type="GeglColor*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_color_from_string"
              c:identifier="gegl_param_spec_color_from_string">
      <doc xml:space="preserve">Creates a new #GParamSpec instance specifying a #GeglColor property.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_color_string" transfer-ownership="none">
          <doc xml:space="preserve">the default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_color_get_default"
              c:identifier="gegl_param_spec_color_get_default">
      <doc xml:space="preserve">Get the default color value of the param spec</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the default #GeglColor</doc>
        <type name="Color" c:type="GeglColor*"/>
      </return-value>
      <parameters>
        <parameter name="self" transfer-ownership="none">
          <doc xml:space="preserve">a #GeglColor #GParamSpec</doc>
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_curve" c:identifier="gegl_param_spec_curve">
      <doc xml:space="preserve">Creates a new #GParamSpec instance specifying a #GeglCurve property.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_curve" transfer-ownership="none">
          <doc xml:space="preserve">the default value for the property specified</doc>
          <type name="Curve" c:type="GeglCurve*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_double" c:identifier="gegl_param_spec_double">
      <doc xml:space="preserve">Creates a new #GeglParamSpecDouble instance.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="ui_minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value a user should be allowed to input</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="ui_maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value a user should be allowed to input</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="ui_gamma" transfer-ownership="none">
          <doc xml:space="preserve">the gamma that should be used when adjusting the value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_enum" c:identifier="gegl_param_spec_enum">
      <doc xml:space="preserve">Creates a new #GeglParamSpecEnum instance.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="enum_type" transfer-ownership="none">
          <doc xml:space="preserve">the enum type to get valid values from</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_file_path"
              c:identifier="gegl_param_spec_file_path">
      <doc xml:space="preserve">Creates a new #GeglParamSpecFilePath instance.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="no_validate" transfer-ownership="none">
          <doc xml:space="preserve">true if the string should be validated with g_utf8_validate</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="null_ok" transfer-ownership="none">
          <doc xml:space="preserve">true if the string can be NULL</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_format" c:identifier="gegl_param_spec_format">
      <doc xml:space="preserve">Creates a new #GeglParamSpecFormat instance specifying a Babl format.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_get_property_key"
              c:identifier="gegl_param_spec_get_property_key">
      <return-value transfer-ownership="none">
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="key_name" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_int" c:identifier="gegl_param_spec_int">
      <doc xml:space="preserve">Creates a new #GeglParamSpecInt instance.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="ui_minimum" transfer-ownership="none">
          <doc xml:space="preserve">minimum value a user should be allowed to input</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="ui_maximum" transfer-ownership="none">
          <doc xml:space="preserve">maximum value a user should be allowed to input</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="ui_gamma" transfer-ownership="none">
          <doc xml:space="preserve">the gamma that should be used when adjusting the value</doc>
          <type name="gdouble" c:type="gdouble"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_path" c:identifier="gegl_param_spec_path">
      <doc xml:space="preserve">Creates a new #GParamSpec instance specifying a #GeglPath property.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_path" transfer-ownership="none">
          <doc xml:space="preserve">the default value for the property specified</doc>
          <type name="Path" c:type="GeglPath*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_seed" c:identifier="gegl_param_spec_seed">
      <doc xml:space="preserve">Creates a new #GeglParamSpecSeed instance specifying an integer random seed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_set_property_key"
              c:identifier="gegl_param_spec_set_property_key">
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pspec" transfer-ownership="none">
          <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
        </parameter>
        <parameter name="key_name" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_string" c:identifier="gegl_param_spec_string">
      <doc xml:space="preserve">Creates a new #GeglParamSpecString instance.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="no_validate" transfer-ownership="none">
          <doc xml:space="preserve">true if the string should be validated with g_utf8_validate</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="null_ok" transfer-ownership="none">
          <doc xml:space="preserve">true if the string can be NULL</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="param_spec_uri" c:identifier="gegl_param_spec_uri">
      <doc xml:space="preserve">Creates a new #GeglParamSpecUri instance.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a newly created parameter specification</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">canonical name of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve">nick name for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve">description of the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="no_validate" transfer-ownership="none">
          <doc xml:space="preserve">true if the string should be validated with g_utf8_validate</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="null_ok" transfer-ownership="none">
          <doc xml:space="preserve">true if the string can be NULL</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve">default value for the property specified</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">flags for the property specified</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="rectangle_infinite_plane"
              c:identifier="gegl_rectangle_infinite_plane"
              moved-to="Rectangle.infinite_plane">
      <doc xml:space="preserve">Returns a GeglRectangle that represents an infininte plane.</doc>
      <return-value transfer-ownership="full">
        <type name="Rectangle" c:type="GeglRectangle"/>
      </return-value>
    </function>
    <function name="render_op"
              c:identifier="gegl_render_op"
              introspectable="0">
      <doc xml:space="preserve">Apply the operation to source_buffer, writing the results to target_buffer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="target_buffer" transfer-ownership="none">
          <doc xml:space="preserve">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="..." transfer-ownership="none">
          <doc xml:space="preserve">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <varargs/>
        </parameter>
      </parameters>
    </function>
    <function name="render_op_valist"
              c:identifier="gegl_render_op_valist"
              introspectable="0">
      <doc xml:space="preserve">Apply the operation to source_buffer, writing the results to target_buffer.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="source_buffer" transfer-ownership="none">
          <doc xml:space="preserve">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="target_buffer" transfer-ownership="none">
          <doc xml:space="preserve">the source #GeglBuffer for the filter</doc>
          <type name="Buffer" c:type="GeglBuffer*"/>
        </parameter>
        <parameter name="operation_name" transfer-ownership="none">
          <doc xml:space="preserve">name of the operation to apply</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="var_args" transfer-ownership="none">
          <doc xml:space="preserve">the settings for the operation. Zero or more key/value pairs,
ended terminated with NULL.</doc>
          <type name="va_list" c:type="va_list"/>
        </parameter>
      </parameters>
    </function>
    <function name="reset_stats" c:identifier="gegl_reset_stats">
      <doc xml:space="preserve">Resets the cumulative data gathered by the #GeglStats object returned
by #gegl_stats().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="serialize" c:identifier="gegl_serialize">
      <return-value transfer-ownership="full">
        <type name="utf8" c:type="gchar*"/>
      </return-value>
      <parameters>
        <parameter name="start" transfer-ownership="none">
          <doc xml:space="preserve">first node in chain to serialize</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="end" transfer-ownership="none">
          <doc xml:space="preserve">last node in chain to serialize</doc>
          <type name="Node" c:type="GeglNode*"/>
        </parameter>
        <parameter name="basepath" transfer-ownership="none">
          <doc xml:space="preserve">top-level absolute path to turn into relative root</doc>
          <type name="utf8" c:type="const char*"/>
        </parameter>
        <parameter name="serialize_flags" transfer-ownership="none">
          <doc xml:space="preserve">anded together combination of:
GEGL_SERIALIZE_TRIM_DEFAULTS, GEGL_SERIALIZE_VERSION, GEGL_SERIALIZE_INDENT.</doc>
          <type name="SerializeFlag" c:type="GeglSerializeFlag"/>
        </parameter>
      </parameters>
    </function>
    <function name="stats" c:identifier="gegl_stats">
      <doc xml:space="preserve">Returns a GeglStats object with properties that can be read to monitor
GEGL statistics.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a #GeglStats</doc>
        <type name="Stats" c:type="GeglStats*"/>
      </return-value>
    </function>
  </namespace>
</repository>
