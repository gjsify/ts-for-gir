---
description: Guidelines for GJS packages (engine-gjs, data-gjs, message-channel-gjs)
globs: examples/**/*
alwaysApply: false
---
# GJS Examples and GObject-Oriented Programming

The examples in ts-for-gir demonstrate TypeScript with GJS applications while showcasing GObject-oriented programming patterns and validating the generated type definitions.

## Purpose and Role

- Showcase practical usage of TypeScript type definitions generated by ts-for-gir
- Demonstrate GObject-oriented programming principles with TypeScript
- Serve as quality assurance tools to verify type correctness in real applications
- Act as test cases for CI to ensure generated types work as expected
- Provide reference implementations for common GObject/GJS patterns
- Demonstrate integration with various bundlers (Vite, Webpack, esbuild, etc.)
- Serve as starting points for developers' own GJS applications

## Example Structure

- Each example is a self-contained application with its own package.json
- Examples use the `@girs/*` NPM packages for type definitions
- All examples include TypeScript configuration (`tsconfig.json`)
- Examples are categorized by library (GTK 3, GTK 4, Gio, etc.)
- Most examples include a preview image showing the resulting application
- Each example demonstrates specific aspects of GJS development and type usage

## GObject-Oriented Programming Patterns

- Adopt a UI-first, declarative approach to application design
- Use GObject properties with correct parameter specs:
  ```typescript
  // Property definition with proper type specifications
  class MyWidget {
    static {
      GObject.registerClass(
        {
          Properties: {
            value: GObject.param_spec_int(
              "value", // name
              "Value", // nick
              "The value", // blurb
              0, // minimum
              100, // maximum
              0, // default
              GObject.ParamFlags.READWRITE
            ),
          },
        },
        this
      );
    }
  }
  ```
- Define signals with proper typing:
  ```typescript
  // Signal definition
  class MyWidget {
    static {
      GObject.registerClass(
        {
          Signals: {
            "load-finished": {},
            "item-activated": {
              param_types: [GObject.TYPE_STRING],
            },
          },
        },
        this
      );
    }
  }
  ```
- Separate data management from UI updates
- Design components that communicate through signals rather than callbacks
- Demonstrate property bindings to keep UI and state in sync

## Template and UI Integration

- Demonstrate Gtk.Template usage with TypeScript type safety:

  ```typescript
  export class MyWidget extends Gtk.Widget {
    static {
      GObject.registerClass(
        {
          Template: "resource:///path/to/template.ui",
          Children: ["label"],
          InternalChildren: ["internal_label"],
          Properties: {
            value: GObject.param_spec_int(
              "value",
              "Value",
              "Value",
              0,
              100,
              0,
              GObject.ParamFlags.READWRITE
            ),
          },
        },
        this
      );
    }

    // Type-checked template child reference
    private label!: Gtk.Label;

    // Type-checked internal template child reference
    private _internal_label!: Gtk.Label;

    // Connection to signal from template
    private _onButtonClicked(_button: Gtk.Button): void {
      // TypeScript knows the types of all objects
    }
  }
  ```

- Show proper typing for template children and callbacks
- Leverage UI files (.ui) with different bundling strategies
- Illustrate signal connections in templates with proper typing

## Bundler Integration

- Demonstrate different bundler configurations (Vite, Webpack, esbuild, Rollup, etc.)
- Show asset loading strategies for UI files and resources
- Highlight TypeScript configuration for each bundler
- Examples include working build scripts in package.json
- Some examples use pure TypeScript compilation without bundlers

## Testing and Quality Assurance

- All examples are built and validated during CI runs
- Many examples are executed as part of automated tests
- Examples serve as regression tests for type definition changes
- When type definition issues are found, examples are created or adapted
- Creating minimal examples is encouraged to demonstrate type issues

## Best Practices Demonstrated

- Proper use of TypeScript interfaces generated from GIR definitions
- Type-safe signal connections:
  ```typescript
  // Type-checked signal connection
  widget.connect(
    "notify::value",
    (obj: GObject.Object, pspec: GObject.ParamSpec) => {
      // TypeScript knows the types of parameters
    }
  );
  ```
- GObject inheritance with correct TypeScript typing
- JSDoc comments that complement TypeScript type information
- Error handling patterns in GJS applications
- Resource management and lifecycle handling
