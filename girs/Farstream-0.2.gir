<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <include name="Gst" version="1.0"/>
  <package name="farstream-0.2"/>
  <c:include name="fs-candidate.h"/>
  <c:include name="fs-codec.h"/>
  <c:include name="fs-conference.h"/>
  <c:include name="fs-participant.h"/>
  <c:include name="fs-session.h"/>
  <c:include name="fs-stream.h"/>
  <c:include name="fs-utils.h"/>
  <namespace name="Farstream"
             version="0.2"
             shared-library="libfarstream-0.2.so.5,libgstreamer-1.0.so.0,libgobject-2.0.so.0,libglib-2.0.so.0"
             c:identifier-prefixes="Fs"
             c:symbol-prefixes="fs">
    <constant name="CODEC_FORMAT"
              value="%d: %s %s clock:%d channels:%d params:%p"
              c:type="FS_CODEC_FORMAT">
      <doc xml:space="preserve">A format that can be used in printf like format strings to format a FsCodec</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <constant name="CODEC_ID_ANY" value="-1" c:type="FS_CODEC_ID_ANY">
      <doc xml:space="preserve">If the id of a #FsCodec is #FS_CODEC_ID_ANY, then it will be replaced
with a dynamic payload type at runtime</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="CODEC_ID_DISABLE" value="-2" c:type="FS_CODEC_ID_DISABLE">
      <doc xml:space="preserve">If the id of a #FsCodec is #FS_CODEC_ID_DISABLE, then this codec will
not be used</doc>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="Candidate"
            c:type="FsCandidate"
            glib:type-name="FsCandidate"
            glib:get-type="fs_candidate_get_type"
            c:symbol-prefix="candidate">
      <doc xml:space="preserve">Struct to hold information about ICE-19 compliant candidates</doc>
      <field name="foundation" writable="1">
        <doc xml:space="preserve">a string representing the foundation of this candidate (maximum 32 chars)</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="component_id" writable="1">
        <doc xml:space="preserve">value between 1 and 256 indicating which component this candidate represents (1 is RTP, 2 is RTCP, #FsComponentType can be used here)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="ip" writable="1">
        <doc xml:space="preserve">IP in dotted format</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="port" writable="1">
        <doc xml:space="preserve">Port to use</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="base_ip" writable="1">
        <doc xml:space="preserve">IP of base in dotted format as defined in ICE-19.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="base_port" writable="1">
        <doc xml:space="preserve">Port of base as defined in ICE-19.</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="proto" writable="1">
        <doc xml:space="preserve">#FsNetworkProtocol for ip protocol to use as candidate</doc>
        <type name="NetworkProtocol" c:type="FsNetworkProtocol"/>
      </field>
      <field name="priority" writable="1">
        <doc xml:space="preserve">Value between 0 and (2^31 - 1) representing the priority</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="type" writable="1">
        <doc xml:space="preserve">The #FsCandidateType of the candidate</doc>
        <type name="CandidateType" c:type="FsCandidateType"/>
      </field>
      <field name="username" writable="1">
        <doc xml:space="preserve">Username to use to connect to client if necessary,
           NULL otherwise</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="password" writable="1">
        <doc xml:space="preserve">Username to use to connect to client if necessary,
           NULL otherwise</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="ttl" writable="1">
        <doc xml:space="preserve">The TTL used when sending Multicast packet (0 = auto)</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="fs_candidate_new">
        <doc xml:space="preserve">Allocates a new #FsCandidate, the rest of the fields can be optionally
filled manually. See also fs_candidate_new_full()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #FsCandidate</doc>
          <type name="Candidate" c:type="FsCandidate*"/>
        </return-value>
        <parameters>
          <parameter name="foundation" transfer-ownership="none">
            <doc xml:space="preserve">The foundation of the candidate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The component this candidate is for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of candidate</doc>
            <type name="CandidateType" c:type="FsCandidateType"/>
          </parameter>
          <parameter name="proto" transfer-ownership="none">
            <doc xml:space="preserve">The protocol this component is for</doc>
            <type name="NetworkProtocol" c:type="FsNetworkProtocol"/>
          </parameter>
          <parameter name="ip"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The IP address of this component (can be NULL for local candidate to
    mean any address)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the UDP/TCP port</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full" c:identifier="fs_candidate_new_full">
        <doc xml:space="preserve">Allocates a new #FsCandidate, filling all the fields. See also
fs_candidate_new()</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocated #FsCandidate</doc>
          <type name="Candidate" c:type="FsCandidate*"/>
        </return-value>
        <parameters>
          <parameter name="foundation" transfer-ownership="none">
            <doc xml:space="preserve">The foundation of the candidate</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="component_id" transfer-ownership="none">
            <doc xml:space="preserve">The component this candidate is for</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="ip"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The IP address of this component (can be NULL for local candidate to
    mean any address)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="port" transfer-ownership="none">
            <doc xml:space="preserve">the UDP/TCP port</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="base_ip"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">IP of base in dotted format as defined in ICE-19.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="base_port" transfer-ownership="none">
            <doc xml:space="preserve">Port of base as defined in ICE-19.</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="proto" transfer-ownership="none">
            <doc xml:space="preserve">The protocol this component is for</doc>
            <type name="NetworkProtocol" c:type="FsNetworkProtocol"/>
          </parameter>
          <parameter name="priority" transfer-ownership="none">
            <doc xml:space="preserve">Value between 0 and (2^31 - 1) representing the priority</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of candidate</doc>
            <type name="CandidateType" c:type="FsCandidateType"/>
          </parameter>
          <parameter name="username"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Username to use to connect to client if necessary,
           NULL otherwise</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="password"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Username to use to connect to client if necessary,
           NULL otherwise</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="ttl" transfer-ownership="none">
            <doc xml:space="preserve">The TTL used when sending Multicast packet (0 = auto)</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy" c:identifier="fs_candidate_copy">
        <doc xml:space="preserve">Copies a #FsCandidate and its contents.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #FsCandidate</doc>
          <type name="Candidate" c:type="FsCandidate*"/>
        </return-value>
        <parameters>
          <instance-parameter name="cand" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCandidate to copy</doc>
            <type name="Candidate" c:type="const FsCandidate*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="fs_candidate_destroy"
              introspectable="0">
        <doc xml:space="preserve">Frees a #FsCandidate and all its contents</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="cand" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCandidate to delete</doc>
            <type name="Candidate" c:type="FsCandidate*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <glib:boxed glib:name="CandidateList"
                c:symbol-prefix="candidate_list"
                glib:type-name="FsCandidateList"
                glib:get-type="fs_candidate_list_get_type">
      <function name="copy" c:identifier="fs_candidate_list_copy">
        <doc xml:space="preserve">Copies a GList of #FsCandidate and its contents</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new GList of #FsCandidate</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Codec"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="candidate_list" transfer-ownership="none">
            <doc xml:space="preserve">A GList of #FsCandidate</doc>
            <type name="GLib.List" c:type="const GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="destroy"
                c:identifier="fs_candidate_list_destroy"
                introspectable="0">
        <doc xml:space="preserve">Deletes a GList of #FsCandidate and its contents</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="candidate_list" transfer-ownership="none">
            <doc xml:space="preserve">A GList of #FsCandidate</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <enumeration name="CandidateType"
                 glib:type-name="FsCandidateType"
                 glib:get-type="fs_candidate_type_get_type"
                 c:type="FsCandidateType">
      <doc xml:space="preserve">An enum for the type of candidate used/reported</doc>
      <member name="host"
              value="0"
              c:identifier="FS_CANDIDATE_TYPE_HOST"
              glib:nick="host">
        <doc xml:space="preserve">A host candidate (local)</doc>
      </member>
      <member name="srflx"
              value="1"
              c:identifier="FS_CANDIDATE_TYPE_SRFLX"
              glib:nick="srflx">
        <doc xml:space="preserve">A server reflexive candidate.</doc>
      </member>
      <member name="prflx"
              value="2"
              c:identifier="FS_CANDIDATE_TYPE_PRFLX"
              glib:nick="prflx">
        <doc xml:space="preserve">A peer reflexive candidate</doc>
      </member>
      <member name="relay"
              value="3"
              c:identifier="FS_CANDIDATE_TYPE_RELAY"
              glib:nick="relay">
        <doc xml:space="preserve">An relay candidate</doc>
      </member>
      <member name="multicast"
              value="4"
              c:identifier="FS_CANDIDATE_TYPE_MULTICAST"
              glib:nick="multicast">
        <doc xml:space="preserve">A multicast address</doc>
      </member>
    </enumeration>
    <record name="Codec"
            c:type="FsCodec"
            glib:type-name="FsCodec"
            glib:get-type="fs_codec_get_type"
            c:symbol-prefix="codec">
      <doc xml:space="preserve">This structure reprensents one codec that can be offered or received</doc>
      <field name="id" writable="1">
        <doc xml:space="preserve">numeric identifier for encoding, eg. PT for SDP</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="encoding_name" writable="1">
        <doc xml:space="preserve">the name of the codec</doc>
        <type name="utf8" c:type="char*"/>
      </field>
      <field name="media_type" writable="1">
        <doc xml:space="preserve">type of media this codec is for</doc>
        <type name="MediaType" c:type="FsMediaType"/>
      </field>
      <field name="clock_rate" writable="1">
        <doc xml:space="preserve">clock rate of this stream</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="channels" writable="1">
        <doc xml:space="preserve">Number of channels codec should decode</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="minimum_reporting_interval" writable="1">
        <doc xml:space="preserve">The minimum interval between two RTCP reports,
 If it is not specified (G_MAXUINT), it is up to the protocol to decide
(it is 5 seconds for RTP).</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="optional_params" writable="1">
        <doc xml:space="preserve">key pairs of param name to param data</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="CodecParameter"/>
        </type>
      </field>
      <field name="feedback_params" writable="1">
        <doc xml:space="preserve">key triplets of
feedbck param type, subtype and extra string that is supported for this codec</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="FeedbackParameter"/>
        </type>
      </field>
      <constructor name="new" c:identifier="fs_codec_new">
        <doc xml:space="preserve">Allocates and initializes a #FsCodec structure</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated #FsCodec</doc>
          <type name="Codec" c:type="FsCodec*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">codec identifier, if RTP this should be based on IETF RTP payload types</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="encoding_name" transfer-ownership="none">
            <doc xml:space="preserve">Name of media type this encodes</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:space="preserve">#FsMediaType for type of codec</doc>
            <type name="MediaType" c:type="FsMediaType"/>
          </parameter>
          <parameter name="clock_rate" transfer-ownership="none">
            <doc xml:space="preserve">The clock rate this codec encodes at, if applicable</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_feedback_parameter"
              c:identifier="fs_codec_add_feedback_parameter">
        <doc xml:space="preserve">This function adds an new feedback parameter to a #FsCodec</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">The #FsCodec to add the parameter to</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of the feedback parameter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="subtype" transfer-ownership="none">
            <doc xml:space="preserve">The subtype of the feedback parameter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="extra_params" transfer-ownership="none">
            <doc xml:space="preserve">The extra_params of the feeback parameter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_optional_parameter"
              c:identifier="fs_codec_add_optional_parameter">
        <doc xml:space="preserve">This function adds an new optional parameter to a #FsCodec</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">The #FsCodec to add the parameter to</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the optional parameter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve">The extra_params of the optional parameter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="are_equal" c:identifier="fs_codec_are_equal">
        <doc xml:space="preserve">Compare two codecs, it will declare two codecs to be identical even
if their optional parameters are in a different order. %NULL encoding names
are ignored.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE of the codecs are identical, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec1" transfer-ownership="none">
            <doc xml:space="preserve">First codec</doc>
            <type name="Codec" c:type="const FsCodec*"/>
          </instance-parameter>
          <parameter name="codec2" transfer-ownership="none">
            <doc xml:space="preserve">Second codec</doc>
            <type name="Codec" c:type="const FsCodec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="fs_codec_copy">
        <doc xml:space="preserve">Copies a #FsCodec structure.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a copy of the codec</doc>
          <type name="Codec" c:type="FsCodec*"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">codec to copy</doc>
            <type name="Codec" c:type="const FsCodec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="fs_codec_destroy"
              introspectable="0">
        <doc xml:space="preserve">Deletes a #FsCodec structure and all its data. Is a no-op on %NULL codec</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">#FsCodec structure to free</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_feedback_parameter"
              c:identifier="fs_codec_get_feedback_parameter">
        <doc xml:space="preserve">Finds the #FsFeedbackParameter in the #FsCodec that has the requested
subtype, type and extra_params. One of which must be non-NULL;</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the #FsFeedbackParameter from the #FsCodec or %NULL</doc>
          <type name="FeedbackParameter" c:type="FsFeedbackParameter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodec</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </instance-parameter>
          <parameter name="type"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The subtype of the parameter to search for or %NULL for
any type</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="subtype"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The subtype of the parameter to search for or %NULL
for any subtype</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="extra_params"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The extra_params of the parameter to search for
or %NULL for any extra_params</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_optional_parameter"
              c:identifier="fs_codec_get_optional_parameter">
        <doc xml:space="preserve">Finds the #FsCodecParameter in the #FsCodec that has the requested name
and, if not %NULL, the requested value</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #FsCodecParameter from the #FsCodec or %NULL</doc>
          <type name="CodecParameter" c:type="FsCodecParameter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodec</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the parameter to search for</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="value"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The value of the parameter to search for or %NULL for
any value</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_feedback_parameter"
              c:identifier="fs_codec_remove_feedback_parameter">
        <doc xml:space="preserve">Removes an optional parameter from a codec.

NULL param will do nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodec</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve">
   a pointer to the #GList element to remove that contains a
#FsFeedbackParameter</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="FeedbackParameter"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="remove_optional_parameter"
              c:identifier="fs_codec_remove_optional_parameter">
        <doc xml:space="preserve">Removes an optional parameter from a codec.

NULL param will do nothing.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodec</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </instance-parameter>
          <parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a pointer to the #FsCodecParameter to remove</doc>
            <type name="CodecParameter" c:type="FsCodecParameter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="fs_codec_to_string">
        <doc xml:space="preserve">Returns a newly-allocated string representing the codec</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly-allocated string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">A farstream codec</doc>
            <type name="Codec" c:type="const FsCodec*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <glib:boxed glib:name="CodecGList"
                c:symbol-prefix="codec_list"
                glib:type-name="FsCodecGList"
                glib:get-type="fs_codec_list_get_type">
      <function name="are_equal" c:identifier="fs_codec_list_are_equal">
        <doc xml:space="preserve">Verifies if two glist of fscodecs are identical</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if they are identical, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="list1"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GList of #FsCodec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
          <parameter name="list2"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GList of #FsCodec</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="copy" c:identifier="fs_codec_list_copy">
        <doc xml:space="preserve">Copies a list of #FsCodec structures.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The new list.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Codec"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="codec_list" transfer-ownership="none">
            <doc xml:space="preserve">
  a GList of #FsCodec to copy</doc>
            <type name="GLib.List" c:type="const GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="destroy"
                c:identifier="fs_codec_list_destroy"
                introspectable="0">
        <doc xml:space="preserve">Deletes a list of #FsCodec structures and the list itself.
Does nothing on %NULL lists.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="codec_list" transfer-ownership="none">
            <doc xml:space="preserve">a GList of #FsCodec to delete</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="from_keyfile"
                c:identifier="fs_codec_list_from_keyfile"
                throws="1">
        <doc xml:space="preserve">Reads the content of a #GKeyFile of the following format into
a #GList of #FsCodec structures.


Example:
|[
[audio/codec1]
clock-rate=8000

[audio/codec1:1]
clock-rate=16000

[audio/codec2]
one_param=QCIF
another_param=WOW

[video/codec3]
wierd_param=42
feedback:nack/pli=1
feedback:tfrc=
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">
The #GList of #FsCodec or %NULL if the keyfile was empty or an error occured.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Codec"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">Name of the #GKeyFile to read the codecs parameters from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <record name="CodecParameter"
            c:type="FsCodecParameter"
            glib:type-name="FsCodecParameter"
            glib:get-type="fs_codec_parameter_get_type"
            c:symbol-prefix="codec_parameter">
      <doc xml:space="preserve">Used to store arbitary parameters for a codec</doc>
      <field name="name" writable="1">
        <doc xml:space="preserve">paramter name.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="value" writable="1">
        <doc xml:space="preserve">parameter value.</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <method name="copy" c:identifier="fs_codec_parameter_copy">
        <doc xml:space="preserve">Makes a copy of a #FsCodecParameter</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #FsCodecParameter</doc>
          <type name="CodecParameter" c:type="FsCodecParameter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodecParameter</doc>
            <type name="CodecParameter" c:type="const FsCodecParameter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="fs_codec_parameter_free">
        <doc xml:space="preserve">Frees a #FsCodecParameter</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodecParameter to free</doc>
            <type name="CodecParameter" c:type="FsCodecParameter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="ComponentType"
                 glib:type-name="FsComponentType"
                 glib:get-type="fs_component_type_get_type"
                 c:type="FsComponentType">
      <doc xml:space="preserve">This enum contains the component IDs defined in ICE-19</doc>
      <member name="none"
              value="0"
              c:identifier="FS_COMPONENT_NONE"
              glib:nick="none">
        <doc xml:space="preserve">Use this when specifying a component is innapropriate</doc>
      </member>
      <member name="rtp"
              value="1"
              c:identifier="FS_COMPONENT_RTP"
              glib:nick="rtp">
        <doc xml:space="preserve">This component is for RTP data</doc>
      </member>
      <member name="rtcp"
              value="2"
              c:identifier="FS_COMPONENT_RTCP"
              glib:nick="rtcp">
        <doc xml:space="preserve">This component is for RTCP control</doc>
      </member>
    </enumeration>
    <class name="Conference"
           c:symbol-prefix="conference"
           c:type="FsConference"
           parent="Gst.Bin"
           abstract="1"
           glib:type-name="FsConference"
           glib:get-type="fs_conference_get_type"
           glib:type-struct="ConferenceClass">
      <doc xml:space="preserve">The #FsConference structure, all the members are private</doc>
      <implements name="Gst.ChildProxy"/>
      <virtual-method name="new_participant"
                      invoker="new_participant"
                      throws="1">
        <doc xml:space="preserve">Create a new Farstream Participant for the type of the given conference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #FsParticipant that has been created.
The #FsParticipant is owned by the user and he must unref it when he is
done with it.</doc>
          <type name="Participant" c:type="FsParticipant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conference" transfer-ownership="none">
            <doc xml:space="preserve">#FsConference interface of a #GstElement</doc>
            <type name="Conference" c:type="FsConference*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_session" invoker="new_session" throws="1">
        <doc xml:space="preserve">Create a new Farstream session for the given conference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #FsSession that has been created.
The #FsSession must be unref'd by the user when closing the session.</doc>
          <type name="Session" c:type="FsSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conference" transfer-ownership="none">
            <doc xml:space="preserve">#FsConference interface of a #GstElement</doc>
            <type name="Conference" c:type="FsConference*"/>
          </instance-parameter>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:space="preserve">#FsMediaType of the new session</doc>
            <type name="MediaType" c:type="FsMediaType"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="new_participant"
              c:identifier="fs_conference_new_participant"
              throws="1">
        <doc xml:space="preserve">Create a new Farstream Participant for the type of the given conference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #FsParticipant that has been created.
The #FsParticipant is owned by the user and he must unref it when he is
done with it.</doc>
          <type name="Participant" c:type="FsParticipant*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conference" transfer-ownership="none">
            <doc xml:space="preserve">#FsConference interface of a #GstElement</doc>
            <type name="Conference" c:type="FsConference*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_session"
              c:identifier="fs_conference_new_session"
              throws="1">
        <doc xml:space="preserve">Create a new Farstream session for the given conference.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #FsSession that has been created.
The #FsSession must be unref'd by the user when closing the session.</doc>
          <type name="Session" c:type="FsSession*"/>
        </return-value>
        <parameters>
          <instance-parameter name="conference" transfer-ownership="none">
            <doc xml:space="preserve">#FsConference interface of a #GstElement</doc>
            <type name="Conference" c:type="FsConference*"/>
          </instance-parameter>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:space="preserve">#FsMediaType of the new session</doc>
            <type name="MediaType" c:type="FsMediaType"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="Gst.Bin" c:type="GstBin"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="ConferenceClass"
            c:type="FsConferenceClass"
            glib:is-gtype-struct-for="Conference">
      <doc xml:space="preserve">#FsConferenceClass class structure.</doc>
      <field name="parent">
        <doc xml:space="preserve">parent GstBin class</doc>
        <type name="Gst.BinClass" c:type="GstBinClass"/>
      </field>
      <field name="new_session">
        <callback name="new_session" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the new #FsSession that has been created.
The #FsSession must be unref'd by the user when closing the session.</doc>
            <type name="Session" c:type="FsSession*"/>
          </return-value>
          <parameters>
            <parameter name="conference" transfer-ownership="none">
              <doc xml:space="preserve">#FsConference interface of a #GstElement</doc>
              <type name="Conference" c:type="FsConference*"/>
            </parameter>
            <parameter name="media_type" transfer-ownership="none">
              <doc xml:space="preserve">#FsMediaType of the new session</doc>
              <type name="MediaType" c:type="FsMediaType"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="new_participant">
        <callback name="new_participant" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the new #FsParticipant that has been created.
The #FsParticipant is owned by the user and he must unref it when he is
done with it.</doc>
            <type name="Participant" c:type="FsParticipant*"/>
          </return-value>
          <parameters>
            <parameter name="conference" transfer-ownership="none">
              <doc xml:space="preserve">#FsConference interface of a #GstElement</doc>
              <type name="Conference" c:type="FsConference*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <enumeration name="DTMFEvent"
                 glib:type-name="FsDTMFEvent"
                 glib:get-type="fs_dtmf_event_get_type"
                 c:type="FsDTMFEvent">
      <doc xml:space="preserve">An enum that represents the different DTMF event that can be sent to a
#FsSession. The values corresponds those those defined in RFC 4733
The rest of the possibles values are in the IANA registry at:
http://www.iana.org/assignments/audio-telephone-event-registry</doc>
      <member name="0" value="0" c:identifier="FS_DTMF_EVENT_0" glib:nick="0">
      </member>
      <member name="1" value="1" c:identifier="FS_DTMF_EVENT_1" glib:nick="1">
      </member>
      <member name="2" value="2" c:identifier="FS_DTMF_EVENT_2" glib:nick="2">
      </member>
      <member name="3" value="3" c:identifier="FS_DTMF_EVENT_3" glib:nick="3">
      </member>
      <member name="4" value="4" c:identifier="FS_DTMF_EVENT_4" glib:nick="4">
      </member>
      <member name="5" value="5" c:identifier="FS_DTMF_EVENT_5" glib:nick="5">
      </member>
      <member name="6" value="6" c:identifier="FS_DTMF_EVENT_6" glib:nick="6">
      </member>
      <member name="7" value="7" c:identifier="FS_DTMF_EVENT_7" glib:nick="7">
      </member>
      <member name="8" value="8" c:identifier="FS_DTMF_EVENT_8" glib:nick="8">
      </member>
      <member name="9" value="9" c:identifier="FS_DTMF_EVENT_9" glib:nick="9">
      </member>
      <member name="star"
              value="10"
              c:identifier="FS_DTMF_EVENT_STAR"
              glib:nick="star">
      </member>
      <member name="pound"
              value="11"
              c:identifier="FS_DTMF_EVENT_POUND"
              glib:nick="pound">
      </member>
      <member name="a" value="12" c:identifier="FS_DTMF_EVENT_A" glib:nick="a">
      </member>
      <member name="b" value="13" c:identifier="FS_DTMF_EVENT_B" glib:nick="b">
      </member>
      <member name="c" value="14" c:identifier="FS_DTMF_EVENT_C" glib:nick="c">
      </member>
      <member name="d" value="15" c:identifier="FS_DTMF_EVENT_D" glib:nick="d">
      </member>
    </enumeration>
    <enumeration name="DTMFMethod"
                 glib:type-name="FsDTMFMethod"
                 glib:get-type="fs_dtmf_method_get_type"
                 c:type="FsDTMFMethod">
      <doc xml:space="preserve">An enum that represents the different ways a DTMF event can be sent</doc>
      <member name="rtp_rfc4733"
              value="1"
              c:identifier="FS_DTMF_METHOD_RTP_RFC4733"
              glib:nick="rtp-rfc4733">
        <doc xml:space="preserve">Send as a special payload type defined by RFC 4733
(which obsoletes RFC 2833)</doc>
      </member>
      <member name="sound"
              value="2"
              c:identifier="FS_DTMF_METHOD_SOUND"
              glib:nick="sound">
        <doc xml:space="preserve">Send as tones as in-band audio sound</doc>
      </member>
    </enumeration>
    <class name="ElementAddedNotifier"
           c:symbol-prefix="element_added_notifier"
           c:type="FsElementAddedNotifier"
           parent="GObject.Object"
           glib:type-name="FsElementAddedNotifier"
           glib:get-type="fs_element_added_notifier_get_type"
           glib:type-struct="ElementAddedNotifierClass">
      <doc xml:space="preserve">All members are private</doc>
      <constructor name="new" c:identifier="fs_element_added_notifier_new">
        <doc xml:space="preserve">Creates a new #FsElementAddedNotifier object</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the newly-created #FsElementAddedNotifier</doc>
          <type name="ElementAddedNotifier" c:type="FsElementAddedNotifier*"/>
        </return-value>
      </constructor>
      <method name="add" c:identifier="fs_element_added_notifier_add">
        <doc xml:space="preserve">Add a #GstBin to on which the #FsElementAddedNotifier::element-added signal
will be called on every element and sub-element present and added in the
future.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="notifier" transfer-ownership="none">
            <doc xml:space="preserve">a #FsElementAddedNotifier</doc>
            <type name="ElementAddedNotifier"
                  c:type="FsElementAddedNotifier*"/>
          </instance-parameter>
          <parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">A #GstBin to watch to added elements</doc>
            <type name="Gst.Bin" c:type="GstBin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove" c:identifier="fs_element_added_notifier_remove">
        <doc xml:space="preserve">Stop watching the passed bin and its subbins.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the #GstBin was being watched, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="notifier" transfer-ownership="none">
            <doc xml:space="preserve">a #FsElementAddedNotifier</doc>
            <type name="ElementAddedNotifier"
                  c:type="FsElementAddedNotifier*"/>
          </instance-parameter>
          <parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">A #GstBin to stop watching</doc>
            <type name="Gst.Bin" c:type="GstBin*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_default_properties"
              c:identifier="fs_element_added_notifier_set_default_properties">
        <doc xml:space="preserve">Same as first calling fs_utils_get_default_element_properties() and using
the result with
fs_element_added_notifier_set_properties_from_keyfile() .

This is binding friendly (since GKeyFile doesn't have a boxed type).</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The id of the signal connection, this can be used to disconnect
this property setter using g_signal_handler_disconnect().</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="notifier" transfer-ownership="none">
            <doc xml:space="preserve">a #FsElementAddedNotifier</doc>
            <type name="ElementAddedNotifier"
                  c:type="FsElementAddedNotifier*"/>
          </instance-parameter>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">Element for which to set the default codec
  preferences</doc>
            <type name="Gst.Element" c:type="GstElement*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_properties_from_file"
              c:identifier="fs_element_added_notifier_set_properties_from_file"
              throws="1">
        <doc xml:space="preserve">Same as fs_element_added_notifier_set_properties_from_keyfile() but using
the name of the file to load instead of the #GKeyFile directly.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the file was successfully loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="notifier" transfer-ownership="none">
            <doc xml:space="preserve">a #FsElementAddedNotifier</doc>
            <type name="ElementAddedNotifier"
                  c:type="FsElementAddedNotifier*"/>
          </instance-parameter>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">The name of the keyfile to use</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_properties_from_keyfile"
              c:identifier="fs_element_added_notifier_set_properties_from_keyfile">
        <doc xml:space="preserve">Using a #GKeyFile where the groups are the element's type or name
and the key=value are the property and its value, this function
will set the properties on the elements added to this object after
this function has been called.  It will take ownership of the
GKeyFile structure. It will first try the group as the element type, if that
does not match, it will check its name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The id of the signal connection, this can be used to disconnect
this property setter using g_signal_handler_disconnect().</doc>
          <type name="gulong" c:type="gulong"/>
        </return-value>
        <parameters>
          <instance-parameter name="notifier" transfer-ownership="none">
            <doc xml:space="preserve">a #FsElementAddedNotifier</doc>
            <type name="ElementAddedNotifier"
                  c:type="FsElementAddedNotifier*"/>
          </instance-parameter>
          <parameter name="keyfile" transfer-ownership="full">
            <doc xml:space="preserve">a #GKeyFile</doc>
            <type name="GLib.KeyFile" c:type="GKeyFile*"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ElementAddedNotifierPrivate"
              c:type="FsElementAddedNotifierPrivate*"/>
      </field>
      <glib:signal name="element-added" when="last">
        <doc xml:space="preserve">This signal is emitted when an element is added to a #GstBin that was added
to this object or one of its sub-bins.
Be careful, there is no guarantee that this will be emitted on your
main thread, it will be emitted in the thread that added the element.
The bin may be %NULL if this is the top-level bin.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="bin" transfer-ownership="none">
            <doc xml:space="preserve">The #GstBin to which this object was added</doc>
            <type name="Gst.Bin"/>
          </parameter>
          <parameter name="element" transfer-ownership="none">
            <doc xml:space="preserve">The #GstElement that was added</doc>
            <type name="Gst.Element"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ElementAddedNotifierClass"
            c:type="FsElementAddedNotifierClass"
            glib:is-gtype-struct-for="ElementAddedNotifier">
      <doc xml:space="preserve">All members are private</doc>
      <field name="parent_class">
        <doc xml:space="preserve">the #GObjectClass parent</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="ElementAddedNotifierPrivate"
            c:type="FsElementAddedNotifierPrivate"
            disguised="1">
    </record>
    <enumeration name="Error"
                 glib:type-name="FsError"
                 glib:get-type="fs_error_get_type"
                 c:type="FsError"
                 glib:error-domain="fs-error">
      <doc xml:space="preserve">This is the enum of error numbers that will come either on the "error"
signal, from the Gst Bus or for error in the FS_ERROR domain in GErrors</doc>
      <member name="construction"
              value="1"
              c:identifier="FS_ERROR_CONSTRUCTION"
              glib:nick="construction">
        <doc xml:space="preserve">Error constructing some of the sub-elements, this
probably denotes an error in the installation of the gstreamer elements.
It is a fatal error.</doc>
      </member>
      <member name="internal"
              value="2"
              c:identifier="FS_ERROR_INTERNAL"
              glib:nick="internal">
        <doc xml:space="preserve">An internal error happened in Farstream, it may be in
an inconsistent state. The object from which this error comes should be
discarded.</doc>
      </member>
      <member name="invalid_arguments"
              value="100"
              c:identifier="FS_ERROR_INVALID_ARGUMENTS"
              glib:nick="invalid-arguments">
        <doc xml:space="preserve">Invalid arguments to the function, this
is a programming error and should not be reported to the user</doc>
      </member>
      <member name="network"
              value="101"
              c:identifier="FS_ERROR_NETWORK"
              glib:nick="network">
        <doc xml:space="preserve">A network related error, this should probably be
 reported to the user.</doc>
      </member>
      <member name="not_implemented"
              value="102"
              c:identifier="FS_ERROR_NOT_IMPLEMENTED"
              glib:nick="not-implemented">
        <doc xml:space="preserve">The optional functionality is not implemented by
this plugin.</doc>
      </member>
      <member name="negotiation_failed"
              value="103"
              c:identifier="FS_ERROR_NEGOTIATION_FAILED"
              glib:nick="negotiation-failed">
        <doc xml:space="preserve">The codec negotiation has failed, this means
that there are no common codecs between the local and remote codecs.</doc>
      </member>
      <member name="unknown_codec"
              value="104"
              c:identifier="FS_ERROR_UNKNOWN_CODEC"
              glib:nick="unknown-codec">
        <doc xml:space="preserve">Data is received on an unknown codec, this most
likely denotes an error on the remote side, the buffers will be ignored.
It can safely be ignored in most cases (but may result in a call with no
media received).</doc>
      </member>
      <member name="no_codecs"
              value="105"
              c:identifier="FS_ERROR_NO_CODECS"
              glib:nick="no-codecs">
        <doc xml:space="preserve">There are no codecs detected for that media type.</doc>
      </member>
      <member name="no_codecs_left"
              value="106"
              c:identifier="FS_ERROR_NO_CODECS_LEFT"
              glib:nick="no-codecs-left">
        <doc xml:space="preserve">All of the codecs have been disabled by the
codec preferences, one should try less strict codec preferences.</doc>
      </member>
      <member name="connection_failed"
              value="107"
              c:identifier="FS_ERROR_CONNECTION_FAILED"
              glib:nick="connection-failed">
        <doc xml:space="preserve">Could not connect to the to remote party.</doc>
      </member>
      <member name="disposed"
              value="108"
              c:identifier="FS_ERROR_DISPOSED"
              glib:nick="disposed">
        <doc xml:space="preserve">The object has been disposed.</doc>
      </member>
      <member name="already_exists"
              value="109"
              c:identifier="FS_ERROR_ALREADY_EXISTS"
              glib:nick="already-exists">
        <doc xml:space="preserve">The object already exists</doc>
      </member>
      <function name="quark" c:identifier="fs_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <record name="FeedbackParameter"
            c:type="FsFeedbackParameter"
            glib:type-name="FsFeedbackParameter"
            glib:get-type="fs_feedback_parameter_get_type"
            c:symbol-prefix="feedback_parameter">
      <doc xml:space="preserve">Use to store feedback parameters</doc>
      <field name="type" writable="1">
        <doc xml:space="preserve">the type of feedback, like "ack", "name", "ccm"</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="subtype" writable="1">
        <doc xml:space="preserve">the subtype of feedback (can be an empty string)</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="extra_params" writable="1">
        <doc xml:space="preserve">a string containing extra parameters (can be empty)</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <method name="copy" c:identifier="fs_feedback_parameter_copy">
        <doc xml:space="preserve">Makes a copy of a #FsFeedbackParameter</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated #FsFeedbackParameter</doc>
          <type name="FeedbackParameter" c:type="FsFeedbackParameter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a #FsFeedbackParameter</doc>
            <type name="FeedbackParameter"
                  c:type="const FsFeedbackParameter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="fs_feedback_parameter_free">
        <doc xml:space="preserve">Frees a #FsFeedbackParameter</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="param" transfer-ownership="none">
            <doc xml:space="preserve">a #FsFeedbackParameter to free</doc>
            <type name="FeedbackParameter" c:type="FsFeedbackParameter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="MediaType"
                 glib:type-name="FsMediaType"
                 glib:get-type="fs_media_type_get_type"
                 c:type="FsMediaType">
      <doc xml:space="preserve">Enum used to signify the media type of a codec or stream.</doc>
      <member name="audio"
              value="0"
              c:identifier="FS_MEDIA_TYPE_AUDIO"
              glib:nick="audio">
        <doc xml:space="preserve">A media type that encodes audio.</doc>
      </member>
      <member name="video"
              value="1"
              c:identifier="FS_MEDIA_TYPE_VIDEO"
              glib:nick="video">
        <doc xml:space="preserve">A media type that encodes video.</doc>
      </member>
      <member name="application"
              value="2"
              c:identifier="FS_MEDIA_TYPE_APPLICATION"
              glib:nick="application">
        <doc xml:space="preserve">A media type for application data.</doc>
      </member>
      <member name="last"
              value="2"
              c:identifier="FS_MEDIA_TYPE_LAST"
              glib:nick="last">
        <doc xml:space="preserve">Largest valid #FsMediaType</doc>
      </member>
      <function name="to_string" c:identifier="fs_media_type_to_string">
        <doc xml:space="preserve">Gives a user-printable string representing the media type</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a static string representing the media type</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:space="preserve">A media type</doc>
            <type name="MediaType" c:type="FsMediaType"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <enumeration name="NetworkProtocol"
                 glib:type-name="FsNetworkProtocol"
                 glib:get-type="fs_network_protocol_get_type"
                 c:type="FsNetworkProtocol">
      <doc xml:space="preserve">An enum for the base IP protocol</doc>
      <member name="udp"
              value="0"
              c:identifier="FS_NETWORK_PROTOCOL_UDP"
              glib:nick="udp">
        <doc xml:space="preserve">A UDP based protocol</doc>
      </member>
      <member name="tcp"
              value="1"
              c:identifier="FS_NETWORK_PROTOCOL_TCP"
              glib:nick="tcp">
        <doc xml:space="preserve">A TCP based protocol, will listen for
incoming connections</doc>
      </member>
      <member name="tcp_passive"
              value="1"
              c:identifier="FS_NETWORK_PROTOCOL_TCP_PASSIVE"
              glib:nick="tcp-passive">
        <doc xml:space="preserve">A TCP based protocol, will listen for
incoming connections</doc>
      </member>
      <member name="tcp_active"
              value="2"
              c:identifier="FS_NETWORK_PROTOCOL_TCP_ACTIVE"
              glib:nick="tcp-active">
        <doc xml:space="preserve">A TCP based protocol, will attempt to
open an outbound connection</doc>
      </member>
      <member name="tcp_so"
              value="3"
              c:identifier="FS_NETWORK_PROTOCOL_TCP_SO"
              glib:nick="tcp-so">
        <doc xml:space="preserve">A TCP based protocol, will listen for
incoming connections and attempt an outbound connection at the same time
as the peer (Simultanuous-Open)</doc>
      </member>
    </enumeration>
    <class name="Participant"
           c:symbol-prefix="participant"
           c:type="FsParticipant"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="FsParticipant"
           glib:get-type="fs_participant_get_type"
           glib:type-struct="ParticipantClass">
      <doc xml:space="preserve">All members are private (access them using the properties)</doc>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="mutex" readable="0" private="1">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ParticipantPrivate" c:type="FsParticipantPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="ParticipantClass"
            c:type="FsParticipantClass"
            glib:is-gtype-struct-for="Participant">
      <doc xml:space="preserve">The FsParticipant class has no virtual methods to implement,
but you may want to override the properties or attach more date to it</doc>
      <field name="parent_class">
        <doc xml:space="preserve">Our parent</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="ParticipantPrivate" c:type="FsParticipantPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ParticipantPrivate"
            c:type="FsParticipantPrivate"
            disguised="1">
    </record>
    <class name="Plugin"
           c:symbol-prefix="plugin"
           c:type="FsPlugin"
           parent="GObject.TypeModule"
           glib:type-name="FsPlugin"
           glib:get-type="fs_plugin_get_type"
           glib:type-struct="PluginClass">
      <doc xml:space="preserve">This structure represents a plugin, it is opaque.</doc>
      <implements name="GObject.TypePlugin"/>
      <function name="create"
                c:identifier="fs_plugin_create"
                introspectable="0">
        <doc xml:space="preserve">Loads the appropriate plugin if necessary and creates a GObject of
the requested type</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The object created (or NULL if there is an error)</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the plugin to load</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type_suffix" transfer-ownership="none">
            <doc xml:space="preserve">The type of plugin to load (normally "transmitter")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">location of a #GError, or NULL if no error occured</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the first property to be set on the
  object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">The NULL-terminated list of properties to set on the transmitter</doc>
            <varargs/>
          </parameter>
        </parameters>
      </function>
      <function name="create_valist"
                c:identifier="fs_plugin_create_valist"
                introspectable="0">
        <doc xml:space="preserve">Loads the appropriate plugin if necessary and creates a GObject of
the requested type</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The object created (or NULL if there is an error)</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the plugin to load</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="type_suffix" transfer-ownership="none">
            <doc xml:space="preserve">The type of plugin to load (normally "transmitter")</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="error" transfer-ownership="none">
            <doc xml:space="preserve">location of a #GError, or NULL if no error occured</doc>
            <type name="GLib.Error" c:type="GError**"/>
          </parameter>
          <parameter name="first_property_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the first property to be set on the
  object</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">The rest of the arguments</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </function>
      <function name="list_available" c:identifier="fs_plugin_list_available">
        <doc xml:space="preserve">Gets the list of all available plugins of a certain type</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated NULL terminated array of
strings or %NULL if no strings were found.
It should be freed with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <parameter name="type_suffix" transfer-ownership="none">
            <doc xml:space="preserve">Get list of plugins with this type suffix</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <field name="parent">
        <doc xml:space="preserve">the parent object</doc>
        <type name="GObject.TypeModule" c:type="GTypeModule"/>
      </field>
      <field name="type" readable="0" private="1">
        <type name="GType" c:type="GType"/>
      </field>
      <field name="name" readable="0" private="1">
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="PluginPrivate" c:type="FsPluginPrivate*"/>
      </field>
      <field name="unused" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PluginClass"
            c:type="FsPluginClass"
            glib:is-gtype-struct-for="Plugin">
      <field name="parent_class">
        <type name="GObject.TypeModuleClass" c:type="GTypeModuleClass"/>
      </field>
      <field name="unused" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="PluginPrivate" c:type="FsPluginPrivate" disguised="1">
    </record>
    <constant name="RTP_HEADER_EXTENSION_FORMAT"
              value="%d: (%s) %s"
              c:type="FS_RTP_HEADER_EXTENSION_FORMAT">
      <doc xml:space="preserve">A format that can be used in printf like format strings to format a
FsRtpHeaderExtension</doc>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <record name="RtpHeaderExtension"
            c:type="FsRtpHeaderExtension"
            glib:type-name="FsRtpHeaderExtension"
            glib:get-type="fs_rtp_header_extension_get_type"
            c:symbol-prefix="rtp_header_extension">
      <doc xml:space="preserve">Defines a RTP header extension with its negotiated identifier, direction
and URI. They should only be created with fs_rtp_header_extension_new().</doc>
      <field name="id" writable="1">
        <doc xml:space="preserve">The identifier of the RTP header extension</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="direction" writable="1">
        <doc xml:space="preserve">the direction in which this extension can be used</doc>
        <type name="StreamDirection" c:type="FsStreamDirection"/>
      </field>
      <field name="uri" writable="1">
        <doc xml:space="preserve">The URI that defines this extension</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <constructor name="new" c:identifier="fs_rtp_header_extension_new">
        <doc xml:space="preserve">Creates a new #FsRtpHeaderExtension</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #FsRtpHeaderExtension</doc>
          <type name="RtpHeaderExtension" c:type="FsRtpHeaderExtension*"/>
        </return-value>
        <parameters>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The identifier of the RTP header extension</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">the direction in which this extension can be used</doc>
            <type name="StreamDirection" c:type="FsStreamDirection"/>
          </parameter>
          <parameter name="uri" transfer-ownership="none">
            <doc xml:space="preserve">The URI that defines this extension</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="are_equal"
              c:identifier="fs_rtp_header_extension_are_equal">
        <doc xml:space="preserve">Compares two #FsRtpHeaderExtension structures</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if they are identical, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension1" transfer-ownership="none">
            <doc xml:space="preserve">The first #FsRtpHeaderExtension</doc>
            <type name="RtpHeaderExtension" c:type="FsRtpHeaderExtension*"/>
          </instance-parameter>
          <parameter name="extension2" transfer-ownership="none">
            <doc xml:space="preserve">The second #FsRtpHeaderExtension</doc>
            <type name="RtpHeaderExtension" c:type="FsRtpHeaderExtension*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="fs_rtp_header_extension_copy"
              introspectable="0">
        <doc xml:space="preserve">Copies a #FsRtpHeaderExtension</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #FsRtpHeaderExtension</doc>
          <type name="RtpHeaderExtension" c:type="FsRtpHeaderExtension*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">The RTP header extension definition to copy</doc>
            <type name="RtpHeaderExtension" c:type="FsRtpHeaderExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="destroy"
              c:identifier="fs_rtp_header_extension_destroy"
              introspectable="0">
        <doc xml:space="preserve">Frees the passed #FsRtpHeaderExtension</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="extension" transfer-ownership="none">
            <doc xml:space="preserve">A RTP header extension to free</doc>
            <type name="RtpHeaderExtension" c:type="FsRtpHeaderExtension*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <glib:boxed glib:name="RtpHeaderExtensionGList"
                c:symbol-prefix="rtp_header_extension_list"
                glib:type-name="FsRtpHeaderExtensionGList"
                glib:get-type="fs_rtp_header_extension_list_get_type">
      <function name="copy" c:identifier="fs_rtp_header_extension_list_copy">
        <doc xml:space="preserve">Does a deep copy of a #GList of #FsRtpHeaderExtension</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new
#GList of #FsRtpHeaderExtension</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="RtpHeaderExtension"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="extensions" transfer-ownership="none">
            <doc xml:space="preserve">
  a #GList of #FsRtpHeaderExtension</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="RtpHeaderExtension"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="destroy"
                c:identifier="fs_rtp_header_extension_list_destroy"
                introspectable="0">
        <doc xml:space="preserve">Frees the passed #GList of #FsRtpHeaderExtension</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="extensions" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #FsRtpHeaderExtension</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="gpointer" c:type="gpointer"/>
            </type>
          </parameter>
        </parameters>
      </function>
      <function name="from_keyfile"
                c:identifier="fs_rtp_header_extension_list_from_keyfile"
                throws="1">
        <doc xml:space="preserve">Reads the content of a #GKeyFile of the following format into a
#GList of #FsRtpHeaderExtension structures.

The groups have a format "rtp-hdrext:audio:XXX" or
"rtp-hdrext:video:XXX" where XXX is a unique string (per media type).

The valid keys are:
&lt;itemizedlist&gt;
 &lt;listitem&gt;id: a int between in the 1-255 and 4096-4351 ranges&lt;/listitem&gt;
 &lt;listitem&gt;uri: a URI describing the RTP Header Extension&lt;/listitem&gt;
 &lt;listitem&gt;direction (optional): To only send or receive a RTP Header
     Extension, possible values are "send", "receive", "none" or "both".
     Defaults to "both"&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Example:
|[
[rtp-hdrext:audio:a]
id=1
uri=urn:ietf:params:rtp-hdrext:toffset

[rtp-hdrext:audio:abc]
id=3
uri=urn:ietf:params:rtp-hdrext:ntp-64
direction=receive
]|</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a
#GList of #FsRtpHeaderExtension that must be freed with
fs_rtp_header_extension_list_destroy()</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="RtpHeaderExtension"/>
          </type>
        </return-value>
        <parameters>
          <parameter name="filename" transfer-ownership="none">
            <doc xml:space="preserve">Name of the #GKeyFile to read the RTP Header Extensions from</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="media_type" transfer-ownership="none">
            <doc xml:space="preserve">The media type for which to get header extensions</doc>
            <type name="MediaType" c:type="FsMediaType"/>
          </parameter>
        </parameters>
      </function>
    </glib:boxed>
    <class name="Session"
           c:symbol-prefix="session"
           c:type="FsSession"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="FsSession"
           glib:get-type="fs_session_get_type"
           glib:type-struct="SessionClass">
      <doc xml:space="preserve">All members are private, access them using methods and properties</doc>
      <virtual-method name="codecs_need_resend" invoker="codecs_need_resend">
        <doc xml:space="preserve">Some codec updates need to be reliably transmitted to the other side
because they contain important parameters required to decode the media.
Other codec updates, caused by user action, don't.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GList of
 #FsCodec that need to be resent or %NULL if there are none. This
 list must be freed with fs_codec_list_destroy().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Codec"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="old_codecs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
 Codecs previously retrieved from the #FsSession:codecs property</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
          <parameter name="new_codecs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  Codecs recently retrieved from the #FsSession:codecs property</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_stream_transmitter_type"
                      invoker="get_stream_transmitter_type">
        <doc xml:space="preserve">Returns the GType of the stream transmitter, bindings can use it
to validate/convert the parameters passed to fs_session_new_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GType of the stream transmitter</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">The name of the transmitter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="list_transmitters" invoker="list_transmitters">
        <doc xml:space="preserve">Get the list of all available transmitters for this session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocagted %NULL terminated array of
named of transmitters or %NULL if no transmitter is needed for this type of
session. It should be freed with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_stream" invoker="new_stream" throws="1">
        <doc xml:space="preserve">This function creates a stream for the given participant into the active session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #FsStream that has been created.
User must unref the #FsStream when the stream is ended. If an error occured,
returns NULL.</doc>
          <type name="Stream" c:type="FsStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="participant" transfer-ownership="none">
            <doc xml:space="preserve">#FsParticipant of a participant for the new stream</doc>
            <type name="Participant" c:type="FsParticipant*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">#FsStreamDirection describing the direction of the new stream that will
be created for this participant</doc>
            <type name="StreamDirection" c:type="FsStreamDirection"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_allowed_caps"
                      invoker="set_allowed_caps"
                      throws="1">
        <doc xml:space="preserve">Sets the allowed caps for the sink and source pads for this #FsSession.
Only codecs that can take the input specified by the @sink_caps and
can produce output as specified by the @src_caps will be produced
in the #FsSession:codecs property and so only those will be negotiated.

If %NULL is passed to either @src_caps or @sink_caps, it is not changed.

The default is "video/x-raw" for a video stream, "audio/x-raw" for an audio
stream and "ANY" for an application stream.

The values can be retrived using the #FsSession:allowed-src-caps and
#FsSession:allowed-sink-caps properties.</doc>
        <doc-version xml:space="preserve">UNRELEASED</doc-version>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the new filter caps were acceptable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="sink_caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Caps for the sink pad or %NULL</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="src_caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Caps for the src pad or %NULL</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_codec_preferences"
                      invoker="set_codec_preferences"
                      throws="1">
        <doc xml:space="preserve">Set the list of desired codec preferences. The user may
change this value during an ongoing session. Note that doing this can cause
the codecs to change. Therefore this requires the user to fetch
the new codecs and renegotiate them with the peers. It is a #GList
of #FsCodec. The changes are immediately effective.
The function does not take ownership of the list.

The payload type may be a valid dynamic PT (96-127), %FS_CODEC_ID_DISABLE
or %FS_CODEC_ID_ANY. If the encoding name is "reserve-pt", then the
payload type of the codec will be "reserved" and not be used by any
dynamically assigned payload type.

If the list of specifications would invalidate all codecs, an error will
be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="codec_preferences"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GList of #FsCodec with the
  desired configuration</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_encryption_parameters"
                      invoker="set_encryption_parameters"
                      throws="1">
        <doc xml:space="preserve">Sets encryption parameters. The exact parameters depend on the type of
plugin being used.</doc>
        <doc-version xml:space="preserve">UNRELEASED</doc-version>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the encryption parameters could be set, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstStructure containing the
  encryption  parameters or %NULL to disable encryption</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_send_codec"
                      invoker="set_send_codec"
                      throws="1">
        <doc xml:space="preserve">This function will set the currently being sent codec for all streams in this
session. The given #FsCodec must be taken directly from the #codecs
property of the session. If the given codec is not in the codecs
list, @error will be set and %FALSE will be returned. The @send_codec will be
copied so it must be free'd using fs_codec_destroy() when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the send codec couldn't be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="send_codec" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodec representing the codec to send</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start_telephony_event"
                      invoker="start_telephony_event">
        <doc xml:space="preserve">This function will start sending a telephony event (such as a DTMF
tone) on the #FsSession. You have to call the function
fs_session_stop_telephony_event() to stop it.

If this function returns %TRUE, a "farstream-telephony-event-started" will
always be emitted when the event is actually played out.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if sucessful, it can return %FALSE if the #FsStream
does not support this telephony event.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">A #FsStreamDTMFEvent or another number defined at
http://www.iana.org/assignments/audio-telephone-event-registry</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">The volume in dBm0 without the negative sign. Should be between
0 and 36. Higher values mean lower volume</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop_telephony_event"
                      invoker="stop_telephony_event">
        <doc xml:space="preserve">This function will stop sending a telephony event started by
fs_session_start_telephony_event(). If the event was being sent
for less than 50ms, it will be sent for 50ms minimum. If the
duration was a positive and the event is not over, it will cut it
short.

If this function returns %TRUE, a "farstream-telephony-event-stopped" will
always be emitted when the event is actually stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if sucessful, it can return %FALSE if the #FsSession
does not support telephony events or if no telephony event is being sent</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">an #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="codecs_need_resend"
              c:identifier="fs_session_codecs_need_resend">
        <doc xml:space="preserve">Some codec updates need to be reliably transmitted to the other side
because they contain important parameters required to decode the media.
Other codec updates, caused by user action, don't.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A new #GList of
 #FsCodec that need to be resent or %NULL if there are none. This
 list must be freed with fs_codec_list_destroy().</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Codec"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="old_codecs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
 Codecs previously retrieved from the #FsSession:codecs property</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
          <parameter name="new_codecs"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  Codecs recently retrieved from the #FsSession:codecs property</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="fs_session_destroy">
        <doc xml:space="preserve">This will cause the session to remove all links to other objects and to
remove itself from the #FsConference, it will also destroy all #FsStream
inside this #FsSession Once a #FsSession has been destroyed, it
can not be used anymore.

It is strongly recommended to call this function from the main thread because
releasing the application's reference to a session.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="emit_error" c:identifier="fs_session_emit_error">
        <doc xml:space="preserve">This function emit the "error" signal on a #FsSession, it should only be
called by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">#FsSession on which to emit the error signal</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="error_no" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error of type #FsError</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_stream_transmitter_type"
              c:identifier="fs_session_get_stream_transmitter_type">
        <doc xml:space="preserve">Returns the GType of the stream transmitter, bindings can use it
to validate/convert the parameters passed to fs_session_new_stream().</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The #GType of the stream transmitter</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">The name of the transmitter</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="list_transmitters"
              c:identifier="fs_session_list_transmitters">
        <doc xml:space="preserve">Get the list of all available transmitters for this session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-allocagted %NULL terminated array of
named of transmitters or %NULL if no transmitter is needed for this type of
session. It should be freed with g_strfreev().</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">A #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_stream"
              c:identifier="fs_session_new_stream"
              throws="1">
        <doc xml:space="preserve">This function creates a stream for the given participant into the active session.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the new #FsStream that has been created.
User must unref the #FsStream when the stream is ended. If an error occured,
returns NULL.</doc>
          <type name="Stream" c:type="FsStream*"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="participant" transfer-ownership="none">
            <doc xml:space="preserve">#FsParticipant of a participant for the new stream</doc>
            <type name="Participant" c:type="FsParticipant*"/>
          </parameter>
          <parameter name="direction" transfer-ownership="none">
            <doc xml:space="preserve">#FsStreamDirection describing the direction of the new stream that will
be created for this participant</doc>
            <type name="StreamDirection" c:type="FsStreamDirection"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_codecs_changed"
              c:identifier="fs_session_parse_codecs_changed">
        <doc xml:space="preserve">Parses a "farstream-codecs-changed" message and checks if it matches
the @session parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the session and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession to match against the message</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_send_codec_changed"
              c:identifier="fs_session_parse_send_codec_changed">
        <doc xml:space="preserve">Parses a "farstream-send-codec-changed" message and checks if it matches
the @session parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the session and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession to match against the message</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="codec"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">Returns the #FsCodec in the message if not
  %NULL.</doc>
            <type name="Codec" c:type="FsCodec**"/>
          </parameter>
          <parameter name="secondary_codecs"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">
 Returns a #GList of #FsCodec of the message if not %NULL</doc>
            <type name="GLib.List" c:type="GList**">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="parse_telephony_event_started"
              c:identifier="fs_session_parse_telephony_event_started">
        <doc xml:space="preserve">Parses a "farstream-telephony-event-started" message and checks if it matches
the @session parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the session and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession to match against the message</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="method"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Returns the #FsDTMFMethod in the message if not %NULL.</doc>
            <type name="DTMFMethod" c:type="FsDTMFMethod*"/>
          </parameter>
          <parameter name="event"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Returns the #FsDTMFEvent in the message if not %NULL.</doc>
            <type name="DTMFEvent" c:type="FsDTMFEvent*"/>
          </parameter>
          <parameter name="volume"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Returns the volume in the message if not %NULL.</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_telephony_event_stopped"
              c:identifier="fs_session_parse_telephony_event_stopped">
        <doc xml:space="preserve">Parses a "farstream-telephony-event-stopped" message and checks if it matches
the @session parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the session and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession to match against the message</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="method"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Returns the #FsDTMFMethod in the message if not %NULL.</doc>
            <type name="DTMFMethod" c:type="FsDTMFMethod*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_allowed_caps"
              c:identifier="fs_session_set_allowed_caps"
              throws="1">
        <doc xml:space="preserve">Sets the allowed caps for the sink and source pads for this #FsSession.
Only codecs that can take the input specified by the @sink_caps and
can produce output as specified by the @src_caps will be produced
in the #FsSession:codecs property and so only those will be negotiated.

If %NULL is passed to either @src_caps or @sink_caps, it is not changed.

The default is "video/x-raw" for a video stream, "audio/x-raw" for an audio
stream and "ANY" for an application stream.

The values can be retrived using the #FsSession:allowed-src-caps and
#FsSession:allowed-sink-caps properties.</doc>
        <doc-version xml:space="preserve">UNRELEASED</doc-version>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the new filter caps were acceptable.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="sink_caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Caps for the sink pad or %NULL</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="src_caps"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Caps for the src pad or %NULL</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_codec_preferences"
              c:identifier="fs_session_set_codec_preferences"
              throws="1">
        <doc xml:space="preserve">Set the list of desired codec preferences. The user may
change this value during an ongoing session. Note that doing this can cause
the codecs to change. Therefore this requires the user to fetch
the new codecs and renegotiate them with the peers. It is a #GList
of #FsCodec. The changes are immediately effective.
The function does not take ownership of the list.

The payload type may be a valid dynamic PT (96-127), %FS_CODEC_ID_DISABLE
or %FS_CODEC_ID_ANY. If the encoding name is "reserve-pt", then the
payload type of the codec will be "reserved" and not be used by any
dynamically assigned payload type.

If the list of specifications would invalidate all codecs, an error will
be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="codec_preferences"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GList of #FsCodec with the
  desired configuration</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_encryption_parameters"
              c:identifier="fs_session_set_encryption_parameters"
              throws="1">
        <doc xml:space="preserve">Sets encryption parameters. The exact parameters depend on the type of
plugin being used.</doc>
        <doc-version xml:space="preserve">UNRELEASED</doc-version>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the encryption parameters could be set, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">a #GstStructure containing the
  encryption  parameters or %NULL to disable encryption</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_send_codec"
              c:identifier="fs_session_set_send_codec"
              throws="1">
        <doc xml:space="preserve">This function will set the currently being sent codec for all streams in this
session. The given #FsCodec must be taken directly from the #codecs
property of the session. If the given codec is not in the codecs
list, @error will be set and %FALSE will be returned. The @send_codec will be
copied so it must be free'd using fs_codec_destroy() when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the send codec couldn't be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="send_codec" transfer-ownership="none">
            <doc xml:space="preserve">a #FsCodec representing the codec to send</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_telephony_event"
              c:identifier="fs_session_start_telephony_event">
        <doc xml:space="preserve">This function will start sending a telephony event (such as a DTMF
tone) on the #FsSession. You have to call the function
fs_session_stop_telephony_event() to stop it.

If this function returns %TRUE, a "farstream-telephony-event-started" will
always be emitted when the event is actually played out.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if sucessful, it can return %FALSE if the #FsStream
does not support this telephony event.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">a #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve">A #FsStreamDTMFEvent or another number defined at
http://www.iana.org/assignments/audio-telephone-event-registry</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="volume" transfer-ownership="none">
            <doc xml:space="preserve">The volume in dBm0 without the negative sign. Should be between
0 and 36. Higher values mean lower volume</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="stop_telephony_event"
              c:identifier="fs_session_stop_telephony_event">
        <doc xml:space="preserve">This function will stop sending a telephony event started by
fs_session_start_telephony_event(). If the event was being sent
for less than 50ms, it will be sent for 50ms minimum. If the
duration was a positive and the event is not over, it will cut it
short.

If this function returns %TRUE, a "farstream-telephony-event-stopped" will
always be emitted when the event is actually stopped.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if sucessful, it can return %FALSE if the #FsSession
does not support telephony events or if no telephony event is being sent</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="session" transfer-ownership="none">
            <doc xml:space="preserve">an #FsSession</doc>
            <type name="Session" c:type="FsSession*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="allowed-sink-caps" transfer-ownership="none">
        <doc xml:space="preserve">These are the #GstCaps that can be fed into the session,
they are used to filter the codecs to only those that can
accepted those caps as input.</doc>
        <type name="Gst.Caps"/>
      </property>
      <property name="allowed-src-caps" transfer-ownership="none">
        <doc xml:space="preserve">These are the #GstCaps that the session can produce,
they are used to filter the codecs to only those that can
accepted those caps as output.</doc>
        <type name="Gst.Caps"/>
      </property>
      <property name="codec-preferences" transfer-ownership="full">
        <doc xml:space="preserve">This is the current preferences list for the local codecs. It is
set by the user to specify the codec options and priorities. The user may
change its value with fs_session_set_codec_preferences() at any time
during a session. It is a #GList of #FsCodec.
The user must free this codec list using fs_codec_list_destroy() when done.

The payload type may be a valid dynamic PT (96-127), %FS_CODEC_ID_DISABLE
or %FS_CODEC_ID_ANY. If the encoding name is "reserve-pt", then the
payload type of the codec will be "reserved" and not be used by any
dynamically assigned payload type.</doc>
        <type name="GLib.List">
          <type name="Codec"/>
        </type>
      </property>
      <property name="codecs" transfer-ownership="full">
        <doc xml:space="preserve">This is the list of codecs used for this session. It will include the
codecs and payload type used to receive media on this session. It will
also include any configuration parameter that must be transmitted reliably
for the other end to decode the content.

It may change when the codec preferences are set, when codecs are set
on a #FsStream in this session, when a #FsStream is destroyed or
asynchronously when new config data is discovered.

If any configuration parameter needs to be discovered, this property
will be %NULL until they have been discovered. One can always get
the codecs from #FsSession:codecs-without-config.
The "farstream-codecs-changed" message will be emitted whenever the value
of this property changes.

It is a #GList of #FsCodec. User must free this codec list using
fs_codec_list_destroy() when done.</doc>
        <type name="GLib.List">
          <type name="Codec"/>
        </type>
      </property>
      <property name="codecs-without-config" transfer-ownership="full">
        <doc xml:space="preserve">This is the same list of codecs as #FsSession:codecs without
the configuration information that describes the data sent. It is suitable
for configurations where a list of codecs is shared by many senders.
If one is using codecs such as Theora, Vorbis or H.264 that require
such information to be transmitted, the configuration data should be
included in the stream and retransmitted regularly.

It may change when the codec preferences are set, when codecs are set
on a #FsStream in this session, when a #FsStream is destroyed or
asynchronously when new config data is discovered.

The "farstream-codecs-changed" message will be emitted whenever the value
of this property changes.

It is a #GList of #FsCodec. User must free this codec list using
fs_codec_list_destroy() when done.</doc>
        <type name="GLib.List">
          <type name="Codec"/>
        </type>
      </property>
      <property name="conference"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #FsConference parent of this session. This property is a
construct param and is read-only.</doc>
        <type name="Conference"/>
      </property>
      <property name="current-send-codec" transfer-ownership="none">
        <doc xml:space="preserve">Indicates the currently active send codec. A user can change the active
send codec by calling fs_session_set_send_codec(). The send codec could
also be automatically changed by Farstream. This property is an
#FsCodec. User must free the codec using fs_codec_destroy() when done.
The "farstream-send-codec-changed" message is emitted on the bus when
the value of this property changes.</doc>
        <type name="Codec"/>
      </property>
      <property name="encryption-parameters" transfer-ownership="none">
        <doc xml:space="preserve">Retrieves previously set encryption parameters</doc>
        <type name="Gst.Structure"/>
      </property>
      <property name="id"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The ID of the session, the first number of the pads linked to this session
will be this id</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="media-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The media-type of the session. This is either Audio, Video or both.
This is a constructor parameter that cannot be changed.</doc>
        <type name="MediaType"/>
      </property>
      <property name="sink-pad" transfer-ownership="none">
        <doc xml:space="preserve">The Gstreamer sink pad that must be used to send media data on this
session. User must unref this GstPad when done with it.</doc>
        <type name="Gst.Pad"/>
      </property>
      <property name="tos" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Sets the IP ToS field (and if possible the IPv6 TCLASS field</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="SessionPrivate" c:type="FsSessionPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted in any error condition, it can be emitted on any
thread. Applications should listen to the GstBus for errors.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <doc xml:space="preserve">The #Gobject that emitted the signal</doc>
            <type name="GObject.Object"/>
          </parameter>
          <parameter name="error_no" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error</doc>
            <type name="Error"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="SessionClass"
            c:type="FsSessionClass"
            glib:is-gtype-struct-for="Session">
      <doc xml:space="preserve">You must override at least new_stream in a subclass.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">Our parent</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="new_stream">
        <callback name="new_stream" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">the new #FsStream that has been created.
User must unref the #FsStream when the stream is ended. If an error occured,
returns NULL.</doc>
            <type name="Stream" c:type="FsStream*"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="participant" transfer-ownership="none">
              <doc xml:space="preserve">#FsParticipant of a participant for the new stream</doc>
              <type name="Participant" c:type="FsParticipant*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <doc xml:space="preserve">#FsStreamDirection describing the direction of the new stream that will
be created for this participant</doc>
              <type name="StreamDirection" c:type="FsStreamDirection"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start_telephony_event">
        <callback name="start_telephony_event">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if sucessful, it can return %FALSE if the #FsStream
does not support this telephony event.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <doc xml:space="preserve">A #FsStreamDTMFEvent or another number defined at
http://www.iana.org/assignments/audio-telephone-event-registry</doc>
              <type name="guint8" c:type="guint8"/>
            </parameter>
            <parameter name="volume" transfer-ownership="none">
              <doc xml:space="preserve">The volume in dBm0 without the negative sign. Should be between
0 and 36. Higher values mean lower volume</doc>
              <type name="guint8" c:type="guint8"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop_telephony_event">
        <callback name="stop_telephony_event">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if sucessful, it can return %FALSE if the #FsSession
does not support telephony events or if no telephony event is being sent</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">an #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_send_codec">
        <callback name="set_send_codec" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%FALSE if the send codec couldn't be set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="send_codec" transfer-ownership="none">
              <doc xml:space="preserve">a #FsCodec representing the codec to send</doc>
              <type name="Codec" c:type="FsCodec*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_codec_preferences">
        <callback name="set_codec_preferences" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE on success, %FALSE on error.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="codec_preferences"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GList of #FsCodec with the
  desired configuration</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Codec"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="list_transmitters">
        <callback name="list_transmitters">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a newly-allocagted %NULL terminated array of
named of transmitters or %NULL if no transmitter is needed for this type of
session. It should be freed with g_strfreev().</doc>
            <array c:type="gchar**">
              <type name="utf8"/>
            </array>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">A #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_stream_transmitter_type">
        <callback name="get_stream_transmitter_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">The #GType of the stream transmitter</doc>
            <type name="GType" c:type="GType"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">A #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="transmitter" transfer-ownership="none">
              <doc xml:space="preserve">The name of the transmitter</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="codecs_need_resend">
        <callback name="codecs_need_resend">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">A new #GList of
 #FsCodec that need to be resent or %NULL if there are none. This
 list must be freed with fs_codec_list_destroy().</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="old_codecs"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">
 Codecs previously retrieved from the #FsSession:codecs property</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Codec"/>
              </type>
            </parameter>
            <parameter name="new_codecs"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">
  Codecs recently retrieved from the #FsSession:codecs property</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Codec"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_allowed_caps">
        <callback name="set_allowed_caps" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the new filter caps were acceptable.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="sink_caps"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">Caps for the sink pad or %NULL</doc>
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="src_caps"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">Caps for the src pad or %NULL</doc>
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_encryption_parameters">
        <callback name="set_encryption_parameters" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the encryption parameters could be set, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="session" transfer-ownership="none">
              <doc xml:space="preserve">a #FsSession</doc>
              <type name="Session" c:type="FsSession*"/>
            </parameter>
            <parameter name="parameters"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">a #GstStructure containing the
  encryption  parameters or %NULL to disable encryption</doc>
              <type name="Gst.Structure" c:type="GstStructure*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="6">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="SessionPrivate" c:type="FsSessionPrivate" disguised="1">
    </record>
    <class name="Stream"
           c:symbol-prefix="stream"
           c:type="FsStream"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="FsStream"
           glib:get-type="fs_stream_get_type"
           glib:type-struct="StreamClass">
      <doc xml:space="preserve">All members are private, access them using methods and properties</doc>
      <virtual-method name="add_id" invoker="add_id">
        <doc xml:space="preserve">This function is used to add data identifiers that allow the
plugin to recognize packets that are meant for id. For example, in RTP,
one would set the SSRCs that are expected.

Depending on the protocol, one may be able to add more than one ID
to a stream (in RTP you can have multiple SSRCs in a stream).
If a protocol supports only one id, adding a new one will overwrite it.
If an ID was already set on a stream, adding it to another stream will
override the previdous decision.

For most protocols, calling this function is optional as the incoming data
can be matched with a stream by its source IP address. This is mostly useful
if one is using multicast or is behind a muxer server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The id to add to the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="add_remote_candidates"
                      invoker="add_remote_candidates"
                      throws="1">
        <doc xml:space="preserve">This function adds remote candidates. Any new candidates are
added to the list. The candidates will be used to establish a connection
with the peer. A copy will be made so the user must free the
passed candidate using fs_candidate_destroy() when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the candidate was valid, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">an #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="candidates" transfer-ownership="none">
            <doc xml:space="preserve">an #GList of #FsCandidate
 representing the remote candidates</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="force_remote_candidates"
                      invoker="force_remote_candidates"
                      throws="1">
        <doc xml:space="preserve">This function forces data to be sent immediately to the selected remote
candidate, by-passing any connectivity checks. There should be at most
one candidate per component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the candidates could be forced, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="remote_candidates" transfer-ownership="none">
            <doc xml:space="preserve">
  a #GList of #FsCandidate to force</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_decryption_parameters"
                      invoker="set_decryption_parameters"
                      throws="1">
        <doc xml:space="preserve">Sets decryption parameters. The exact parameters depend on the type of
plugin being used.</doc>
        <doc-version xml:space="preserve">UNRELEASED</doc-version>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the decryption parameters could be set, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">a #GstStructure containing the decryption
 parameters</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_remote_codecs"
                      invoker="set_remote_codecs"
                      throws="1">
        <doc xml:space="preserve">This function will set the list of remote codecs for this stream. If
the given remote codecs couldn't be negotiated with the list of local
codecs or already negotiated codecs for the corresponding #FsSession, @error
will be set and %FALSE will be returned. The @remote_codecs list will be
copied so it must be free'd using fs_codec_list_destroy() when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the remote codecs couldn't be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="remote_codecs" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #FsCodec representing
  the remote codecs</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_transmitter"
                      invoker="set_transmitter"
                      throws="1">
        <doc xml:space="preserve">Set the transmitter to use for this stream. This function will only succeed
once.

The parameters correspond to the varios GObject properties of the
selected stream transmitter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the transmitter could be set, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">Name of the type of transmitter to use for this stream</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="stream_transmitter_parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  an array of n_parameters #GParameter struct that will be passed
  to the newly-create #FsStreamTransmitter</doc>
            <array length="2" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
          <parameter name="stream_transmitter_n_parameters"
                     transfer-ownership="none">
            <doc xml:space="preserve">Number of parametrs passed to the stream
 transmitter</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_id" c:identifier="fs_stream_add_id">
        <doc xml:space="preserve">This function is used to add data identifiers that allow the
plugin to recognize packets that are meant for id. For example, in RTP,
one would set the SSRCs that are expected.

Depending on the protocol, one may be able to add more than one ID
to a stream (in RTP you can have multiple SSRCs in a stream).
If a protocol supports only one id, adding a new one will overwrite it.
If an ID was already set on a stream, adding it to another stream will
override the previdous decision.

For most protocols, calling this function is optional as the incoming data
can be matched with a stream by its source IP address. This is mostly useful
if one is using multicast or is behind a muxer server.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="id" transfer-ownership="none">
            <doc xml:space="preserve">The id to add to the stream</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_remote_candidates"
              c:identifier="fs_stream_add_remote_candidates"
              throws="1">
        <doc xml:space="preserve">This function adds remote candidates. Any new candidates are
added to the list. The candidates will be used to establish a connection
with the peer. A copy will be made so the user must free the
passed candidate using fs_candidate_destroy() when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE if the candidate was valid, FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">an #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="candidates" transfer-ownership="none">
            <doc xml:space="preserve">an #GList of #FsCandidate
 representing the remote candidates</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" c:identifier="fs_stream_destroy">
        <doc xml:space="preserve">This will cause the stream to remove all links to other objects and to
remove itself from the #FsSession. Once a #FsStream has been destroyed, it
can not be used anymore.

It is strongly recommended to call this function from the main thread because
releasing the application's reference to a stream.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="emit_error" c:identifier="fs_stream_emit_error">
        <doc xml:space="preserve">This function emits the #FsStream::error" signal, it should only be
called by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">#FsStream on which to emit the error signal</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="error_no" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message to be displayed to user</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="emit_src_pad_added"
              c:identifier="fs_stream_emit_src_pad_added">
        <doc xml:space="preserve">Emits the #FsStream::src-pad-added" signal, it should only be
called by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">#FsStream on which to emit the src-pad-added signal</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve">the #GstPad that this #FsStream has created</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">The #FsCodec for this pad</doc>
            <type name="Codec" c:type="FsCodec*"/>
          </parameter>
        </parameters>
      </method>
      <method name="force_remote_candidates"
              c:identifier="fs_stream_force_remote_candidates"
              throws="1">
        <doc xml:space="preserve">This function forces data to be sent immediately to the selected remote
candidate, by-passing any connectivity checks. There should be at most
one candidate per component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the candidates could be forced, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="remote_candidates" transfer-ownership="none">
            <doc xml:space="preserve">
  a #GList of #FsCandidate to force</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="iterate_src_pads"
              c:identifier="fs_stream_iterate_src_pads">
        <doc xml:space="preserve">Creates a #GstIterator that can be used to iterate the src pads of this
stream. These are the pads that were announced by #FsStream:src-pad-added
and are still valid.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The #GstIterator</doc>
          <type name="Gst.Iterator" c:type="GstIterator*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="parse_component_state_changed"
              c:identifier="fs_stream_parse_component_state_changed">
        <doc xml:space="preserve">Parses a "farstream-component-state-changed" message and checks if it matches
the @stream parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the stream and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream to match against the message</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="component"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Returns the component from the #GstMessage if not %NULL</doc>
            <type name="guint" c:type="guint*"/>
          </parameter>
          <parameter name="state"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">Returns the #FsStreamState from the #GstMessage if not %NULL</doc>
            <type name="StreamState" c:type="FsStreamState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_local_candidates_prepared"
              c:identifier="fs_stream_parse_local_candidates_prepared">
        <doc xml:space="preserve">Parses a "farstream-local-candidates-prepared" message and checks if it matches
the @stream parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the stream and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream to match against the message</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_new_active_candidate_pair"
              c:identifier="fs_stream_parse_new_active_candidate_pair">
        <doc xml:space="preserve">Parses a "farstream-new-active-candidate-pair" message and checks
if it matches the @stream parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the stream and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream to match against the message</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="local_candidate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">Returns the local #FsCandidate in
 the message if not %NULL.</doc>
            <type name="Candidate" c:type="FsCandidate**"/>
          </parameter>
          <parameter name="remote_candidate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">Returns the remote #FsCandidate in
 the message if not %NULL.</doc>
            <type name="Candidate" c:type="FsCandidate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_new_local_candidate"
              c:identifier="fs_stream_parse_new_local_candidate">
        <doc xml:space="preserve">Parses a "farstream-new-local-candidate" message and checks if it matches
the @stream parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the stream and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream to match against the message</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="candidate"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">Returns the #FsCandidate in the message
 if not %NULL.</doc>
            <type name="Candidate" c:type="FsCandidate**"/>
          </parameter>
        </parameters>
      </method>
      <method name="parse_recv_codecs_changed"
              c:identifier="fs_stream_parse_recv_codecs_changed">
        <doc xml:space="preserve">Parses a "farstream-recv-codecs-changed" message and checks if it matches
the @stream parameters.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the message matches the stream and is valid.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream to match against the message</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="message" transfer-ownership="none">
            <doc xml:space="preserve">a #GstMessage to parse</doc>
            <type name="Gst.Message" c:type="GstMessage*"/>
          </parameter>
          <parameter name="codecs"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">
 Returns a #GList of #FsCodec of the message if not %NULL</doc>
            <type name="GLib.List" c:type="GList**">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_decryption_parameters"
              c:identifier="fs_stream_set_decryption_parameters"
              throws="1">
        <doc xml:space="preserve">Sets decryption parameters. The exact parameters depend on the type of
plugin being used.</doc>
        <doc-version xml:space="preserve">UNRELEASED</doc-version>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the decryption parameters could be set, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">a #GstStructure containing the decryption
 parameters</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_remote_codecs"
              c:identifier="fs_stream_set_remote_codecs"
              throws="1">
        <doc xml:space="preserve">This function will set the list of remote codecs for this stream. If
the given remote codecs couldn't be negotiated with the list of local
codecs or already negotiated codecs for the corresponding #FsSession, @error
will be set and %FALSE will be returned. The @remote_codecs list will be
copied so it must be free'd using fs_codec_list_destroy() when done.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%FALSE if the remote codecs couldn't be set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="remote_codecs" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #FsCodec representing
  the remote codecs</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Codec"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="set_transmitter"
              c:identifier="fs_stream_set_transmitter"
              throws="1">
        <doc xml:space="preserve">Set the transmitter to use for this stream. This function will only succeed
once.

The parameters correspond to the varios GObject properties of the
selected stream transmitter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the transmitter could be set, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">Name of the type of transmitter to use for this stream</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="stream_transmitter_parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  an array of n_parameters #GParameter struct that will be passed
  to the newly-create #FsStreamTransmitter</doc>
            <array length="2" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
          <parameter name="stream_transmitter_n_parameters"
                     transfer-ownership="none">
            <doc xml:space="preserve">Number of parametrs passed to the stream
 transmitter</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_transmitter_ht"
              c:identifier="fs_stream_set_transmitter_ht"
              throws="1">
        <doc xml:space="preserve">Set the transmitter to use for this stream. This function will only succeed
once.

The parameters correspond to the varios GObject properties of the
selected stream transmitter.

This is the same as fs_stream_set_transmitter() except that the parameters
are passed in a #GHashTable to make it more friendly to GObject introspection</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the transmitter could be set, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="stream" transfer-ownership="none">
            <doc xml:space="preserve">a #FsStream</doc>
            <type name="Stream" c:type="FsStream*"/>
          </instance-parameter>
          <parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">Name of the type of transmitter to use for this stream</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="stream_transmitter_parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  A #GHashTable of string-&gt;GValue containing the parameters.</doc>
            <type name="GLib.HashTable" c:type="GHashTable*">
              <type name="utf8"/>
              <type name="GObject.Value"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <property name="current-recv-codecs" transfer-ownership="full">
        <doc xml:space="preserve">This is the list of codecs that have been received by this stream.
The user must free the list if fs_codec_list_destroy().
The "farstream-recv-codecs-changed" message is send on the #GstBus
when the value of this property changes.
It is normally emitted right after #FsStream::src-pad-added
only if that codec was not previously received in this stream, but it can
also be emitted if the pad already exists, but the source material that
will come to it is different.</doc>
        <type name="GLib.List">
          <type name="Codec"/>
        </type>
      </property>
      <property name="decryption-parameters" transfer-ownership="none">
        <doc xml:space="preserve">Retrieves previously set decryption parameters</doc>
        <type name="Gst.Structure"/>
      </property>
      <property name="direction"
                writable="1"
                construct="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The direction of the stream. This property is set initially as a parameter
to the fs_session_new_stream() function. It can be changed later if
required by setting this property.</doc>
        <type name="StreamDirection"/>
      </property>
      <property name="negotiated-codecs" transfer-ownership="full">
        <doc xml:space="preserve">This is the list of negotiatied codecs, it is the same list as the list
of #FsCodec from the parent #FsSession, except that the codec config data
has been replaced with the data from the remote codecs for this stream.
This is the list of #FsCodec used to receive data from this stream.
It is a #GList of #FsCodec.</doc>
        <type name="GLib.List">
          <type name="Codec"/>
        </type>
      </property>
      <property name="participant"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #FsParticipant for this stream. This property is a construct param and
is read-only construction.</doc>
        <type name="Participant"/>
      </property>
      <property name="remote-codecs" transfer-ownership="full">
        <doc xml:space="preserve">This is the list of remote codecs for this stream. They must be set by the
user as soon as they are known using fs_stream_set_remote_codecs()
(generally through external signaling). It is a #GList of #FsCodec.</doc>
        <type name="GLib.List">
          <type name="Codec"/>
        </type>
      </property>
      <property name="session"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #FsSession for this stream. This property is a construct param and
is read-only construction.</doc>
        <type name="Session"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="StreamPrivate" c:type="FsStreamPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted in any error condition</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="errorno" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error</doc>
            <type name="Error"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message to be displayed to user</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="src-pad-added" when="last">
        <doc xml:space="preserve">This signal is emitted when a new gst source pad has been created for a
specific codec being received. There will be a different source pad for
each codec that is received. The user must ref the #GstPad if he wants to
keep it. The user should not modify the #FsCodec and must copy it if he
wants to use it outside the callback scope.

This signal is not emitted on the main thread, but on GStreamer's streaming
thread!</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve">#GstPad of the new source pad</doc>
            <type name="Gst.Pad"/>
          </parameter>
          <parameter name="codec" transfer-ownership="none">
            <doc xml:space="preserve">#FsCodec of the codec being received on the new source pad</doc>
            <type name="Codec"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamClass"
            c:type="FsStreamClass"
            glib:is-gtype-struct-for="Stream">
      <doc xml:space="preserve">You must override add_remote_candidate in a subclass.
If you have to negotiate codecs, then you must override set_remote_codecs too</doc>
      <field name="parent_class">
        <doc xml:space="preserve">Our parent</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_remote_candidates">
        <callback name="add_remote_candidates" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE if the candidate was valid, FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">an #FsStream</doc>
              <type name="Stream" c:type="FsStream*"/>
            </parameter>
            <parameter name="candidates" transfer-ownership="none">
              <doc xml:space="preserve">an #GList of #FsCandidate
 representing the remote candidates</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Candidate"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="force_remote_candidates">
        <callback name="force_remote_candidates" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the candidates could be forced, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStream</doc>
              <type name="Stream" c:type="FsStream*"/>
            </parameter>
            <parameter name="remote_candidates" transfer-ownership="none">
              <doc xml:space="preserve">
  a #GList of #FsCandidate to force</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Candidate"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_remote_codecs">
        <callback name="set_remote_codecs" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%FALSE if the remote codecs couldn't be set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStream</doc>
              <type name="Stream" c:type="FsStream*"/>
            </parameter>
            <parameter name="remote_codecs" transfer-ownership="none">
              <doc xml:space="preserve">a #GList of #FsCodec representing
  the remote codecs</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Codec"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="add_id">
        <callback name="add_id">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStream</doc>
              <type name="Stream" c:type="FsStream*"/>
            </parameter>
            <parameter name="id" transfer-ownership="none">
              <doc xml:space="preserve">The id to add to the stream</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_transmitter">
        <callback name="set_transmitter" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the transmitter could be set, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStream</doc>
              <type name="Stream" c:type="FsStream*"/>
            </parameter>
            <parameter name="transmitter" transfer-ownership="none">
              <doc xml:space="preserve">Name of the type of transmitter to use for this stream</doc>
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="stream_transmitter_parameters"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <doc xml:space="preserve">
  an array of n_parameters #GParameter struct that will be passed
  to the newly-create #FsStreamTransmitter</doc>
              <array length="3" zero-terminated="0" c:type="GParameter*">
                <type name="GObject.Parameter" c:type="GParameter"/>
              </array>
            </parameter>
            <parameter name="stream_transmitter_n_parameters"
                       transfer-ownership="none">
              <doc xml:space="preserve">Number of parametrs passed to the stream
 transmitter</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_decryption_parameters">
        <callback name="set_decryption_parameters" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the decryption parameters could be set, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="stream" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStream</doc>
              <type name="Stream" c:type="FsStream*"/>
            </parameter>
            <parameter name="parameters" transfer-ownership="none">
              <doc xml:space="preserve">a #GstStructure containing the decryption
 parameters</doc>
              <type name="Gst.Structure" c:type="GstStructure*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="7">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="StreamDirection"
              glib:type-name="FsStreamDirection"
              glib:get-type="fs_stream_direction_get_type"
              c:type="FsStreamDirection">
      <doc xml:space="preserve">An enum for specifying the direction of a stream</doc>
      <member name="none"
              value="0"
              c:identifier="FS_DIRECTION_NONE"
              glib:nick="none">
        <doc xml:space="preserve">No direction specified</doc>
      </member>
      <member name="send"
              value="1"
              c:identifier="FS_DIRECTION_SEND"
              glib:nick="send">
        <doc xml:space="preserve">Send only</doc>
      </member>
      <member name="recv"
              value="2"
              c:identifier="FS_DIRECTION_RECV"
              glib:nick="recv">
        <doc xml:space="preserve">Receive only</doc>
      </member>
      <member name="both"
              value="3"
              c:identifier="FS_DIRECTION_BOTH"
              glib:nick="both">
        <doc xml:space="preserve">Send and receive</doc>
      </member>
    </bitfield>
    <record name="StreamPrivate" c:type="FsStreamPrivate" disguised="1">
    </record>
    <enumeration name="StreamState"
                 glib:type-name="FsStreamState"
                 glib:get-type="fs_stream_state_get_type"
                 c:type="FsStreamState">
      <doc xml:space="preserve">These are the possible states of a stream, a simple multicast stream
could only be in "disconnected" or "ready" state.
An stream using an ICE transmitter would use all of these.</doc>
      <member name="failed"
              value="0"
              c:identifier="FS_STREAM_STATE_FAILED"
              glib:nick="failed">
        <doc xml:space="preserve">connectivity checks have been completed,
                         but connectivity was not established</doc>
      </member>
      <member name="disconnected"
              value="1"
              c:identifier="FS_STREAM_STATE_DISCONNECTED"
              glib:nick="disconnected">
        <doc xml:space="preserve">no activity scheduled</doc>
      </member>
      <member name="gathering"
              value="2"
              c:identifier="FS_STREAM_STATE_GATHERING"
              glib:nick="gathering">
        <doc xml:space="preserve">gathering local candidates</doc>
      </member>
      <member name="connecting"
              value="3"
              c:identifier="FS_STREAM_STATE_CONNECTING"
              glib:nick="connecting">
        <doc xml:space="preserve">establishing connectivity</doc>
      </member>
      <member name="connected"
              value="4"
              c:identifier="FS_STREAM_STATE_CONNECTED"
              glib:nick="connected">
        <doc xml:space="preserve">at least one working candidate pair</doc>
      </member>
      <member name="ready"
              value="5"
              c:identifier="FS_STREAM_STATE_READY"
              glib:nick="ready">
        <doc xml:space="preserve">ICE concluded, candidate pair selection is now final</doc>
      </member>
    </enumeration>
    <class name="StreamTransmitter"
           c:symbol-prefix="stream_transmitter"
           c:type="FsStreamTransmitter"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="FsStreamTransmitter"
           glib:get-type="fs_stream_transmitter_get_type"
           glib:type-struct="StreamTransmitterClass">
      <doc xml:space="preserve">All members are private, access them using methods and properties</doc>
      <virtual-method name="add_remote_candidates"
                      invoker="add_remote_candidates"
                      throws="1">
        <doc xml:space="preserve">This function is used to add remote candidates to the transmitter</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE of the candidate could be added, FALSE if it couldnt
  (and the #GError will be set)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTranmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
          <parameter name="candidates" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of the remote candidates</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="force_remote_candidates"
                      invoker="force_remote_candidates"
                      throws="1">
        <doc xml:space="preserve">This function forces data to be sent immediately to the selected remote
candidate, by-passing any connectivity checks. There should be at most
one candidate per component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the candidates could be forced, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTransmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
          <parameter name="remote_candidates" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #FsCandidate to
  force</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="gather_local_candidates"
                      invoker="gather_local_candidates"
                      throws="1">
        <doc xml:space="preserve">This function tells the transmitter to start gathering local candidates,
signals for new candidates and newly active candidates can be emitted
during the call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if it succeeds (or is not implemented), %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTransmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop" invoker="stop">
        <doc xml:space="preserve">This functions stops the #FsStreamTransmitter, it must be called before
the last reference is dropped.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTransmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_remote_candidates"
              c:identifier="fs_stream_transmitter_add_remote_candidates"
              throws="1">
        <doc xml:space="preserve">This function is used to add remote candidates to the transmitter</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">TRUE of the candidate could be added, FALSE if it couldnt
  (and the #GError will be set)</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTranmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
          <parameter name="candidates" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of the remote candidates</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="emit_error"
              c:identifier="fs_stream_transmitter_emit_error">
        <doc xml:space="preserve">This function emit the "error" signal on a #FsStreamTransmitter, it should
only be called by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">#FsStreamTransmitter on which to emit the error signal</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
          <parameter name="error_no" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message (for the programmer)</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="force_remote_candidates"
              c:identifier="fs_stream_transmitter_force_remote_candidates"
              throws="1">
        <doc xml:space="preserve">This function forces data to be sent immediately to the selected remote
candidate, by-passing any connectivity checks. There should be at most
one candidate per component.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the candidates could be forced, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTransmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
          <parameter name="remote_candidates" transfer-ownership="none">
            <doc xml:space="preserve">a #GList of #FsCandidate to
  force</doc>
            <type name="GLib.List" c:type="GList*">
              <type name="Candidate"/>
            </type>
          </parameter>
        </parameters>
      </method>
      <method name="gather_local_candidates"
              c:identifier="fs_stream_transmitter_gather_local_candidates"
              throws="1">
        <doc xml:space="preserve">This function tells the transmitter to start gathering local candidates,
signals for new candidates and newly active candidates can be emitted
during the call to this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if it succeeds (or is not implemented), %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTransmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="fs_stream_transmitter_stop">
        <doc xml:space="preserve">This functions stops the #FsStreamTransmitter, it must be called before
the last reference is dropped.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="streamtransmitter"
                              transfer-ownership="none">
            <doc xml:space="preserve">a #FsStreamTransmitter</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="associate-on-source"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">This tells the stream transmitter to associate incoming data with this
based on the source without looking at the content if possible.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="preferred-local-candidates"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="CandidateList"/>
      </property>
      <property name="sending" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">A network source #GstElement to be used by the #FsSession</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="StreamTransmitterPrivate"
              c:type="FsStreamTransmitterPrivate*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted in any error condition</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="errorno" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error</doc>
            <type name="Error"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message (for the programmer)</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="known-source-packet-received" when="last">
        <doc xml:space="preserve">This signal is emitted when a buffer coming from a confirmed known source
is received.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="component" transfer-ownership="none">
            <doc xml:space="preserve">The Component on which this buffer was received</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve">the #GstBuffer coming from the known source</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="local-candidates-prepared" when="last">
        <doc xml:space="preserve">This signal is emitted when all local candidates have been
prepared, an ICE implementation would send its SDP offer or answer.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="new-active-candidate-pair" when="last">
        <doc xml:space="preserve">This signal is emitted when there is a new active chandidate pair that has
been established. This is specially useful for ICE where the active
candidate pair can change automatically due to network conditions. The user
must not modify the candidates and must copy them if he wants to use them
outside the callback scope.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="local_candidate" transfer-ownership="none">
            <doc xml:space="preserve">#FsCandidate of the local candidate being used</doc>
            <type name="Candidate"/>
          </parameter>
          <parameter name="remote_candidate" transfer-ownership="none">
            <doc xml:space="preserve">#FsCandidate of the remote candidate being used</doc>
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="new-local-candidate" when="last">
        <doc xml:space="preserve">This signal is emitted when a new local candidate is discovered.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="local_candidate" transfer-ownership="none">
            <doc xml:space="preserve">#FsCandidate of the local candidate</doc>
            <type name="Candidate"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="state-changed" when="last">
        <doc xml:space="preserve">This signal is emitted when the ICE state (or equivalent) of the component
changes</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="component" transfer-ownership="none">
            <doc xml:space="preserve">the id of the component which state has changed</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve">the new state of the component</doc>
            <type name="StreamState"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="StreamTransmitterClass"
            c:type="FsStreamTransmitterClass"
            glib:is-gtype-struct-for="StreamTransmitter">
      <doc xml:space="preserve">You must override the add_remote_candidate in a subclass</doc>
      <field name="parent_class">
        <doc xml:space="preserve">Our parent</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="add_remote_candidates">
        <callback name="add_remote_candidates" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">TRUE of the candidate could be added, FALSE if it couldnt
  (and the #GError will be set)</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="streamtransmitter" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStreamTranmitter</doc>
              <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
            </parameter>
            <parameter name="candidates" transfer-ownership="none">
              <doc xml:space="preserve">a #GList of the remote candidates</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Candidate"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="force_remote_candidates">
        <callback name="force_remote_candidates" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if the candidates could be forced, %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="streamtransmitter" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStreamTransmitter</doc>
              <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
            </parameter>
            <parameter name="remote_candidates" transfer-ownership="none">
              <doc xml:space="preserve">a #GList of #FsCandidate to
  force</doc>
              <type name="GLib.List" c:type="GList*">
                <type name="Candidate"/>
              </type>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="gather_local_candidates">
        <callback name="gather_local_candidates" throws="1">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">%TRUE if it succeeds (or is not implemented), %FALSE otherwise</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="streamtransmitter" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStreamTransmitter</doc>
              <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="streamtransmitter" transfer-ownership="none">
              <doc xml:space="preserve">a #FsStreamTransmitter</doc>
              <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="StreamTransmitterPrivate"
            c:type="FsStreamTransmitterPrivate"
            disguised="1">
    </record>
    <class name="Transmitter"
           c:symbol-prefix="transmitter"
           c:type="FsTransmitter"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="FsTransmitter"
           glib:get-type="fs_transmitter_get_type"
           glib:type-struct="TransmitterClass">
      <doc xml:space="preserve">All members are private, access them using methods and properties</doc>
      <constructor name="new" c:identifier="fs_transmitter_new" throws="1">
        <doc xml:space="preserve">This function creates a new transmitter of the requested type.
It will load the appropriate plugin as required.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly-created #FsTransmitter of the requested type
   (or NULL if there is an error)</doc>
          <type name="Transmitter" c:type="FsTransmitter*"/>
        </return-value>
        <parameters>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve">The type of transmitter to create</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="components" transfer-ownership="none">
            <doc xml:space="preserve">The number of components to create</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="tos" transfer-ownership="none">
            <doc xml:space="preserve">The Type of Service of the socket, max is 255</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="list_available"
                c:identifier="fs_transmitter_list_available">
        <doc xml:space="preserve">Get the list of all available transmitters</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a newly allocated array of strings containing the
list of all available transmitters or %NULL if there are none. It should
 be freed with g_strfreev().</doc>
          <array c:type="char**">
            <type name="utf8"/>
          </array>
        </return-value>
      </function>
      <virtual-method name="get_stream_transmitter_type"
                      invoker="get_stream_transmitter_type">
        <doc xml:space="preserve">This function returns the GObject type for the stream transmitter.
This is meant for bindings that need to introspect the type of arguments
that can be passed to the _new_stream_transmitter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">A #FsTransmitter object</doc>
            <type name="Transmitter" c:type="FsTransmitter*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="new_stream_transmitter"
                      invoker="new_stream_transmitter"
                      throws="1">
        <doc xml:space="preserve">This function will create a new #FsStreamTransmitter element for a
specific participant for this #FsTransmitter</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #FsStreamTransmitter, or NULL if there is an
 error</doc>
          <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">a #FsTranmitter</doc>
            <type name="Transmitter" c:type="FsTransmitter*"/>
          </instance-parameter>
          <parameter name="participant" transfer-ownership="none">
            <doc xml:space="preserve">the #FsParticipant for which the #FsStream using this
new #FsStreamTransmitter is created</doc>
            <type name="Participant" c:type="FsParticipant*"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">The number of parameters to pass to the newly created
#FsStreamTransmitter</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GParameter</doc>
            <type name="GObject.Parameter" c:type="GParameter*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="emit_error" c:identifier="fs_transmitter_emit_error">
        <doc xml:space="preserve">This function emit the "error" signal on a #FsTransmitter, it should
only be called by subclasses.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">#FsTransmitter on which to emit the error signal</doc>
            <type name="Transmitter" c:type="FsTransmitter*"/>
          </instance-parameter>
          <parameter name="error_no" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message to be displayed to user</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_stream_transmitter_type"
              c:identifier="fs_transmitter_get_stream_transmitter_type">
        <doc xml:space="preserve">This function returns the GObject type for the stream transmitter.
This is meant for bindings that need to introspect the type of arguments
that can be passed to the _new_stream_transmitter.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #GType</doc>
          <type name="GType" c:type="GType"/>
        </return-value>
        <parameters>
          <instance-parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">A #FsTransmitter object</doc>
            <type name="Transmitter" c:type="FsTransmitter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_stream_transmitter"
              c:identifier="fs_transmitter_new_stream_transmitter"
              throws="1">
        <doc xml:space="preserve">This function will create a new #FsStreamTransmitter element for a
specific participant for this #FsTransmitter</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #FsStreamTransmitter, or NULL if there is an
 error</doc>
          <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
        </return-value>
        <parameters>
          <instance-parameter name="transmitter" transfer-ownership="none">
            <doc xml:space="preserve">a #FsTranmitter</doc>
            <type name="Transmitter" c:type="FsTransmitter*"/>
          </instance-parameter>
          <parameter name="participant" transfer-ownership="none">
            <doc xml:space="preserve">the #FsParticipant for which the #FsStream using this
new #FsStreamTransmitter is created</doc>
            <type name="Participant" c:type="FsParticipant*"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">The number of parameters to pass to the newly created
#FsStreamTransmitter</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GParameter</doc>
            <type name="GObject.Parameter" c:type="GParameter*"/>
          </parameter>
        </parameters>
      </method>
      <property name="components"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The number of components to create</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="do-timestamp" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Apply current stream time to buffers or provide buffers without
timestamps. Must be set before creating a stream transmitter.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="gst-sink" transfer-ownership="none">
        <doc xml:space="preserve">A network source #GstElement to be used by the #FsSession
These element's sink must have async=FALSE
This element MUST provide a pad named "sink_\%u" per component.
These pads number must start at 1 (the \%u corresponds to the component
number).
These pads MUST be static pads.</doc>
        <type name="Gst.Element"/>
      </property>
      <property name="gst-src" transfer-ownership="none">
        <doc xml:space="preserve">A network source #GstElement to be used by the #FsSession
This element MUST provide a source pad named "src_%u" per component.
These pads number must start at 1 (the %u corresponds to the component
number).
These pads MUST be static pads.</doc>
        <type name="Gst.Element"/>
      </property>
      <property name="tos" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">Sets the IP ToS field (and if possible the IPv6 TCLASS field</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="TransmitterPrivate" c:type="FsTransmitterPrivate*"/>
      </field>
      <field name="construction_error" readable="0" private="1">
        <type name="GLib.Error" c:type="GError*"/>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="error" when="last">
        <doc xml:space="preserve">This signal is emitted in any error condition</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="errorno" transfer-ownership="none">
            <doc xml:space="preserve">The number of the error</doc>
            <type name="Error"/>
          </parameter>
          <parameter name="error_msg" transfer-ownership="none">
            <doc xml:space="preserve">Error message to be displayed to user</doc>
            <type name="utf8" c:type="gchar*"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="TransmitterClass"
            c:type="FsTransmitterClass"
            glib:is-gtype-struct-for="Transmitter">
      <doc xml:space="preserve">You must override both methods in a subclass.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">Our parent</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="new_stream_transmitter">
        <callback name="new_stream_transmitter" throws="1">
          <return-value transfer-ownership="full">
            <doc xml:space="preserve">a new #FsStreamTransmitter, or NULL if there is an
 error</doc>
            <type name="StreamTransmitter" c:type="FsStreamTransmitter*"/>
          </return-value>
          <parameters>
            <parameter name="transmitter" transfer-ownership="none">
              <doc xml:space="preserve">a #FsTranmitter</doc>
              <type name="Transmitter" c:type="FsTransmitter*"/>
            </parameter>
            <parameter name="participant" transfer-ownership="none">
              <doc xml:space="preserve">the #FsParticipant for which the #FsStream using this
new #FsStreamTransmitter is created</doc>
              <type name="Participant" c:type="FsParticipant*"/>
            </parameter>
            <parameter name="n_parameters" transfer-ownership="none">
              <doc xml:space="preserve">The number of parameters to pass to the newly created
#FsStreamTransmitter</doc>
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="parameters" transfer-ownership="none">
              <doc xml:space="preserve">an array of #GParameter</doc>
              <type name="GObject.Parameter" c:type="GParameter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_stream_transmitter_type">
        <callback name="get_stream_transmitter_type">
          <return-value transfer-ownership="none">
            <doc xml:space="preserve">the #GType</doc>
            <type name="GType" c:type="GType"/>
          </return-value>
          <parameters>
            <parameter name="transmitter" transfer-ownership="none">
              <doc xml:space="preserve">A #FsTransmitter object</doc>
              <type name="Transmitter" c:type="FsTransmitter*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="TransmitterPrivate"
            c:type="FsTransmitterPrivate"
            disguised="1">
    </record>
    <function name="candidate_list_copy"
              c:identifier="fs_candidate_list_copy"
              moved-to="CandidateList.copy">
      <doc xml:space="preserve">Copies a GList of #FsCandidate and its contents</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new GList of #FsCandidate</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Codec"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="candidate_list" transfer-ownership="none">
          <doc xml:space="preserve">A GList of #FsCandidate</doc>
          <type name="GLib.List" c:type="const GList*">
            <type name="Codec"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="candidate_list_destroy"
              c:identifier="fs_candidate_list_destroy"
              moved-to="CandidateList.destroy"
              introspectable="0">
      <doc xml:space="preserve">Deletes a GList of #FsCandidate and its contents</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="candidate_list" transfer-ownership="none">
          <doc xml:space="preserve">A GList of #FsCandidate</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="codec_list_are_equal"
              c:identifier="fs_codec_list_are_equal"
              moved-to="CodecGList.are_equal">
      <doc xml:space="preserve">Verifies if two glist of fscodecs are identical</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if they are identical, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="list1"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #GList of #FsCodec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Codec"/>
          </type>
        </parameter>
        <parameter name="list2"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">a #GList of #FsCodec</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Codec"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="codec_list_copy"
              c:identifier="fs_codec_list_copy"
              moved-to="CodecGList.copy">
      <doc xml:space="preserve">Copies a list of #FsCodec structures.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The new list.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Codec"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="codec_list" transfer-ownership="none">
          <doc xml:space="preserve">
  a GList of #FsCodec to copy</doc>
          <type name="GLib.List" c:type="const GList*">
            <type name="Codec"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="codec_list_destroy"
              c:identifier="fs_codec_list_destroy"
              moved-to="CodecGList.destroy"
              introspectable="0">
      <doc xml:space="preserve">Deletes a list of #FsCodec structures and the list itself.
Does nothing on %NULL lists.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="codec_list" transfer-ownership="none">
          <doc xml:space="preserve">a GList of #FsCodec to delete</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="codec_list_from_keyfile"
              c:identifier="fs_codec_list_from_keyfile"
              moved-to="CodecGList.from_keyfile"
              throws="1">
      <doc xml:space="preserve">Reads the content of a #GKeyFile of the following format into
a #GList of #FsCodec structures.


Example:
|[
[audio/codec1]
clock-rate=8000

[audio/codec1:1]
clock-rate=16000

[audio/codec2]
one_param=QCIF
another_param=WOW

[video/codec3]
wierd_param=42
feedback:nack/pli=1
feedback:tfrc=
]|</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
The #GList of #FsCodec or %NULL if the keyfile was empty or an error occured.</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Codec"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">Name of the #GKeyFile to read the codecs parameters from</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark"
              c:identifier="fs_error_quark"
              moved-to="Error.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="media_type_to_string"
              c:identifier="fs_media_type_to_string"
              moved-to="MediaType.to_string">
      <doc xml:space="preserve">Gives a user-printable string representing the media type</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">a static string representing the media type</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="media_type" transfer-ownership="none">
          <doc xml:space="preserve">A media type</doc>
          <type name="MediaType" c:type="FsMediaType"/>
        </parameter>
      </parameters>
    </function>
    <function name="parse_error" c:identifier="fs_parse_error">
      <doc xml:space="preserve">Parses a "farstream-farstream" message and checks if it matches
the @object parameters.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the message matches the object and is valid.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="object" transfer-ownership="none">
          <doc xml:space="preserve">a #GObject to match against the message</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </parameter>
        <parameter name="message" transfer-ownership="none">
          <doc xml:space="preserve">a #GstMessage to parse</doc>
          <type name="Gst.Message" c:type="GstMessage*"/>
        </parameter>
        <parameter name="error"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">Returns the #FsError error number in
the message if not %NULL.</doc>
          <type name="Error" c:type="FsError*"/>
        </parameter>
        <parameter name="error_msg"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">Returns the error message if not %NULL</doc>
          <type name="utf8" c:type="const gchar**"/>
        </parameter>
      </parameters>
    </function>
    <function name="rtp_header_extension_list_copy"
              c:identifier="fs_rtp_header_extension_list_copy"
              moved-to="RtpHeaderExtensionGList.copy">
      <doc xml:space="preserve">Does a deep copy of a #GList of #FsRtpHeaderExtension</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a new
#GList of #FsRtpHeaderExtension</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="RtpHeaderExtension"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="extensions" transfer-ownership="none">
          <doc xml:space="preserve">
  a #GList of #FsRtpHeaderExtension</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="RtpHeaderExtension"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="rtp_header_extension_list_destroy"
              c:identifier="fs_rtp_header_extension_list_destroy"
              moved-to="RtpHeaderExtensionGList.destroy"
              introspectable="0">
      <doc xml:space="preserve">Frees the passed #GList of #FsRtpHeaderExtension</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="extensions" transfer-ownership="none">
          <doc xml:space="preserve">a #GList of #FsRtpHeaderExtension</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="gpointer" c:type="gpointer"/>
          </type>
        </parameter>
      </parameters>
    </function>
    <function name="rtp_header_extension_list_from_keyfile"
              c:identifier="fs_rtp_header_extension_list_from_keyfile"
              moved-to="RtpHeaderExtensionGList.from_keyfile"
              throws="1">
      <doc xml:space="preserve">Reads the content of a #GKeyFile of the following format into a
#GList of #FsRtpHeaderExtension structures.

The groups have a format "rtp-hdrext:audio:XXX" or
"rtp-hdrext:video:XXX" where XXX is a unique string (per media type).

The valid keys are:
&lt;itemizedlist&gt;
 &lt;listitem&gt;id: a int between in the 1-255 and 4096-4351 ranges&lt;/listitem&gt;
 &lt;listitem&gt;uri: a URI describing the RTP Header Extension&lt;/listitem&gt;
 &lt;listitem&gt;direction (optional): To only send or receive a RTP Header
     Extension, possible values are "send", "receive", "none" or "both".
     Defaults to "both"&lt;/listitem&gt;
&lt;/itemizedlist&gt;

Example:
|[
[rtp-hdrext:audio:a]
id=1
uri=urn:ietf:params:rtp-hdrext:toffset

[rtp-hdrext:audio:abc]
id=3
uri=urn:ietf:params:rtp-hdrext:ntp-64
direction=receive
]|</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a
#GList of #FsRtpHeaderExtension that must be freed with
fs_rtp_header_extension_list_destroy()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="RtpHeaderExtension"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <doc xml:space="preserve">Name of the #GKeyFile to read the RTP Header Extensions from</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="media_type" transfer-ownership="none">
          <doc xml:space="preserve">The media type for which to get header extensions</doc>
          <type name="MediaType" c:type="FsMediaType"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_get_default_codec_preferences"
              c:identifier="fs_utils_get_default_codec_preferences">
      <doc xml:space="preserve">These default codec preferences should work with the elements that are
available in the main GStreamer element repositories.
They should be suitable for standards based protocols like SIP or XMPP.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">
The default codec preferences for this plugin.
This #GList should be freed with fs_codec_list_destroy()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Codec"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <doc xml:space="preserve">Element for which to fetch default codec preferences</doc>
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_get_default_element_properties"
              c:identifier="fs_utils_get_default_element_properties"
              introspectable="0">
      <doc xml:space="preserve">This function produces a #GKeyFile that can be fed to
fs_element_added_notifier_set_properties_from_keyfile(). If no
default properties have been found, it will return %NULL.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">a #GKeyFile containing the default element
properties for this element or %NULL if no properties were found.
Caller must free the #GKeyFile when he is done.</doc>
        <type name="GLib.KeyFile" c:type="GKeyFile*"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <doc xml:space="preserve">Element for which to fetch default element properties</doc>
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_get_default_rtp_header_extension_preferences"
              c:identifier="fs_utils_get_default_rtp_header_extension_preferences">
      <doc xml:space="preserve">These default rtp header extension preferences should work with the elements
that are available in the main GStreamer element repositories.
They should be suitable for standards based protocols like SIP or XMPP.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The default rtp
header extension preferences for this plugin, this #GList should be
freed with fs_codec_list_destroy()</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Codec"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <doc xml:space="preserve">Element for which to fetch default RTP Header Extension preferences</doc>
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
        <parameter name="media_type" transfer-ownership="none">
          <doc xml:space="preserve">The #FsMediaType for which to get default RTP Header Extension
 preferences</doc>
          <type name="MediaType" c:type="FsMediaType"/>
        </parameter>
      </parameters>
    </function>
    <function name="utils_set_bitrate" c:identifier="fs_utils_set_bitrate">
      <doc xml:space="preserve">This allows setting the bitrate on all elements that have a "bitrate"
property without having to know the type or of the unit used by that element.

This will be obsolete in 0.11 (when all elements use bit/sec for the
"bitrate" property.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="element" transfer-ownership="none">
          <doc xml:space="preserve">The #GstElement</doc>
          <type name="Gst.Element" c:type="GstElement*"/>
        </parameter>
        <parameter name="bitrate" transfer-ownership="none">
          <doc xml:space="preserve">The bitrate in bits/sec</doc>
          <type name="glong" c:type="glong"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_candidate_list"
              c:identifier="fs_value_set_candidate_list">
      <doc xml:space="preserve">This is for the bindings benefit. Works around the limitations of GObject
introspection.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue of type #FS_TYPE_CANDIDATE_LIST</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="candidates"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">A #GList of #FsCandidate</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Candidate"/>
          </type>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
