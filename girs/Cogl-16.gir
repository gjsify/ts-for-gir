<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:doc="http://www.gtk.org/introspection/doc/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GL" version="1.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Graphene" version="1.0"/>
  <include name="Mtk" version="16"/>
  <include name="xlib" version="2.0"/>
  <package name="mutter-cogl-16"/>
  <c:include name="cogl/cogl.h"/>
  <doc:format name="unknown"/>
  <namespace name="Cogl"
             version="16"
             shared-library="libmutter-cogl-16.so.0"
             c:identifier-prefixes="Cogl"
             c:symbol-prefixes="cogl">
    <alias name="PipelineKey" c:type="CoglPipelineKey">
      <source-position filename="cogl/cogl/cogl-context.h" line="271"/>
      <type name="utf8" c:type="const char* const"/>
    </alias>
    <constant name="AFIRST_BIT" value="64" c:type="COGL_AFIRST_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="49"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="ATLAS_TEXTURE"
                    c:identifier="COGL_ATLAS_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="67"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATLAS_TEXTURE_CLASS"
                    c:identifier="COGL_ATLAS_TEXTURE_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="69"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATLAS_TEXTURE_CONST"
                    c:identifier="COGL_ATLAS_TEXTURE_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="68"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATLAS_TEXTURE_GET_CLASS"
                    c:identifier="COGL_ATLAS_TEXTURE_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="72"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATTRIBUTE_BUFFER"
                    c:identifier="COGL_ATTRIBUTE_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="52"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATTRIBUTE_BUFFER_CLASS"
                    c:identifier="COGL_ATTRIBUTE_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="54"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATTRIBUTE_BUFFER_CONST"
                    c:identifier="COGL_ATTRIBUTE_BUFFER_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="53"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ATTRIBUTE_BUFFER_GET_CLASS"
                    c:identifier="COGL_ATTRIBUTE_BUFFER_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="57"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="A_BIT" value="16" c:type="COGL_A_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="47"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <class name="Atlas"
           c:symbol-prefix="atlas"
           c:type="CoglAtlas"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglAtlas"
           glib:get-type="cogl_atlas_get_type"
           glib:type-struct="AtlasClass">
      <source-position filename="cogl/cogl/cogl-atlas.h" line="47"/>
      <constructor name="new" c:identifier="cogl_atlas_new" introspectable="0">
        <source-position filename="cogl/cogl/cogl-atlas.h" line="58"/>
        <return-value transfer-ownership="full">
          <type name="Atlas" c:type="CoglAtlas*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="texture_format" transfer-ownership="none">
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <type name="AtlasFlags" c:type="CoglAtlasFlags"/>
          </parameter>
          <parameter name="update_position_cb" transfer-ownership="none">
            <type name="AtlasUpdatePositionCallback"
                  c:type="CoglAtlasUpdatePositionCallback"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_reorganize_callback"
              c:identifier="cogl_atlas_add_reorganize_callback"
              introspectable="0">
        <source-position filename="cogl/cogl/cogl-atlas.h" line="73"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="atlas" transfer-ownership="none">
            <type name="Atlas" c:type="CoglAtlas*"/>
          </instance-parameter>
          <parameter name="pre_callback" transfer-ownership="none">
            <type name="GLib.HookFunc" c:type="GHookFunc"/>
          </parameter>
          <parameter name="post_callback"
                     transfer-ownership="none"
                     closure="2">
            <type name="GLib.HookFunc" c:type="GHookFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reserve_space" c:identifier="cogl_atlas_reserve_space">
        <source-position filename="cogl/cogl/cogl-atlas.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="atlas" transfer-ownership="none">
            <type name="Atlas" c:type="CoglAtlas*"/>
          </instance-parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="AtlasClass"
            c:type="CoglAtlasClass"
            glib:is-gtype-struct-for="Atlas">
      <source-position filename="cogl/cogl/cogl-atlas.h" line="47"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <bitfield name="AtlasFlags" c:type="CoglAtlasFlags">
      <source-position filename="cogl/cogl/cogl-atlas.h" line="42"/>
      <member name="clear_texture"
              value="1"
              c:identifier="COGL_ATLAS_CLEAR_TEXTURE">
      </member>
      <member name="disable_migration"
              value="2"
              c:identifier="COGL_ATLAS_DISABLE_MIGRATION">
      </member>
    </bitfield>
    <class name="AtlasTexture"
           c:symbol-prefix="atlas_texture"
           c:type="CoglAtlasTexture"
           parent="Texture"
           final="1"
           glib:type-name="CoglAtlasTexture"
           glib:get-type="cogl_atlas_texture_get_type"
           glib:type-struct="AtlasTextureClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-atlas-texture.h"
           line="43">Functions for managing textures in Cogl's global
set of texture atlases

A texture atlas is a texture that contains many smaller images that
an application is interested in. These are packed together as a way
of optimizing drawing with those images by avoiding the costs of
repeatedly telling the hardware to change what texture it should
sample from.  This can enable more geometry to be batched together
into few draw calls.

Each #CoglContext has an shared, pool of texture atlases that are
are managed by Cogl.

This api lets applications upload texture data into one of Cogl's
shared texture atlases using a high-level #CoglAtlasTexture which
represents a sub-region of one of these atlases.

A #CoglAtlasTexture is a high-level meta texture which has
some limitations to be aware of.</doc>
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="74"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_atlas_texture_new_from_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-atlas-texture.h"
             line="115">Creates a new #CoglAtlasTexture texture based on data residing in a
@bmp. A #CoglAtlasTexture represents a sub-region within one of
Cogl's shared texture atlases.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

Allocate call can fail if Cogl considers the internal
format to be incompatible with the format of its internal
atlases.

The returned #CoglAtlasTexture is a high-level meta-texture
with some limitations.</doc>
        <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="144"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-atlas-texture.h"
               line="141">A new #CoglAtlasTexture object.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="bmp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-atlas-texture.h"
                 line="117">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_atlas_texture_new_with_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-atlas-texture.h"
             line="81">Creates a #CoglAtlasTexture with a given @width and @height. A
#CoglAtlasTexture represents a sub-region within one of Cogl's
shared texture atlases.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().

Allocate call can fail if Cogl considers the internal
format to be incompatible with the format of its internal
atlases.

The returned #CoglAtlasTexture is a high-level meta-texture
with some limitations.</doc>
        <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="111"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-atlas-texture.h"
               line="108">A new #CoglAtlasTexture object.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-atlas-texture.h"
                 line="83">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-atlas-texture.h"
                 line="84">The width of your atlased texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-atlas-texture.h"
                 line="85">The height of your atlased texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <function name="add_reorganize_callback"
                c:identifier="cogl_atlas_texture_add_reorganize_callback"
                introspectable="0">
        <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="150"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="2">
            <type name="GLib.HookFunc" c:type="GHookFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
      <function name="remove_reorganize_callback"
                c:identifier="cogl_atlas_texture_remove_reorganize_callback"
                introspectable="0">
        <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="158"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="callback" transfer-ownership="none" closure="2">
            <type name="GLib.HookFunc" c:type="GHookFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </function>
    </class>
    <record name="AtlasTextureClass"
            c:type="CoglAtlasTextureClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="AtlasTexture">
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="74"/>
    </record>
    <callback name="AtlasUpdatePositionCallback"
              c:type="CoglAtlasUpdatePositionCallback">
      <source-position filename="cogl/cogl/cogl-atlas.h" line="34"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="0">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="new_texture" transfer-ownership="none">
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
        <parameter name="rect" transfer-ownership="none">
          <type name="Mtk.Rectangle" c:type="const MtkRectangle*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Attribute"
           c:symbol-prefix="attribute"
           c:type="CoglAttribute"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglAttribute"
           glib:get-type="cogl_attribute_get_type"
           glib:type-struct="AttributeClass">
      <source-position filename="cogl/cogl/cogl-attribute.h" line="50"/>
      <constructor name="new" c:identifier="cogl_attribute_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-attribute.h"
             line="56">Describes the layout for a list of vertex attribute values (For
example, a list of texture coordinates or colors).

The @name is used to access the attribute inside a GLSL vertex
shader and there are some special names you should use if they are
applicable:

- "cogl_position_in" (used for vertex positions)
- "cogl_color_in" (used for vertex colors)
- "cogl_tex_coord0_in", "cogl_tex_coord1", ...
(used for vertex texture coordinates)
- "cogl_normal_in" (used for vertex normals)
- "cogl_point_size_in" (used to set the size of points
   per-vertex. Note this can only be used if
   %COGL_FEATURE_ID_POINT_SIZE_ATTRIBUTE is advertised and
   cogl_pipeline_set_per_vertex_point_size() is called on the pipeline.

The attribute values corresponding to different vertices can either
be tightly packed or interleaved with other attribute values. For
example it's common to define a structure for a single vertex like:
```c
typedef struct
{
  float x, y, z; /&lt;!-- --&gt;* position attribute *&lt;!-- --&gt;/
  float s, t; /&lt;!-- --&gt;* texture coordinate attribute *&lt;!-- --&gt;/
} MyVertex;
```

And then create an array of vertex data something like:
```c
MyVertex vertices[100] = { .... }
```

In this case, to describe either the position or texture coordinate
attribute you have to move `sizeof (MyVertex)` bytes to
move from one vertex to the next.  This is called the attribute
@stride. If you weren't interleving attributes and you instead had
a packed array of float x, y pairs then the attribute stride would
be `(2 * sizeof (float))`. So the @stride is the number of
bytes to move to find the attribute value of the next vertex.

Normally a list of attributes starts at the beginning of an array.
So for the `MyVertex` example above the @offset is the
offset inside the `MyVertex` structure to the first
component of the attribute. For the texture coordinate attribute
the offset would be `offsetof (MyVertex, s)` or instead of
using the offsetof macro you could use `sizeof (float) *
3`.  If you've divided your @array into blocks of non-interleved
attributes then you will need to calculate the @offset as the number of
bytes in blocks preceding the attribute you're describing.

An attribute often has more than one component. For example a color
is often comprised of 4 red, green, blue and alpha @components, and a
position may be comprised of 2 x and y @components. You should aim
to keep the number of components to a minimum as more components
means more data needs to be mapped into the GPU which can be a
bottleneck when dealing with a large number of vertices.

Finally you need to specify the component data type. Here you
should aim to use the smallest type that meets your precision
requirements. Again the larger the type then more data needs to be
mapped into the GPU which can be a bottleneck when dealing with
a large number of vertices.</doc>
        <source-position filename="cogl/cogl/cogl-attribute.h" line="142"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-attribute.h"
               line="135">A newly allocated #CoglAttribute
         describing the layout for a list of attribute values
         stored in @array.</doc>
          <type name="Attribute" c:type="CoglAttribute*"/>
        </return-value>
        <parameters>
          <parameter name="attribute_buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="58">The #CoglAttributeBuffer containing the actual
                   attribute data</doc>
            <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="60">The name of the attribute (used to reference it from GLSL)</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="stride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="61">The number of bytes to jump to get to the next attribute
         value for the next vertex. (Usually
         `sizeof (MyVertex)`)</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="64">The byte offset from the start of @attribute_buffer for
         the first attribute value. (Usually
         `offsetof (MyVertex, component0)`</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="67">The number of components (e.g. 4 for an rgba color or
             3 for and (x,y,z) position)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="69">FIXME</doc>
            <type name="AttributeType" c:type="CoglAttributeType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_buffer" c:identifier="cogl_attribute_get_buffer">
        <source-position filename="cogl/cogl/cogl-attribute.h" line="176"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-attribute.h"
               line="172">the #CoglAttributeBuffer that was
       set with cogl_attribute_new().</doc>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="170">A #CoglAttribute</doc>
            <type name="Attribute" c:type="CoglAttribute*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_normalized"
              c:identifier="cogl_attribute_set_normalized">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-attribute.h"
             line="149">Sets whether fixed point attribute types are mapped to the range
0â†’1. For example when this property is TRUE and a
%COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE type is used then the value 255
will be mapped to 1.0.

The default value of this property depends on the name of the
attribute. For the builtin properties cogl_color_in and
cogl_normal_in it will default to TRUE and for all other names it
will default to FALSE.</doc>
        <source-position filename="cogl/cogl/cogl-attribute.h" line="165"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="attribute" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="151">A #CoglAttribute</doc>
            <type name="Attribute" c:type="CoglAttribute*"/>
          </instance-parameter>
          <parameter name="normalized" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute.h"
                 line="152">The new value for the normalized property.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <class name="AttributeBuffer"
           c:symbol-prefix="attribute_buffer"
           c:type="CoglAttributeBuffer"
           parent="Buffer"
           final="1"
           glib:type-name="CoglAttributeBuffer"
           glib:get-type="cogl_attribute_buffer_get_type"
           glib:type-struct="AttributeBufferClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-attribute-buffer.h"
           line="46">Functions for creating and manipulating attribute buffers</doc>
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="59"/>
      <constructor name="new" c:identifier="cogl_attribute_buffer_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-attribute-buffer.h"
             line="91">Describes a new #CoglAttributeBuffer of @size bytes to contain
arrays of vertex attribute data and also uploads @size bytes read
from @data to the new buffer.

You should never pass a %NULL data pointer.

This function does not report out-of-memory errors back to
the caller by returning %NULL and so you can assume this function
always succeeds.

In the unlikely case that there is an out of memory problem
then Cogl will abort the application with a message. If your
application needs to gracefully handle out-of-memory errors then
you can use cogl_attribute_buffer_new_with_size() and then
explicitly catch errors with cogl_buffer_set_data() or
cogl_buffer_map().</doc>
        <source-position filename="cogl/cogl/cogl-attribute-buffer.h"
                         line="118"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-attribute-buffer.h"
               line="115">A newly allocated #CoglAttributeBuffer (never %NULL)</doc>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute-buffer.h"
                 line="93">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute-buffer.h"
                 line="94">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute-buffer.h"
                 line="95">An optional
       pointer to vertex data to upload immediately.</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_attribute_buffer_new_with_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-attribute-buffer.h"
             line="66">Describes a new #CoglAttributeBuffer of @size bytes to contain
arrays of vertex attribute data. Afterwards data can be set using
cogl_buffer_set_data() or by mapping it into the application's
address space using cogl_buffer_map().

The underlying storage of this buffer isn't allocated by this
function so that you have an opportunity to use the
cogl_buffer_set_update_hint()
functions which may influence how the storage is allocated. The
storage will be allocated once you upload data to the buffer.

Note: You can assume this function always succeeds and won't return
%NULL</doc>
        <source-position filename="cogl/cogl/cogl-attribute-buffer.h"
                         line="88"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-attribute-buffer.h"
               line="85">A newly allocated #CoglAttributeBuffer. Never %NULL.</doc>
          <type name="AttributeBuffer" c:type="CoglAttributeBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute-buffer.h"
                 line="68">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-attribute-buffer.h"
                 line="69">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <record name="AttributeBufferClass"
            c:type="CoglAttributeBufferClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="AttributeBuffer">
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="59"/>
    </record>
    <record name="AttributeClass"
            c:type="CoglAttributeClass"
            glib:is-gtype-struct-for="Attribute">
      <source-position filename="cogl/cogl/cogl-attribute.h" line="50"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="AttributeType"
                 glib:type-name="CoglAttributeType"
                 glib:get-type="cogl_attribute_type_get_type"
                 c:type="CoglAttributeType">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="103">Data types for the components of a vertex attribute.</doc>
      <member name="byte"
              value="5120"
              c:identifier="COGL_ATTRIBUTE_TYPE_BYTE"
              glib:nick="byte"
              glib:name="COGL_ATTRIBUTE_TYPE_BYTE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="105">Data is the same size of a byte</doc>
      </member>
      <member name="unsigned_byte"
              value="5121"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE"
              glib:nick="unsigned-byte"
              glib:name="COGL_ATTRIBUTE_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="106">Data is the same size of an
  unsigned byte</doc>
      </member>
      <member name="short"
              value="5122"
              c:identifier="COGL_ATTRIBUTE_TYPE_SHORT"
              glib:nick="short"
              glib:name="COGL_ATTRIBUTE_TYPE_SHORT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="108">Data is the same size of a short integer</doc>
      </member>
      <member name="unsigned_short"
              value="5123"
              c:identifier="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT"
              glib:nick="unsigned-short"
              glib:name="COGL_ATTRIBUTE_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="109">Data is the same size of
  an unsigned short integer</doc>
      </member>
      <member name="float"
              value="5126"
              c:identifier="COGL_ATTRIBUTE_TYPE_FLOAT"
              glib:nick="float"
              glib:name="COGL_ATTRIBUTE_TYPE_FLOAT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="111">Data is the same size of a float</doc>
      </member>
    </enumeration>
    <constant name="BGR_BIT" value="32" c:type="COGL_BGR_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="48"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="BUFFER"
                    c:identifier="COGL_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-buffer.h" line="67"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BUFFER_CLASS"
                    c:identifier="COGL_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-buffer.h" line="69"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BUFFER_CONST"
                    c:identifier="COGL_BUFFER_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-buffer.h" line="68"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BUFFER_GET_CLASS"
                    c:identifier="COGL_BUFFER_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-buffer.h" line="72"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Bitmap"
           c:symbol-prefix="bitmap"
           c:type="CoglBitmap"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglBitmap"
           glib:get-type="cogl_bitmap_get_type"
           glib:type-struct="BitmapClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-bitmap.h"
           line="47">Functions for loading images

Cogl allows loading image data into memory as CoglBitmaps without
loading them immediately into GPU textures.</doc>
      <source-position filename="cogl/cogl/cogl-bitmap.h" line="59"/>
      <constructor name="new_for_data" c:identifier="cogl_bitmap_new_for_data">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="121">Creates a bitmap using some existing data. The data is not copied
so the application must keep the buffer alive for the lifetime of
the #CoglBitmap. This can be used for example with
[method@Cogl.Framebuffer.read_pixels_into_bitmap] to read data directly
into an application buffer with the specified rowstride.</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="141"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="138">A new #CoglBitmap.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="123">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="124">The width of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="125">The height of the bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="126">The format of the pixel data.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="127">The rowstride of the bitmap (the number of bytes from
  the start of one row of the bitmap to the next).</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="129">A pointer to the data. The bitmap will take
  ownership of this data.</doc>
            <array zero-terminated="0" c:type="uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_buffer"
                   c:identifier="cogl_bitmap_new_from_buffer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="65">Wraps some image data that has been uploaded into a #CoglBuffer as
a #CoglBitmap. The data is not copied in this process.</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="82"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="79">a #CoglBitmap encapsulating the given @buffer.</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="67">A #CoglBuffer containing image data</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="68">The #CoglPixelFormat defining the format of the image data
         in the given @buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="70">The width of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="71">The height of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="72">The rowstride in bytes of the image data in the given @buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="73">The offset into the given @buffer to the first pixel that
         should be considered part of the #CoglBitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_bitmap_new_with_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-bitmap.h"
             line="89">Creates a new #CoglBitmap with the given width, height and format.
The initial contents of the bitmap are undefined.

The data for the bitmap will be stored in a newly created
#CoglPixelBuffer. You can get a pointer to the pixel buffer using
[method@Cogl.Bitmap.get_buffer]. The #CoglBuffer API can then be
used to fill the bitmap with data.

Cogl will try its best to provide a hardware array you can
map, write into and effectively do a zero copy upload when creating
a texture from it with cogl_texture_new_from_bitmap(). For various
reasons, such arrays are likely to have a stride larger than width
* bytes_per_pixel. The user must take the stride into account when
writing into it. The stride can be retrieved with
[method@Cogl.Bitmap.get_rowstride].</doc>
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="116"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="112">a #CoglPixelBuffer representing the
              newly created array or %NULL on failure</doc>
          <type name="Bitmap" c:type="CoglBitmap*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="91">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="92">width of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="93">height of the bitmap in pixels</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="94">the format of the pixels the array will store</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_buffer" c:identifier="cogl_bitmap_get_buffer">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="194"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="190">the #CoglPixelBuffer that this
  buffer uses for storage.</doc>
          <type name="PixelBuffer" c:type="CoglPixelBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="188">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="cogl_bitmap_get_format">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="155"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="152">the #CoglPixelFormat that the data for the bitmap is in.</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="150">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_bitmap_get_height">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="173"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="170">the height of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="168">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rowstride" c:identifier="cogl_bitmap_get_rowstride">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="184"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="179">the rowstride of the bitmap. This is the number of
  bytes between the address of start of one row to the address of the
  next row in the image.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="177">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_bitmap_get_width">
        <source-position filename="cogl/cogl/cogl-bitmap.h" line="164"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-bitmap.h"
               line="161">the width of the bitmap</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-bitmap.h"
                 line="159">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="BitmapClass"
            c:type="CoglBitmapClass"
            glib:is-gtype-struct-for="Bitmap">
      <source-position filename="cogl/cogl/cogl-bitmap.h" line="59"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="Buffer"
           c:symbol-prefix="buffer"
           c:type="CoglBuffer"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CoglBuffer"
           glib:get-type="cogl_buffer_get_type"
           glib:type-struct="BufferClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-buffer.h"
           line="45">Common buffer functions, including data upload APIs

The CoglBuffer API provides a common interface to manipulate
buffers that have been allocated either via `cogl_pixel_buffer_new()`
or `cogl_attribute_buffer_new()`. The API allows you to upload data
to these buffers and define usage hints that help Cogl manage your
buffer optimally.

Data can either be uploaded by supplying a pointer and size so Cogl
can copy your data, or you can mmap() a CoglBuffer and then you can
copy data to the buffer directly.

One of the most common uses for CoglBuffers is to upload texture
data asynchronously since the ability to mmap the buffers into
the CPU makes it possible for another thread to handle the IO
of loading an image file and unpacking it into the mapped buffer
without blocking other Cogl operations.</doc>
      <source-position filename="cogl/cogl/cogl-buffer.h" line="74"/>
      <method name="get_size" c:identifier="cogl_buffer_get_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="81">Retrieves the size of buffer</doc>
        <source-position filename="cogl/cogl/cogl-buffer.h" line="90"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-buffer.h"
               line="87">the size of the buffer in bytes</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="83">a buffer object</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_update_hint"
              c:identifier="cogl_buffer_get_update_hint">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="121">Retrieves the update hints set using [method@Cogl.Buffer.set_update_hint]</doc>
        <source-position filename="cogl/cogl/cogl-buffer.h" line="130"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-buffer.h"
               line="127">the #CoglBufferUpdateHint currently used by the buffer</doc>
          <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="123">a buffer object</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="cogl_buffer_map">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="182">Maps the buffer into the application address space for direct
access. This is equivalent to calling [method@Cogl.Buffer.map_range] with
zero as the offset and the size of the entire buffer as the size.

It is strongly recommended that you pass
%COGL_BUFFER_MAP_HINT_DISCARD as a hint if you are going to replace
all the buffer's data. This way if the buffer is currently being
used by the GPU then the driver won't have to stall the CPU and
wait for the hardware to finish because it can instead allocate a
new buffer to map.

The behaviour is undefined if you access the buffer in a way
conflicting with the @access mask you pass. It is also an error to
release your last reference while the buffer is mapped.</doc>
        <source-position filename="cogl/cogl/cogl-buffer.h" line="208"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-buffer.h"
               line="204">A pointer to the mapped memory or
       %NULL is the call fails</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="184">a buffer object</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </instance-parameter>
          <parameter name="access" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="185">how the mapped buffer will be used by the application</doc>
            <type name="BufferAccess" c:type="CoglBufferAccess"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="186">A mask of `CoglBufferMapHint`s that tell Cogl how
  the data will be modified once mapped.</doc>
            <type name="BufferMapHint" c:type="CoglBufferMapHint"/>
          </parameter>
        </parameters>
      </method>
      <method name="map_range" c:identifier="cogl_buffer_map_range" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="212">Maps a sub-region of the buffer into the application's address space
for direct access.

It is strongly recommended that you pass
%COGL_BUFFER_MAP_HINT_DISCARD as a hint if you are going to replace
all the buffer's data. This way if the buffer is currently being
used by the GPU then the driver won't have to stall the CPU and
wait for the hardware to finish because it can instead allocate a
new buffer to map. You can pass
%COGL_BUFFER_MAP_HINT_DISCARD_RANGE instead if you want the
regions outside of the mapping to be retained.

The behaviour is undefined if you access the buffer in a way
conflicting with the @access mask you pass. It is also an error to
release your last reference while the buffer is mapped.</doc>
        <source-position filename="cogl/cogl/cogl-buffer.h" line="242"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-buffer.h"
               line="238">A pointer to the mapped memory or
       %NULL is the call fails</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="214">a buffer object</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="215">Offset within the buffer to start the mapping</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="216">The size of data to map</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="access" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="217">how the mapped buffer will be used by the application</doc>
            <type name="BufferAccess" c:type="CoglBufferAccess"/>
          </parameter>
          <parameter name="hints" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="218">A mask of `CoglBufferMapHint`s that tell Cogl how
  the data will be modified once mapped.</doc>
            <type name="BufferMapHint" c:type="CoglBufferMapHint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="cogl_buffer_set_data">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="258">Updates part of the buffer with new data from @data. Where to put this new
data is controlled by @offset and @offset + @data should be less than the
buffer size.</doc>
        <source-position filename="cogl/cogl/cogl-buffer.h" line="273"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-buffer.h"
               line="270">%TRUE is the operation succeeded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="260">a buffer object</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="261">destination offset (in bytes) in the buffer</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="262">a pointer to the data to be copied
  into the buffer</doc>
            <array zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="264">number of bytes to copy</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_update_hint"
              c:identifier="cogl_buffer_set_update_hint"
              glib:set-property="update-hint">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="109">Sets the update hint on a buffer. See #CoglBufferUpdateHint for a description
of the available hints.</doc>
        <source-position filename="cogl/cogl/cogl-buffer.h" line="118"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="111">a buffer object</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </instance-parameter>
          <parameter name="hint" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="112">the new hint</doc>
            <type name="BufferUpdateHint" c:type="CoglBufferUpdateHint"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmap" c:identifier="cogl_buffer_unmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="249">Unmaps a buffer previously mapped by [method@Cogl.Buffer.map].</doc>
        <source-position filename="cogl/cogl/cogl-buffer.h" line="256"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-buffer.h"
                 line="251">a buffer object</doc>
            <type name="Buffer" c:type="CoglBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="context"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Context"/>
      </property>
      <property name="default-target"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="COGL_BUFFER_BIND_TARGET_PIXEL_PACK">
        <type name="BufferBindTarget"/>
      </property>
      <property name="impl"
                introspectable="0"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type/>
      </property>
      <property name="size"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="update-hint"
                readable="0"
                writable="1"
                construct="1"
                transfer-ownership="none"
                setter="set_update_hint"
                default-value="COGL_BUFFER_UPDATE_HINT_STATIC">
        <type name="BufferUpdateHint"/>
      </property>
    </class>
    <bitfield name="BufferAccess"
              glib:type-name="CoglBufferAccess"
              glib:get-type="cogl_buffer_access_get_type"
              c:type="CoglBufferAccess">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-buffer.h"
           line="132">The access hints for [method@Cogl.Buffer.set_update_hint]</doc>
      <member name="read"
              value="1"
              c:identifier="COGL_BUFFER_ACCESS_READ"
              glib:nick="read"
              glib:name="COGL_BUFFER_ACCESS_READ">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="134">the buffer will be read</doc>
      </member>
      <member name="write"
              value="2"
              c:identifier="COGL_BUFFER_ACCESS_WRITE"
              glib:nick="write"
              glib:name="COGL_BUFFER_ACCESS_WRITE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="135">the buffer will written to</doc>
      </member>
      <member name="read_write"
              value="3"
              c:identifier="COGL_BUFFER_ACCESS_READ_WRITE"
              glib:nick="read-write"
              glib:name="COGL_BUFFER_ACCESS_READ_WRITE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="136">the buffer will be used for both reading and
  writing</doc>
      </member>
    </bitfield>
    <enumeration name="BufferBindTarget"
                 glib:type-name="CoglBufferBindTarget"
                 glib:get-type="cogl_buffer_bind_target_get_type"
                 c:type="CoglBufferBindTarget">
      <member name="pixel_pack"
              value="0"
              c:identifier="COGL_BUFFER_BIND_TARGET_PIXEL_PACK"
              glib:nick="pixel-pack"
              glib:name="COGL_BUFFER_BIND_TARGET_PIXEL_PACK">
      </member>
      <member name="pixel_unpack"
              value="1"
              c:identifier="COGL_BUFFER_BIND_TARGET_PIXEL_UNPACK"
              glib:nick="pixel-unpack"
              glib:name="COGL_BUFFER_BIND_TARGET_PIXEL_UNPACK">
      </member>
      <member name="attribute_buffer"
              value="2"
              c:identifier="COGL_BUFFER_BIND_TARGET_ATTRIBUTE_BUFFER"
              glib:nick="attribute-buffer"
              glib:name="COGL_BUFFER_BIND_TARGET_ATTRIBUTE_BUFFER">
      </member>
      <member name="index_buffer"
              value="3"
              c:identifier="COGL_BUFFER_BIND_TARGET_INDEX_BUFFER"
              glib:nick="index-buffer"
              glib:name="COGL_BUFFER_BIND_TARGET_INDEX_BUFFER">
      </member>
      <member name="count"
              value="4"
              c:identifier="COGL_BUFFER_BIND_TARGET_COUNT"
              glib:nick="count"
              glib:name="COGL_BUFFER_BIND_TARGET_COUNT">
      </member>
    </enumeration>
    <bitfield name="BufferBit"
              glib:type-name="CoglBufferBit"
              glib:get-type="cogl_buffer_bit_get_type"
              c:type="CoglBufferBit">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="288">Types of auxiliary buffers</doc>
      <member name="color"
              value="1"
              c:identifier="COGL_BUFFER_BIT_COLOR"
              glib:nick="color"
              glib:name="COGL_BUFFER_BIT_COLOR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="290">Selects the primary color buffer</doc>
      </member>
      <member name="depth"
              value="2"
              c:identifier="COGL_BUFFER_BIT_DEPTH"
              glib:nick="depth"
              glib:name="COGL_BUFFER_BIT_DEPTH">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="291">Selects the depth buffer</doc>
      </member>
      <member name="stencil"
              value="4"
              c:identifier="COGL_BUFFER_BIT_STENCIL"
              glib:nick="stencil"
              glib:name="COGL_BUFFER_BIT_STENCIL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="292">Selects the stencil buffer</doc>
      </member>
    </bitfield>
    <record name="BufferClass"
            c:type="CoglBufferClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Buffer">
      <source-position filename="cogl/cogl/cogl-buffer.h" line="74"/>
    </record>
    <bitfield name="BufferMapHint"
              glib:type-name="CoglBufferMapHint"
              glib:get-type="cogl_buffer_map_hint_get_type"
              c:type="CoglBufferMapHint">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-buffer.h"
           line="149">Hints to Cogl about how you are planning to modify the data once it
is mapped.</doc>
      <member name="discard"
              value="1"
              c:identifier="COGL_BUFFER_MAP_HINT_DISCARD"
              glib:nick="discard"
              glib:name="COGL_BUFFER_MAP_HINT_DISCARD">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="151">Tells Cogl that you plan to replace
   all the buffer's contents. When this flag is used to map a
   buffer, the entire contents of the buffer become undefined, even
   if only a subregion of the buffer is mapped.</doc>
      </member>
      <member name="discard_range"
              value="2"
              c:identifier="COGL_BUFFER_MAP_HINT_DISCARD_RANGE"
              glib:nick="discard-range"
              glib:name="COGL_BUFFER_MAP_HINT_DISCARD_RANGE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="155">Tells Cogl that you plan to
   replace all the contents of the mapped region. The contents of
   the region specified are undefined after this flag is used to
   map a buffer.</doc>
      </member>
    </bitfield>
    <enumeration name="BufferUpdateHint"
                 glib:type-name="CoglBufferUpdateHint"
                 glib:get-type="cogl_buffer_update_hint_get_type"
                 c:type="CoglBufferUpdateHint">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-buffer.h"
           line="92">The update hint on a buffer allows the user to give some detail on how often
the buffer data is going to be updated.</doc>
      <member name="static"
              value="0"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STATIC"
              glib:nick="static"
              glib:name="COGL_BUFFER_UPDATE_HINT_STATIC">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="94">the buffer will not change over time</doc>
      </member>
      <member name="dynamic"
              value="1"
              c:identifier="COGL_BUFFER_UPDATE_HINT_DYNAMIC"
              glib:nick="dynamic"
              glib:name="COGL_BUFFER_UPDATE_HINT_DYNAMIC">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="95">the buffer will change from time to time</doc>
      </member>
      <member name="stream"
              value="2"
              c:identifier="COGL_BUFFER_UPDATE_HINT_STREAM"
              glib:nick="stream"
              glib:name="COGL_BUFFER_UPDATE_HINT_STREAM">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-buffer.h"
             line="96">the buffer will be used once or a couple of
  times</doc>
      </member>
    </enumeration>
    <function-macro name="COLOR_INIT"
                    c:identifier="COGL_COLOR_INIT"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="60">A macro that initializes a #CoglColor, to be used when declaring it.</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="69"/>
      <parameters>
        <parameter name="_r">
        </parameter>
        <parameter name="_g">
        </parameter>
        <parameter name="_b">
        </parameter>
        <parameter name="_a">
        </parameter>
      </parameters>
    </function-macro>
    <record name="Color"
            c:type="CoglColor"
            glib:type-name="CoglColor"
            glib:get-type="cogl_color_get_type"
            c:symbol-prefix="color">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="44">A generic color definition

#CoglColor is a simple structure holding the definition of a color such
that it can be efficiently used by GL</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="59"/>
      <field name="red" writable="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="green" writable="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="blue" writable="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="alpha" writable="1">
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <method name="copy" c:identifier="cogl_color_copy">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="87">Creates a copy of @color</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="97"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="93">a newly-allocated #CoglColor. Use cogl_color_free()
  to free the allocate resources</doc>
          <type name="Color" c:type="CoglColor*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="89">the color to copy</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="equal" c:identifier="cogl_color_equal">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="244">Compares two `CoglColor`s and checks if they are the same.

This function can be passed to g_hash_table_new() as the @key_equal_func
parameter, when using `CoglColor`s as keys in a #GHashTable.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="257"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="254">%TRUE if the two colors are the same.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="v1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="246">a #CoglColor</doc>
            <type name="Color" c:type="void*"/>
          </instance-parameter>
          <parameter name="v2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="247">a #CoglColor</doc>
            <type name="Color" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="cogl_color_free" introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="99">Frees the resources allocated by cogl_color_new() and cogl_color_copy()</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="106"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="101">the color to free</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha" c:identifier="cogl_color_get_alpha">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="221">Retrieves the alpha channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="231"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="228">the alpha channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="223">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue" c:identifier="cogl_color_get_blue">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="209">Retrieves the blue channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="219"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="216">the blue channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="211">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green" c:identifier="cogl_color_get_green">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="197">Retrieves the green channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="207"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="204">the green channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="199">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_red" c:identifier="cogl_color_get_red">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="185">Retrieves the red channel of @color as a fixed point
value between 0 and 1.0.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="195"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="192">the red channel of the passed color</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="187">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="hash" c:identifier="cogl_color_hash">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="260">Converts a #CoglColor to a hash value.

This function can be passed to g_hash_table_new() as the @hash_func
parameter, when using `CoglColor`s as keys in a #GHashTable.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="272"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="269">a hash value corresponding to the color</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="v" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="262">a #CoglColor</doc>
            <type name="Color" c:type="gconstpointer"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_from_4f" c:identifier="cogl_color_init_from_4f">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="168">Sets the values of the passed channels into a #CoglColor</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="179"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="170">A pointer to a #CoglColor to initialize</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="171">value of the red channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="172">value of the green channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="173">value of the blue channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="174">value of the alpha channel, between 0 and 1.0</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="premultiply" c:identifier="cogl_color_premultiply">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="233">Converts a non-premultiplied color to a pre-multiplied color. For
example, semi-transparent red is (1.0, 0, 0, 0.5) when non-premultiplied
and (0.5, 0, 0, 0.5) when premultiplied.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="242"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="235">the color to premultiply</doc>
            <type name="Color" c:type="CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="to_hsl" c:identifier="cogl_color_to_hsl">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="274">Converts @color to the HLS format.

The @hue value is in the 0 .. 360 range. The @luminance and
@saturation values are in the 0 .. 1 range.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="287"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="276">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
          <parameter name="hue"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="277">return location for the hue value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="saturation"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="278">return location for the saturation value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="luminance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="279">return location for the luminance value or %NULL</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="to_string" c:identifier="cogl_color_to_string">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="109">Returns a textual specification of @color in the hexadecimal form
`&amp;num;rrggbbaa`, where `r`, `g`, `b` and `a` are
hexadecimal digits representing the red, green, blue and alpha components
respectively.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="121"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="118">a newly-allocated text string</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="111">a #CoglColor</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="from_string" c:identifier="cogl_color_from_string">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="123">Parses a string definition of a color, filling the #CoglColor.red,
#CoglColor.green, #CoglColor.blue and #CoglColor.alpha fields
of @color.

The @color is not allocated.

The format of @str can be either one of:

  - an hexadecimal value in the form: `#rgb`, `#rrggbb`, `#rgba`, or `#rrggbbaa`
  - a RGB color in the form: `rgb(r, g, b)`
  - a RGB color in the form: `rgba(r, g, b, a)`
  - a HSL color in the form: `hsl(h, s, l)`
   -a HSL color in the form: `hsla(h, s, l, a)`

where 'r', 'g', 'b' and 'a' are (respectively) the red, green, blue color
intensities and the opacity. The 'h', 's' and 'l' are (respectively) the
hue, saturation and luminance values.

In the rgb() and rgba() formats, the 'r', 'g', and 'b' values are either
integers between 0 and 255, or percentage values in the range between 0%
and 100%; the percentages require the '%' character. The 'a' value, if
specified, can only be a floating point value between 0.0 and 1.0.

In the hls() and hlsa() formats, the 'h' value (hue) is an angle between
0 and 360.0 degrees; the 'l' and 's' values (luminance and saturation) are
percentage values in the range between 0% and 100%. The 'a' value, if specified,
can only be a floating point value between 0.0 and 1.0.

Whitespace inside the definitions is ignored; no leading whitespace
is allowed.

If the alpha component is not specified then it is assumed to be set to
be fully opaque.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="165"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="162">%TRUE if parsing succeeded, and %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="125">return location for a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
          <parameter name="str" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="126">a string specifying a color</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </function>
      <function name="init_from_hsl" c:identifier="cogl_color_init_from_hsl">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="292">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
        <source-position filename="cogl/cogl/cogl-color.h" line="303"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="294">return location for a #CoglColor</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
          <parameter name="hue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="295">hue value, in the 0 .. 360 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="saturation" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="296">saturation value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="luminance" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-color.h"
                 line="297">luminance value, in the 0 .. 1 range</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <class name="Context"
           c:symbol-prefix="context"
           c:type="CoglContext"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglContext"
           glib:get-type="cogl_context_get_type"
           glib:type-struct="ContextClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="53">The top level application context.

A #CoglContext is the top most sandbox of Cogl state for an
application or toolkit. Its main purpose is to act as a sandbox
for the memory management of state objects. Normally an application
will only create a single context since there is no way to share
resources between contexts.

For those familiar with OpenGL or perhaps Cairo it should be
understood that unlike these APIs a Cogl context isn't a rendering
context as such. In other words Cogl doesn't aim to provide a state
machine style model for configuring rendering parameters. Most
rendering state in Cogl is directly associated with user managed
objects called pipelines and geometry is drawn with a specific
pipeline object to a framebuffer object and those 3 things fully
define the state for drawing. This is an important part of Cogl's
design since it helps you write orthogonal rendering components
that can all access the same GPU without having to worry about
what state other components have left you with.

Cogl does not maintain internal references to the context for
resources that depend on the context so applications. This is to
help applications control the lifetime a context without us needing to
introduce special api to handle the breakup of internal circular
references due to internal resources and caches associated with the
context.

One a context has been destroyed then all directly or indirectly
dependent resources will be in an inconsistent state and should not
be manipulated or queried in any way.

For applications that rely on the operating system to clean up
resources this policy shouldn't affect them, but for applications
that need to carefully destroy and re-create Cogl contexts multiple
times throughout their lifetime (such as Android applications) they
should be careful to destroy all context dependent resources, such as
framebuffers or textures etc before unrefing and destroying the
context.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="99"/>
      <constructor name="new" c:identifier="cogl_context_new" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="105">Creates a new #CoglContext which acts as an application sandbox
for any state objects that are allocated.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="116"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="113">A newly allocated #CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <parameter name="display"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="107">A #CoglDisplay pointer</doc>
            <type name="Display" c:type="CoglDisplay*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="flush" c:identifier="cogl_context_flush">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="345">This function should only need to be called in exceptional circumstances.

As an optimization Cogl drawing functions may batch up primitives
internally, so if you are trying to use raw GL outside of Cogl you stand a
better chance of being successful if you ask Cogl to flush any batched
geometry before making your state changes.

It only ensure that the underlying driver is issued all the commands
necessary to draw the batched primitives. It provides no guarantees about
when the driver will complete the rendering.

This provides no guarantees about the GL state upon returning and to avoid
confusing Cogl you should aim to restore any changes you make before
resuming use of Cogl.

If you are making state changes with the intention of affecting Cogl drawing
primitives you are 100% on your own since you stand a good chance of
conflicting with Cogl internals. For example clutter-gst which currently
uses direct GL calls to bind ARBfp programs will very likely break when Cogl
starts to use ARBfb programs itself for the pipeline API.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="371"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="347">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_timestamp_query"
              c:identifier="cogl_context_free_timestamp_query">
        <source-position filename="cogl/cogl/cogl-context.h" line="309"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="305">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="306">a #CoglTimestampQuery</doc>
            <type name="TimestampQuery" c:type="CoglTimestampQuery*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_display" c:identifier="cogl_context_get_display">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="119">Retrieves the #CoglDisplay that is internally associated with the
given @context. This will return the same #CoglDisplay that was
passed to cogl_context_new() or if %NULL was passed to
cogl_context_new() then this function returns a pointer to the
display that was automatically setup internally.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="133"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="129">The #CoglDisplay associated with the
              given @context.</doc>
          <type name="Display" c:type="CoglDisplay*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="121">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gpu_time_ns"
              c:identifier="cogl_context_get_gpu_time_ns">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="316">This function should only be called if the COGL_FEATURE_ID_TIMESTAMP_QUERY
feature is advertised.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="326"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="323">Current GPU time in nanoseconds</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="318">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_graphics_reset_status"
              c:identifier="cogl_context_get_graphics_reset_status">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="245">Returns the graphics reset status as reported by
GetGraphicsResetStatusARB defined in the ARB_robustness extension.

Note that Cogl doesn't normally enable the ARB_robustness
extension in which case this will only ever return
#COGL_GRAPHICS_RESET_STATUS_NO_ERROR.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="259"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="256">a #CoglGraphicsResetStatus</doc>
          <type name="GraphicsResetStatus" c:type="CoglGraphicsResetStatus"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="247">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_latest_sync_fd"
              c:identifier="cogl_context_get_latest_sync_fd">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="328">This function is used to get support for waiting on previous
GPU work through sync fds. It will return a sync fd which will
signal when the previous work has completed.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="340"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="336">sync fd for latest GPU submission if available,
returns -1 if not.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="330">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_named_pipeline"
              c:identifier="cogl_context_get_named_pipeline">
        <source-position filename="cogl/cogl/cogl-context.h" line="300"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="295">The #CoglPipeline associated with the
              given @context and @key, or %NULL if no such #CoglPipeline
              was found.</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="292">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="293">a #CoglPipelineKey pointer</doc>
            <type name="PipelineKey" c:type="CoglPipelineKey*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_rectangle_indices"
              c:identifier="cogl_context_get_rectangle_indices">
        <source-position filename="cogl/cogl/cogl-context.h" line="379"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="376">a #CoglIndices</doc>
          <type name="Indices" c:type="CoglIndices*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_renderer" c:identifier="cogl_context_get_renderer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="135">Retrieves the #CoglRenderer that is internally associated with the
given @context. This will return the same #CoglRenderer that was
passed to cogl_display_new() or if %NULL was passed to
cogl_display_new() or cogl_context_new() then this function returns
a pointer to the renderer that was automatically connected
internally.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="150"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="146">The #CoglRenderer associated with the
              given @context.</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="137">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_feature" c:identifier="cogl_context_has_feature">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="204">Checks if a given @feature is currently available

Cogl does not aim to be a lowest common denominator API, it aims to
expose all the interesting features of GPUs to application which
means applications have some responsibility to explicitly check
that certain features are available before depending on them.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="216">%TRUE if the @feature is currently supported or %FALSE if
not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="206">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="207">A #CoglFeatureID</doc>
            <type name="FeatureID" c:type="CoglFeatureID"/>
          </parameter>
        </parameters>
      </method>
      <method name="has_winsys_feature"
              c:identifier="cogl_context_has_winsys_feature">
        <source-position filename="cogl/cogl/cogl-context.h" line="343"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="feature" transfer-ownership="none">
            <type name="WinsysFeature" c:type="CoglWinsysFeature"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_hardware_accelerated"
              c:identifier="cogl_context_is_hardware_accelerated">
        <source-position filename="cogl/cogl/cogl-context.h" line="269"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-context.h"
               line="265">%TRUE if the @context is hardware accelerated, or %FALSE if
not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="263">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_named_pipeline"
              c:identifier="cogl_context_set_named_pipeline">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="273">Associate a #CoglPipeline with a @context and @key. This will not take a new
reference to the @pipeline, but will unref all associated pipelines when
the @context gets destroyed. Similarly, if a pipeline gets overwritten,
it will get unreffed as well.</doc>
        <source-position filename="cogl/cogl/cogl-context.h" line="286"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="275">a #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="276">a #CoglPipelineKey pointer</doc>
            <type name="PipelineKey" c:type="CoglPipelineKey*"/>
          </parameter>
          <parameter name="pipeline"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-context.h"
                 line="277">a #CoglPipeline to associate with the @context and
           @key</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
        </parameters>
      </method>
      <method name="timestamp_query_get_time_ns"
              c:identifier="cogl_context_timestamp_query_get_time_ns">
        <source-position filename="cogl/cogl/cogl-context.h" line="313"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="TimestampQuery" c:type="CoglTimestampQuery*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="ContextClass"
            c:type="CoglContextClass"
            glib:is-gtype-struct-for="Context">
      <source-position filename="cogl/cogl/cogl-context.h" line="99"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <function-macro name="DEPRECATED_FOR"
                    c:identifier="COGL_DEPRECATED_FOR"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-macros.h" line="44"/>
      <parameters>
        <parameter name="f">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="DEPTH_BIT" value="256" c:type="COGL_DEPTH_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="51"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <record name="DepthState" c:type="CoglDepthState">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-depth-state.h"
           line="41">Functions for describing the depth testing state of your GPU.</doc>
      <source-position filename="cogl/cogl/cogl-depth-state.h" line="55"/>
      <field name="private_member_magic" readable="0" private="1">
        <type name="guint32" c:type="uint32_t"/>
      </field>
      <field name="private_member_test_enabled" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="private_member_test_function" readable="0" private="1">
        <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
      </field>
      <field name="private_member_write_enabled" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="private_member_range_near" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="private_member_range_far" readable="0" private="1">
        <type name="gfloat" c:type="float"/>
      </field>
      <method name="init" c:identifier="cogl_depth_state_init">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-depth-state.h"
             line="57">Initializes the members of @state to their default values.

You should never pass an un initialized #CoglDepthState structure
to cogl_pipeline_set_depth_state().</doc>
        <source-position filename="cogl/cogl/cogl-depth-state.h" line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="59">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_range" c:identifier="cogl_depth_state_set_range">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-depth-state.h"
             line="136">Sets the range to map depth values in normalized device coordinates
to before writing out to a depth buffer.

After your geometry has be transformed, clipped and had perspective
division applied placing it in normalized device
coordinates all depth values between the near and far z clipping
planes are in the range -1 to 1. Before writing any depth value to
the depth buffer though the value is mapped into the range [0, 1].

With this function you can change the range which depth values are
mapped too although the range must still lye within the range [0,
1].

By default normalized device coordinate depth values are mapped to
the full range of depth buffer values, [0, 1].

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state().</doc>
        <source-position filename="cogl/cogl/cogl-depth-state.h" line="165"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="138">A #CoglDepthState object</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="near_val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="139">The near component of the desired depth range which will be
clamped to the range [0, 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far_val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="141">The far component of the desired depth range which will be
clamped to the range [0, 1]</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_test_enabled"
              c:identifier="cogl_depth_state_set_test_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-depth-state.h"
             line="69">Enables or disables depth testing according to the value of
@enable.

If depth testing is enable then the #CoglDepthTestFunction set
using cogl_depth_state_set_test_function() us used to evaluate
the depth value of incoming fragments against the corresponding
value stored in the current depth buffer, and if the test passes
then the fragments depth value is used to update the depth buffer.
(unless you have disabled depth writing via
cogl_depth_state_set_write_enabled())

By default depth testing is disabled.

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <source-position filename="cogl/cogl/cogl-depth-state.h" line="92"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="71">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="72">The enable state you want</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_test_function"
              c:identifier="cogl_depth_state_set_test_function">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-depth-state.h"
             line="117">Sets the #CoglDepthTestFunction used to compare the depth value of
an incoming fragment against the corresponding value in the current
depth buffer.

By default the depth test function is %COGL_DEPTH_TEST_FUNCTION_LESS

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <source-position filename="cogl/cogl/cogl-depth-state.h" line="133"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="119">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="function" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="120">The #CoglDepthTestFunction to set</doc>
            <type name="DepthTestFunction" c:type="CoglDepthTestFunction"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_write_enabled"
              c:identifier="cogl_depth_state_set_write_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-depth-state.h"
             line="95">Enables or disables depth buffer writing according to the value of
@enable. Normally when depth testing is enabled and the comparison
between a fragment's depth value and the corresponding depth buffer
value passes then the fragment's depth is written to the depth
buffer unless writing is disabled here.

By default depth writing is enabled

NB: this won't directly affect the state of the GPU. You have
to then set the state on a #CoglPipeline using
cogl_pipeline_set_depth_state()</doc>
        <source-position filename="cogl/cogl/cogl-depth-state.h" line="113"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="97">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-depth-state.h"
                 line="98">The enable state you want</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="DepthTestFunction"
                 glib:type-name="CoglDepthTestFunction"
                 glib:get-type="cogl_depth_test_function_get_type"
                 c:type="CoglDepthTestFunction">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="177">When using depth testing one of these functions is used to compare
the depth of an incoming fragment against the depth value currently
stored in the depth buffer. The function is changed using
cogl_depth_state_set_test_function().

The test is only done when depth testing is explicitly enabled. (See
cogl_depth_state_set_test_enabled())</doc>
      <member name="never"
              value="512"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NEVER"
              glib:nick="never"
              glib:name="COGL_DEPTH_TEST_FUNCTION_NEVER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="179">Never passes.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LESS"
              glib:nick="less"
              glib:name="COGL_DEPTH_TEST_FUNCTION_LESS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="180">Passes if the fragment's depth
value is less than the value currently in the depth buffer.</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_EQUAL"
              glib:nick="equal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_EQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="182">Passes if the fragment's depth
value is equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_LEQUAL"
              glib:nick="lequal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_LEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="184">Passes if the fragment's depth
value is less or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GREATER"
              glib:nick="greater"
              glib:name="COGL_DEPTH_TEST_FUNCTION_GREATER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="186">Passes if the fragment's depth
value is greater than the value currently in the depth buffer.</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL"
              glib:nick="notequal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_NOTEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="188">Passes if the fragment's depth
value is not equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_GEQUAL"
              glib:nick="gequal"
              glib:name="COGL_DEPTH_TEST_FUNCTION_GEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="190">Passes if the fragment's depth
value greater than or equal to the value currently in the depth buffer.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_DEPTH_TEST_FUNCTION_ALWAYS"
              glib:nick="always"
              glib:name="COGL_DEPTH_TEST_FUNCTION_ALWAYS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="192">Always passes.</doc>
      </member>
    </enumeration>
    <class name="Display"
           c:symbol-prefix="display"
           c:type="CoglDisplay"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglDisplay"
           glib:get-type="cogl_display_get_type"
           glib:type-struct="DisplayClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-display.h"
           line="45">Common aspects of a display pipeline

The basic intention for this object is to let the application
configure common display preferences before creating a context, and
there are a few different aspects to this...

Firstly there are options directly relating to the physical display
pipeline that is currently being used including the digital to
analogue conversion hardware and the screens the user sees.

Another aspect is that display options may constrain or affect how
onscreen framebuffers should later be configured. The original
rationale for the display object in fact was to let us handle GLX
and EGLs requirements that framebuffers must be "compatible" with
the config associated with the current context meaning we have to
force the user to describe how they would like to create their
onscreen windows before we can choose a suitable fbconfig and
create a GLContext.</doc>
      <source-position filename="cogl/cogl/cogl-display.h" line="71"/>
      <constructor name="new" c:identifier="cogl_display_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-display.h"
             line="77">Explicitly allocates a new #CoglDisplay object to encapsulate the
common state of the display pipeline that applies to the whole
application.

A @display can only be made for a specific choice of renderer which
is why this takes the @renderer argument.

When a display is first allocated via cogl_display_new() it is in a
mutable configuration mode. It's designed this way so we can
extend the apis available for configuring a display without
requiring huge numbers of constructor arguments.

When you have finished configuring a display object you can
optionally call cogl_display_setup() to explicitly apply the
configuration and check for errors. Alternaitvely you can pass the
display to cogl_context_new() and Cogl will implicitly apply your
configuration but if there are errors then the application will
abort with a message. For simple applications with no fallback
options then relying on the implicit setup can be fine.</doc>
        <source-position filename="cogl/cogl/cogl-display.h" line="105"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-display.h"
               line="101">A newly allocated #CoglDisplay
              object in a mutable configuration mode.</doc>
          <type name="Display" c:type="CoglDisplay*"/>
        </return-value>
        <parameters>
          <parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-display.h"
                 line="79">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_renderer" c:identifier="cogl_display_get_renderer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-display.h"
             line="107">Queries the #CoglRenderer associated with the given @display.</doc>
        <source-position filename="cogl/cogl/cogl-display.h" line="117"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-display.h"
               line="113">The associated #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-display.h"
                 line="109">a #CoglDisplay</doc>
            <type name="Display" c:type="CoglDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="setup" c:identifier="cogl_display_setup" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-display.h"
             line="119">Explicitly sets up the given @display object. Use of this api is
optional since Cogl will internally setup the display if not done
explicitly.

When a display is first allocated via cogl_display_new() it is in a
mutable configuration mode. This allows us to extend the apis
available for configuring a display without requiring huge numbers
of constructor arguments.

Its possible to request a configuration that might not be
supportable on the current system and so this api provides a means
to apply the configuration explicitly but if it fails then an
exception will be returned so you can handle the error gracefully
and perhaps fall back to an alternative configuration.

If you instead rely on Cogl implicitly calling cogl_display_setup()
for you then if there is an error with the configuration you won't
get an opportunity to handle that and the application may abort
with a message.  For simple applications that don't have any
fallback options this behaviour may be fine.</doc>
        <source-position filename="cogl/cogl/cogl-display.h" line="149"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-display.h"
               line="145">Returns %TRUE if there was no error, else it returns
              %FALSE and returns an exception via @error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="display" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-display.h"
                 line="121">a #CoglDisplay</doc>
            <type name="Display" c:type="CoglDisplay*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="DisplayClass"
            c:type="CoglDisplayClass"
            glib:is-gtype-struct-for="Display">
      <source-position filename="cogl/cogl/cogl-display.h" line="71"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <record name="DmaBufHandle"
            c:type="CoglDmaBufHandle"
            disguised="1"
            opaque="1"
            free-function="cogl_dma_buf_handle_free">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="62">An opaque type that tracks the lifetime of a DMA buffer fd. Release
with cogl_dma_buf_handle_free().</doc>
      <source-position filename="cogl/cogl/cogl-types.h" line="68"/>
      <method name="free" c:identifier="cogl_dma_buf_handle_free">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-dma-buf-handle.h"
             line="58">Releases @dmabuf_handle; it is a programming error to release
an already released handle.</doc>
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="66"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-dma-buf-handle.h"
                 line="60">a #CoglDmaBufHandle</doc>
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bpp" c:identifier="cogl_dma_buf_handle_get_bpp">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="147"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_fd" c:identifier="cogl_dma_buf_handle_get_fd">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-dma-buf-handle.h"
             line="96">Retrieves the file descriptor of @dmabuf_handle.</doc>
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="104"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-dma-buf-handle.h"
               line="101">a valid file descriptor</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
          <parameter name="plane" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_framebuffer"
              c:identifier="cogl_dma_buf_handle_get_framebuffer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-dma-buf-handle.h"
             line="85">Retrieves the #CoglFramebuffer, backed by an exported DMABuf buffer,
of @dmabuf_handle.</doc>
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="94"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-dma-buf-handle.h"
               line="91">a #CoglFramebuffer</doc>
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_dma_buf_handle_get_height">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="121"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modifier"
              c:identifier="cogl_dma_buf_handle_get_modifier">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="163"/>
        <return-value transfer-ownership="none">
          <type name="guint64" c:type="uint64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_planes"
              c:identifier="cogl_dma_buf_handle_get_n_planes">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="155"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_offset" c:identifier="cogl_dma_buf_handle_get_offset">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="138"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
          <parameter name="plane" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_stride" c:identifier="cogl_dma_buf_handle_get_stride">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="129"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
          <parameter name="plane" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_dma_buf_handle_get_width">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h"
                         line="113"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="mmap" c:identifier="cogl_dma_buf_handle_mmap" throws="1">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="77"/>
        <return-value transfer-ownership="none" nullable="1">
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="munmap"
              c:identifier="cogl_dma_buf_handle_munmap"
              throws="1">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="81"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="sync_read_end"
              c:identifier="cogl_dma_buf_handle_sync_read_end"
              throws="1">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="73"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="sync_read_start"
              c:identifier="cogl_dma_buf_handle_sync_read_start"
              throws="1">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="69"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="dmabuf_handle" transfer-ownership="none">
            <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="cogl_dma_buf_handle_new"
                introspectable="0">
        <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="45"/>
        <return-value>
          <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
        </return-value>
        <parameters>
          <parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <type name="guint32" c:type="uint32_t"/>
          </parameter>
          <parameter name="modifier" transfer-ownership="none">
            <type name="guint64" c:type="uint64_t"/>
          </parameter>
          <parameter name="n_planes" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="fds" transfer-ownership="none">
            <type name="gint" c:type="int*"/>
          </parameter>
          <parameter name="strides" transfer-ownership="none">
            <type name="guint32" c:type="uint32_t*"/>
          </parameter>
          <parameter name="offsets" transfer-ownership="none">
            <type name="guint32" c:type="uint32_t*"/>
          </parameter>
          <parameter name="bpp" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_func"
                     transfer-ownership="none"
                     scope="async">
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <enumeration name="DriverId" c:type="CoglDriverId">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-renderer.h"
           line="181">Identifiers for underlying hardware drivers that may be used by
Cogl for rendering.</doc>
      <source-position filename="cogl/cogl/cogl-renderer.h" line="197"/>
      <member name="any" value="0" c:identifier="COGL_DRIVER_ID_ANY">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="183">Implies no preference for which driver is used</doc>
      </member>
      <member name="nop" value="1" c:identifier="COGL_DRIVER_ID_NOP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="184">A No-Op driver.</doc>
      </member>
      <member name="gl3" value="2" c:identifier="COGL_DRIVER_ID_GL3">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="185">An OpenGL driver using the core GL 3.1 profile</doc>
      </member>
      <member name="gles2" value="3" c:identifier="COGL_DRIVER_ID_GLES2">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="186">An OpenGL ES 2.0 driver.</doc>
      </member>
    </enumeration>
    <bitfield name="DrmModifierFilter" c:type="CoglDrmModifierFilter">
      <source-position filename="cogl/cogl/cogl-renderer.h" line="47"/>
      <member name="none"
              value="0"
              c:identifier="COGL_DRM_MODIFIER_FILTER_NONE">
      </member>
      <member name="single_plane"
              value="1"
              c:identifier="COGL_DRM_MODIFIER_FILTER_SINGLE_PLANE">
      </member>
      <member name="not_external_only"
              value="2"
              c:identifier="COGL_DRM_MODIFIER_FILTER_NOT_EXTERNAL_ONLY">
      </member>
    </bitfield>
    <bitfield name="EglImageFlags" c:type="CoglEglImageFlags">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="75"/>
      <member name="none" value="0" c:identifier="COGL_EGL_IMAGE_FLAG_NONE">
      </member>
      <member name="no_get_data"
              value="1"
              c:identifier="COGL_EGL_IMAGE_FLAG_NO_GET_DATA">
      </member>
    </bitfield>
    <enumeration name="FeatureID" c:type="CoglFeatureID">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="156">All the capabilities that can vary between different GPUs supported
by Cogl. Applications that depend on any of these features should explicitly
check for them using [method@Cogl.Context.has_feature].</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="201"/>
      <member name="ogl_feature_id_unsigned_int_indices"
              value="0"
              c:identifier="COGL_FEATURE_ID_UNSIGNED_INT_INDICES">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="164">Set if
    %COGL_INDICES_TYPE_UNSIGNED_INT is supported in
    cogl_indices_new().</doc>
      </member>
      <member name="ogl_feature_id_map_buffer_for_read"
              value="1"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_READ">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="167">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including read support.</doc>
      </member>
      <member name="ogl_feature_id_map_buffer_for_write"
              value="2"
              c:identifier="COGL_FEATURE_ID_MAP_BUFFER_FOR_WRITE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="169">Whether cogl_buffer_map() is
    supported with CoglBufferAccess including write support.</doc>
      </member>
      <member name="ogl_feature_id_fence"
              value="3"
              c:identifier="COGL_FEATURE_ID_FENCE">
      </member>
      <member name="ogl_feature_id_texture_rg"
              value="4"
              c:identifier="COGL_FEATURE_ID_TEXTURE_RG">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="158">Support for
   %COGL_TEXTURE_COMPONENTS_RG as the internal components of a
   texture.</doc>
      </member>
      <member name="ogl_feature_id_texture_rgba1010102"
              value="5"
              c:identifier="COGL_FEATURE_ID_TEXTURE_RGBA1010102">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="161">Support for 10bpc RGBA formats</doc>
      </member>
      <member name="ogl_feature_id_texture_half_float"
              value="6"
              c:identifier="COGL_FEATURE_ID_TEXTURE_HALF_FLOAT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="162">Support for half float formats</doc>
      </member>
      <member name="ogl_feature_id_texture_norm16"
              value="7"
              c:identifier="COGL_FEATURE_ID_TEXTURE_NORM16">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="163">Support for 16bpc formats</doc>
      </member>
      <member name="ogl_feature_id_buffer_age"
              value="8"
              c:identifier="COGL_FEATURE_ID_BUFFER_AGE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="171">Available if the age of #CoglOnscreen back
   buffers are tracked and so cogl_onscreen_get_buffer_age() can be
   expected to return age values other than 0.</doc>
      </member>
      <member name="ogl_feature_id_texture_egl_image_external"
              value="9"
              c:identifier="COGL_FEATURE_ID_TEXTURE_EGL_IMAGE_EXTERNAL">
      </member>
      <member name="ogl_feature_id_blit_framebuffer"
              value="10"
              c:identifier="COGL_FEATURE_ID_BLIT_FRAMEBUFFER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-context.h"
             line="174">Whether blitting using
   [method@Cogl.Framebuffer.blit] is supported.
@COGL_FEATURE_ID_SYNC_FD
   cogl_context_get_latest_sync_fd() is supported.</doc>
      </member>
      <member name="ogl_feature_id_timestamp_query"
              value="11"
              c:identifier="COGL_FEATURE_ID_TIMESTAMP_QUERY">
      </member>
      <member name="ogl_feature_id_sync_fd"
              value="12"
              c:identifier="COGL_FEATURE_ID_SYNC_FD">
      </member>
    </enumeration>
    <enumeration name="FilterReturn"
                 glib:type-name="CoglFilterReturn"
                 glib:get-type="cogl_filter_return_get_type"
                 c:type="CoglFilterReturn">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="221">Return values for the #CoglXlibFilterFunc and #CoglWin32FilterFunc functions.</doc>
      <member name="continue"
              value="0"
              c:identifier="COGL_FILTER_CONTINUE"
              glib:nick="continue"
              glib:name="COGL_FILTER_CONTINUE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="223">The event was not handled, continues the
                       processing</doc>
      </member>
      <member name="remove"
              value="1"
              c:identifier="COGL_FILTER_REMOVE"
              glib:nick="remove"
              glib:name="COGL_FILTER_REMOVE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="225">Remove the event, stops the processing</doc>
      </member>
    </enumeration>
    <callback name="FrameCallback" c:type="CoglFrameCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="297">Is a callback that can be registered via
cogl_onscreen_add_frame_callback() to be called when a frame
progresses in some notable way.

Please see the documentation for #CoglFrameEvent and
cogl_onscreen_add_frame_callback() for more details about what
events can be notified.</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="314"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="onscreen" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="299">The onscreen that the frame is associated with</doc>
          <type name="Onscreen" c:type="CoglOnscreen*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="300">A #CoglFrameEvent notifying how the frame has progressed</doc>
          <type name="FrameEvent" c:type="CoglFrameEvent"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="301">The meta information, such as timing information, about
       the frame that has progressed.</doc>
          <type name="FrameInfo" c:type="CoglFrameInfo*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="303">The user pointer passed to
            cogl_onscreen_add_frame_callback()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="FrameClosure"
            c:type="CoglFrameClosure"
            opaque="1"
            glib:type-name="CoglFrameClosure"
            glib:get-type="cogl_frame_closure_get_type"
            c:symbol-prefix="frame_closure">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="319">An opaque type that tracks a #CoglFrameCallback and associated user
data. A #CoglFrameClosure pointer will be returned from
cogl_onscreen_add_frame_callback() and it allows you to remove a
callback later using cogl_onscreen_remove_frame_callback().</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="327"/>
    </record>
    <enumeration name="FrameEvent" c:type="CoglFrameEvent">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-onscreen.h"
           line="263">Identifiers that are passed to #CoglFrameCallback functions
(registered using cogl_onscreen_add_frame_callback()) that
mark the progression of a frame in some way which usually
means that new information will have been accumulated in the
frame's corresponding #CoglFrameInfo object.

The last event that will be sent for a frame will be a
@COGL_FRAME_EVENT_COMPLETE event and so these are a good
opportunity to collect statistics about a frame since the
#CoglFrameInfo should hold the most data at this point.

A frame may not be completed before the next frame can start
so applications should avoid needing to collect all statistics for
a particular frame before they can start a new frame.</doc>
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="295"/>
      <member name="sync" value="1" c:identifier="COGL_FRAME_EVENT_SYNC">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="265">Notifies that the system compositor has
                        acknowledged a frame and is ready for a
                        new frame to be created.</doc>
      </member>
      <member name="complete"
              value="2"
              c:identifier="COGL_FRAME_EVENT_COMPLETE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="268">Notifies that a frame has ended. This
                            is a good time for applications to
                            collect statistics about the frame
                            since the #CoglFrameInfo should hold
                            the most data at this point. No other
                            events should be expected after a
                            @COGL_FRAME_EVENT_COMPLETE event.</doc>
      </member>
    </enumeration>
    <class name="FrameInfo"
           c:symbol-prefix="frame_info"
           c:type="CoglFrameInfo"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglFrameInfo"
           glib:get-type="cogl_frame_info_get_type"
           glib:type-struct="FrameInfoClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-frame-info.h"
           line="47">Frame information.</doc>
      <source-position filename="cogl/cogl/cogl-frame-info.h" line="55"/>
      <method name="get_frame_counter"
              c:identifier="cogl_frame_info_get_frame_counter">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="61">Gets the frame counter for the #CoglOnscreen that corresponds
to this frame.</doc>
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="71"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="68">The frame counter value</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-frame-info.h"
                 line="63">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_global_frame_counter"
              c:identifier="cogl_frame_info_get_global_frame_counter">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="125"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_is_symbolic"
              c:identifier="cogl_frame_info_get_is_symbolic">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="131"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_presentation_time_us"
              c:identifier="cogl_frame_info_get_presentation_time_us">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="73">Gets the presentation time for the frame. This is the time at which
the frame became visible to the user.

The presentation time measured in microseconds, is based on
CLOCK_MONOTONIC.

Some buggy Mesa drivers up to 9.0.1 may
incorrectly report non-monotonic timestamps.</doc>
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="89"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="86">the presentation time for the frame</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-frame-info.h"
                 line="75">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_refresh_rate"
              c:identifier="cogl_frame_info_get_refresh_rate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="106">Gets the refresh rate in Hertz for the output that the frame was on
at the time the frame was presented.

Some platforms can't associate a #CoglOutput with a
#CoglFrameInfo object but are able to report a refresh rate via
this api. Therefore if you need this information then this api is
more reliable than using cogl_frame_info_get_output() followed by
cogl_output_get_refresh_rate().</doc>
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="122"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="119">the refresh rate in Hertz</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-frame-info.h"
                 line="108">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_rendering_duration_ns"
              c:identifier="cogl_frame_info_get_rendering_duration_ns">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="149"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sequence" c:identifier="cogl_frame_info_get_sequence">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="143"/>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_target_presentation_time_us"
              c:identifier="cogl_frame_info_get_target_presentation_time_us">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-frame-info.h"
             line="91">Gets the target presentation time for the frame. This is the time at
which the frame was expected to became visible to the user.

The target presentation time measured in microseconds, is based on
CLOCK_MONOTONIC.</doc>
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="104"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-frame-info.h"
               line="101">the presentation time for the frame if available, or 0</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-frame-info.h"
                 line="93">a #CoglFrameInfo object</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_time_before_buffer_swap_us"
              c:identifier="cogl_frame_info_get_time_before_buffer_swap_us">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="152"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_view_frame_counter"
              c:identifier="cogl_frame_info_get_view_frame_counter">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="128"/>
        <return-value transfer-ownership="none">
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_valid_gpu_rendering_duration"
              c:identifier="cogl_frame_info_has_valid_gpu_rendering_duration">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="146"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_hw_clock" c:identifier="cogl_frame_info_is_hw_clock">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_vsync" c:identifier="cogl_frame_info_is_vsync">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="140"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_zero_copy" c:identifier="cogl_frame_info_is_zero_copy">
        <source-position filename="cogl/cogl/cogl-frame-info.h" line="137"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="FrameInfoClass"
            c:type="CoglFrameInfoClass"
            glib:is-gtype-struct-for="FrameInfo">
      <source-position filename="cogl/cogl/cogl-frame-info.h" line="55"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="Framebuffer"
           c:symbol-prefix="framebuffer"
           c:type="CoglFramebuffer"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CoglFramebuffer"
           glib:get-type="cogl_framebuffer_get_type"
           glib:type-struct="FramebufferClass">
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="101"/>
      <function name="error_quark" c:identifier="cogl_framebuffer_error_quark">
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1022"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <virtual-method name="allocate" invoker="allocate" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="103">Explicitly allocates a configured #CoglFramebuffer allowing developers to
check and handle any errors that might arise from an unsupported
configuration so that fallback configurations may be tried.

Many applications don't support any fallback options at least when
they are initially developed and in that case the don't need to use this API
since Cogl will automatically allocate a framebuffer when it first gets
used.  The disadvantage of relying on automatic allocation is that the
program will abort with an error message if there is an error during
automatic allocation.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="98"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="119">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="105">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_y_flipped">
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="100"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="allocate"
              c:identifier="cogl_framebuffer_allocate"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="103">Explicitly allocates a configured #CoglFramebuffer allowing developers to
check and handle any errors that might arise from an unsupported
configuration so that fallback configurations may be tried.

Many applications don't support any fallback options at least when
they are initially developed and in that case the don't need to use this API
since Cogl will automatically allocate a framebuffer when it first gets
used.  The disadvantage of relying on automatic allocation is that the
program will abort with an error message if there is an error during
automatic allocation.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="122"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="119">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="105">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="blit" c:identifier="cogl_framebuffer_blit" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1036">@return FALSE for an immediately detected error, TRUE otherwise.

This blits a region of the color buffer of the source buffer
to the destination buffer. This function should only be
called if the COGL_FEATURE_ID_BLIT_FRAMEBUFFER feature is
advertised.

The source and destination rectangles are defined in offscreen
framebuffer orientation. When copying between an offscreen and
onscreen framebuffers, the image is y-flipped accordingly.

The two buffers must have the same value types (e.g. floating-point,
unsigned int, signed int, or fixed-point), but color formats do not
need to match. This limitation comes from OpenGL ES 3.0 definition
of glBlitFramebuffer.

Note that this function differs a lot from the glBlitFramebuffer
function provided by the GL_EXT_framebuffer_blit extension. Notably
it doesn't support having different sizes for the source and
destination rectangle. This doesn't seem
like a particularly useful feature. If the application wanted to
scale the results it may make more sense to draw a primitive
instead.

The GL function is documented to be affected by the scissor. This
function therefore ensure that an empty clip stack is flushed
before performing the blit which means the scissor is effectively
ignored.

The function also doesn't support specifying the buffers to copy
and instead only the color buffer is copied. When copying the depth
or stencil buffers the extension on GLES2.0 only supports copying
the full buffer which would be awkward to document with this
API. If we wanted to support that feature it may be better to have
a separate function to copy the entire buffer for a given mask.

The @c error argument is optional, it can be NULL. If it is not NULL
and this function returns FALSE, an error object with a code from
COGL_SYSTEM_ERROR will be created.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1089"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1038">The source #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="dst" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1039">The destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1040">Source x position</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1041">Source y position</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1042">Destination x position</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1043">Destination y position</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1044">Width of region to copy</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1045">Height of region to copy</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="cogl_framebuffer_clear">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="618">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="631"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="620">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="621">A mask of `CoglBufferBit`s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="623">The color to clear the color buffer too if specified in
        @buffers.</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear4f" c:identifier="cogl_framebuffer_clear4f">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="635">Clears all the auxiliary buffers identified in the @buffers mask, and if
that includes the color buffer then the specified @color is used.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="654"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="637">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="638">A mask of `CoglBufferBit`s identifying which auxiliary
  buffers to clear</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
          <parameter name="red" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="640">The red component of color to clear the color buffer too if
      specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="green" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="642">The green component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="blue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="644">The blue component of color to clear the color buffer too if
       specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="alpha" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="646">The alpha component of color to clear the color buffer too if
        specified in @buffers.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_timestamp_query"
              c:identifier="cogl_framebuffer_create_timestamp_query"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1111">Creates a query for the GPU timestamp that will complete upon completion of
all previously submitted GL commands related to this framebuffer. E.g. when
the rendering is finished on this framebuffer.

This function should only be called if the COGL_FEATURE_ID_TIMESTAMP_QUERY
feature is advertised.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1122"/>
        <return-value>
          <type name="TimestampQuery" c:type="CoglTimestampQuery*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="discard_buffers"
              c:identifier="cogl_framebuffer_discard_buffers">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="898">Declares that the specified @buffers no longer need to be referenced
by any further rendering commands. This can be an important
optimization to avoid subsequent frames of rendering depending on
the results of a previous frame.

For example; some tile-based rendering GPUs are able to avoid allocating and
accessing system memory for the depth and stencil buffer so long as these
buffers are not required as input for subsequent frames and that can save a
significant amount of memory bandwidth used to save and restore their
contents to system memory between frames.

It is currently considered an error to try and explicitly discard the color
buffer by passing %COGL_BUFFER_BIT_COLOR. This is because the color buffer is
already implicitly discard when you finish rendering to a #CoglOnscreen
framebuffer, and it's not meaningful to try and discard the color buffer of
a #CoglOffscreen framebuffer since they are single-buffered.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="924"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="900">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="buffers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="901">A #CoglBufferBit mask of which ancillary buffers you want
          to discard.</doc>
            <type name="gulong" c:type="unsigned long"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_multitextured_rectangle"
              c:identifier="cogl_framebuffer_draw_multitextured_rectangle">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="742">Draws a textured rectangle to @framebuffer with the given @pipeline
state with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2). As a pipeline may
contain multiple texture layers this interface lets you supply
texture coordinates for each layer of the pipeline.

The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.

This is a high level drawing api that can handle any kind of
#CoglTexture texture for the first layer such as
#CoglTexture2DSliced textures which may internally be comprised of
multiple low-level textures.  This is unlike low-level drawing apis
such as cogl_primitive_draw() which only support low level texture
types that are directly supported by GPUs such as #CoglTexture2D.

This api can not currently handle multiple high-level meta
texture layers. The first layer may be a high level meta texture
such as #CoglTexture2DSliced but all other layers much be low
level textures such as #CoglTexture2D.

The top left texture coordinate for layer 0 of any pipeline will be
(tex_coords[0], tex_coords[1]) and the bottom right coordinate will
be (tex_coords[2], tex_coords[3]). The coordinates for layer 1
would be (tex_coords[4], tex_coords[5]) (tex_coords[6],
tex_coords[7]) and so on...

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.

The first pair of coordinates are for the first layer (with the
smallest layer index) and if you supply less texture coordinates
than there are layers in the current source pipeline then default
texture coordinates (0.0, 0.0, 1.0, 1.0) are generated.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="799"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="744">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="745">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="746">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="747">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="748">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="749">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tex_coords" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="750">An array containing groups of
  4 float values: [s_1, t_1, s_2, t_2] that are interpreted as two texture
  coordinates; one for the top left texel, and one for the bottom right
  texel. Each value should be between 0.0 and 1.0, where the coordinate
  (0.0, 0.0) represents the top left of the texture, and (1.0, 1.0) the
  bottom right.</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="tex_coords_len" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="756">The length of the @tex_coords array. (For one layer
  and one group of texture coordinates, this would be 4)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangle"
              c:identifier="cogl_framebuffer_draw_rectangle">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="661">Draws a rectangle to @framebuffer with the given @pipeline state
and with the top left corner positioned at (@x_1, @y_1) and the
bottom right corner positioned at (@x_2, @y_2).

The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.

If you want to describe a rectangle with a texture mapped on
it then you can use
cogl_framebuffer_draw_textured_rectangle().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="683"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="663">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="664">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="665">X coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="666">Y coordinate of the top-left corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="667">X coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="668">Y coordinate of the bottom-right corner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_rectangles"
              c:identifier="cogl_framebuffer_draw_rectangles">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="808">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_rectangle() does.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The positions for
the second rectangle are (coordinates[4], coordinates[5]) and
(coordinates[6], coordinates[7]) and so on...

The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="840"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="810">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="811">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="812">an array of coordinates
  containing groups of 4 float values: [x_1, y_1, x_2, y_2] that are
  interpreted as two position coordinates; one for the top left of
  the rectangle (x1, y1), and one for the bottom right of the
  rectangle (x2, y2).</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="817">number of rectangles defined in @coordinates.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangle"
              c:identifier="cogl_framebuffer_draw_textured_rectangle">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="690">Draws a textured rectangle to @framebuffer using the given
@pipeline state with the top left corner positioned at (@x_1, @y_1)
and the bottom right corner positioned at (@x_2, @y_2). The top
left corner will have texture coordinates of (@s_1, @t_1) and the
bottom right corner will have texture coordinates of (@s_2, @t_2).

The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.

This is a high level drawing api that can handle any kind of
#CoglTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

The given texture coordinates will only be used for the first
texture layer of the pipeline and if your pipeline has more than
one layer then all other layers will have default texture
coordinates of @s_1=0.0 @t_1=0.0 @s_2=1.0 @t_2=1.0

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in @s_1=0, @t_1=0, @s_2=1, @t_2=1.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="731"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="692">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="693">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="694">x coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="695">y coordinate upper left on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="696">x coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="697">y coordinate lower right on screen.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="698">S texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="699">T texture coordinate of the top-left coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="s_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="700">S texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="t_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="701">T texture coordinate of the bottom-right coorner</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="draw_textured_rectangles"
              c:identifier="cogl_framebuffer_draw_textured_rectangles">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="845">Draws a series of rectangles to @framebuffer with the given
@pipeline state in the same way that
cogl_framebuffer_draw_textured_rectangle() does.

The position is the position before the rectangle has been
transformed by the model-view matrix and the projection
matrix.

This is a high level drawing api that can handle any kind of
#CoglTexture texture such as #CoglTexture2DSliced textures
which may internally be comprised of multiple low-level textures.
This is unlike low-level drawing apis such as cogl_primitive_draw()
which only support low level texture types that are directly
supported by GPUs such as #CoglTexture2D.

The top left corner of the first rectangle is positioned at
(coordinates[0], coordinates[1]) and the bottom right corner is
positioned at (coordinates[2], coordinates[3]). The top left
texture coordinate is (coordinates[4], coordinates[5]) and the
bottom right texture coordinate is (coordinates[6],
coordinates[7]). The coordinates for subsequent rectangles
are defined similarly by the subsequent coordinates.

As a general rule for better performance its recommended to use
this this API instead of calling
cogl_framebuffer_draw_textured_rectangle() separately for multiple
rectangles if all of the rectangles will be drawn together with the
same @pipeline state.

The given texture coordinates should always be normalized such that
(0, 0) corresponds to the top left and (1, 1) corresponds to the
bottom right. To map an entire texture across the rectangle pass
in tex_coords[0]=0, tex_coords[1]=0, tex_coords[2]=1,
tex_coords[3]=1.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="891"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="847">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="848">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
          <parameter name="coordinates" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="849">an array containing
  groups of 8 float values: [x_1, y_1, x_2, y_2, s_1, t_1, s_2, t_2]
  that have the same meaning as the arguments for
  cogl_framebuffer_draw_textured_rectangle().</doc>
            <array zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
          <parameter name="n_rectangles" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="853">number of rectangles to @coordinates to draw</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish" c:identifier="cogl_framebuffer_finish">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="927">This blocks the CPU until all pending rendering associated with the
specified framebuffer has completed. It's very rare that developers should
ever need this level of synchronization with the GPU and should never be
used unless you clearly understand why you need to explicitly force
synchronization.

One example might be for benchmarking purposes to be sure timing
measurements reflect the time that the GPU is busy for not just the time it
takes to queue rendering commands.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="942"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="929">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="cogl_framebuffer_flush">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1099">Flushes @framebuffer to ensure the current batch of commands is
submitted to the GPU.

Unlike cogl_framebuffer_finish(), this does not block the CPU.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1109"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="1101">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="frustum" c:identifier="cogl_framebuffer_frustum">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="375">Replaces the current projection matrix with a perspective matrix
for a given viewing frustum defined by 4 side clip planes that
all cross through the origin and 2 near and far clip planes.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="394"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="377">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="378">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="380">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="382">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="384">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="386">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="387">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_bits"
              c:identifier="cogl_framebuffer_get_alpha_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="524">Retrieves the number of alpha bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="534"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="530">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="526">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_blue_bits"
              c:identifier="cogl_framebuffer_get_blue_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="512">Retrieves the number of blue bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="522"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="518">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="514">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context"
              c:identifier="cogl_framebuffer_get_context"
              glib:get-property="context">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="604">Can be used to query the #CoglContext a given @framebuffer was
instantiated within. This is the #CoglContext that was passed to
cogl_onscreen_new() for example.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="616"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="612">The #CoglContext that the given
              @framebuffer was instantiated within.</doc>
          <type name="Context" c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="606">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_write_enabled"
              c:identifier="cogl_framebuffer_get_depth_write_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="576">Queries whether depth buffer writing is enabled for @framebuffer. This
can be controlled via cogl_framebuffer_set_depth_write_enabled().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="586"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="583">%TRUE if depth writing is enabled or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="578">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dither_enabled"
              c:identifier="cogl_framebuffer_get_dither_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="536">Returns whether dithering has been requested for the given @framebuffer.
See cogl_framebuffer_set_dither_enabled() for more details about dithering.

This may return %TRUE even when the underlying @framebuffer
display pipeline does not support dithering. This value only represents
the user's request for dithering.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="550"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="547">%TRUE if dithering has been requested or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="538">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_green_bits"
              c:identifier="cogl_framebuffer_get_green_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="500">Retrieves the number of green bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="510"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="506">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="502">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_height"
              c:identifier="cogl_framebuffer_get_height"
              glib:get-property="height">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="136">Queries the current height of the given @framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="145"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="142">The height of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="138">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_internal_format"
              c:identifier="cogl_framebuffer_get_internal_format"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="1125">Returns the pixel format used internally by the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1131"/>
        <return-value transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_modelview_matrix"
              c:identifier="cogl_framebuffer_get_modelview_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="329">Stores the current model-view matrix in @matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="337"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="331">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="332">return location for the model-view matrix</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_projection_matrix"
              c:identifier="cogl_framebuffer_get_projection_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="428">Stores the current projection matrix in @matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="436"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="430">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="431">return location for the projection matrix</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_red_bits" c:identifier="cogl_framebuffer_get_red_bits">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="488">Retrieves the number of red bits of @framebuffer</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="498"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="494">the number of bits</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="490">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport4fv"
              c:identifier="cogl_framebuffer_get_viewport4fv">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="229">Queries the x, y, width and height components of the current viewport as set
using cogl_framebuffer_set_viewport() or the default values which are 0, 0,
framebuffer_width and framebuffer_height.  The values are written into the
given @viewport array.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="243"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="231">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="viewport"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="232">A pointer to an
           array of 4 floats to receive the (x, y, width, height)
           components of the current viewport.</doc>
            <array zero-terminated="0" c:type="float*" fixed-size="4">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_viewport_height"
              c:identifier="cogl_framebuffer_get_viewport_height">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="217">Queries the height of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the height of the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="227"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="224">The height of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="219">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_width"
              c:identifier="cogl_framebuffer_get_viewport_width">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="205">Queries the width of the viewport as set using cogl_framebuffer_set_viewport()
or the default value which is the width of the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="215"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="212">The width of the viewport.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="207">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_x"
              c:identifier="cogl_framebuffer_get_viewport_x">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="181">Queries the x coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="191"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="188">The x coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="183">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_viewport_y"
              c:identifier="cogl_framebuffer_get_viewport_y">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="193">Queries the y coordinate of the viewport origin as set using cogl_framebuffer_set_viewport()
or the default value which is 0.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="203"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="200">The y coordinate of the viewport origin.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="195">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width"
              c:identifier="cogl_framebuffer_get_width"
              glib:get-property="width">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="125">Queries the current width of the given @framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="134"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="131">The width of @framebuffer.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="127">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="orthographic" c:identifier="cogl_framebuffer_orthographic">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="402">Replaces the current projection matrix with an orthographic projection
matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="420"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="404">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="405">The x coordinate for the first vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="406">The y coordinate for the first horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="407">The x coordinate for the second vertical clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="408">The y coordinate for the second horizontal clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="409">The *distance* to the near clipping
  plane (will be *negative* if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="412">The *distance* to the far clipping
  plane (will be *negative* if the plane is
  behind the viewer)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="perspective" c:identifier="cogl_framebuffer_perspective">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="351">Replaces the current projection matrix with a perspective matrix
based on the provided values.

You should be careful not to have to great a @z_far / @z_near
ratio since that will reduce the effectiveness of depth testing
since there won't be enough precision to identify the depth of
objects near to each other.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="369"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="353">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="fov_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="354">Vertical field of view angle in degrees.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="aspect" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="355">The (width over height) aspect ratio for display</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="356">The distance to the near clipping plane (Must be positive,
  and must not be 0)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="358">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop_clip" c:identifier="cogl_framebuffer_pop_clip">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="478">Reverts the clipping region to the state before the last call to
cogl_framebuffer_push_rectangle_clip()</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="486"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="480">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_matrix" c:identifier="cogl_framebuffer_pop_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="256">Restores the model-view matrix on the top of the matrix stack.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="263"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="258">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_matrix" c:identifier="cogl_framebuffer_push_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="246">Copies the current model-view matrix onto the matrix stack. The matrix
can later be restored with cogl_framebuffer_pop_matrix().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="254"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="248">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_rectangle_clip"
              c:identifier="cogl_framebuffer_push_rectangle_clip">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="450">Specifies a modelview transformed rectangular clipping area for all
subsequent drawing operations. Any drawing commands that extend
outside the rectangle will be clipped so that only the portion
inside the rectangle will be displayed. The rectangle dimensions
are transformed by the current model-view matrix.

The rectangle is intersected with the current clip region. To undo
the effect of this function, call cogl_framebuffer_pop_clip().</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="468"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="452">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="453">x coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="454">y coordinate for top left corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="455">x coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="456">y coordinate for bottom right corner of the clip rectangle</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_region_clip"
              c:identifier="cogl_framebuffer_push_region_clip">
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="475"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <type name="Mtk.Region" c:type="MtkRegion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels" c:identifier="cogl_framebuffer_read_pixels">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="975">This is a convenience wrapper around
cogl_framebuffer_read_pixels_into_bitmap() which allocates a
temporary #CoglBitmap to read pixel data directly into the given
buffer. The rowstride of the buffer is assumed to be the width of
the region times the bytes per pixel of the format. The source for
the data is always taken from the color buffer. If you want to use
any other rowstride or source, please use the
cogl_framebuffer_read_pixels_into_bitmap() function directly.

The implementation of the function looks like this:

```c
bitmap = cogl_bitmap_new_for_data (context,
                                   width, height,
                                   format,
                                   /&lt;!-- --&gt;* rowstride *&lt;!-- --&gt;/
                                   bpp * width,
                                   pixels);
cogl_framebuffer_read_pixels_into_bitmap (framebuffer,
                                          x, y,
                                          COGL_READ_PIXELS_COLOR_BUFFER,
                                          bitmap);
g_object_unref (bitmap);
```</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1013"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="1010">%TRUE if the read succeeded or %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="977">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="978">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="979">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="980">The width of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="981">The height of the region of rectangles to read</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="982">The pixel format to store the data in</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="pixels" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="983">The address of the buffer to store the data in</doc>
            <type name="guint8" c:type="uint8_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_pixels_into_bitmap"
              c:identifier="cogl_framebuffer_read_pixels_into_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="944">This reads a rectangle of pixels from the given framebuffer where
position (0, 0) is the top left. The pixel at (x, y) is the first
read, and a rectangle of pixels with the same size as the bitmap is
read right and downwards from that point.

Currently Cogl assumes that the framebuffer is in a premultiplied
format so if the format of @bitmap is non-premultiplied it will
convert it. To read the pixel values without any conversion you
should either specify a format that doesn't use an alpha channel or
use one of the formats ending in PRE.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="969"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-framebuffer.h"
               line="964">%TRUE if the read succeeded or %FALSE otherwise. The
 function is only likely to fail if the bitmap points to a pixel
 buffer and it could not be mapped.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="946">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="947">The x position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="948">The y position to read from</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="949">Identifies which auxiliary buffer you want to read
         (only COGL_READ_PIXELS_COLOR_BUFFER supported currently)</doc>
            <type name="ReadPixelsFlags" c:type="CoglReadPixelsFlags"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="951">The bitmap to store the results in.</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_framebuffer_rotate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="297">Multiplies the current model-view matrix by one that rotates the
model around the axis-vector specified by @x, @y and @z. The
rotation follows the right-hand thumb rule so for example rotating
by 10 degrees about the axis-vector (0, 0, 1) causes a small
counter-clockwise rotation.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="312"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="299">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="300">Angle in degrees to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="301">X-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="302">Y-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="303">Z-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_framebuffer_scale">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="265">Multiplies the current model-view matrix by one that scales the x,
y and z axes by the given values.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="276"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="267">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="268">Amount to scale along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="269">Amount to scale along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="270">Amount to scale along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_write_enabled"
              c:identifier="cogl_framebuffer_set_depth_write_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="588">Enables or disables depth buffer writing when rendering to @framebuffer.
If depth writing is enabled for both the framebuffer and the rendering
pipeline, and the framebuffer has an associated depth buffer, depth
information will be written to this buffer during rendering.

Depth buffer writing is enabled by default.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="601"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="590">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="depth_write_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="591">%TRUE to enable depth writing or %FALSE to disable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dither_enabled"
              c:identifier="cogl_framebuffer_set_dither_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="552">Enables or disabled dithering if supported by the hardware.

Dithering is a hardware dependent technique to increase the visible
color resolution beyond what the underlying hardware supports by playing
tricks with the colors placed into the framebuffer to give the illusion
of other colors. (For example this can be compared to half-toning used
by some news papers to show varying levels of grey even though their may
only be black and white are available).

If the current display pipeline for @framebuffer does not support dithering
then this has no affect.

Dithering is enabled by default.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="573"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="554">a pointer to a #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="dither_enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="555">%TRUE to enable dithering or %FALSE to disable</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_modelview_matrix"
              c:identifier="cogl_framebuffer_set_modelview_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="340">Sets @matrix as the new model-view matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="348"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="342">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="343">the new model-view matrix</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_projection_matrix"
              c:identifier="cogl_framebuffer_set_projection_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="439">Sets @matrix as the new projection matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="447"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="441">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="442">the new projection matrix</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_viewport" c:identifier="cogl_framebuffer_set_viewport">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="147">Defines a scale and offset for everything rendered relative to the
top-left of the destination framebuffer.

By default the viewport has an origin of (0,0) and width and height
that match the framebuffer's size. Assuming a default projection and
modelview matrix then you could translate the contents of a window
down and right by leaving the viewport size unchanged by moving the
offset to (10,10). The viewport coordinates are measured in pixels.
If you left the x and y origin as (0,0) you could scale the windows
contents down by specify and width and height that's half the real
size of the framebuffer.

Although the function takes floating point arguments, existing
drivers only allow the use of integer values. In the future floating
point values will be exposed via a checkable feature.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="175"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="149">A #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="150">The top-left x coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="152">The top-left y coordinate of the viewport origin (only integers
    supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="154">The width of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="155">The height of the viewport (only integers supported currently)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="transform" c:identifier="cogl_framebuffer_transform">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="318">Multiplies the current model-view matrix by the given matrix.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="326"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="320">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="321">the matrix to multiply with the current model-view</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_framebuffer_translate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-framebuffer.h"
             line="281">Multiplies the current model-view matrix by one that translates the
model along all three axes according to the given values.</doc>
        <source-position filename="cogl/cogl/cogl-framebuffer.h" line="292"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="283">A #CoglFramebuffer pointer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="284">Distance to translate along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="285">Distance to translate along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="286">Distance to translate along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <property name="context"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                getter="get_context">
        <type name="Context"/>
      </property>
      <property name="driver-config"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="height"
                writable="1"
                construct="1"
                transfer-ownership="none"
                getter="get_height"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="width"
                writable="1"
                construct="1"
                transfer-ownership="none"
                getter="get_width"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <glib:signal name="destroy" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <record name="FramebufferClass"
            c:type="CoglFramebufferClass"
            glib:is-gtype-struct-for="Framebuffer">
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="101"/>
      <field name="parent_class" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="allocate">
        <callback name="allocate" throws="1">
          <source-position filename="cogl/cogl/cogl-framebuffer.h" line="98"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-framebuffer.h"
                 line="119">%TRUE if there were no error allocating the framebuffer, else %FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="framebuffer" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-framebuffer.h"
                   line="105">A #CoglFramebuffer</doc>
              <type name="Framebuffer" c:type="CoglFramebuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_y_flipped">
        <callback name="is_y_flipped">
          <source-position filename="cogl/cogl/cogl-framebuffer.h" line="100"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="framebuffer" transfer-ownership="none">
              <type name="Framebuffer" c:type="CoglFramebuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <enumeration name="FramebufferError" c:type="CoglFramebufferError">
      <source-position filename="cogl/cogl/cogl-framebuffer.h" line="1034"/>
      <member name="framebuffer_error_allocate"
              value="0"
              c:identifier="COGL_FRAMEBUFFER_ERROR_ALLOCATE">
      </member>
    </enumeration>
    <enumeration name="GraphicsResetStatus" c:type="CoglGraphicsResetStatus">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-context.h"
           line="223">All the error values that might be returned by
cogl_context_get_graphics_reset_status(). Each value's meaning corresponds
to the similarly named value defined in the ARB_robustness and
NV_robustness_video_memory_purge extensions.</doc>
      <source-position filename="cogl/cogl/cogl-context.h" line="243"/>
      <member name="no_error"
              value="0"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_NO_ERROR">
      </member>
      <member name="guilty_context_reset"
              value="1"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_GUILTY_CONTEXT_RESET">
      </member>
      <member name="innocent_context_reset"
              value="2"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_INNOCENT_CONTEXT_RESET">
      </member>
      <member name="unknown_context_reset"
              value="3"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_UNKNOWN_CONTEXT_RESET">
      </member>
      <member name="purged_context_reset"
              value="4"
              c:identifier="COGL_GRAPHICS_RESET_STATUS_PURGED_CONTEXT_RESET">
      </member>
    </enumeration>
    <function-macro name="INDEX_BUFFER"
                    c:identifier="COGL_INDEX_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="52"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INDEX_BUFFER_CLASS"
                    c:identifier="COGL_INDEX_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="54"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INDEX_BUFFER_CONST"
                    c:identifier="COGL_INDEX_BUFFER_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="53"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="INDEX_BUFFER_GET_CLASS"
                    c:identifier="COGL_INDEX_BUFFER_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="57"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ATLAS_TEXTURE"
                    c:identifier="COGL_IS_ATLAS_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="70"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ATLAS_TEXTURE_CLASS"
                    c:identifier="COGL_IS_ATLAS_TEXTURE_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-atlas-texture.h" line="71"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ATTRIBUTE_BUFFER"
                    c:identifier="COGL_IS_ATTRIBUTE_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ATTRIBUTE_BUFFER_CLASS"
                    c:identifier="COGL_IS_ATTRIBUTE_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-attribute-buffer.h" line="56"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BUFFER"
                    c:identifier="COGL_IS_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-buffer.h" line="70"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BUFFER_CLASS"
                    c:identifier="COGL_IS_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-buffer.h" line="71"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_INDEX_BUFFER"
                    c:identifier="COGL_IS_INDEX_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_INDEX_BUFFER_CLASS"
                    c:identifier="COGL_IS_INDEX_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="56"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PARAM_SPEC_COLOR"
                    c:identifier="COGL_IS_PARAM_SPEC_COLOR"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-color.h" line="311"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PIXEL_BUFFER"
                    c:identifier="COGL_IS_PIXEL_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PIXEL_BUFFER_CLASS"
                    c:identifier="COGL_IS_PIXEL_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="56"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SUB_TEXTURE"
                    c:identifier="COGL_IS_SUB_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="53"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_SUB_TEXTURE_CLASS"
                    c:identifier="COGL_IS_SUB_TEXTURE_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="54"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TEXTURE_2D"
                    c:identifier="COGL_IS_TEXTURE_2D"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="60"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TEXTURE_2D_CLASS"
                    c:identifier="COGL_IS_TEXTURE_2D_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="61"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TEXTURE_2D_SLICED"
                    c:identifier="COGL_IS_TEXTURE_2D_SLICED"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="73"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_TEXTURE_2D_SLICED_CLASS"
                    c:identifier="COGL_IS_TEXTURE_2D_SLICED_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="74"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <class name="IndexBuffer"
           c:symbol-prefix="index_buffer"
           c:type="CoglIndexBuffer"
           parent="Buffer"
           final="1"
           glib:type-name="CoglIndexBuffer"
           glib:get-type="cogl_index_buffer_get_type"
           glib:type-struct="IndexBufferClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-index-buffer.h"
           line="46">Functions for creating and manipulating vertex indices.</doc>
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="59"/>
      <constructor name="new" c:identifier="cogl_index_buffer_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-index-buffer.h"
             line="67">Declares a new #CoglIndexBuffer of @size bytes to contain vertex
indices. Once declared, data can be set using
cogl_buffer_set_data() or by mapping it into the application's
address space using cogl_buffer_map().</doc>
        <source-position filename="cogl/cogl/cogl-index-buffer.h" line="80"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-index-buffer.h"
               line="77">A newly allocated #CoglIndexBuffer</doc>
          <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-index-buffer.h"
                 line="69">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="bytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-index-buffer.h"
                 line="70">The number of bytes to allocate for vertex attribute data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <record name="IndexBufferClass"
            c:type="CoglIndexBufferClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="IndexBuffer">
      <source-position filename="cogl/cogl/cogl-index-buffer.h" line="59"/>
    </record>
    <class name="Indices"
           c:symbol-prefix="indices"
           c:type="CoglIndices"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglIndices"
           glib:get-type="cogl_indices_get_type"
           glib:type-struct="IndicesClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-indices.h"
           line="46">Describe vertex indices stored in a #CoglIndexBuffer.

Indices allow you to avoid duplicating vertices in your vertex data
by virtualizing your data and instead providing a sequence of index
values that tell the GPU which data should be used for each vertex.

If the GPU is given a sequence of indices it doesn't simply walk
through each vertex of your data in order it will instead walk
through the indices which can provide random access to the
underlying data.

Since it's very common to have duplicate vertices when describing a
shape as a list of triangles it can often be a significant space
saving to describe geometry using indices. Reducing the size of
your models can make it cheaper to map them into the GPU by
reducing the demand on memory bandwidth and may help to make better
use of your GPUs internal vertex caching.

For example, to describe a quadrilateral as 2 triangles for the GPU
you could either provide data with 6 vertices or instead with
indices you can provide vertex data for just 4 vertices and an
index buffer that specifies the 6 vertices by indexing the shared
vertices multiple times.

```c
  CoglVertexP2 quad_vertices[] = {
    {x0, y0}, //0 = top left
    {x1, y1}, //1 = bottom left
    {x2, y2}, //2 = bottom right
    {x3, y3}, //3 = top right
  };
  //tell the gpu how to interpret the quad as 2 triangles...
  unsigned char indices[] = {0, 1, 2, 0, 2, 3};
```

Even in the above illustration we see a saving of 10bytes for one
quad compared to having data for 6 vertices and no indices but if
you need to draw 100s or 1000s of quads then its really quite
significant.

Something else to consider is that often indices can be defined
once and remain static while the vertex data may change for
animations perhaps. That means you may be able to ignore the
negligible cost of mapping your indices into the GPU if they don't
ever change.

The above illustration is actually a good example of static indices
because it's really common that developers have quad mesh data that
they need to display and we know exactly what that indices array
needs to look like depending on the number of quads that need to be
drawn. It doesn't matter how the quads might be animated and
changed the indices will remain the same. Cogl even has a utility
([method@Cogl.Context.get_rectangle_indices]) to get access to re-useable indices
for drawing quads as above.</doc>
      <source-position filename="cogl/cogl/cogl-indices.h" line="108"/>
      <constructor name="new" c:identifier="cogl_indices_new">
        <source-position filename="cogl/cogl/cogl-indices.h" line="112"/>
        <return-value transfer-ownership="full">
          <type name="Indices" c:type="CoglIndices*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="type" transfer-ownership="none">
            <type name="IndicesType" c:type="CoglIndicesType"/>
          </parameter>
          <parameter name="indices_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="n_indices" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_buffer" c:identifier="cogl_indices_get_buffer">
        <source-position filename="cogl/cogl/cogl-indices.h" line="123"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-indices.h"
               line="120">a #CoglIndexBuffer</doc>
          <type name="IndexBuffer" c:type="CoglIndexBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="indices" transfer-ownership="none">
            <type name="Indices" c:type="CoglIndices*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_indices_type"
              c:identifier="cogl_indices_get_indices_type">
        <source-position filename="cogl/cogl/cogl-indices.h" line="126"/>
        <return-value transfer-ownership="none">
          <type name="IndicesType" c:type="CoglIndicesType"/>
        </return-value>
        <parameters>
          <instance-parameter name="indices" transfer-ownership="none">
            <type name="Indices" c:type="CoglIndices*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="IndicesClass"
            c:type="CoglIndicesClass"
            glib:is-gtype-struct-for="Indices">
      <source-position filename="cogl/cogl/cogl-indices.h" line="108"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="IndicesType"
                 glib:type-name="CoglIndicesType"
                 glib:get-type="cogl_indices_type_get_type"
                 c:type="CoglIndicesType">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="124">You should aim to use the smallest data type that gives you enough
range, since it reduces the size of your index array and can help
reduce the demand on memory bandwidth.

Note that %COGL_INDICES_TYPE_UNSIGNED_INT is only supported if the
%COGL_FEATURE_ID_UNSIGNED_INT_INDICES feature is available. This
should always be available on OpenGL but on OpenGL ES it will only
be available if the GL_OES_element_index_uint extension is
advertized.</doc>
      <member name="byte"
              value="0"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_BYTE"
              glib:nick="byte"
              glib:name="COGL_INDICES_TYPE_UNSIGNED_BYTE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="126">Your indices are unsigned bytes</doc>
      </member>
      <member name="short"
              value="1"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_SHORT"
              glib:nick="short"
              glib:name="COGL_INDICES_TYPE_UNSIGNED_SHORT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="127">Your indices are unsigned shorts</doc>
      </member>
      <member name="int"
              value="2"
              c:identifier="COGL_INDICES_TYPE_UNSIGNED_INT"
              glib:nick="int"
              glib:name="COGL_INDICES_TYPE_UNSIGNED_INT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="128">Your indices are unsigned ints</doc>
      </member>
    </enumeration>
    <record name="MatrixEntry"
            c:type="CoglMatrixEntry"
            opaque="1"
            glib:type-name="CoglMatrixEntry"
            glib:get-type="cogl_matrix_entry_get_type"
            c:symbol-prefix="matrix_entry">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-matrix-stack.h"
           line="93">Represents a single immutable transformation that was retrieved
from a #CoglMatrixStack using cogl_matrix_stack_get_entry().

Internally a #CoglMatrixEntry represents a single matrix
operation (such as "rotate", "scale", "translate") which is applied
to the transform of a single parent entry.

Using the #CoglMatrixStack api effectively builds up a graph of
these immutable #CoglMatrixEntry structures whereby operations
that can be shared between multiple transformations will result
in shared #CoglMatrixEntry nodes in the graph.

When a #CoglMatrixStack is first created it references one
#CoglMatrixEntry that represents a single "load identity"
operation. This serves as the root entry and all operations
that are then applied to the stack will extend the graph
starting from this root "load identity" entry.

Given the typical usage model for a #CoglMatrixStack and the way
the entries are built up while traversing a scenegraph then in most
cases where an application is interested in comparing two
transformations for equality then it is enough to simply compare
two #CoglMatrixEntry pointers directly. Technically this can lead
to false negatives that could be identified with a deeper
comparison but often these false negatives are unlikely and
don't matter anyway so this enables extremely cheap comparisons.

`CoglMatrixEntry`s are reference counted using
cogl_matrix_entry_ref() and cogl_matrix_entry_unref() not with
g_object_ref() and g_object_unref().</doc>
      <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="127"/>
      <method name="calculate_translation"
              c:identifier="cogl_matrix_entry_calculate_translation">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="405">Determines if the only difference between two transforms is a
translation and if so returns what the @x, @y, and @z components of
the translation are.

If the difference between the two translations involves anything
other than a translation then the function returns %FALSE.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="425"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-matrix-stack.h"
               line="420">%TRUE if the only difference between the transform of
               @entry0 and the transform of @entry1 is a translation,
               otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry0" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="407">The first reference transform</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
          <parameter name="entry1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="408">A second reference transform</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </parameter>
          <parameter name="x"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="409">The destination for the x-component of the translation</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="y"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="410">The destination for the y-component of the translation</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
          <parameter name="z"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="411">The destination for the z-component of the translation</doc>
            <type name="gfloat" c:type="float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="cogl_matrix_entry_get">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="360">Resolves the current @entry transform into a #graphene_matrix_t by
combining the sequence of operations that have been applied to
build up the current transform.

There are two possible ways that this function may return its
result depending on whether it's possible to directly point
to an internal #graphene_matrix_t or whether the result needs to be
composed of multiple operations.

If an internal matrix contains the required result then this
function will directly return a pointer to that matrix, otherwise
if the function returns %NULL then @matrix will be initialized
to match the transform of @entry.

@matrix will be left untouched if a direct pointer is
returned.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="388"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-matrix-stack.h"
               line="383">A direct pointer to a #graphene_matrix_t transform or %NULL
              and in that case @matrix will be initialized with
              the effective transform represented by @entry.</doc>
          <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="362">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="363">The potential destination for the transform as
                a matrix</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_identity" c:identifier="cogl_matrix_entry_is_identity">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="431">Determines whether @entry is known to represent an identity
transform.

If this returns %TRUE then the entry is definitely the identity
matrix. If it returns %FALSE it may or may not be the identity
matrix but no expensive comparison is performed to verify it.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="446"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-matrix-stack.h"
               line="442">%TRUE if @entry is definitely an identity transform,
              otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="433">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="cogl_matrix_entry_ref">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="448">Takes a reference on the given @entry to ensure the @entry stays
alive and remains valid. When you are finished with the @entry then
you should call cogl_matrix_entry_unref().</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="457"/>
        <return-value transfer-ownership="full">
          <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="450">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="cogl_matrix_entry_unref">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="459">Releases a reference on @entry either taken by calling
cogl_matrix_entry_unref() or to release the reference given when
calling cogl_matrix_stack_get_entry().</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="468"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="entry" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="461">A #CoglMatrixEntry</doc>
            <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <class name="MatrixStack"
           c:symbol-prefix="matrix_stack"
           c:type="CoglMatrixStack"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglMatrixStack"
           glib:get-type="cogl_matrix_stack_get_type"
           glib:type-struct="MatrixStackClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-matrix-stack.h"
           line="45">Efficiently tracking many related transformations.

Tracks your current position within a hierarchy and lets you build
up a graph of transformations as you traverse through a hierarchy
such as a scenegraph.

A #CoglMatrixStack always maintains a reference to a single
transformation at any point in time, representing the
transformation at the current position in the hierarchy. You can
get a reference to the current transformation by calling
cogl_matrix_stack_get_entry().

When a #CoglMatrixStack is first created with
cogl_matrix_stack_new() then it is conceptually positioned at the
root of your hierarchy and the current transformation simply
represents an identity transformation.

As you traverse your object hierarchy (your scenegraph) then you
should call cogl_matrix_stack_push() whenever you move down one
level and call cogl_matrix_stack_pop() whenever you move back up
one level towards the root.

At any time you can apply a set of operations, such as "rotate",
"scale", "translate" on top of the current transformation of a
#CoglMatrixStack using functions such as
cogl_matrix_stack_rotate(), cogl_matrix_stack_scale() and
cogl_matrix_stack_translate(). These operations will derive a new
current transformation and will never affect a transformation
that you have referenced using cogl_matrix_stack_get_entry().

Internally applying operations to a #CoglMatrixStack builds up a
graph of #CoglMatrixEntry structures which each represent a single
immutable transform.</doc>
      <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="87"/>
      <constructor name="new" c:identifier="cogl_matrix_stack_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="138">Allocates a new #CoglMatrixStack that can be used to build up
transformations relating to objects in a scenegraph like hierarchy.
(See the description of #CoglMatrixStack and #CoglMatrixEntry for
more details of what a matrix stack is best suited for)

When a #CoglMatrixStack is first allocated it is conceptually
positioned at the root of your scenegraph hierarchy. As you
traverse your scenegraph then you should call
cogl_matrix_stack_push() whenever you move down a level and
cogl_matrix_stack_pop() whenever you move back up a level towards
the root.

Once you have allocated a #CoglMatrixStack you can get a reference
to the current transformation for the current position in the
hierarchy by calling cogl_matrix_stack_get_entry().

Once you have allocated a #CoglMatrixStack you can apply operations
such as rotate, scale and translate to modify the current transform
for the current position in the hierarchy by calling
cogl_matrix_stack_rotate(), cogl_matrix_stack_scale() and
cogl_matrix_stack_translate().</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="167"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-matrix-stack.h"
               line="164">A newly allocated #CoglMatrixStack</doc>
          <type name="MatrixStack" c:type="CoglMatrixStack*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="140">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="frustum" c:identifier="cogl_matrix_stack_frustum">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="282">Replaces the current matrix with a perspective matrix for a given
viewing frustum defined by 4 side clip planes that all cross
through the origin and 2 near and far clip planes.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="301"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="284">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="left" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="285">X position of the left clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="right" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="287">X position of the right clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="bottom" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="289">Y position of the bottom clipping plane where it
  intersects the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="top" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="291">Y position of the top clipping plane where it intersects
  the near clipping plane</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_near" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="293">The distance to the near clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z_far" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="294">The distance to the far clipping plane (Must be positive)</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="get" c:identifier="cogl_matrix_stack_get">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="330">Resolves the current @stack transform into a #graphene_matrix_t by
combining the operations that have been applied to build up the
current transform.

There are two possible ways that this function may return its
result depending on whether the stack is able to directly point
to an internal #graphene_matrix_t or whether the result needs to be
composed of multiple operations.

If an internal matrix contains the required result then this
function will directly return a pointer to that matrix, otherwise
if the function returns %NULL then @matrix will be initialized
to match the current transform of @stack.

@matrix will be left untouched if a direct pointer is
returned.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="357"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-matrix-stack.h"
               line="352">A direct pointer to the current transform or %NULL
              and in that case @matrix will be initialized with
              the value of the current transform.</doc>
          <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="332">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="matrix"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="333">The potential destination for the current matrix</doc>
            <type name="Graphene.Matrix" c:type="graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_entry" c:identifier="cogl_matrix_stack_get_entry">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="309">Gets a reference to the current transform represented by a
#CoglMatrixEntry pointer.

The transform represented by a #CoglMatrixEntry is
immutable.

`CoglMatrixEntry`s are reference counted using
cogl_matrix_entry_ref() and cogl_matrix_entry_unref() and you
should call cogl_matrix_entry_unref() when you are finished with
and entry you get via cogl_matrix_stack_get_entry().</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="328"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-matrix-stack.h"
               line="324">A pointer to the #CoglMatrixEntry
              representing the current matrix stack transform.</doc>
          <type name="MatrixEntry" c:type="CoglMatrixEntry*"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="311">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_identity"
              c:identifier="cogl_matrix_stack_load_identity">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="197">Resets the current matrix to the identity matrix.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="204"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="199">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="multiply" c:identifier="cogl_matrix_stack_multiply">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="271">Multiplies the current matrix by the given matrix.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="279"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="273">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="274">the matrix to multiply with the current model-view</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="cogl_matrix_stack_pop">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="184">Restores the previous transform that was last saved by calling
cogl_matrix_stack_push().

This is usually called while traversing a scenegraph whenever you
return up one level in the graph towards the root node.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="195"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="186">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="cogl_matrix_stack_push">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="169">Saves the current transform and starts a new transform that derives
from the current transform.

This is usually called while traversing a scenegraph whenever you
traverse one level deeper. cogl_matrix_stack_pop() can then be
called when going back up one layer to restore the previous
transform of an ancestor.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="182"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="171">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="rotate" c:identifier="cogl_matrix_stack_rotate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="238">Multiplies the current matrix by one that rotates the around the
axis-vector specified by @x, @y and @z. The rotation follows the
right-hand thumb rule so for example rotating by 10 degrees about
the axis-vector (0, 0, 1) causes a small counter-clockwise
rotation.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="253"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="240">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="angle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="241">Angle in degrees to rotate.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="242">X-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="243">Y-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="244">Z-component of vertex to rotate around.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="rotate_euler"
              c:identifier="cogl_matrix_stack_rotate_euler">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="259">Multiplies the current matrix by one that rotates according to the
rotation described by @euler.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="268"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="261">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="euler" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="262">A #graphene_euler_t</doc>
            <type name="Graphene.Euler" c:type="const graphene_euler_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="scale" c:identifier="cogl_matrix_stack_scale">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="206">Multiplies the current matrix by one that scales the x, y and z
axes by the given values.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="217"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="208">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="209">Amount to scale along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="210">Amount to scale along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="211">Amount to scale along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set" c:identifier="cogl_matrix_stack_set">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="391">Replaces the current @stack matrix value with the value of @matrix.
This effectively discards any other operations that were applied
since the last time cogl_matrix_stack_push() was called or since
the stack was initialized.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="402"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="393">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="394">A #graphene_matrix_t replace the current matrix value with</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="translate" c:identifier="cogl_matrix_stack_translate">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-matrix-stack.h"
             line="222">Multiplies the current matrix by one that translates along all
three axes according to the given values.</doc>
        <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="233"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="stack" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="224">A #CoglMatrixStack</doc>
            <type name="MatrixStack" c:type="CoglMatrixStack*"/>
          </instance-parameter>
          <parameter name="x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="225">Distance to translate along the x-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="226">Distance to translate along the y-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="z" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-matrix-stack.h"
                 line="227">Distance to translate along the z-axis</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="MatrixStackClass"
            c:type="CoglMatrixStackClass"
            glib:is-gtype-struct-for="MatrixStack">
      <source-position filename="cogl/cogl/cogl-matrix-stack.h" line="87"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="Offscreen"
           c:symbol-prefix="offscreen"
           c:type="CoglOffscreen"
           parent="Framebuffer"
           final="1"
           glib:type-name="CoglOffscreen"
           glib:get-type="cogl_offscreen_get_type"
           glib:type-struct="OffscreenClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-offscreen.h"
           line="44">Functions for creating and manipulating offscreen framebuffers.</doc>
      <source-position filename="cogl/cogl/cogl-offscreen.h" line="54"/>
      <constructor name="new_with_texture"
                   c:identifier="cogl_offscreen_new_with_texture">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-offscreen.h"
             line="58">This creates an offscreen framebuffer object using the given
@texture as the primary color buffer. It doesn't just initialize
the contents of the offscreen buffer with the @texture; they are
tightly bound so that drawing to the offscreen buffer effectively
updates the contents of the given texture. You don't need to
destroy the offscreen buffer before you can use the @texture again.

This api only works with low-level #CoglTexture types such as
#CoglTexture2D and not with meta-texture types such as
#CoglTexture2DSliced.

The storage for the framebuffer is actually allocated lazily
so this function will never return %NULL to indicate a runtime
error. This means it is still possible to configure the framebuffer
before it is really allocated.

Simple applications without full error handling can simply rely on
Cogl to lazily allocate the storage of framebuffers but you should
be aware that if Cogl encounters an error (such as running out of
GPU memory) then your application will simply abort with an error
message. If you need to be able to catch such exceptions at runtime
then you can explicitly allocate your framebuffer when you have
finished configuring it by calling cogl_framebuffer_allocate() and
passing in a #GError argument to catch any exceptions.</doc>
        <source-position filename="cogl/cogl/cogl-offscreen.h" line="91"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-offscreen.h"
               line="87">a newly instantiated #CoglOffscreen
  framebuffer.</doc>
          <type name="Offscreen" c:type="CoglOffscreen*"/>
        </return-value>
        <parameters>
          <parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-offscreen.h"
                 line="60">A #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_texture" c:identifier="cogl_offscreen_get_texture">
        <source-position filename="cogl/cogl/cogl-offscreen.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-offscreen.h"
               line="96">a #CoglTexture</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="offscreen" transfer-ownership="none">
            <type name="Offscreen" c:type="CoglOffscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="OffscreenClass"
            c:type="CoglOffscreenClass"
            glib:is-gtype-struct-for="Offscreen">
      <source-position filename="cogl/cogl/cogl-offscreen.h" line="54"/>
      <field name="parent_class">
        <type name="FramebufferClass" c:type="CoglFramebufferClass"/>
      </field>
    </record>
    <class name="Onscreen"
           c:symbol-prefix="onscreen"
           c:type="CoglOnscreen"
           parent="Framebuffer"
           glib:type-name="CoglOnscreen"
           glib:get-type="cogl_onscreen_get_type"
           glib:type-struct="OnscreenClass">
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="85"/>
      <virtual-method name="bind">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="59"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="direct_scanout"
                      invoker="direct_scanout"
                      throws="1">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="74"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_buffer_age" invoker="get_buffer_age">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="111">Gets the current age of the buffer contents.

This function allows applications to query the age of the current
back buffer contents for a #CoglOnscreen as the number of frames
elapsed since the contents were most recently defined.

These age values exposes enough information to applications about
how Cogl internally manages back buffers to allow applications to
re-use the contents of old frames and minimize how much must be
redrawn for the next frame.

The back buffer contents can either be reported as invalid (has an
age of 0) or it may be reported to be the same contents as from n
frames prior to the current frame.

The queried value remains valid until the next buffer swap.

One caveat is that under X11 the buffer age does not reflect
changes to buffer contents caused by the window systems. X11
applications must track Expose events to determine what buffer
regions need to additionally be repaired each frame.

The recommended way to take advantage of this buffer age api is to
build up a circular buffer of length 3 for tracking damage regions
over the last 3 frames and when starting a new frame look at the
age of the buffer and combine the damage regions for the current
frame with the damage regions of previous @age frames so you know
everything that must be redrawn to update the old contents for the
new frame.

If the system doesn't not support being able to track the age
of back buffers then this function will always return 0 which
implies that the contents are undefined.

The %COGL_FEATURE_ID_BUFFER_AGE feature can optionally be
explicitly checked to determine if Cogl is currently tracking the
age of #CoglOnscreen back buffer contents. If this feature is
missing then this function will always return 0.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="80"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="154">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="113">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_window_handles" invoker="get_window_handles">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="82"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="device_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="window_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="queue_damage_region" invoker="queue_damage_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="160">Implementation for https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_partial_update.txt
This immediately queues state to OpenGL that will be used for the
next swap.
This needs to be called every frame.

The expected values are independent of any viewport transforms applied to
the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="71"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="162">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="163">A region representing damage</doc>
            <type name="Mtk.Region" c:type="const MtkRegion*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="swap_buffers_with_damage"
                      invoker="swap_buffers_with_damage">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="177">Swaps the current back buffer being rendered too, to the front for
display and provides information to any system compositor about
what regions of the buffer have changed (damage) with respect to
the last swapped buffer.

This function has the same semantics as
cogl_framebuffer_swap_buffers() except that it additionally allows
applications to pass a damage region which may be used to minimize how much
of the screen is redrawn.

For example if your application is only animating a small object in
the corner of the screen and everything else is remaining static
then it can help the compositor to know that only the bottom right
corner of your newly swapped buffer has really changed with respect
to your previously swapped front buffer.

If @region is NULL then the whole buffer will implicitly be
reported as damaged as if cogl_onscreen_swap_buffers() had been
called.

This function also implicitly discards the contents of the color,
depth and stencil buffers as if cogl_framebuffer_discard_buffers()
were used. The significance of the discard is that you should not
expect to be able to start a new frame that incrementally builds on
the contents of the previous frame. If you want to perform
incremental updates to older back buffers then please refer to the
cogl_onscreen_get_buffer_age() api.

Whenever possible it is recommended that applications use this
function instead of cogl_onscreen_swap_buffers() to improve
performance when running under a compositor.

It is highly recommended to use this API in conjunction with
the cogl_onscreen_get_buffer_age() api so that your application can
perform incremental rendering based on old back buffers.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="61"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="179">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="180">A region representing damage</doc>
            <type name="Mtk.Region" c:type="const MtkRegion*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="swap_region" invoker="swap_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="243">Swaps a region of the back buffer being rendered too, to the front for
display.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="66"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="245">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="246">A region</doc>
            <type name="Mtk.Region" c:type="const MtkRegion*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="2">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_frame_callback"
              c:identifier="cogl_onscreen_add_frame_callback">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="337">Installs a @callback function that will be called for significant
events relating to the given @onscreen framebuffer.

The @callback will be used to notify when the system compositor is
ready for this application to render a new frame. In this case
%COGL_FRAME_EVENT_SYNC will be passed as the event argument to the
given @callback in addition to the #CoglFrameInfo corresponding to
the frame being acknowledged by the compositor.

The @callback will also be called to notify when the frame has
ended. In this case %COGL_FRAME_EVENT_COMPLETE will be passed as
the event argument to the given @callback in addition to the
#CoglFrameInfo corresponding to the newly presented frame.  The
meaning of "ended" here simply means that no more timing
information will be collected within the corresponding
#CoglFrameInfo and so this is a good opportunity to analyse the
given info. It does not necessarily mean that the GPU has finished
rendering the corresponding frame.

We highly recommend throttling your application according to
%COGL_FRAME_EVENT_SYNC events so that your application can avoid
wasting resources, drawing more frames than your system compositor
can display.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="374"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="370">a #CoglFrameClosure pointer that can be used to
         remove the callback and associated @user_data later.</doc>
          <type name="FrameClosure" c:type="CoglFrameClosure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="339">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="notified"
                     closure="1"
                     destroy="2">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="340">A callback function
           to call for frame events</doc>
            <type name="FrameCallback" c:type="CoglFrameCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="342">A private pointer to be passed to @callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
          <parameter name="destroy"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     scope="async">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="343">An optional callback to destroy @user_data
          when the @callback is removed or @onscreen is freed.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_frame_info"
              c:identifier="cogl_onscreen_add_frame_info">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="240"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="236">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="237">A #CoglFrameInfo</doc>
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="direct_scanout"
              c:identifier="cogl_onscreen_direct_scanout"
              throws="1">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="228"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_age"
              c:identifier="cogl_onscreen_get_buffer_age">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="111">Gets the current age of the buffer contents.

This function allows applications to query the age of the current
back buffer contents for a #CoglOnscreen as the number of frames
elapsed since the contents were most recently defined.

These age values exposes enough information to applications about
how Cogl internally manages back buffers to allow applications to
re-use the contents of old frames and minimize how much must be
redrawn for the next frame.

The back buffer contents can either be reported as invalid (has an
age of 0) or it may be reported to be the same contents as from n
frames prior to the current frame.

The queried value remains valid until the next buffer swap.

One caveat is that under X11 the buffer age does not reflect
changes to buffer contents caused by the window systems. X11
applications must track Expose events to determine what buffer
regions need to additionally be repaired each frame.

The recommended way to take advantage of this buffer age api is to
build up a circular buffer of length 3 for tracking damage regions
over the last 3 frames and when starting a new frame look at the
age of the buffer and combine the damage regions for the current
frame with the damage regions of previous @age frames so you know
everything that must be redrawn to update the old contents for the
new frame.

If the system doesn't not support being able to track the age
of back buffers then this function will always return 0 which
implies that the contents are undefined.

The %COGL_FEATURE_ID_BUFFER_AGE feature can optionally be
explicitly checked to determine if Cogl is currently tracking the
age of #CoglOnscreen back buffer contents. If this feature is
missing then this function will always return 0.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="158"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="154">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="113">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_frame_counter"
              c:identifier="cogl_onscreen_get_frame_counter">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="396">Gets the value of the framebuffers frame counter. This is
a counter that increases by one each time
cogl_onscreen_swap_buffers() or cogl_onscreen_swap_region()
is called.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="407"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-onscreen.h"
               line="404">the current frame counter value</doc>
          <type name="gint64" c:type="int64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_window_handles"
              c:identifier="cogl_onscreen_get_window_handles">
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="410"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="device_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
          <parameter name="window_out"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="queue_damage_region"
              c:identifier="cogl_onscreen_queue_damage_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="160">Implementation for https://www.khronos.org/registry/EGL/extensions/KHR/EGL_KHR_partial_update.txt
This immediately queues state to OpenGL that will be used for the
next swap.
This needs to be called every frame.

The expected values are independent of any viewport transforms applied to
the framebuffer.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="174"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="162">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="163">A region representing damage</doc>
            <type name="Mtk.Region" c:type="const MtkRegion*"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_frame_callback"
              c:identifier="cogl_onscreen_remove_frame_callback">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="379">Removes a callback and associated user data that were previously
registered using cogl_onscreen_add_frame_callback().

If a destroy callback was passed to
cogl_onscreen_add_frame_callback() to destroy the user data then
this will get called.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="393"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="381">A #CoglOnscreen</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="closure" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="382">A #CoglFrameClosure returned from
          cogl_onscreen_add_frame_callback()</doc>
            <type name="FrameClosure" c:type="CoglFrameClosure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_buffers" c:identifier="cogl_onscreen_swap_buffers">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="87">Swaps the current back buffer being rendered too, to the front for display.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.

It is highly recommended that applications use
cogl_onscreen_swap_buffers_with_damage() instead whenever possible
and also use the cogl_onscreen_get_buffer_age() api so they can
perform incremental updates to older buffers instead of having to
render a full buffer for every frame.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="106"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="89">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="frame_info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_buffers_with_damage"
              c:identifier="cogl_onscreen_swap_buffers_with_damage">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="177">Swaps the current back buffer being rendered too, to the front for
display and provides information to any system compositor about
what regions of the buffer have changed (damage) with respect to
the last swapped buffer.

This function has the same semantics as
cogl_framebuffer_swap_buffers() except that it additionally allows
applications to pass a damage region which may be used to minimize how much
of the screen is redrawn.

For example if your application is only animating a small object in
the corner of the screen and everything else is remaining static
then it can help the compositor to know that only the bottom right
corner of your newly swapped buffer has really changed with respect
to your previously swapped front buffer.

If @region is NULL then the whole buffer will implicitly be
reported as damaged as if cogl_onscreen_swap_buffers() had been
called.

This function also implicitly discards the contents of the color,
depth and stencil buffers as if cogl_framebuffer_discard_buffers()
were used. The significance of the discard is that you should not
expect to be able to start a new frame that incrementally builds on
the contents of the previous frame. If you want to perform
incremental updates to older back buffers then please refer to the
cogl_onscreen_get_buffer_age() api.

Whenever possible it is recommended that applications use this
function instead of cogl_onscreen_swap_buffers() to improve
performance when running under a compositor.

It is highly recommended to use this API in conjunction with
the cogl_onscreen_get_buffer_age() api so that your application can
perform incremental rendering based on old back buffers.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="219"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="179">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="180">A region representing damage</doc>
            <type name="Mtk.Region" c:type="const MtkRegion*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="swap_region" c:identifier="cogl_onscreen_swap_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-onscreen.h"
             line="243">Swaps a region of the back buffer being rendered too, to the front for
display.

This function also implicitly discards the contents of the color, depth and
stencil buffers as if cogl_framebuffer_discard_buffers() were used. The
significance of the discard is that you should not expect to be able to
start a new frame that incrementally builds on the contents of the previous
frame.</doc>
        <source-position filename="cogl/cogl/cogl-onscreen.h" line="258"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="onscreen" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="245">A #CoglOnscreen framebuffer</doc>
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </instance-parameter>
          <parameter name="region" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="246">A region</doc>
            <type name="Mtk.Region" c:type="const MtkRegion*"/>
          </parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="FrameInfo" c:type="CoglFrameInfo*"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent_instance">
        <type name="Framebuffer" c:type="CoglFramebuffer"/>
      </field>
    </class>
    <record name="OnscreenClass"
            c:type="CoglOnscreenClass"
            glib:is-gtype-struct-for="Onscreen">
      <source-position filename="cogl/cogl/cogl-onscreen.h" line="85"/>
      <field name="parent_class" readable="0" private="1">
        <type name="FramebufferClass" c:type="CoglFramebufferClass"/>
      </field>
      <field name="bind">
        <callback name="bind">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="59"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="swap_buffers_with_damage">
        <callback name="swap_buffers_with_damage">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="61"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="179">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="region" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="180">A region representing damage</doc>
              <type name="Mtk.Region" c:type="const MtkRegion*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FrameInfo" c:type="CoglFrameInfo*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="swap_region">
        <callback name="swap_region">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="66"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="245">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="region" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="246">A region</doc>
              <type name="Mtk.Region" c:type="const MtkRegion*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FrameInfo" c:type="CoglFrameInfo*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="queue_damage_region">
        <callback name="queue_damage_region">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="71"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="162">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="region" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="163">A region representing damage</doc>
              <type name="Mtk.Region" c:type="const MtkRegion*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="direct_scanout">
        <callback name="direct_scanout" throws="1">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="74"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="scanout" transfer-ownership="none">
              <type name="Scanout" c:type="CoglScanout*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="FrameInfo" c:type="CoglFrameInfo*"/>
            </parameter>
            <parameter name="user_data"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1"
                       closure="3">
              <type name="gpointer" c:type="gpointer"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_buffer_age">
        <callback name="get_buffer_age">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="80"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-onscreen.h"
                 line="154">The age of the buffer contents or 0 when the buffer
              contents are undefined.</doc>
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="cogl/cogl/cogl-onscreen.h"
                   line="113">A #CoglOnscreen framebuffer</doc>
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_window_handles">
        <callback name="get_window_handles">
          <source-position filename="cogl/cogl/cogl-onscreen.h" line="82"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="onscreen" transfer-ownership="none">
              <type name="Onscreen" c:type="CoglOnscreen*"/>
            </parameter>
            <parameter name="device_out"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="gpointer*"/>
            </parameter>
            <parameter name="window_out"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="gpointer" c:type="gpointer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <function-macro name="PARAM_SPEC_COLOR"
                    c:identifier="COGL_PARAM_SPEC_COLOR"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-color.h" line="310"/>
      <parameters>
        <parameter name="pspec">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PIXEL_BUFFER"
                    c:identifier="COGL_PIXEL_BUFFER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="52"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PIXEL_BUFFER_CLASS"
                    c:identifier="COGL_PIXEL_BUFFER_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="54"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PIXEL_BUFFER_CONST"
                    c:identifier="COGL_PIXEL_BUFFER_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="53"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PIXEL_BUFFER_GET_CLASS"
                    c:identifier="COGL_PIXEL_BUFFER_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="57"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="PIXEL_FORMAT_MAX_PLANES"
              value="4"
              c:type="COGL_PIXEL_FORMAT_MAX_PLANES">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="277">The maximum number of planes of a pixel format (see also
cogl_pixel_format_get_planes()).</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="283"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="PREMULT_BIT" value="128" c:type="COGL_PREMULT_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="50"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="PRIVATE"
                    c:identifier="COGL_PRIVATE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-types.h" line="54"/>
      <parameters>
        <parameter name="x">
        </parameter>
      </parameters>
    </function-macro>
    <class name="ParamSpecColor"
           c:symbol-prefix="param_color"
           c:type="CoglParamSpecColor"
           introspectable="0"
           parent="GObject.ParamSpec"
           glib:type-name="CoglParamSpecColor"
           glib:get-type="cogl_param_color_get_type"
           glib:fundamental="1">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="321">A #GParamSpec subclass for defining properties holding
a #CoglColor.</doc>
      <field name="parent_instance" readable="0" private="1">
        <type name="GObject.ParamSpec" c:type="GParamSpec"/>
      </field>
      <field name="default_value">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="323">default color value</doc>
        <type name="Color" c:type="CoglColor*"/>
      </field>
    </class>
    <class name="Pipeline"
           c:symbol-prefix="pipeline"
           c:type="CoglPipeline"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglPipeline"
           glib:get-type="cogl_pipeline_get_type"
           glib:type-struct="PipelineClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline.h"
           line="45">Functions for creating and manipulating the GPU pipeline

Cogl allows creating and manipulating objects representing the full
configuration of the GPU pipeline. In simplified terms the GPU
pipeline takes primitive geometry as the input, it first performs
vertex processing, allowing you to deform your geometry, then
rasterizes that (turning it from pure geometry into fragments) then
performs fragment processing including depth testing and texture
mapping. Finally it blends the result with the framebuffer.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline.h" line="62"/>
      <constructor name="new" c:identifier="cogl_pipeline_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="64">Allocates and initializes a default simple pipeline that will color
a primitive white.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="74"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="71">a pointer to a new #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="66">a #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="add_layer_snippet"
              c:identifier="cogl_pipeline_add_layer_snippet">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="454">Adds a shader snippet that will hook on to the given layer of the
pipeline. The exact part of the pipeline that the snippet wraps
around depends on the hook that is given to
cogl_snippet_new(). Note that some hooks can't be used with a layer
and need to be added with cogl_pipeline_add_snippet() instead.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="467"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="456">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="457">The layer to hook the snippet to</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="458">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="add_snippet" c:identifier="cogl_pipeline_add_snippet">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="603">Adds a shader snippet to @pipeline. The snippet will wrap around or
replace some part of the pipeline as defined by the hook point in
@snippet. Note that some hook points are specific to a layer and
must be added with cogl_pipeline_add_layer_snippet() instead.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="614"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="605">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="606">The #CoglSnippet to add to the vertex processing hook</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy" c:identifier="cogl_pipeline_copy">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="76">Creates a new pipeline with the configuration copied from the
source pipeline.

We would strongly advise developers to always aim to use
cogl_pipeline_copy() instead of cogl_pipeline_new() whenever there will
be any similarity between two pipelines. Copying a pipeline helps Cogl
keep track of a pipelines ancestry which we may use to help minimize GPU
state changes.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="92"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="89">a pointer to the newly allocated #CoglPipeline</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </return-value>
        <parameters>
          <instance-parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="78">a #CoglPipeline object to copy</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_layer" c:identifier="cogl_pipeline_foreach_layer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="107">Iterates all the layer indices of the given @pipeline.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="117"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="109">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="110">A #CoglPipelineLayerCallback
           to be called for each layer index</doc>
            <type name="PipelineLayerCallback"
                  c:type="CoglPipelineLayerCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="112">Private data that will be passed to the callback</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_function"
              c:identifier="cogl_pipeline_get_alpha_test_function">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="132">The alpha test function of @pipeline.</doc>
          <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="130">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_alpha_test_reference"
              c:identifier="cogl_pipeline_get_alpha_test_reference">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="144"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="141">The alpha test reference value of @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="139">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_color" c:identifier="cogl_pipeline_get_color">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="62">Retrieves the current pipeline color.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="64">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="65">The location to store the color</doc>
            <type name="Color" c:type="CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_cull_face_mode"
              c:identifier="cogl_pipeline_get_cull_face_mode">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="432"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="428">the cull face mode that was previously set with
cogl_pipeline_set_cull_face_mode().</doc>
          <type name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_depth_state"
              c:identifier="cogl_pipeline_get_depth_state">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="372">Retrieves the current depth state configuration for the given
@pipeline as previously set using cogl_pipeline_set_depth_state().</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="381"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="374">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state_out"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="375">A destination #CoglDepthState struct</doc>
            <type name="DepthState" c:type="CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_front_face_winding"
              c:identifier="cogl_pipeline_get_front_face_winding">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="451">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="466"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="463">The @pipeline front face winding</doc>
          <type name="Winding" c:type="CoglWinding"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="453">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_layer_filters"
              c:identifier="cogl_pipeline_get_layer_filters">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="305">Returns the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="318"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="307">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="308">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="309">Return location for the filter used when scaling
  a texture down.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter*"/>
          </parameter>
          <parameter name="mag_filter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="311">Return location for the filter used when magnifying
  a texture.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_get_layer_point_sprite_coords_enabled">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="366">Gets whether point sprite coordinate generation is enabled for this
texture layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="378"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="374">whether the texture coordinates will be replaced with
point sprite coordinates.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="368">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="369">the layer number to check.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_texture"
              c:identifier="cogl_pipeline_get_layer_texture">
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="178"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="174">the texture that was set for the
  given layer of the pipeline or %NULL if no texture was set.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="171">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="172">the index of the layer</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_s">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="381">Returns the wrap mode for the 's' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="393"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="389">the wrap mode for the 's' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="383">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="384">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_get_layer_wrap_mode_t">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="409">Returns the wrap mode for the 't' coordinate of texture lookups on this
layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="421"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="417">the wrap mode for the 't' coordinate of texture lookups on
this layer.</doc>
          <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="411">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="412">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_n_layers" c:identifier="cogl_pipeline_get_n_layers">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="294">Retrieves the number of layers defined for the given @pipeline</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="303"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="300">the number of layers</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="296">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="cogl_pipeline_get_name">
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="166"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="163">The pipeline name, or %NULL</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="161">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_per_vertex_point_size"
              c:identifier="cogl_pipeline_get_per_vertex_point_size">
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="293"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="288">%TRUE if the pipeline has per-vertex point size
  enabled or %FALSE otherwise. The per-vertex point size can be
  enabled with cogl_pipeline_set_per_vertex_point_size().</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="287">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_point_size"
              c:identifier="cogl_pipeline_get_point_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="250">Get the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the vertex buffer API.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="260"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="257">the point size of the @pipeline.</doc>
          <type name="gfloat" c:type="float"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="252">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_uniform_location"
              c:identifier="cogl_pipeline_get_uniform_location">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="121">This is used to get an integer representing the uniform with the
name @uniform_name. The integer can be passed to functions such as
cogl_pipeline_set_uniform_1f() to set the value of a uniform.

This function will always return a valid integer. Ie, unlike
OpenGL, it does not return -1 if the uniform is not available in
this pipeline so it can not be used to test whether uniforms are
present. It is not necessary to set the program on the pipeline
before calling this function.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="139"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="136">A integer representing the location of the given uniform.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="123">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="124">The name of a uniform</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_user_program"
              c:identifier="cogl_pipeline_get_user_program">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="295">Queries what user program has been associated with the given
@pipeline using cogl_pipeline_set_user_program().</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="305"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="302">The current user program or %NULL.</doc>
          <type name="Program" c:type="CoglProgram*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="297">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_capability"
              c:identifier="cogl_pipeline_has_capability">
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="143"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="capability" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_layer" c:identifier="cogl_pipeline_remove_layer">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="181">This function removes a layer from your pipeline</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="189"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="183">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="184">Specifies the layer you want to remove</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_alpha_test_function"
              c:identifier="cogl_pipeline_set_alpha_test_function">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="108">Before a primitive is blended with the framebuffer, it goes through an
alpha test stage which lets you discard fragments based on the current
alpha value. This function lets you change the function used to evaluate
the alpha channel, and thus determine which fragments are discarded
and which continue on to the blending stage.

The default is %COGL_PIPELINE_ALPHA_FUNC_ALWAYS</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="124"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="110">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="alpha_func" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="111">A @CoglPipelineAlphaFunc constant</doc>
            <type name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc"/>
          </parameter>
          <parameter name="alpha_reference" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="112">A reference point that the chosen alpha function uses
  to compare incoming fragments to.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend"
              c:identifier="cogl_pipeline_set_blend"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="146">Blending occurs after the alpha test function, and combines fragments with
the framebuffer.

Currently the only blend function Cogl exposes is ADD(). So any valid
blend statements will be of the form:

```
  &amp;lt;channel-mask&amp;gt;=ADD(SRC_COLOR*(&amp;lt;factor&amp;gt;), DST_COLOR*(&amp;lt;factor&amp;gt;))
```

This is the list of source-names usable as blend factors:

- `SRC_COLOR`: The color of the incoming fragment
- `DST_COLOR`: The color of the framebuffer
- `CONSTANT`: The constant set via cogl_pipeline_set_blend_constant()

These can also be used as factors:

- `0`: (0, 0, 0, 0)
- `1`: (1, 1, 1, 1)
- `SRC_ALPHA_SATURATE_FACTOR`: (f,f,f,1) where `f = MIN(SRC_COLOR[A],1-DST_COLOR[A])`

Remember; all color components are normalized to the range [0, 1]
before computing the result of blending.

- Blend Strings/1:
Blend a non-premultiplied source over a destination with
premultiplied alpha:
  ```
"RGB = ADD(SRC_COLOR*(SRC_COLOR[A]), DST_COLOR*(1-SRC_COLOR[A]))"
"A   = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  ```

Blend Strings/2:
  Blend a premultiplied source over a destination with
  premultiplied alpha
  ```
"RGBA = ADD(SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))"
  ```

The default blend string is:
```
   RGBA = ADD (SRC_COLOR, DST_COLOR*(1-SRC_COLOR[A]))
```

That gives normal alpha-blending when the calculated color for the pipeline
is in premultiplied form.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="212"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="206">%TRUE if the blend string was successfully parsed, and the
  described blending is supported by the underlying driver/hardware. If
  there was an error, %FALSE is returned and @error is set accordingly (if
  present).</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="148">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="149">A Cogl blend string
  describing the desired blend function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blend_constant"
              c:identifier="cogl_pipeline_set_blend_constant">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="216">When blending is setup to reference a CONSTANT blend factor then
blending will depend on the constant set with this function.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="225"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="218">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="constant_color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="219">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_color" c:identifier="cogl_pipeline_set_color">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="44">Sets the basic color of the pipeline, used when no lighting is enabled.

Note that if you don't add any layers to the pipeline then the color
will be blended unmodified with the destination; the default blend
expects premultiplied colors: for example, use (0.5, 0.0, 0.0, 0.5) for
semi-transparent red. See cogl_color_premultiply().

The default value is (1.0, 1.0, 1.0, 1.0)</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="59"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="46">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="color" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="47">The components of the color</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_cull_face_mode"
              c:identifier="cogl_pipeline_set_cull_face_mode">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="403">Sets which faces will be culled when drawing. Face culling can be
used to increase efficiency by avoiding drawing faces that would
get overridden. For example, if a model has gaps so that it is
impossible to see the inside then faces which are facing away from
the screen will never be seen so there is no point in drawing
them. This can be achieved by setting the cull face mode to
%COGL_PIPELINE_CULL_FACE_MODE_BACK.

Face culling relies on the primitives being drawn with a specific
order to represent which faces are facing inside and outside the
model. This order can be specified by calling
cogl_pipeline_set_front_face_winding().</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="422"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="405">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="cull_face_mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="406">The new mode to set</doc>
            <type name="PipelineCullFaceMode"
                  c:type="CoglPipelineCullFaceMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_depth_state"
              c:identifier="cogl_pipeline_set_depth_state"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="350">This commits all the depth state configured in @state struct to the
given @pipeline. The configuration values are copied into the
pipeline so there is no requirement to keep the #CoglDepthState
struct around if you don't need it any more.

Note: Since some platforms do not support the depth range feature
it is possible for this function to fail and report an @error.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="368"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="364">%TRUE if the GPU supports all the given @state else %FALSE
         and returns an @error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="352">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="state" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="353">A #CoglDepthState struct</doc>
            <type name="DepthState" c:type="const CoglDepthState*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_front_face_winding"
              c:identifier="cogl_pipeline_set_front_face_winding">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="434">The order of the vertices within a primitive specifies whether it
is considered to be front or back facing. This function specifies
which order is considered to be the front
faces. %COGL_WINDING_COUNTER_CLOCKWISE sets the front faces to
primitives with vertices in a counter-clockwise order and
%COGL_WINDING_CLOCKWISE sets them to be clockwise. The default is
%COGL_WINDING_COUNTER_CLOCKWISE.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="448"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="436">a #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="front_winding" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="437">the winding order</doc>
            <type name="Winding" c:type="CoglWinding"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine"
              c:identifier="cogl_pipeline_set_layer_combine"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="192">These are all the functions available for texture combining:

- `REPLACE(arg0) = arg0`
- `MODULATE(arg0, arg1) = arg0 x arg1`
- `ADD(arg0, arg1) = arg0 + arg1`
- `ADD_SIGNED(arg0, arg1) = arg0 + arg1 - 0.5`
- `INTERPOLATE(arg0, arg1, arg2) = arg0 x arg2 + arg1 x (1 - arg2)`
- `SUBTRACT(arg0, arg1) = arg0 - arg1`
-
```
 DOT3_RGB(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                             (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                             (arg0[B] - 0.5)) * (arg1[B] - 0.5))
```
-
```
 DOT3_RGBA(arg0, arg1) = 4 x ((arg0[R] - 0.5)) * (arg1[R] - 0.5) +
                              (arg0[G] - 0.5)) * (arg1[G] - 0.5) +
                              (arg0[B] - 0.5)) * (arg1[B] - 0.5))
```

The valid source names for texture combining are:

- `TEXTURE`: Use the color from the current texture layer
- `TEXTURE_0, TEXTURE_1, etc`: Use the color from the specified texture layer
- `CONSTANT`: Use the color from the constant given with
    [method@Cogl.Pipeline.set_layer_combine_constant]
- `PRIMARY`: Use the color of the pipeline as set with
    [method@Cogl.Pipeline.set_color]
- `PREVIOUS`: Either use the texture color from the previous layer, or
    if this is layer 0, use the color of the pipeline as set with
    [method@Cogl.Pipeline.set_color]

Layer Combine Examples:

This is effectively what the default blending is:

```
RGBA = MODULATE (PREVIOUS, TEXTURE)
```

This could be used to cross-fade between two images, using
the alpha component of a constant as the interpolator. The constant
color is given by calling [method@Cogl.Pipeline.set_layer_combine_constant].

```
RGBA = INTERPOLATE (PREVIOUS, TEXTURE, CONSTANT[A])
```

You can't give a multiplication factor for arguments as you can
with blending.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="260"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="255">%TRUE if the blend string was successfully parsed, and the
  described texture combining is supported by the underlying driver and
  or hardware. On failure, %FALSE is returned and @error is set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="194">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="195">Specifies the layer you want define a combine function for</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="blend_string" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="196">A Cogl blend string describing the desired
 texture combine function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_combine_constant"
              c:identifier="cogl_pipeline_set_layer_combine_constant">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="265">When you are using the 'CONSTANT' color source in a layer combine
description then you can use this function to define its value.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="276"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="267">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="268">Specifies the layer you want to specify a constant used
              for texture combining</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="constant" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="270">The constant color you want</doc>
            <type name="Color" c:type="const CoglColor*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_filters"
              c:identifier="cogl_pipeline_set_layer_filters">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="323">Changes the decimation and interpolation filters used when a texture is
drawn at other scales than 100%.

It is an error to pass anything other than
%COGL_PIPELINE_FILTER_NEAREST or %COGL_PIPELINE_FILTER_LINEAR as
magnification filters since magnification doesn't ever need to
reference values stored in the mipmap chain.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="339"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="325">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="326">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="min_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="327">the filter used when scaling a texture down.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
          <parameter name="mag_filter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="328">the filter used when magnifying a texture.</doc>
            <type name="PipelineFilter" c:type="CoglPipelineFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_matrix"
              c:identifier="cogl_pipeline_set_layer_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="280">This function lets you set a matrix that can be used to e.g. translate
and rotate a single layer of a pipeline used to fill your geometry.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="290"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="282">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="283">the index for the layer inside @pipeline</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="matrix" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="284">the transformation matrix for the layer</doc>
            <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_max_mipmap_level"
              c:identifier="cogl_pipeline_set_layer_max_mipmap_level">
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="472"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_level" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_null_texture"
              c:identifier="cogl_pipeline_set_layer_null_texture">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="151">Sets the texture for this layer to be the default texture for the
given type. The default texture is a 1x1 pixel white texture.

This function is mostly useful if you want to create a base
pipeline that you want to create multiple copies from using
cogl_pipeline_copy(). In that case this function can be used to
specify the texture type so that any pipeline copies can share the
internal texture type state for efficiency.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="166"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="153">A #CoglPipeline</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="154">The layer number to modify</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_point_sprite_coords_enabled"
              c:identifier="cogl_pipeline_set_layer_point_sprite_coords_enabled"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="344">When rendering points, if @enable is %TRUE then the texture
coordinates for this layer will be replaced with coordinates that
vary from 0.0 to 1.0 across the primitive. The top left of the
point will have the coordinates 0.0,0.0 and the bottom right will
have 1.0,1.0. If @enable is %FALSE then the coordinates will be
fixed for the entire point.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="361"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-layer-state.h"
               line="358">%TRUE if the function succeeds, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="346">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="347">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="348">whether to enable point sprite coord generation.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_texture"
              c:identifier="cogl_pipeline_set_layer_texture">
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="147"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode"
              c:identifier="cogl_pipeline_set_layer_wrap_mode">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="438">Sets the wrap mode for all three coordinates of texture lookups on
this layer. This is equivalent to calling
cogl_pipeline_set_layer_wrap_mode_s() and
cogl_pipeline_set_layer_wrap_mode_t() separately.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="450"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="440">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="441">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="442">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_s"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_s">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="396">Sets the wrap mode for the 's' coordinate of texture lookups on this layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="405"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="398">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="399">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="400">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_layer_wrap_mode_t"
              c:identifier="cogl_pipeline_set_layer_wrap_mode_t">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="425">Sets the wrap mode for the 't' coordinate of texture lookups on this layer.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                         line="434"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="427">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="layer_index" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="428">the layer number to change.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-layer-state.h"
                 line="429">the new wrap mode</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_per_vertex_point_size"
              c:identifier="cogl_pipeline_set_per_vertex_point_size"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="262">Sets whether to use a per-vertex point size or to use the value set
by cogl_pipeline_set_point_size(). If per-vertex point size is
enabled then the point size can be set for an individual point
either by drawing with a #CoglAttribute with the name
â€˜cogl_point_size_inâ€™ or by writing to the GLSL builtin
â€˜cogl_point_size_outâ€™ from a vertex shader snippet.

If per-vertex point size is enabled and this attribute is not used
and cogl_point_size_out is not written to then the results are
undefined.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="281"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline-state.h"
               line="278">%TRUE if the change succeeded or %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="264">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="enable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="265">whether to enable per-vertex point size</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_point_size"
              c:identifier="cogl_pipeline_set_point_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="228">Changes the size of points drawn when %COGL_VERTICES_MODE_POINTS is
used with the attribute buffer API. Note that typically the GPU
will only support a limited minimum and maximum range of point
sizes. If the chosen point size is outside that range then the
nearest value within that range will be used instead. The size of a
point is in screen space so it will be the same regardless of any
transformations.

If the point size is set to 0.0 then drawing points with the
pipeline will have undefined results. This is the default value so
if an application wants to draw points it must make sure to use a
pipeline that has an explicit point size set on it.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="247"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="230">a #CoglPipeline pointer</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="point_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="231">the new point size.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_static_name"
              c:identifier="cogl_pipeline_set_static_name">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline.h"
             line="147">Set a pipeline name. It may be used for debugging or logging purposes. The
string must be a static string, and string. It will not be copied.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline.h" line="156"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="149">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline.h"
                 line="150">A descriptive name</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1f"
              c:identifier="cogl_pipeline_set_uniform_1f">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="468">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
float. It can also be used to set a single member of a float array
uniform.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="486"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="470">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="471">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="472">The new value for the uniform</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1i"
              c:identifier="cogl_pipeline_set_uniform_1i">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="490">Sets a new value for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given value will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function should be used to set uniforms that are of type
int. It can also be used to set a single member of a int array
uniform or a sampler uniform.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="508"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="492">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="493">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="494">The new value for the uniform</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_float"
              c:identifier="cogl_pipeline_set_uniform_float">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="512">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any floating point type uniform,
including float arrays and float vectors. For example, to set a
single vec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 float values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="534"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="514">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="515">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="516">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="517">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="518">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_int"
              c:identifier="cogl_pipeline_set_uniform_int">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="540">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any integer type uniform,
including int arrays and int vectors. For example, to set a single
ivec4 uniform you would use 4 for @n_components and 1 for
@count. To set an array of 8 int values, you could use 1 for
@n_components and 8 for @count.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="562"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="542">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="543">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="544">The number of components in the corresponding uniform's type</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="545">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="546">Pointer to the new values to set</doc>
            <type name="gint" c:type="const int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix"
              c:identifier="cogl_pipeline_set_uniform_matrix">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="568">Sets new values for the uniform at @uniform_location. If this
pipeline has a user program attached and is later used as a source
for drawing, the given values will be assigned to the uniform which
can be accessed from the shader's source. The value for
@uniform_location should be retrieved from the string name of the
uniform by calling cogl_pipeline_get_uniform_location().

This function can be used to set any matrix type uniform, including
matrix arrays. For example, to set a single mat4 uniform you would
use 4 for @dimensions and 1 for @count. To set an array of 8
mat3 values, you could use 3 for @dimensions and 8 for @count.

If @transpose is %FALSE then the matrix is expected to be in
column-major order or if it is %TRUE then the matrix is in
row-major order. You can pass a #graphene_matrix_t by calling by passing
the result of graphene_matrix_to_float() in @value and setting
@transpose to %FALSE.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="596"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="570">A #CoglPipeline object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="571">The uniform's location identifier</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dimensions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="572">The size of the matrix</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="573">The number of values to set</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="574">Whether to transpose the matrix</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="575">Pointer to the new values to set</doc>
            <type name="gfloat" c:type="const float*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_user_program"
              c:identifier="cogl_pipeline_set_user_program">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="307">Associates a linked CoglProgram with the given pipeline so that the
program can take full control of vertex and/or fragment processing.

This is an example of how it can be used to associate an ARBfp
program with a #CoglPipeline:
```c
CoglShader *shader;
CoglProgram *program;
CoglPipeline *pipeline;

shader = cogl_shader_new (COGL_SHADER_TYPE_FRAGMENT);
cogl_shader_source (shader,
                    "!!ARBfp1.0\n"
                    "MOV result.color,fragment.color;\n"
                    "END\n");

program = cogl_program_new ();
cogl_program_attach_shader (program, shader);
cogl_program_link (program);

pipeline = cogl_pipeline_new ();
cogl_pipeline_set_user_program (pipeline, program);

cogl_set_source_color4ub (0xff, 0x00, 0x00, 0xff);
cogl_rectangle (0, 0, 100, 100);
```

It is possibly worth keeping in mind that this API is not part of
the long term design for how we want to expose shaders to Cogl
developers (We are planning on deprecating the cogl_program and
cogl_shader APIs in favour of a "snippet" framework) but in the
meantime we hope this will handle most practical GLSL and ARBfp
requirements.</doc>
        <source-position filename="cogl/cogl/cogl-pipeline-state.h"
                         line="347"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="309">a #CoglPipeline object.</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </instance-parameter>
          <parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pipeline-state.h"
                 line="310">A linked CoglProgram</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <enumeration name="PipelineAlphaFunc" c:type="CoglPipelineAlphaFunc">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-state.h"
           line="73">Alpha testing happens before blending primitives with the framebuffer and
gives an opportunity to discard fragments based on a comparison with the
incoming alpha value and a reference alpha value. The #CoglPipelineAlphaFunc
determines how the comparison is done.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="105"/>
      <member name="never"
              value="512"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NEVER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="75">Never let the fragment through.</doc>
      </member>
      <member name="less"
              value="513"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LESS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="76">Let the fragment through if the incoming
  alpha value is less than the reference alpha value</doc>
      </member>
      <member name="equal"
              value="514"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_EQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="78">Let the fragment through if the incoming
  alpha value equals the reference alpha value</doc>
      </member>
      <member name="lequal"
              value="515"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_LEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="80">Let the fragment through if the incoming
  alpha value is less than or equal to the reference alpha value</doc>
      </member>
      <member name="greater"
              value="516"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GREATER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="82">Let the fragment through if the incoming
  alpha value is greater than the reference alpha value</doc>
      </member>
      <member name="notequal"
              value="517"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_NOTEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="84">Let the fragment through if the incoming
  alpha value does not equal the reference alpha value</doc>
      </member>
      <member name="gequal"
              value="518"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_GEQUAL">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="86">Let the fragment through if the incoming
  alpha value is greater than or equal to the reference alpha value.</doc>
      </member>
      <member name="always"
              value="519"
              c:identifier="COGL_PIPELINE_ALPHA_FUNC_ALWAYS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="88">Always let the fragment through.</doc>
      </member>
    </enumeration>
    <record name="PipelineClass"
            c:type="CoglPipelineClass"
            glib:is-gtype-struct-for="Pipeline">
      <source-position filename="cogl/cogl/cogl-pipeline.h" line="62"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="PipelineCullFaceMode" c:type="CoglPipelineCullFaceMode">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-state.h"
           line="384">Specifies which faces should be culled. This can be set on a
pipeline using cogl_pipeline_set_cull_face_mode().</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-state.h" line="401"/>
      <member name="none"
              value="0"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_NONE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="386">Neither face will be
 culled. This is the default.</doc>
      </member>
      <member name="front"
              value="1"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_FRONT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="388">Front faces will be culled.</doc>
      </member>
      <member name="back"
              value="2"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BACK">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="389">Back faces will be culled.</doc>
      </member>
      <member name="both"
              value="3"
              c:identifier="COGL_PIPELINE_CULL_FACE_MODE_BOTH">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-state.h"
             line="390">All faces will be culled.</doc>
      </member>
    </enumeration>
    <enumeration name="PipelineFilter" c:type="CoglPipelineFilter">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-layer-state.h"
           line="43">Texture filtering is used whenever the current pixel maps either to more
than one texture element (texel) or less than one. These filter enums
correspond to different strategies used to come up with a pixel color, by
possibly referring to multiple neighbouring texels and taking a weighted
average or simply using the nearest texel.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                       line="78"/>
      <member name="nearest"
              value="9728"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="45">Measuring in manhatten distance from the,
  current pixel center, use the nearest texture texel</doc>
      </member>
      <member name="linear"
              value="9729"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="47">Use the weighted average of the 4 texels
  nearest the current pixel center</doc>
      </member>
      <member name="nearest_mipmap_nearest"
              value="9984"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="49">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_NEAREST criterion</doc>
      </member>
      <member name="linear_mipmap_nearest"
              value="9985"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_NEAREST">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="52">Select the mimap level whose
  texel size most closely matches the current pixel, and use the
  %COGL_PIPELINE_FILTER_LINEAR criterion</doc>
      </member>
      <member name="nearest_mipmap_linear"
              value="9986"
              c:identifier="COGL_PIPELINE_FILTER_NEAREST_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="55">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_NEAREST criterion on each one and take
  their weighted average</doc>
      </member>
      <member name="linear_mipmap_linear"
              value="9987"
              c:identifier="COGL_PIPELINE_FILTER_LINEAR_MIPMAP_LINEAR">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="59">Select the two mimap levels
  whose texel size most closely matches the current pixel, use
  the %COGL_PIPELINE_FILTER_LINEAR criterion on each one and take
  their weighted average</doc>
      </member>
    </enumeration>
    <callback name="PipelineLayerCallback" c:type="CoglPipelineLayerCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline.h"
           line="94">The callback prototype used with cogl_pipeline_foreach_layer() for
iterating all the layers of a @pipeline.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline.h" line="103"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pipeline" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="96">The #CoglPipeline whose layers are being iterated</doc>
          <type name="Pipeline" c:type="CoglPipeline*"/>
        </parameter>
        <parameter name="layer_index" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="97">The current layer index</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pipeline.h"
               line="98">The private data passed to cogl_pipeline_foreach_layer()</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <enumeration name="PipelineWrapMode" c:type="CoglPipelineWrapMode">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pipeline-layer-state.h"
           line="81">The wrap mode specifies what happens when texture coordinates
outside the range 0â†’1 are used. Note that if the filter mode is
anything but %COGL_PIPELINE_FILTER_NEAREST then texels outside the
range 0â†’1 might be used even when the coordinate is exactly 0 or 1
because OpenGL will try to sample neighbouring pixels. For example
if you are trying to render the full texture then you may get
artifacts around the edges when the pixels from the other side are
merged in if the wrap mode is set to repeat.</doc>
      <source-position filename="cogl/cogl/cogl-pipeline-layer-state.h"
                       line="119"/>
      <member name="repeat"
              value="10497"
              c:identifier="COGL_PIPELINE_WRAP_MODE_REPEAT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="83">The texture will be repeated. This
  is useful for example to draw a tiled background.</doc>
      </member>
      <member name="mirrored_repeat"
              value="33648"
              c:identifier="COGL_PIPELINE_WRAP_MODE_MIRRORED_REPEAT">
      </member>
      <member name="clamp_to_edge"
              value="33071"
              c:identifier="COGL_PIPELINE_WRAP_MODE_CLAMP_TO_EDGE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="85">The coordinates outside the
  range 0â†’1 will sample copies of the edge pixels of the
  texture. This is useful to avoid artifacts if only one copy of
  the texture is being rendered.</doc>
      </member>
      <member name="automatic"
              value="519"
              c:identifier="COGL_PIPELINE_WRAP_MODE_AUTOMATIC">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pipeline-layer-state.h"
             line="89">Cogl will try to automatically
  decide which of the above two to use. For cogl_rectangle(), it
  will use repeat mode if any of the texture coordinates are
  outside the range 0â†’1, otherwise it will use clamp to edge. For
  cogl_polygon() it will always use repeat mode. For
  cogl_vertex_buffer_draw() it will use repeat mode except for
  layers that have point sprite coordinate generation enabled. This
  is the default value.</doc>
      </member>
    </enumeration>
    <class name="PixelBuffer"
           c:symbol-prefix="pixel_buffer"
           c:type="CoglPixelBuffer"
           parent="Buffer"
           final="1"
           glib:type-name="CoglPixelBuffer"
           glib:get-type="cogl_pixel_buffer_get_type"
           glib:type-struct="PixelBufferClass">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="59"/>
      <constructor name="new" c:identifier="cogl_pixel_buffer_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-buffer.h"
             line="66">Declares a new #CoglPixelBuffer of @size bytes to contain arrays of
pixels. Once declared, data can be set using cogl_buffer_set_data()
or by mapping it into the application's address space using
cogl_buffer_map().

If @data isn't %NULL then @size bytes will be read from @data and
immediately copied into the new buffer.</doc>
        <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="84"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-buffer.h"
               line="81">a newly allocated #CoglPixelBuffer</doc>
          <type name="PixelBuffer" c:type="CoglPixelBuffer*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pixel-buffer.h"
                 line="68">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pixel-buffer.h"
                 line="69">The number of bytes to allocate for the pixel data.</doc>
            <type name="gsize" c:type="size_t"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pixel-buffer.h"
                 line="70">An optional pointer to
  vertex data to upload immediately</doc>
            <array length="1" zero-terminated="0" c:type="void*">
              <type name="guint8"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <record name="PixelBufferClass"
            c:type="CoglPixelBufferClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="PixelBuffer">
      <source-position filename="cogl/cogl/cogl-pixel-buffer.h" line="59"/>
    </record>
    <enumeration name="PixelFormat"
                 glib:type-name="CoglPixelFormat"
                 glib:get-type="cogl_pixel_format_get_type"
                 c:type="CoglPixelFormat">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="123">Pixel formats used by Cogl. For the formats with a byte per
component, the order of the components specify the order in
increasing memory addresses. So for example
%COGL_PIXEL_FORMAT_RGB_888 would have the red component in the
lowest address, green in the next address and blue after that
regardless of the endianness of the system.

For the formats with non byte aligned components the component
order specifies the order within a 16-bit or 32-bit number from
most significant bit to least significant. So for
%COGL_PIXEL_FORMAT_RGB_565, the red component would be in bits
11-15, the green component would be in 6-11 and the blue component
would be in 1-5. Therefore the order in memory depends on the
endianness of the system.

When uploading a texture %COGL_PIXEL_FORMAT_ANY can be used as the
internal format. Cogl will try to pick the best format to use
internally and convert the texture data if necessary.</doc>
      <member name="any"
              value="0"
              c:identifier="COGL_PIXEL_FORMAT_ANY"
              glib:nick="any"
              glib:name="COGL_PIXEL_FORMAT_ANY">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="125">Any format</doc>
      </member>
      <member name="a_8"
              value="17"
              c:identifier="COGL_PIXEL_FORMAT_A_8"
              glib:nick="a-8"
              glib:name="COGL_PIXEL_FORMAT_A_8">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="126">8 bits alpha mask</doc>
      </member>
      <member name="rgb_565"
              value="4"
              c:identifier="COGL_PIXEL_FORMAT_RGB_565"
              glib:nick="rgb-565"
              glib:name="COGL_PIXEL_FORMAT_RGB_565">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="130">RGB, 16 bits</doc>
      </member>
      <member name="rgba_4444"
              value="21"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444"
              glib:nick="rgba-4444"
              glib:name="COGL_PIXEL_FORMAT_RGBA_4444">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="131">RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551"
              value="22"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551"
              glib:nick="rgba-5551"
              glib:name="COGL_PIXEL_FORMAT_RGBA_5551">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="132">RGBA, 16 bits</doc>
      </member>
      <member name="yuv"
              value="7"
              c:identifier="COGL_PIXEL_FORMAT_YUV"
              glib:nick="yuv"
              glib:name="COGL_PIXEL_FORMAT_YUV">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="133">Not currently supported</doc>
      </member>
      <member name="r_8"
              value="8"
              c:identifier="COGL_PIXEL_FORMAT_R_8"
              glib:nick="r-8"
              glib:name="COGL_PIXEL_FORMAT_R_8">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="134">Single luminance component</doc>
      </member>
      <member name="rg_88"
              value="9"
              c:identifier="COGL_PIXEL_FORMAT_RG_88"
              glib:nick="rg-88"
              glib:name="COGL_PIXEL_FORMAT_RG_88">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="127">RG, 16 bits. Note that red-green textures
  are only available if %COGL_FEATURE_ID_TEXTURE_RG is advertised.
  See cogl_texture_set_components() for details.</doc>
      </member>
      <member name="rgb_888"
              value="2"
              c:identifier="COGL_PIXEL_FORMAT_RGB_888"
              glib:nick="rgb-888"
              glib:name="COGL_PIXEL_FORMAT_RGB_888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="135">RGB, 24 bits</doc>
      </member>
      <member name="bgr_888"
              value="34"
              c:identifier="COGL_PIXEL_FORMAT_BGR_888"
              glib:nick="bgr-888"
              glib:name="COGL_PIXEL_FORMAT_BGR_888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="136">BGR, 24 bits</doc>
      </member>
      <member name="rgbx_8888"
              value="3"
              c:identifier="COGL_PIXEL_FORMAT_RGBX_8888"
              glib:nick="rgbx-8888"
              glib:name="COGL_PIXEL_FORMAT_RGBX_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="137">RGBX, 32 bits</doc>
      </member>
      <member name="rgba_8888"
              value="19"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888"
              glib:nick="rgba-8888"
              glib:name="COGL_PIXEL_FORMAT_RGBA_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="138">RGBA, 32 bits</doc>
      </member>
      <member name="bgrx_8888"
              value="35"
              c:identifier="COGL_PIXEL_FORMAT_BGRX_8888"
              glib:nick="bgrx-8888"
              glib:name="COGL_PIXEL_FORMAT_BGRX_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="139">BGRX, 32 bits</doc>
      </member>
      <member name="bgra_8888"
              value="51"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888"
              glib:nick="bgra-8888"
              glib:name="COGL_PIXEL_FORMAT_BGRA_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="140">BGRA, 32 bits</doc>
      </member>
      <member name="xrgb_8888"
              value="67"
              c:identifier="COGL_PIXEL_FORMAT_XRGB_8888"
              glib:nick="xrgb-8888"
              glib:name="COGL_PIXEL_FORMAT_XRGB_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="141">XRGB, 32 bits</doc>
      </member>
      <member name="argb_8888"
              value="83"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888"
              glib:nick="argb-8888"
              glib:name="COGL_PIXEL_FORMAT_ARGB_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="142">ARGB, 32 bits</doc>
      </member>
      <member name="xbgr_8888"
              value="99"
              c:identifier="COGL_PIXEL_FORMAT_XBGR_8888"
              glib:nick="xbgr-8888"
              glib:name="COGL_PIXEL_FORMAT_XBGR_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="143">XBGR, 32 bits</doc>
      </member>
      <member name="abgr_8888"
              value="115"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888"
              glib:nick="abgr-8888"
              glib:name="COGL_PIXEL_FORMAT_ABGR_8888">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="144">ABGR, 32 bits</doc>
      </member>
      <member name="rgba_8888_pre"
              value="147"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_8888_PRE"
              glib:nick="rgba-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="145">Premultiplied RGBA, 32 bits</doc>
      </member>
      <member name="bgra_8888_pre"
              value="179"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_8888_PRE"
              glib:nick="bgra-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_BGRA_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="146">Premultiplied BGRA, 32 bits</doc>
      </member>
      <member name="argb_8888_pre"
              value="211"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_8888_PRE"
              glib:nick="argb-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_ARGB_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="147">Premultiplied ARGB, 32 bits</doc>
      </member>
      <member name="abgr_8888_pre"
              value="243"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_8888_PRE"
              glib:nick="abgr-8888-pre"
              glib:name="COGL_PIXEL_FORMAT_ABGR_8888_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="148">Premultiplied ABGR, 32 bits</doc>
      </member>
      <member name="rgba_4444_pre"
              value="149"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_4444_PRE"
              glib:nick="rgba-4444-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_4444_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="149">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_5551_pre"
              value="150"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_5551_PRE"
              glib:nick="rgba-5551-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_5551_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="150">Premultiplied RGBA, 16 bits</doc>
      </member>
      <member name="rgba_1010102"
              value="29"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102"
              glib:nick="rgba-1010102"
              glib:name="COGL_PIXEL_FORMAT_RGBA_1010102">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="151">RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102"
              value="61"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102"
              glib:nick="bgra-1010102"
              glib:name="COGL_PIXEL_FORMAT_BGRA_1010102">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="152">BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="xrgb_2101010"
              value="77"
              c:identifier="COGL_PIXEL_FORMAT_XRGB_2101010"
              glib:nick="xrgb-2101010"
              glib:name="COGL_PIXEL_FORMAT_XRGB_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="153">XRGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010"
              value="93"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010"
              glib:nick="argb-2101010"
              glib:name="COGL_PIXEL_FORMAT_ARGB_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="154">ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="xbgr_2101010"
              value="109"
              c:identifier="COGL_PIXEL_FORMAT_XBGR_2101010"
              glib:nick="xbgr-2101010"
              glib:name="COGL_PIXEL_FORMAT_XBGR_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="155">XBGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010"
              value="125"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010"
              glib:nick="abgr-2101010"
              glib:name="COGL_PIXEL_FORMAT_ABGR_2101010">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="156">ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="rgba_1010102_pre"
              value="157"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_1010102_PRE"
              glib:nick="rgba-1010102-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_1010102_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="157">Premultiplied RGBA, 32 bits, 10 bpc</doc>
      </member>
      <member name="bgra_1010102_pre"
              value="189"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_1010102_PRE"
              glib:nick="bgra-1010102-pre"
              glib:name="COGL_PIXEL_FORMAT_BGRA_1010102_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="158">Premultiplied BGRA, 32 bits, 10 bpc</doc>
      </member>
      <member name="argb_2101010_pre"
              value="221"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_2101010_PRE"
              glib:nick="argb-2101010-pre"
              glib:name="COGL_PIXEL_FORMAT_ARGB_2101010_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="159">Premultiplied ARGB, 32 bits, 10 bpc</doc>
      </member>
      <member name="abgr_2101010_pre"
              value="253"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_2101010_PRE"
              glib:nick="abgr-2101010-pre"
              glib:name="COGL_PIXEL_FORMAT_ABGR_2101010_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="160">Premultiplied ABGR, 32 bits, 10 bpc</doc>
      </member>
      <member name="rgbx_fp_16161616"
              value="11"
              c:identifier="COGL_PIXEL_FORMAT_RGBX_FP_16161616"
              glib:nick="rgbx-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_RGBX_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="161">RGBX half floating point, 64 bit</doc>
      </member>
      <member name="rgba_fp_16161616"
              value="27"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_FP_16161616"
              glib:nick="rgba-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_RGBA_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="162">RGBA half floating point, 64 bit</doc>
      </member>
      <member name="bgrx_fp_16161616"
              value="43"
              c:identifier="COGL_PIXEL_FORMAT_BGRX_FP_16161616"
              glib:nick="bgrx-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_BGRX_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="163">BGRX half floating point, 64 bit</doc>
      </member>
      <member name="bgra_fp_16161616"
              value="59"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_FP_16161616"
              glib:nick="bgra-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_BGRA_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="164">BGRA half floating point, 64 bit</doc>
      </member>
      <member name="xrgb_fp_16161616"
              value="75"
              c:identifier="COGL_PIXEL_FORMAT_XRGB_FP_16161616"
              glib:nick="xrgb-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_XRGB_FP_16161616">
      </member>
      <member name="argb_fp_16161616"
              value="91"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_FP_16161616"
              glib:nick="argb-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_ARGB_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="165">ARGB half floating point, 64 bit</doc>
      </member>
      <member name="xbgr_fp_16161616"
              value="107"
              c:identifier="COGL_PIXEL_FORMAT_XBGR_FP_16161616"
              glib:nick="xbgr-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_XBGR_FP_16161616">
      </member>
      <member name="abgr_fp_16161616"
              value="123"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_FP_16161616"
              glib:nick="abgr-fp-16161616"
              glib:name="COGL_PIXEL_FORMAT_ABGR_FP_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="166">ABGR half floating point, 64 bit</doc>
      </member>
      <member name="rgba_fp_16161616_pre"
              value="155"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_FP_16161616_PRE"
              glib:nick="rgba-fp-16161616-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="167">Premultiplied RGBA half floating point, 64 bit</doc>
      </member>
      <member name="bgra_fp_16161616_pre"
              value="187"
              c:identifier="COGL_PIXEL_FORMAT_BGRA_FP_16161616_PRE"
              glib:nick="bgra-fp-16161616-pre"
              glib:name="COGL_PIXEL_FORMAT_BGRA_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="168">Premultiplied BGRA half floating point, 64 bit</doc>
      </member>
      <member name="argb_fp_16161616_pre"
              value="219"
              c:identifier="COGL_PIXEL_FORMAT_ARGB_FP_16161616_PRE"
              glib:nick="argb-fp-16161616-pre"
              glib:name="COGL_PIXEL_FORMAT_ARGB_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="169">Premultiplied ARGB half floating point, 64 bit</doc>
      </member>
      <member name="abgr_fp_16161616_pre"
              value="251"
              c:identifier="COGL_PIXEL_FORMAT_ABGR_FP_16161616_PRE"
              glib:nick="abgr-fp-16161616-pre"
              glib:name="COGL_PIXEL_FORMAT_ABGR_FP_16161616_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="170">Premultiplied ABGR half floating point, 64 bit</doc>
      </member>
      <member name="rgba_fp_32323232"
              value="28"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_FP_32323232"
              glib:nick="rgba-fp-32323232"
              glib:name="COGL_PIXEL_FORMAT_RGBA_FP_32323232">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="171">RGBA floating point, 128 bit</doc>
      </member>
      <member name="rgba_fp_32323232_pre"
              value="156"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_FP_32323232_PRE"
              glib:nick="rgba-fp-32323232-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_FP_32323232_PRE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="172">Premultiplied RGBA floating point, 128 bit</doc>
      </member>
      <member name="r_16"
              value="14"
              c:identifier="COGL_PIXEL_FORMAT_R_16"
              glib:nick="r-16"
              glib:name="COGL_PIXEL_FORMAT_R_16">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="173">Single luminance component, 16 bits</doc>
      </member>
      <member name="rg_1616"
              value="15"
              c:identifier="COGL_PIXEL_FORMAT_RG_1616"
              glib:nick="rg-1616"
              glib:name="COGL_PIXEL_FORMAT_RG_1616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="174">RG, 32 bits</doc>
      </member>
      <member name="rgba_16161616"
              value="26"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_16161616"
              glib:nick="rgba-16161616"
              glib:name="COGL_PIXEL_FORMAT_RGBA_16161616">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="175">RGBA, 64 bits, 16bpc</doc>
      </member>
      <member name="rgba_16161616_pre"
              value="154"
              c:identifier="COGL_PIXEL_FORMAT_RGBA_16161616_PRE"
              glib:nick="rgba-16161616-pre"
              glib:name="COGL_PIXEL_FORMAT_RGBA_16161616_PRE">
      </member>
      <member name="depth_16"
              value="265"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_16"
              glib:nick="depth-16"
              glib:name="COGL_PIXEL_FORMAT_DEPTH_16">
      </member>
      <member name="depth_24_stencil_8"
              value="771"
              c:identifier="COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8"
              glib:nick="depth-24-stencil-8"
              glib:name="COGL_PIXEL_FORMAT_DEPTH_24_STENCIL_8">
      </member>
      <function name="get_bytes_per_pixel"
                c:identifier="cogl_pixel_format_get_bytes_per_pixel">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="285">Queries the number of bytes per pixel for a given format in the given plane.</doc>
        <source-position filename="cogl/cogl/cogl-pixel-format.h" line="296"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="293">The number of bytes per pixel in the given format's given plane.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pixel-format.h"
                 line="287">The pixel format</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="plane" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pixel-format.h"
                 line="288">The index of the plane (should not be more than the number of planes
        in the given format).</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </function>
      <function name="get_n_planes"
                c:identifier="cogl_pixel_format_get_n_planes">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="341">Returns the number of planes the given CoglPixelFormat specifies.</doc>
        <source-position filename="cogl/cogl/cogl-pixel-format.h" line="350"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="347">The no. of planes of @format (at most %COGL_PIXEL_FORMAT_MAX_PLANES)</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pixel-format.h"
                 line="343">The format for which to get the number of planes</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
      <function name="to_string" c:identifier="cogl_pixel_format_to_string">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="352">Returns a string representation of @format, useful for debugging purposes.</doc>
        <source-position filename="cogl/cogl/cogl-pixel-format.h" line="361"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="358">A string representation of @format.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-pixel-format.h"
                 line="354">a #CoglPixelFormat</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </function>
    </enumeration>
    <class name="Primitive"
           c:symbol-prefix="primitive"
           c:type="CoglPrimitive"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglPrimitive"
           glib:get-type="cogl_primitive_get_type"
           glib:type-struct="PrimitiveClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-primitive.h"
           line="48">Functions for creating, manipulating and drawing primitives</doc>
      <source-position filename="cogl/cogl/cogl-primitive.h" line="57"/>
      <constructor name="new"
                   c:identifier="cogl_primitive_new"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="135">Combines a set of `CoglAttribute`s with a specific draw @mode
and defines a vertex count so a #CoglPrimitive object can be retained and
drawn later with no addition information required.

The value passed as @n_vertices will simply update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="153"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-primitive.h"
               line="150">A newly allocated #CoglPrimitive object</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="137">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="138">The number of vertices to process when drawing</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="139">A %NULL terminated list of attributes</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p2" c:identifier="cogl_primitive_new_p2">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="181">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
attribute with a #CoglAttribute and upload your data.

For example to draw a convex polygon you can do:
```c
CoglVertexP2 triangle[] =
{
  { 0,   300 },
  { 150, 0,  },
  { 300, 300 }
};
prim = cogl_primitive_new_p2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                              3, triangle);
cogl_primitive_draw (prim);
```

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). If your
hardware doesn't support non-power of two textures (For example you
are using GLES 1.1) then you will need to make sure your assets are
resized to a power-of-two size (though they don't have to be square)</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="226"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-primitive.h"
               line="222">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using g_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="183">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="184">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="185">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="187">An array
       of #CoglVertexP2 vertices</doc>
            <array length="2" zero-terminated="0" c:type="const CoglVertexP2*">
              <type name="VertexP2"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p2c4" c:identifier="cogl_primitive_new_p2c4">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="281">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
and color attributes with `CoglAttribute`s and upload
your data.

For example to draw a convex polygon with a linear gradient you
can do:
```c
CoglVertexP2C4 triangle[] =
{
  { 0,   300,  0xff, 0x00, 0x00, 0xff },
  { 150, 0,    0x00, 0xff, 0x00, 0xff },
  { 300, 300,  0xff, 0x00, 0x00, 0xff }
};
prim = cogl_primitive_new_p2c4 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                3, triangle);
cogl_primitive_draw (prim);
```

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). If your
hardware doesn't support non-power of two textures (For example you
are using GLES 1.1) then you will need to make sure your assets are
resized to a power-of-two size (though they don't have to be square)</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="328"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-primitive.h"
               line="324">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using g_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="283">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="284">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="285">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="287">An array
       of #CoglVertexP2C4 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP2C4*">
              <type name="VertexP2C4"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p2t2" c:identifier="cogl_primitive_new_p2t2">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="333">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position and
texture coordinate attributes with `CoglAttribute`s and
upload your data.

For example to draw a convex polygon with texture mapping you can
do:
```c
CoglVertexP2T2 triangle[] =
{
  { 0,   300,  0.0, 1.0},
  { 150, 0,    0.5, 0.0},
  { 300, 300,  1.0, 1.0}
};
prim = cogl_primitive_new_p2t2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                3, triangle);
cogl_primitive_draw (prim);
```

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). If your
hardware doesn't support non-power of two textures (For example you
are using GLES 1.1) then you will need to make sure your assets are
resized to a power-of-two size (though they don't have to be square)</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="380"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-primitive.h"
               line="376">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using g_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="335">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="336">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="337">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="339">An array
       of #CoglVertexP2T2 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP2T2*">
              <type name="VertexP2T2"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p3" c:identifier="cogl_primitive_new_p3">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="231">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position
attribute with a #CoglAttribute and upload your data.

For example to draw a convex polygon you can do:
```c
CoglVertexP3 triangle[] =
{
  { 0,   300, 0 },
  { 150, 0,   0 },
  { 300, 300, 0 }
};
prim = cogl_primitive_new_p3 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                              3, triangle);
cogl_primitive_draw (prim);
```

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). If your
hardware doesn't support non-power of two textures (For example you
are using GLES 1.1) then you will need to make sure your assets are
resized to a power-of-two size (though they don't have to be square)</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="276"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-primitive.h"
               line="272">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using g_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="233">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="234">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="235">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="237">An array of
       #CoglVertexP3 vertices</doc>
            <array length="2" zero-terminated="0" c:type="const CoglVertexP3*">
              <type name="VertexP3"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_p3t2" c:identifier="cogl_primitive_new_p3t2">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="385">Provides a convenient way to describe a primitive, such as a single
triangle strip or a triangle fan, that will internally allocate the
necessary #CoglAttributeBuffer storage, describe the position and
texture coordinate attributes with `CoglAttribute`s and
upload your data.

For example to draw a convex polygon with texture mapping you can
do:
```c
CoglVertexP3T2 triangle[] =
{
  { 0,   300, 0,  0.0, 1.0},
  { 150, 0,   0,  0.5, 0.0},
  { 300, 300, 0,  1.0, 1.0}
};
prim = cogl_primitive_new_p3t2 (COGL_VERTICES_MODE_TRIANGLE_FAN,
                                3, triangle);
cogl_primitive_draw (prim);
```

The value passed as @n_vertices is initially used to determine how
much can be read from @data but it will also be used to update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.

The primitive API doesn't support drawing with sliced
textures (since switching between slices implies changing state and
so that implies multiple primitives need to be submitted). If your
hardware doesn't support non-power of two textures (For example you
are using GLES 1.1) then you will need to make sure your assets are
resized to a power-of-two size (though they don't have to be square)</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="432"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-primitive.h"
               line="428">A newly allocated #CoglPrimitive
with a reference of 1. This can be freed using g_object_unref().</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="context" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="387">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="388">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="389">The number of vertices to read from @data and also
             the number of vertices to read when later drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="391">An array
       of #CoglVertexP3T2 vertices</doc>
            <array length="2"
                   zero-terminated="0"
                   c:type="const CoglVertexP3T2*">
              <type name="VertexP3T2"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_attributes"
                   c:identifier="cogl_primitive_new_with_attributes">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="157">Combines a set of `CoglAttribute`s with a specific draw @mode
and defines a vertex count so a #CoglPrimitive object can be retained and
drawn later with no addition information required.

The value passed as @n_vertices will simply update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to read when drawing.</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="176"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-primitive.h"
               line="173">A newly allocated #CoglPrimitive object</doc>
          <type name="Primitive" c:type="CoglPrimitive*"/>
        </return-value>
        <parameters>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="159">A #CoglVerticesMode defining how to draw the vertices</doc>
            <type name="VerticesMode" c:type="CoglVerticesMode"/>
          </parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="160">The number of vertices to process when drawing</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="161">An array of CoglAttribute</doc>
            <array length="3" zero-terminated="0" c:type="CoglAttribute**">
              <type name="Attribute" c:type="CoglAttribute*"/>
            </array>
          </parameter>
          <parameter name="n_attributes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="162">The number of attributes</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="draw" c:identifier="cogl_primitive_draw">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="491">Draws the given @primitive geometry to the specified destination
@framebuffer using the graphics processing state described by @pipeline.

This drawing api doesn't support high-level meta texture types such
as #CoglTexture2DSliced so it is the user's responsibility to
ensure that only low-level textures that can be directly sampled by
a GPU such as #CoglTexture2D are associated with layers of the given
@pipeline.</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="507"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="493">A #CoglPrimitive geometry object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="framebuffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="494">A destination #CoglFramebuffer</doc>
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </parameter>
          <parameter name="pipeline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="495">A #CoglPipeline state object</doc>
            <type name="Pipeline" c:type="CoglPipeline*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_first_vertex"
              c:identifier="cogl_primitive_set_first_vertex">
        <source-position filename="cogl/cogl/cogl-primitive.h" line="438"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="first_vertex" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_indices" c:identifier="cogl_primitive_set_indices">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="461">Associates a sequence of #CoglIndices with the given @primitive.

#CoglIndices provide a way to virtualize your real vertex data by
providing a sequence of indices that index into your real vertex
data. The GPU will walk though the index values to indirectly
lookup the data for each vertex instead of sequentially walking
through the data directly. This lets you save memory by indexing
shared data multiple times instead of duplicating the data.

The value passed as @n_indices will simply update the
#CoglPrimitive `n_vertices` property as if
cogl_primitive_set_n_vertices() were called. This property defines
the number of vertices to draw or, put another way, how many
indices should be read from @indices when drawing.

The #CoglPrimitive `first_vertex` property
also affects drawing with indices by defining the first entry of the
indices to start drawing from.</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="487"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="463">A #CoglPrimitive</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="464">A #CoglIndices array</doc>
            <array length="1" zero-terminated="0" c:type="CoglIndices*">
              <type name="Indices" c:type="CoglIndices"/>
            </array>
          </parameter>
          <parameter name="n_indices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="465">The number of indices to reference when drawing</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_n_vertices"
              c:identifier="cogl_primitive_set_n_vertices">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="441">Specifies how many vertices should be read when drawing the given
@primitive.

Usually this value is set implicitly when associating vertex data
or indices with a #CoglPrimitive.

To be clear; it doesn't refer to the number of vertices - in
terms of data - associated with the primitive it's just the number
of vertices to read and draw.</doc>
        <source-position filename="cogl/cogl/cogl-primitive.h" line="457"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="primitive" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="443">A #CoglPrimitive object</doc>
            <type name="Primitive" c:type="CoglPrimitive*"/>
          </instance-parameter>
          <parameter name="n_vertices" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-primitive.h"
                 line="444">The number of vertices to read when drawing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="PrimitiveClass"
            c:type="CoglPrimitiveClass"
            glib:is-gtype-struct-for="Primitive">
      <source-position filename="cogl/cogl/cogl-primitive.h" line="57"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <class name="Program"
           c:symbol-prefix="program"
           c:type="CoglProgram"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglProgram"
           glib:get-type="cogl_program_get_type"
           glib:type-struct="ProgramClass">
      <source-position filename="cogl/cogl/deprecated/cogl-program.h"
                       line="36"/>
      <constructor name="new"
                   c:identifier="cogl_program_new"
                   deprecated="1"
                   deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="177">Create a new cogl program object that can be used to replace parts of the GL
rendering pipeline with custom code.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="188"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="183">a new cogl program.</doc>
          <type name="Program" c:type="CoglProgram*"/>
        </return-value>
      </constructor>
      <method name="attach_shader"
              c:identifier="cogl_program_attach_shader"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="190">Attaches a shader to a program object. A program can have multiple
vertex or fragment shaders but only one of them may provide a
main() function. It is allowed to use a program with only a vertex
shader or only a fragment shader.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="204"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="192">a #CoglProgram for a shader program.</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
          <parameter name="shader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="193">a #CoglShader for a vertex of fragment shader.</doc>
            <type name="Shader" c:type="CoglShader*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uniform_location"
              c:identifier="cogl_program_get_uniform_location"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="221">Retrieve the location (offset) of a uniform variable in a shader program,
a uniform is a variable that is constant for all vertices/fragments for a
shader object and is possible to modify as an external parameter.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="235"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="230">the offset of a uniform in a specified program.</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="223">A shader program.</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
          <parameter name="uniform_name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="224">the name of a uniform.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="link"
              c:identifier="cogl_program_link"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="207">Links a program making it ready for use. Note that calling this
function is optional. If it is not called the program will
automatically be linked the first time it is used.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="219"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="209">A shader program.</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_uniform_1f"
              c:identifier="cogl_program_set_uniform_1f"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="238">Changes the value of a floating point uniform for the given linked
@program.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="251"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="240">A linked program</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="241">the uniform location retrieved from
   [method@Program.get_uniform_location].</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="243">the new value of the uniform.</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_1i"
              c:identifier="cogl_program_set_uniform_1i"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="255">Changes the value of an integer uniform for the given linked
@program.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="268"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="257">A linked program</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="258">the uniform location retrieved from
   [method@Program.get_uniform_location].</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="260">the new value of the uniform.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_float"
              c:identifier="cogl_program_set_uniform_float"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="272">Changes the value of a float vector uniform, or uniform array for
the given linked @program.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="289"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="274">A linked program</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="275">the uniform location retrieved from
   [method@Program.get_uniform_location].</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="277">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="279">For uniform arrays this is the array length otherwise just
pass 1</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="281">the new value of the uniform[s].</doc>
            <array length="2" zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_int"
              c:identifier="cogl_program_set_uniform_int"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="295">Changes the value of a int vector uniform, or uniform array for
the given linked @program.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="312"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="297">A linked program</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="298">the uniform location retrieved from
   [method@Program.get_uniform_location].</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="n_components" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="300">The number of components for the uniform. For
example with glsl you'd use 3 for a vec3 or 4 for a vec4.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="302">For uniform arrays this is the array length otherwise just
pass 1</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="304">the new value of the uniform[s].</doc>
            <array length="2" zero-terminated="0" c:type="const int*">
              <type name="gint" c:type="int"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_uniform_matrix"
              c:identifier="cogl_program_set_uniform_matrix"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="318">Changes the value of a matrix uniform, or uniform array in the
given linked @program.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api instead</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="336"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="program" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="320">A linked program</doc>
            <type name="Program" c:type="CoglProgram*"/>
          </instance-parameter>
          <parameter name="uniform_location" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="321">the uniform location retrieved from
   [method@Program.get_uniform_location].</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dimensions" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="323">The dimensions of the matrix. So for for example pass
   2 for a 2x2 matrix or 3 for 3x3.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="count" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="325">For uniform arrays this is the array length otherwise just
pass 1</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="transpose" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="327">Whether to transpose the matrix when setting the uniform.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="328">the new value of the uniform.</doc>
            <array length="2" zero-terminated="0" c:type="const float*">
              <type name="gfloat" c:type="float"/>
            </array>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="ProgramClass"
            c:type="CoglProgramClass"
            glib:is-gtype-struct-for="Program">
      <source-position filename="cogl/cogl/deprecated/cogl-program.h"
                       line="36"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <bitfield name="ReadPixelsFlags"
              glib:type-name="CoglReadPixelsFlags"
              glib:get-type="cogl_read_pixels_flags_get_type"
              c:type="CoglReadPixelsFlags">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="303">Flags for cogl_framebuffer_read_pixels_into_bitmap()</doc>
      <member name="color_buffer"
              value="1"
              c:identifier="COGL_READ_PIXELS_COLOR_BUFFER"
              glib:nick="color-buffer"
              glib:name="COGL_READ_PIXELS_COLOR_BUFFER">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="305">Read from the color buffer</doc>
      </member>
    </bitfield>
    <class name="Renderer"
           c:symbol-prefix="renderer"
           c:type="CoglRenderer"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglRenderer"
           glib:get-type="cogl_renderer_get_type"
           glib:type-struct="RendererClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-renderer.h"
           line="49">Choosing a means to render

A #CoglRenderer represents a means to render. It encapsulates the
selection of an underlying driver, such as OpenGL or OpenGL-ES and
a selection of a window system binding API such as GLX or EGL.

A #CoglRenderer has two states, "unconnected" and "connected". When
a renderer is first instantiated using cogl_renderer_new() it is
unconnected so that it can be configured and constraints can be
specified for how the backend driver and window system should be
chosen.

After configuration a #CoglRenderer can (optionally) be explicitly
connected using cogl_renderer_connect() which allows for the
handling of connection errors so that fallback configurations can
be tried if necessary. Applications that don't support any
fallbacks though can skip using cogl_renderer_connect() and leave
Cogl to automatically connect the renderer.

Once you have a configured #CoglRenderer it can be used to create a
#CoglDisplay object using cogl_display_new().</doc>
      <source-position filename="cogl/cogl/cogl-renderer.h" line="89"/>
      <constructor name="new" c:identifier="cogl_renderer_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="96">Instantiates a new (unconnected) #CoglRenderer object. A
#CoglRenderer represents a means to render. It encapsulates the
selection of an underlying driver, such as OpenGL or OpenGL-ES and
a selection of a window system binding API such as GLX or EGL.

There are also some platform specific configuration apis such
as cogl_xlib_renderer_set_foreign_display() that may also be
used while the renderer is unconnected.

Once the renderer has been configured, then it may (optionally) be
explicitly connected using cogl_renderer_connect() which allows
errors to be handled gracefully and potentially fallback
configurations can be tried out if there are initial failures.

If a renderer is not explicitly connected then cogl_display_new()
will automatically connect the renderer for you. If you don't
have any code to deal with error/fallback situations then its fine
to just let Cogl do the connection for you.

Once you have setup your renderer then the next step is to create a
#CoglDisplay using cogl_display_new().</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="124"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-renderer.h"
               line="121">A newly created #CoglRenderer.</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </return-value>
      </constructor>
      <method name="bind_api" c:identifier="cogl_renderer_bind_api">
        <source-position filename="cogl/cogl/cogl-renderer.h" line="291"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="connect" c:identifier="cogl_renderer_connect" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="165">Connects the configured @renderer. Renderer connection isn't a
very active process, it basically just means validating that
any given constraint criteria can be satisfied and that a
usable driver and window system backend can be found.</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="179"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-renderer.h"
               line="175">%TRUE if there was no error while connecting the
              given @renderer. %FALSE if there was an error.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="167">An unconnected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="create_dma_buf"
              c:identifier="cogl_renderer_create_dma_buf"
              introspectable="0"
              throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="248">Creates a new #CoglFramebuffer with @width x @height, with pixel
format @format, and exports the new framebuffer's DMA buffer
handle.

Passing an empty modifier array (passing a 0 n_modifiers) means implicit
modifiers will be used.</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="270"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-renderer.h"
               line="265">a #CoglDmaBufHandle. The
return result must be released with cogl_dma_buf_handle_free()
after use.</doc>
          <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="250">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="251">A #CoglPixelFormat</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="modifiers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="252">array of DRM format modifiers</doc>
            <type name="guint64" c:type="uint64_t*"/>
          </parameter>
          <parameter name="n_modifiers" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="253">length of modifiers array</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="254">width of the new</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="255">height of the new</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_driver_id" c:identifier="cogl_renderer_get_driver_id">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="217">Queries what underlying driver is being used by Cogl.

This may only be called on a connected #CoglRenderer.</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="226"/>
        <return-value transfer-ownership="none">
          <type name="DriverId" c:type="CoglDriverId"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="219">A connected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_implicit_drm_modifier"
              c:identifier="cogl_renderer_get_implicit_drm_modifier">
        <source-position filename="cogl/cogl/cogl-renderer.h" line="242"/>
        <return-value transfer-ownership="none">
          <type name="guint64" c:type="uint64_t"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_proc_address"
              c:identifier="cogl_renderer_get_proc_address">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="293">Gets a pointer to a given GL or GL ES extension function. This acts
as a wrapper around glXGetProcAddress() or whatever is the
appropriate function for the current backend.

This function should not be used to query core opengl API
symbols since eglGetProcAddress for example doesn't allow this and
and may return a junk pointer if you do.</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="310"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-renderer.h"
               line="306">a pointer to the requested function or %NULL if the
  function is not available.</doc>
          <type name="gpointer" c:type="void*"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="295">A #CoglRenderer.</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="296">the name of the function.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_winsys_id" c:identifier="cogl_renderer_get_winsys_id">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="149">Queries which window system backend Cogl has chosen to use.

This may only be called on a connected #CoglRenderer.</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="161"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-renderer.h"
               line="157">The #CoglWinsysID corresponding to the chosen window
         system backend.</doc>
          <type name="WinsysID" c:type="CoglWinsysID"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="151">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="handle_event"
              c:identifier="cogl_renderer_handle_event"
              introspectable="0">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="313">Processes a single event.</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="327"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-renderer.h"
               line="320">#CoglFilterReturn. %COGL_FILTER_REMOVE indicates that
Cogl has internally handled the event and the caller should do no
further processing. %COGL_FILTER_CONTINUE indicates that Cogl is
either not interested in the event, or has used the event to update
internal state without taking any exclusive action.</doc>
          <type name="FilterReturn" c:type="CoglFilterReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="315">a #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="event"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="316">pointer to an event structure</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_dma_buf_supported"
              c:identifier="cogl_renderer_is_dma_buf_supported">
        <source-position filename="cogl/cogl/cogl-renderer.h" line="285"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-renderer.h"
               line="282">%TRUE if DMA buffers can be allocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="280">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_implicit_drm_modifier"
              c:identifier="cogl_renderer_is_implicit_drm_modifier">
        <source-position filename="cogl/cogl/cogl-renderer.h" line="245"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="modifier" transfer-ownership="none">
            <type name="guint64" c:type="uint64_t"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_drm_modifiers"
              c:identifier="cogl_renderer_query_drm_modifiers"
              introspectable="0"
              throws="1">
        <source-position filename="cogl/cogl/cogl-renderer.h" line="236"/>
        <return-value>
          <array name="GLib.Array" c:type="GArray*">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="231">A #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="232">The #CoglPixelFormat</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="DrmModifierFilter" c:type="CoglDrmModifierFilter"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_driver" c:identifier="cogl_renderer_set_driver">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="199">Requests that Cogl should try to use a specific underlying driver
for rendering.

If you select an unsupported driver then cogl_renderer_connect()
will fail and report an error. Most applications should not
explicitly select a driver and should rely on Cogl automatically
choosing the driver.

This may only be called on an un-connected #CoglRenderer.</doc>
        <source-position filename="cogl/cogl/cogl-renderer.h" line="214"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="renderer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-renderer.h"
                 line="201">An unconnected #CoglRenderer</doc>
            <type name="Renderer" c:type="CoglRenderer*"/>
          </instance-parameter>
          <parameter name="driver" transfer-ownership="none">
            <type name="DriverId" c:type="CoglDriverId"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="RendererClass"
            c:type="CoglRendererClass"
            glib:is-gtype-struct-for="Renderer">
      <source-position filename="cogl/cogl/cogl-renderer.h" line="89"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="RendererError"
                 glib:type-name="CoglRendererError"
                 glib:get-type="cogl_renderer_error_get_type"
                 c:type="CoglRendererError">
      <member name="xlib_display_open"
              value="0"
              c:identifier="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN"
              glib:nick="xlib-display-open"
              glib:name="COGL_RENDERER_ERROR_XLIB_DISPLAY_OPEN">
      </member>
      <member name="bad_constraint"
              value="1"
              c:identifier="COGL_RENDERER_ERROR_BAD_CONSTRAINT"
              glib:nick="bad-constraint"
              glib:name="COGL_RENDERER_ERROR_BAD_CONSTRAINT">
      </member>
      <function name="quark" c:identifier="cogl_renderer_error_quark">
        <source-position filename="cogl/cogl/cogl-renderer.h" line="84"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
    </enumeration>
    <constant name="STENCIL_BIT" value="512" c:type="COGL_STENCIL_BIT">
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="52"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="SUB_TEXTURE"
                    c:identifier="COGL_SUB_TEXTURE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="50"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SUB_TEXTURE_CLASS"
                    c:identifier="COGL_SUB_TEXTURE_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="52"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SUB_TEXTURE_CONST"
                    c:identifier="COGL_SUB_TEXTURE_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="51"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="SUB_TEXTURE_GET_CLASS"
                    c:identifier="COGL_SUB_TEXTURE_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Scanout"
           c:symbol-prefix="scanout"
           c:type="CoglScanout"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglScanout"
           glib:get-type="cogl_scanout_get_type"
           glib:type-struct="ScanoutClass">
      <source-position filename="cogl/cogl/cogl-scanout.h" line="39"/>
      <constructor name="new" c:identifier="cogl_scanout_new">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="84"/>
        <return-value transfer-ownership="full">
          <type name="Scanout" c:type="CoglScanout*"/>
        </return-value>
        <parameters>
          <parameter name="scanout_buffer" transfer-ownership="none">
            <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
          </parameter>
          <parameter name="dst_rect" transfer-ownership="none">
            <type name="Mtk.Rectangle" c:type="const MtkRectangle*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="blit_to_framebuffer"
              c:identifier="cogl_scanout_blit_to_framebuffer"
              throws="1">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="62"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </instance-parameter>
          <parameter name="framebuffer" transfer-ownership="none">
            <type name="Framebuffer" c:type="CoglFramebuffer*"/>
          </parameter>
          <parameter name="x" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="y" transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer" c:identifier="cogl_scanout_get_buffer">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="77"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-scanout.h"
               line="74">a #CoglScanoutBuffer</doc>
          <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dst_rect" c:identifier="cogl_scanout_get_dst_rect">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="96"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </instance-parameter>
          <parameter name="dst_rect" transfer-ownership="none">
            <type name="Mtk.Rectangle" c:type="MtkRectangle*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_src_rect" c:identifier="cogl_scanout_get_src_rect">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="88"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <type name="Graphene.Rect" c:type="graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <method name="notify_failed" c:identifier="cogl_scanout_notify_failed">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="80"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </instance-parameter>
          <parameter name="onscreen" transfer-ownership="none">
            <type name="Onscreen" c:type="CoglOnscreen*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_src_rect" c:identifier="cogl_scanout_set_src_rect">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="92"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout" transfer-ownership="none">
            <type name="Scanout" c:type="CoglScanout*"/>
          </instance-parameter>
          <parameter name="rect" transfer-ownership="none">
            <type name="Graphene.Rect" c:type="const graphene_rect_t*"/>
          </parameter>
        </parameters>
      </method>
      <glib:signal name="scanout-failed" when="last">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Onscreen"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <interface name="ScanoutBuffer"
               c:symbol-prefix="scanout_buffer"
               c:type="CoglScanoutBuffer"
               glib:type-name="CoglScanoutBuffer"
               glib:get-type="cogl_scanout_buffer_get_type"
               glib:type-struct="ScanoutBufferInterface">
      <source-position filename="cogl/cogl/cogl-scanout.h" line="59"/>
      <virtual-method name="get_height" invoker="get_height">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="58"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout_buffer" transfer-ownership="none">
            <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_width" invoker="get_width">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="57"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout_buffer" transfer-ownership="none">
            <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_height" c:identifier="cogl_scanout_buffer_get_height">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="69"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout_buffer" transfer-ownership="none">
            <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_scanout_buffer_get_width">
        <source-position filename="cogl/cogl/cogl-scanout.h" line="68"/>
        <return-value transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="scanout_buffer" transfer-ownership="none">
            <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
          </instance-parameter>
        </parameters>
      </method>
    </interface>
    <record name="ScanoutBufferInterface"
            c:type="CoglScanoutBufferInterface"
            glib:is-gtype-struct-for="ScanoutBuffer">
      <source-position filename="cogl/cogl/cogl-scanout.h" line="59"/>
      <field name="parent_iface">
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="blit_to_framebuffer">
        <callback name="blit_to_framebuffer" throws="1">
          <source-position filename="cogl/cogl/cogl-scanout.h" line="51"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="scanout" transfer-ownership="none">
              <type name="Scanout" c:type="CoglScanout*"/>
            </parameter>
            <parameter name="framebuffer" transfer-ownership="none">
              <type name="Framebuffer" c:type="CoglFramebuffer*"/>
            </parameter>
            <parameter name="x" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
            <parameter name="y" transfer-ownership="none">
              <type name="gint" c:type="int"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_width">
        <callback name="get_width">
          <source-position filename="cogl/cogl/cogl-scanout.h" line="57"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="scanout_buffer" transfer-ownership="none">
              <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_height">
        <callback name="get_height">
          <source-position filename="cogl/cogl/cogl-scanout.h" line="58"/>
          <return-value transfer-ownership="none">
            <type name="gint" c:type="int"/>
          </return-value>
          <parameters>
            <parameter name="scanout_buffer" transfer-ownership="none">
              <type name="ScanoutBuffer" c:type="CoglScanoutBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <record name="ScanoutClass"
            c:type="CoglScanoutClass"
            glib:is-gtype-struct-for="Scanout">
      <source-position filename="cogl/cogl/cogl-scanout.h" line="39"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="ScanoutError"
                 glib:type-name="CoglScanoutError"
                 glib:get-type="cogl_scanout_error_get_type"
                 c:type="CoglScanoutError"
                 glib:error-domain="cogl-scanout-error-quark">
      <member name="inhibited"
              value="0"
              c:identifier="COGL_SCANOUT_ERROR_INHIBITED"
              glib:nick="inhibited"
              glib:name="COGL_SCANOUT_ERROR_INHIBITED">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="355">Scanout inhibited</doc>
      </member>
      <function name="quark" c:identifier="cogl_scanout_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </enumeration>
    <class name="Shader"
           c:symbol-prefix="shader"
           c:type="CoglShader"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglShader"
           glib:get-type="cogl_shader_get_type"
           glib:type-struct="ShaderClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/deprecated/cogl-shader.h"
           line="43">Functions for accessing the programmable GL pipeline

Cogl allows accessing the GL programmable pipeline in order to create
vertex and fragment shaders.

When using GLSL Cogl provides replacement names for most of the
builtin varyings and uniforms. It is recommended to use these names
wherever possible to increase portability between OpenGL 2.0 and
GLES 2.0. GLES 2.0 does not have most of the builtins under their
original names so they will only work with the Cogl names.

For use in all GLSL shaders, the Cogl builtins are as follows:

- `uniform mat4 cogl_modelview_matrix`
   The current modelview matrix. This is equivalent to
   #gl_ModelViewMatrix.
- `uniform mat4 cogl_projection_matrix`
   The current projection matrix. This is equivalent to
   #gl_ProjectionMatrix.
- `uniform mat4 cogl_modelview_projection_matrix`
   The combined modelview and projection matrix. A vertex shader
   would typically use this to transform the incoming vertex
   position. The separate modelview and projection matrices are
   usually only needed for lighting calculations. This is
   equivalent to #gl_ModelViewProjectionMatrix.
- `uniform mat4 cogl_texture_matrix[]`
   An array of matrices for transforming the texture
   coordinates. This is equivalent to #gl_TextureMatrix.

In a vertex shader, the following are also available:

- `attribute vec4 cogl_position_in`
   The incoming vertex position. This is equivalent to #gl_Vertex.
- `attribute vec4 cogl_color_in`
   The incoming vertex color. This is equivalent to #gl_Color.
- `attribute vec4 cogl_tex_coord_in`
   The texture coordinate for the first texture unit. This is
   equivalent to #gl_MultiTexCoord0.
- `attribute vec4 cogl_tex_coord0_in`
   The texture coordinate for the first texture unit. This is
   equivalent to #gl_MultiTexCoord0. There is also
   #cogl_tex_coord1_in and so on.
- `attribute vec3 cogl_normal_in`
   The normal of the vertex. This is equivalent to #gl_Normal.
- `vec4 cogl_position_out`
   The calculated position of the vertex. This must be written to
   in all vertex shaders. This is equivalent to #gl_Position.
- `float cogl_point_size_out`
   The calculated size of a point. This is equivalent to #gl_PointSize.
- `varying vec4 cogl_color_out`
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
- `varying vec4 cogl_tex_coord_out[]`
   An array of calculated texture coordinates for a vertex. This is
   equivalent to #gl_TexCoord.

In a fragment shader, the following are also available:

- `varying vec4 cogl_color_in`
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
- `varying vec4 cogl_tex_coord_in[]`
   An array of calculated texture coordinates for a vertex. This is
   equivalent to #gl_TexCoord.
- `vec4 cogl_color_out`
   The final calculated color of the fragment. All fragment shaders
   must write to this variable. This is equivalent to
   #gl_FrontColor.
- `float cogl_depth_out`
   An optional output variable specifying the depth value to use
   for this fragment. This is equivalent to #gl_FragDepth.
- `bool cogl_front_facing`
   A readonly variable that will be true if the current primitive
   is front facing. This can be used to implement two-sided
   coloring algorithms. This is equivalent to #gl_FrontFacing.

It's worth nothing that this API isn't what Cogl would like to have
in the long term and it may be removed in Cogl 2.0. The
experimental #CoglShader API is the proposed replacement.</doc>
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="128"/>
      <constructor name="new"
                   c:identifier="cogl_shader_new"
                   deprecated="1"
                   deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="134">Create a new shader handle, use cogl_shader_source() to set the
source code to be used on it.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="146"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="141">a new shader handle.</doc>
          <type name="Shader" c:type="CoglShader*"/>
        </return-value>
        <parameters>
          <parameter name="shader_type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="136">COGL_SHADER_TYPE_VERTEX or COGL_SHADER_TYPE_FRAGMENT.</doc>
            <type name="ShaderType" c:type="CoglShaderType"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_shader_type"
              c:identifier="cogl_shader_get_shader_type"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="163">Retrieves the type of a shader</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="175"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/deprecated/cogl-shader.h"
               line="169">%COGL_SHADER_TYPE_VERTEX if the shader is a vertex processor
         or %COGL_SHADER_TYPE_FRAGMENT if the shader is a fragment processor</doc>
          <type name="ShaderType" c:type="CoglShaderType"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="165">#CoglShader for a shader.</doc>
            <type name="Shader" c:type="CoglShader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="source"
              c:identifier="cogl_shader_source"
              deprecated="1"
              deprecated-version="1.16">
        <doc xml:space="preserve"
             filename="cogl/cogl/deprecated/cogl-shader.h"
             line="148">Replaces the current source associated with a shader with a new
one.</doc>
        <doc-deprecated xml:space="preserve">Use #CoglSnippet api</doc-deprecated>
        <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                         line="160"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="150">A shader.</doc>
            <type name="Shader" c:type="CoglShader*"/>
          </instance-parameter>
          <parameter name="source" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/deprecated/cogl-shader.h"
                 line="151">Shader source.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="ShaderClass"
            c:type="CoglShaderClass"
            glib:is-gtype-struct-for="Shader">
      <source-position filename="cogl/cogl/deprecated/cogl-shader.h"
                       line="128"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="ShaderType"
                 glib:type-name="CoglShaderType"
                 glib:get-type="cogl_shader_type_get_type"
                 c:type="CoglShaderType">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="314">Types of shaders</doc>
      <member name="vertex"
              value="0"
              c:identifier="COGL_SHADER_TYPE_VERTEX"
              glib:nick="vertex"
              glib:name="COGL_SHADER_TYPE_VERTEX">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="316">A program for processing vertices</doc>
      </member>
      <member name="fragment"
              value="1"
              c:identifier="COGL_SHADER_TYPE_FRAGMENT"
              glib:nick="fragment"
              glib:name="COGL_SHADER_TYPE_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="317">A program for processing fragments</doc>
      </member>
    </enumeration>
    <class name="Snippet"
           c:symbol-prefix="snippet"
           c:type="CoglSnippet"
           parent="GObject.Object"
           final="1"
           glib:type-name="CoglSnippet"
           glib:get-type="cogl_snippet_get_type"
           glib:type-struct="SnippetClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-snippet.h"
           line="42">Functions for creating and manipulating shader snippets

`CoglSnippet`s are used to modify or replace parts of a
#CoglPipeline using GLSL. GLSL is a programming language supported
by OpenGL on programmable hardware to provide a more flexible
description of what should be rendered. A description of GLSL
itself is outside the scope of this documentation but any good
OpenGL book should help to describe it.

Unlike in OpenGL, when using GLSL with Cogl it is possible to write
short snippets to replace small sections of the pipeline instead of
having to replace the whole of either the vertex or fragment
pipelines. Of course it is also possible to replace the whole of
the pipeline if needed.

Each snippet is a standalone chunk of code which would attach to
the pipeline at a particular point. The code is split into four
separate strings (all of which are optional):

- `declarations`
The code in this string will be inserted outside of any function in
the global scope of the shader. This can be used to declare
uniforms, attributes, varyings and functions to be used by the
snippet.
- `pre`
The code in this string will be inserted before the hook point.
- `post`
The code in this string will be inserted after the hook point. This
can be used to modify the results of the builtin generated code for
that hook point.
- `replace
If present the code in this string will replace the generated code
for the hook point.

All of the strings apart from the declarations string of a pipeline
are generated in a single function so they can share variables
declared from one string in another. The scope of the code is
limited to each snippet so local variables declared in the snippet
will not collide with variables declared in another
snippet. However, code in the 'declarations' string is global to
the shader so it is the application's responsibility to ensure that
variables declared here will not collide with those from other
snippets.

The snippets can be added to a pipeline with
cogl_pipeline_add_snippet() or
cogl_pipeline_add_layer_snippet(). Which function to use depends on
which hook the snippet is targeting. The snippets are all
generated in the order they are added to the pipeline. That is, the
post strings are executed in the order they are added to the
pipeline and the pre strings are executed in reverse order. If any
replace strings are given for a snippet then any other snippets
with the same hook added before that snippet will be ignored. The
different hooks are documented under #CoglSnippetHook.

For portability with GLES2, it is recommended not to use the GLSL
builtin names such as gl_FragColor. Instead there are replacement
names under the cogl_* namespace which can be used instead. These
are:

- `uniform mat4 cogl_modelview_matrix
   The current modelview matrix. This is equivalent to
   #gl_ModelViewMatrix.
- `uniform mat4 cogl_projection_matrix
   The current projection matrix. This is equivalent to
   #gl_ProjectionMatrix.
- `uniform mat4 cogl_modelview_projection_matrix
   The combined modelview and projection matrix. A vertex shader
   would typically use this to transform the incoming vertex
   position. The separate modelview and projection matrices are
   usually only needed for lighting calculations. This is
   equivalent to #gl_ModelViewProjectionMatrix.
- `uniform mat4 cogl_texture_matrix[]
   An array of matrices for transforming the texture
   coordinates. This is equivalent to #gl_TextureMatrix.

In a vertex shader, the following are also available:

- `attribute vec4 cogl_position_in
   The incoming vertex position. This is equivalent to #gl_Vertex.
- `attribute vec4 cogl_color_in`
   The incoming vertex color. This is equivalent to #gl_Color.
- `attribute vec4 cogl_tex_coord_in`
   The texture coordinate for layer 0. This is an alternative name
   for #cogl_tex_coord0_in.
- `attribute vec4 cogl_tex_coord0_in
   The texture coordinate for the layer 0. This is equivalent to
   #gl_MultiTexCoord0. There will also be #cogl_tex_coord1_in and
   so on if more layers are added to the pipeline.
- `attribute vec3 cogl_normal_in`
   The normal of the vertex. This is equivalent to #gl_Normal.
- `vec4 cogl_position_out
   The calculated position of the vertex. This must be written to
   in all vertex shaders. This is equivalent to #gl_Position.
- `float cogl_point_size_in
   The incoming point size from the cogl_point_size_in attribute.
   This is only available if
   cogl_pipeline_set_per_vertex_point_size() is set on the
   pipeline.
- `float cogl_point_size_out`
   The calculated size of a point. This is equivalent to #gl_PointSize.
- `varying vec4 cogl_color_out`
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
- `varying vec4 cogl_tex_coord0_out`
   The calculated texture coordinate for layer 0 of the pipeline.
   This is equivalent to #gl_TexCoord[0]. There will also be
   #cogl_tex_coord1_out and so on if more layers are added to the
   pipeline. In the fragment shader, this varying is called
   #cogl_tex_coord0_in.

In a fragment shader, the following are also available:

- `varying vec4 cogl_color_in`
   The calculated color of a vertex. This is equivalent to #gl_FrontColor.
- `varying vec4 cogl_tex_coord0_in`
   The texture coordinate for layer 0. This is equivalent to
   #gl_TexCoord[0]. There will also be #cogl_tex_coord1_in and so
   on if more layers are added to the pipeline.
- `vec4 cogl_color_out`
   The final calculated color of the fragment. All fragment shaders
   must write to this variable. This is equivalent to
   #gl_FrontColor.
- `float cogl_depth_out`
   An optional output variable specifying the depth value to use
   for this fragment. This is equivalent to #gl_FragDepth.
- `bool cogl_front_facing`
   A readonly variable that will be true if the current primitive
   is front facing. This can be used to implement two-sided
   coloring algorithms. This is equivalent to #gl_FrontFacing.
- `vec2 cogl_point_coord`
   When rendering points, this will contain a vec2 which represents
   the position within the point of the current fragment.
   vec2(0.0,0.0) will be the topleft of the point and vec2(1.0,1.0)
   will be the bottom right. Note that there is currently a bug in
   Cogl where when rendering to an offscreen buffer these
   coordinates will be upside-down. The value is undefined when not
   rendering points.

Here is an example of using a snippet to add a desaturate effect to the
generated color on a pipeline.

```c
  CoglPipeline *pipeline = cogl_pipeline_new ();

  /&lt;!-- --&gt;* Set up the pipeline here, ie by adding a texture or other
     layers *&lt;!-- --&gt;/

  /&lt;!-- --&gt;* Create the snippet. The first string is the declarations which
     we will use to add a uniform. The second is the 'post' string which
     will contain the code to perform the desaturation. *&lt;!-- --&gt;/
  CoglSnippet *snippet =
    cogl_snippet_new (COGL_SNIPPET_HOOK_FRAGMENT,
                      "uniform float factor;",
                      "float gray = dot (vec3 (0.299, 0.587, 0.114), "
                      "                  cogl_color_out.rgb);"
                      "cogl_color_out.rgb = mix (vec3 (gray),"
                      "                          cogl_color_out.rgb,"
                      "                          factor);");

  /&lt;!-- --&gt;* Add it to the pipeline *&lt;!-- --&gt;/
  cogl_pipeline_add_snippet (pipeline, snippet);
  /&lt;!-- --&gt;* The pipeline keeps a reference to the snippet
     so we don't need to *&lt;!-- --&gt;/
  g_object_unref (snippet);

  /&lt;!-- --&gt;* Update the custom uniform on the pipeline *&lt;!-- --&gt;/
  int location = cogl_pipeline_get_uniform_location (pipeline, "factor");
  cogl_pipeline_set_uniform_1f (pipeline, location, 0.5f);

  /&lt;!-- --&gt;* Now we can render with the snippet as usual *&lt;!-- --&gt;/
  cogl_push_source (pipeline);
  cogl_rectangle (0, 0, 10, 10);
  cogl_pop_source ();
```</doc>
      <source-position filename="cogl/cogl/cogl-snippet.h" line="223"/>
      <constructor name="new" c:identifier="cogl_snippet_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="482">Allocates and initializes a new snippet with the given source strings.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="496"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="493">a pointer to a new #CoglSnippet</doc>
          <type name="Snippet" c:type="CoglSnippet*"/>
        </return-value>
        <parameters>
          <parameter name="hook" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="484">The point in the pipeline that this snippet will wrap around
  or replace.</doc>
            <type name="SnippetHook" c:type="CoglSnippetHook"/>
          </parameter>
          <parameter name="declarations"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="486">The source code for the declarations for this
  snippet or %NULL. See cogl_snippet_set_declarations().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
          <parameter name="post"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="488">The source code to run after the hook point where this
  shader snippet is attached or %NULL. See cogl_snippet_set_post().</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_declarations"
              c:identifier="cogl_snippet_get_declarations">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="537"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="533">the source string that was set with
  cogl_snippet_set_declarations() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="531">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_hook" c:identifier="cogl_snippet_get_hook">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="508"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="504">the hook that was set when cogl_snippet_new()
  was called.</doc>
          <type name="SnippetHook" c:type="CoglSnippetHook"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="502">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_post" c:identifier="cogl_snippet_get_post">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="621"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="617">the source string that was set with
  cogl_snippet_set_post() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="615">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_pre" c:identifier="cogl_snippet_get_pre">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="565"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="561">the source string that was set with
  cogl_snippet_set_pre() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="559">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_replace" c:identifier="cogl_snippet_get_replace">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="593"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-snippet.h"
               line="589">the source string that was set with
  cogl_snippet_set_replace() or %NULL if none was set.</doc>
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="587">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_capability" c:identifier="cogl_snippet_set_capability">
        <source-position filename="cogl/cogl/cogl-snippet.h" line="624"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
          <parameter name="capability" transfer-ownership="none">
            <type name="guint" c:type="unsigned int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_declarations"
              c:identifier="cogl_snippet_set_declarations">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="510">Sets a source string that will be inserted in the global scope of
the generated shader when this snippet is used on a pipeline. This
string is typically used to declare uniforms, attributes or
functions that will be used by the other parts of the snippets.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="526"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="512">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="declarations" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="513">The new source string for the declarations section
  of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_post" c:identifier="cogl_snippet_set_post">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="595">Sets a source string that will be inserted after the hook point in
the generated shader for the pipeline that this snippet is attached
to. Please see the documentation of each hook point in
#CoglPipeline for a description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="610"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="597">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="post" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="598">The new source string for the post section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pre" c:identifier="cogl_snippet_set_pre">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="539">Sets a source string that will be inserted before the hook point in
the generated shader for the pipeline that this snippet is attached
to. Please see the documentation of each hook point in
#CoglPipeline for a description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="554"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="541">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="pre" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="542">The new source string for the pre section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_replace" c:identifier="cogl_snippet_set_replace">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="567">Sets a source string that will be used instead of any generated
source code or any previous snippets for this hook point. Please
see the documentation of each hook point in #CoglPipeline for a
description of how this string should be used.

This function should only be called before the snippet is attached
to its first pipeline. After that the snippet should be considered
immutable.</doc>
        <source-position filename="cogl/cogl/cogl-snippet.h" line="582"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="snippet" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="569">A #CoglSnippet</doc>
            <type name="Snippet" c:type="CoglSnippet*"/>
          </instance-parameter>
          <parameter name="replace" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-snippet.h"
                 line="570">The new source string for the replace section of this snippet.</doc>
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="SnippetClass"
            c:type="CoglSnippetClass"
            glib:is-gtype-struct-for="Snippet">
      <source-position filename="cogl/cogl/cogl-snippet.h" line="223"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="SnippetHook" c:type="CoglSnippetHook">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-snippet.h"
           line="231">#CoglSnippetHook is used to specify a location within a
#CoglPipeline where the code of the snippet should be used when it
is attached to a pipeline.

- `COGL_SNIPPET_HOOK_VERTEX_GLOBALS`

Adds a shader snippet at the beginning of the global section of the
shader for the vertex processing. Any declarations here can be
shared with all other snippets that are attached to a vertex hook.
Only the â€˜declarationsâ€™ string is used and the other strings are
ignored.

- `COGL_SNIPPET_HOOK_FRAGMENT_GLOBALS`

Adds a shader snippet at the beginning of the global section of the
shader for the fragment processing. Any declarations here can be
shared with all other snippets that are attached to a fragment
hook. Only the â€˜declarationsâ€™ string is used and the other strings
are ignored.

- `COGL_SNIPPET_HOOK_VERTEX`

Adds a shader snippet that will hook on to the vertex processing
stage of the pipeline. This gives a chance for the application to
modify the vertex attributes generated by the shader. Typically the
snippet will modify cogl_color_out or cogl_position_out builtins.

The â€˜declarationsâ€™ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.

The â€˜preâ€™ string in @snippet will be inserted at the top of the
main() function before any vertex processing is done.

The â€˜replaceâ€™ string in @snippet will be used instead of the
generated vertex processing if it is present. This can be used if
the application wants to provide a complete vertex shader and
doesn't need the generated output from Cogl.

The â€˜postâ€™ string in @snippet will be inserted after all of the
standard vertex processing is done. This can be used to modify the
outputs.

- `COGL_SNIPPET_HOOK_VERTEX_TRANSFORM`

Adds a shader snippet that will hook on to the vertex transform stage.
Typically the snippet will use the cogl_modelview_matrix,
cogl_projection_matrix and cogl_modelview_projection_matrix matrices and the
cogl_position_in attribute. The hook must write to cogl_position_out.
The default processing for this hook will multiply cogl_position_in by
the combined modelview-projection matrix and store it on cogl_position_out.

The â€˜declarationsâ€™ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.

The â€˜preâ€™ string in @snippet will be inserted at the top of the
main() function before the vertex transform is done.

The â€˜replaceâ€™ string in @snippet will be used instead of the
generated vertex transform if it is present.

The â€˜postâ€™ string in @snippet will be inserted after all of the
standard vertex transformation is done. This can be used to modify the
cogl_position_out in addition to the default processing.

- `COGL_SNIPPET_HOOK_POINT_SIZE`

Adds a shader snippet that will hook on to the point size
calculation step within the vertex shader stage. The snippet should
write to the builtin cogl_point_size_out with the new point size.
The snippet can either read cogl_point_size_in directly and write a
new value or first read an existing value in cogl_point_size_out
that would be set by a previous snippet. Note that this hook is
only used if cogl_pipeline_set_per_vertex_point_size() is enabled
on the pipeline.

The â€˜declarationsâ€™ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.

The â€˜preâ€™ string in @snippet will be inserted just before
calculating the point size.

The â€˜replaceâ€™ string in @snippet will be used instead of the
generated point size calculation if it is present.

The â€˜postâ€™ string in @snippet will be inserted after the
standard point size calculation is done. This can be used to modify
cogl_point_size_out in addition to the default processing.

- `COGL_SNIPPET_HOOK_FRAGMENT`

Adds a shader snippet that will hook on to the fragment processing
stage of the pipeline. This gives a chance for the application to
modify the fragment color generated by the shader. Typically the
snippet will modify cogl_color_out.

The â€˜declarationsâ€™ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.

The â€˜preâ€™ string in @snippet will be inserted at the top of the
main() function before any fragment processing is done.

The â€˜replaceâ€™ string in @snippet will be used instead of the
generated fragment processing if it is present. This can be used if
the application wants to provide a complete fragment shader and
doesn't need the generated output from Cogl.

The â€˜postâ€™ string in @snippet will be inserted after all of the
standard fragment processing is done. At this point the generated
value for the rest of the pipeline state will already be in
cogl_color_out so the application can modify the result by altering
this variable.

- `COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM`

Adds a shader snippet that will hook on to the texture coordinate
transformation of a particular layer. This can be used to replace
the processing for a layer or to modify the results.

Within the snippet code for this hook there are two extra
variables. The first is a mat4 called cogl_matrix which represents
the user matrix for this layer. The second is called cogl_tex_coord
and represents the incoming and outgoing texture coordinate. On
entry to the hook, cogl_tex_coord contains the value of the
corresponding texture coordinate attribute for this layer. The hook
is expected to modify this variable. The output will be passed as a
varying to the fragment processing stage. The default code will
just multiply cogl_matrix by cogl_tex_coord and store the result in
cogl_tex_coord.

The â€˜declarationsâ€™ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.

The â€˜preâ€™ string in @snippet will be inserted just before the
fragment processing for this layer. At this point cogl_tex_coord
still contains the value of the texture coordinate attribute.
If a â€˜replaceâ€™ string is given then this will be used instead of
the default fragment processing for this layer. The snippet can
modify cogl_tex_coord or leave it as is to apply no transformation.

The â€˜postâ€™ string in @snippet will be inserted just after the
transformation. At this point cogl_tex_coord will contain the
results of the transformation but it can be further modified by the
snippet.

- `COGL_SNIPPET_HOOK_LAYER_FRAGMENT`

Adds a shader snippet that will hook on to the fragment processing
of a particular layer. This can be used to replace the processing
for a layer or to modify the results.

Within the snippet code for this hook there is an extra vec4
variable called â€˜cogl_layerâ€™. This contains the resulting color
that will be used for the layer. This can be modified in the â€˜postâ€™
section or it the default processing can be replaced entirely using
the â€˜replaceâ€™ section.

The â€˜declarationsâ€™ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.

The â€˜preâ€™ string in @snippet will be inserted just before the
fragment processing for this layer.

If a â€˜replaceâ€™ string is given then this will be used instead of
the default fragment processing for this layer. The snippet must write to
the â€˜cogl_layerâ€™ variable in that case.

The â€˜postâ€™ string in @snippet will be inserted just after the
fragment processing for the layer. The results can be modified by changing
the value of the â€˜cogl_layerâ€™ variable.

- `COGL_SNIPPET_HOOK_TEXTURE_LOOKUP`

Adds a shader snippet that will hook on to the texture lookup part
of a given layer. This gives a chance for the application to modify
the coordinates that will be used for the texture lookup or to
alter the returned texel.

Within the snippet code for this hook there are three extra
variables available. â€˜cogl_samplerâ€™ is a sampler object
representing the sampler for the layer where the snippet is
attached. â€˜cogl_tex_coordâ€™ is a vec4 which contains the texture
coordinates that will be used for the texture lookup. This can be
modified. â€˜cogl_texelâ€™ will contain the result of the texture
lookup. This can also be modified.

The â€˜declarationsâ€™ string in @snippet will be inserted in the
global scope of the shader. Use this to declare any uniforms,
attributes or functions that the snippet requires.

The â€˜preâ€™ string in @snippet will be inserted at the top of the
main() function before any fragment processing is done. This is a
good place to modify the cogl_tex_coord variable.

If a â€˜replaceâ€™ string is given then this will be used instead of a
the default texture lookup. The snippet would typically use its own
sampler in this case.

The â€˜postâ€™ string in @snippet will be inserted after texture lookup
has been performed. Here the snippet can modify the cogl_texel
variable to alter the returned texel.</doc>
      <source-position filename="cogl/cogl/cogl-snippet.h" line="480"/>
      <member name="vertex" value="0" c:identifier="COGL_SNIPPET_HOOK_VERTEX">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="239">A hook for the entire vertex processing
  stage of the pipeline.</doc>
      </member>
      <member name="vertex_transform"
              value="1"
              c:identifier="COGL_SNIPPET_HOOK_VERTEX_TRANSFORM">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="241">A hook for the vertex transformation.</doc>
      </member>
      <member name="vertex_globals"
              value="2"
              c:identifier="COGL_SNIPPET_HOOK_VERTEX_GLOBALS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="233">A hook for declaring global data
  that can be shared with all other snippets that are on a vertex
  hook.</doc>
      </member>
      <member name="point_size"
              value="3"
              c:identifier="COGL_SNIPPET_HOOK_POINT_SIZE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="242">A hook for manipulating the point
  size of a vertex. This is only used if
  cogl_pipeline_set_per_vertex_point_size() is enabled on the
  pipeline.</doc>
      </member>
      <member name="fragment"
              value="2048"
              c:identifier="COGL_SNIPPET_HOOK_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="246">A hook for the entire fragment
  processing stage of the pipeline.</doc>
      </member>
      <member name="fragment_globals"
              value="2049"
              c:identifier="COGL_SNIPPET_HOOK_FRAGMENT_GLOBALS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="236">A hook for declaring global
  data wthat can be shared with all other snippets that are on a
  fragment hook.</doc>
      </member>
      <member name="texture_coord_transform"
              value="4096"
              c:identifier="COGL_SNIPPET_HOOK_TEXTURE_COORD_TRANSFORM">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="248">A hook for applying the
  layer matrix to a texture coordinate for a layer.</doc>
      </member>
      <member name="layer_fragment"
              value="6144"
              c:identifier="COGL_SNIPPET_HOOK_LAYER_FRAGMENT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="250">A hook for the fragment
  processing of a particular layer.</doc>
      </member>
      <member name="texture_lookup"
              value="6145"
              c:identifier="COGL_SNIPPET_HOOK_TEXTURE_LOOKUP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-snippet.h"
             line="252">A hook for the texture lookup
  stage of a given layer in a pipeline.</doc>
      </member>
    </enumeration>
    <class name="SubTexture"
           c:symbol-prefix="sub_texture"
           c:type="CoglSubTexture"
           parent="Texture"
           final="1"
           glib:type-name="CoglSubTexture"
           glib:get-type="cogl_sub_texture_get_type"
           glib:type-struct="SubTextureClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-sub-texture.h"
           line="40">Functions for creating and manipulating sub-textures.

These functions allow high-level textures to be created that
represent a sub-region of another texture. For example these
can be used to implement custom texture atlasing schemes.</doc>
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="57"/>
      <constructor name="new" c:identifier="cogl_sub_texture_new">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-sub-texture.h"
             line="63">Creates a high-level #CoglSubTexture representing a sub-region of
any other #CoglTexture. The sub-region must strictly lye within the
bounds of the @parent_texture. The returned texture implements the
#CoglTexture interface because it's not a low level texture
that hardware can understand natively.

Remember: Unless you are using high level drawing APIs such
as cogl_rectangle() or other APIs documented to understand the
#CoglTexture interface then you need to use the
#CoglTexture interface to resolve a #CoglSubTexture into a
low-level texture before drawing.</doc>
        <source-position filename="cogl/cogl/cogl-sub-texture.h" line="92"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-sub-texture.h"
               line="88">A newly allocated #CoglSubTexture
         representing a sub-region of @parent_texture.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-sub-texture.h"
                 line="65">A #CoglContext pointer</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="parent_texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-sub-texture.h"
                 line="66">The full texture containing a sub-region you want
                 to make a #CoglSubTexture from.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </parameter>
          <parameter name="sub_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-sub-texture.h"
                 line="68">The top-left x coordinate of the parent region to make
        a texture from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-sub-texture.h"
                 line="70">The top-left y coordinate of the parent region to make
        a texture from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-sub-texture.h"
                 line="72">The width of the parent region to make a texture from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="sub_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-sub-texture.h"
                 line="73">The height of the parent region to make a texture
             from.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="get_parent" c:identifier="cogl_sub_texture_get_parent">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-sub-texture.h"
             line="99">Retrieves the parent texture that @sub_texture derives its content
from.  This is the texture that was passed to
cogl_sub_texture_new() as the parent_texture argument.</doc>
        <source-position filename="cogl/cogl/cogl-sub-texture.h" line="111"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-sub-texture.h"
               line="107">The parent texture that @sub_texture
              derives its content from.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sub_texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-sub-texture.h"
                 line="101">A pointer to a #CoglSubTexture</doc>
            <type name="SubTexture" c:type="CoglSubTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="SubTextureClass"
            c:type="CoglSubTextureClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="SubTexture">
      <source-position filename="cogl/cogl/cogl-sub-texture.h" line="57"/>
    </record>
    <enumeration name="SystemError"
                 glib:type-name="CoglSystemError"
                 glib:get-type="cogl_system_error_get_type"
                 c:type="CoglSystemError">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="72">Error enumeration for Cogl

The @COGL_SYSTEM_ERROR_UNSUPPORTED error can be thrown for a
variety of reasons. For example:

- You've tried to use a feature that is not advertised by
  [method@Cogl.Context.has_feature].
- The GPU can not handle the configuration you have requested.
  An example might be if you try to use too many texture
  layers in a single #CoglPipeline
- The driver does not support some configuration.

Currently this is only used by Cogl API marked as experimental so
this enum should also be considered experimental.</doc>
      <member name="cogl_system_error_unsupported"
              value="0"
              c:identifier="COGL_SYSTEM_ERROR_UNSUPPORTED"
              glib:nick="cogl-system-error-unsupported"
              glib:name="COGL_SYSTEM_ERROR_UNSUPPORTED">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="74">You tried to use a feature or
   configuration not currently available.</doc>
      </member>
      <member name="cogl_system_error_no_memory"
              value="1"
              c:identifier="COGL_SYSTEM_ERROR_NO_MEMORY"
              glib:nick="cogl-system-error-no-memory"
              glib:name="COGL_SYSTEM_ERROR_NO_MEMORY">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="76">You tried to allocate a resource
   such as a texture and there wasn't enough memory.</doc>
      </member>
    </enumeration>
    <function-macro name="TEXTURE_2D"
                    c:identifier="COGL_TEXTURE_2D"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="57"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_CLASS"
                    c:identifier="COGL_TEXTURE_2D_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="59"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_CONST"
                    c:identifier="COGL_TEXTURE_2D_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="58"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_GET_CLASS"
                    c:identifier="COGL_TEXTURE_2D_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="62"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_SLICED"
                    c:identifier="COGL_TEXTURE_2D_SLICED"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="70"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_SLICED_CLASS"
                    c:identifier="COGL_TEXTURE_2D_SLICED_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="72"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_SLICED_CONST"
                    c:identifier="COGL_TEXTURE_2D_SLICED_CONST"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="71"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TEXTURE_2D_SLICED_GET_CLASS"
                    c:identifier="COGL_TEXTURE_2D_SLICED_GET_CLASS"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="75"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="TEXTURE_MAX_WASTE"
              value="127"
              c:type="COGL_TEXTURE_MAX_WASTE">
      <source-position filename="cogl/cogl/cogl-texture.h" line="66"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="TRACE_BEGIN_ANCHORED"
                    c:identifier="COGL_TRACE_BEGIN_ANCHORED"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="177"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_BEGIN_SCOPED"
                    c:identifier="COGL_TRACE_BEGIN_SCOPED"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="151"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_DEFINE_COUNTER_DOUBLE"
                    c:identifier="COGL_TRACE_DEFINE_COUNTER_DOUBLE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="211"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
        <parameter name="description">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_DEFINE_COUNTER_INT"
                    c:identifier="COGL_TRACE_DEFINE_COUNTER_INT"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="207"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
        <parameter name="description">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_DESCRIBE"
                    c:identifier="COGL_TRACE_DESCRIBE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="168"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="description">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_END"
                    c:identifier="COGL_TRACE_END"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="161"/>
      <parameters>
        <parameter name="Name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_INTERNAL_DEFINE_COUNTER"
                    c:identifier="COGL_TRACE_INTERNAL_DEFINE_COUNTER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="195"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="name">
        </parameter>
        <parameter name="description">
        </parameter>
        <parameter name="func">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_INTERNAL_SET_COUNTER"
                    c:identifier="COGL_TRACE_INTERNAL_SET_COUNTER"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="215"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="value">
        </parameter>
        <parameter name="func">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_MESSAGE"
                    c:identifier="COGL_TRACE_MESSAGE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="184"/>
      <parameters>
        <parameter name="name">
        </parameter>
        <parameter name="...">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_SCOPED_ANCHOR"
                    c:identifier="COGL_TRACE_SCOPED_ANCHOR"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="172"/>
      <parameters>
        <parameter name="Name">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_SET_COUNTER_DOUBLE"
                    c:identifier="COGL_TRACE_SET_COUNTER_DOUBLE"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="229"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="value">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="TRACE_SET_COUNTER_INT"
                    c:identifier="COGL_TRACE_SET_COUNTER_INT"
                    introspectable="0">
      <source-position filename="cogl/cogl/cogl-trace.h" line="225"/>
      <parameters>
        <parameter name="Name">
        </parameter>
        <parameter name="value">
        </parameter>
      </parameters>
    </function-macro>
    <class name="Texture"
           c:symbol-prefix="texture"
           c:type="CoglTexture"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="CoglTexture"
           glib:get-type="cogl_texture_get_type"
           glib:type-struct="TextureClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture.h"
           line="46">Functions for creating and manipulating textures

Cogl allows creating and manipulating textures using a uniform
API that tries to hide all the various complexities of creating,
loading and manipulating textures.</doc>
      <source-position filename="cogl/cogl/cogl-texture.h" line="56"/>
      <function name="error_quark" c:identifier="cogl_texture_error_quark">
        <source-position filename="cogl/cogl/cogl-texture.h" line="93"/>
        <return-value transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </return-value>
      </function>
      <method name="allocate" c:identifier="cogl_texture_allocate" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="424">Explicitly allocates the storage for the given @texture which
allows you to be sure that there is enough memory for the
texture and if not then the error can be handled gracefully.

Normally applications don't need to use this api directly
since the texture will be implicitly allocated when data is set on
the texture, or if the texture is attached to a #CoglOffscreen
framebuffer and rendered too.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="443"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="438">%TRUE if the texture was successfully allocated,
              otherwise %FALSE and @error will be updated if it
              wasn't %NULL.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="426">A #CoglTexture</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="foreach_in_region"
              c:identifier="cogl_texture_foreach_in_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-meta-texture.h"
             line="121">Allows you to manually iterate the low-level textures that define a
given region of a high-level #CoglTexture.

For example cogl_texture_2d_sliced_new_with_size() can be used to
create a meta texture that may slice a large image into multiple,
smaller power-of-two sized textures. These high level textures are
not directly understood by a GPU and so this API must be used to
manually resolve the underlying textures for drawing.

All high level textures (#CoglAtlasTexture, #CoglSubTexture,
#CoglTexturePixmapX11, and #CoglTexture2DSliced) can be handled
consistently using this interface which greately simplifies
implementing primitives that support all texture types.

For example if you use the cogl_rectangle() API then Cogl will
internally use this API to resolve the low level textures of any
meta textures you have associated with CoglPipeline layers.

The low level drawing APIs such as cogl_primitive_draw()
don't understand the #CoglTexture interface and so it is your
responsibility to use this API to resolve all CoglPipeline textures
into low-level textures before drawing.

For each low-level texture that makes up part of the given region
of the @meta_texture, @callback is called specifying how the
low-level texture maps to the original region.</doc>
        <source-position filename="cogl/cogl/cogl-meta-texture.h" line="162"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="123">An object implementing the #CoglTexture interface.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="tx_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="124">The top-left x coordinate of the region to iterate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="ty_1" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="125">The top-left y coordinate of the region to iterate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="tx_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="126">The bottom-right x coordinate of the region to iterate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="ty_2" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="127">The bottom-right y coordinate of the region to iterate</doc>
            <type name="gfloat" c:type="float"/>
          </parameter>
          <parameter name="wrap_s" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="128">The wrap mode for the x-axis</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
          <parameter name="wrap_t" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="129">The wrap mode for the y-axis</doc>
            <type name="PipelineWrapMode" c:type="CoglPipelineWrapMode"/>
          </parameter>
          <parameter name="callback"
                     transfer-ownership="none"
                     scope="call"
                     closure="7">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="130">A #CoglTextureForeachCallback pointer to be called
           for each low-level texture within the specified region.</doc>
            <type name="TextureForeachCallback"
                  c:type="CoglTextureForeachCallback"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-meta-texture.h"
                 line="132">A private pointer that is passed to @callback.</doc>
            <type name="gpointer" c:type="void*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_components" c:identifier="cogl_texture_get_components">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="145">Queries what components the given @texture stores internally as set
via cogl_texture_set_components().

For textures created by the â€˜_with_sizeâ€™ constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="158"/>
        <return-value transfer-ownership="none">
          <type name="TextureComponents" c:type="CoglTextureComponents"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="147">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_context" c:identifier="cogl_texture_get_context">
        <source-position filename="cogl/cogl/cogl-texture.h" line="461"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="458">The associated %CoglContext</doc>
          <type name="Context" c:type="CoglContext*"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="cogl_texture_get_data">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="267">Copies the pixel data from a cogl texture to system memory.

Don't pass the value of cogl_texture_get_rowstride() as the
@rowstride argument, the rowstride should be the rowstride you
want for the destination @data buffer not the rowstride of the
source texture</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="287"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="284">the size of the texture data in bytes</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="269">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="270">the #CoglPixelFormat to store the texture as.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="271">the rowstride of @data in bytes or pass 0 to calculate
            from the bytes-per-pixel of @format multiplied by the
            @texture width.</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="274">memory location to write the @texture's contents,
or %NULL to only query the data size through the return value.</doc>
            <array zero-terminated="0" c:type="uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_format" c:identifier="cogl_texture_get_format">
        <source-position filename="cogl/cogl/cogl-texture.h" line="453"/>
        <return-value transfer-ownership="none">
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_gl_texture" c:identifier="cogl_texture_get_gl_texture">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="246">Queries the GL handles for a GPU side texture through its #CoglTexture.

If the texture is spliced the data for the first sub texture will be
queried.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="263"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="259">%TRUE if the handle was successfully retrieved, %FALSE
  if the handle was invalid</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="248">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="out_gl_handle"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="249">pointer to return location for the
  textures GL handle, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
          <parameter name="out_gl_target"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="251">pointer to return location for the
  GL target type, or %NULL.</doc>
            <type name="guint" c:type="unsigned int*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_height" c:identifier="cogl_texture_get_height">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="221">Queries the height of a cogl texture.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="230"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="227">the height of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="223">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_premultiplied"
              c:identifier="cogl_texture_get_premultiplied">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="193">Queries the pre-multiplied alpha status for internally stored red,
green and blue components for the given @texture as set by
cogl_texture_set_premultiplied().

By default the pre-multiplied state is @TRUE.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="208"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="203">%TRUE if red, green and blue components are
              internally stored pre-multiplied by the alpha
              value or %FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="195">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_width" c:identifier="cogl_texture_get_width">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="210">Queries the width of a cogl texture.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="219"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="216">the width of the GPU side texture in pixels</doc>
          <type name="guint" c:type="unsigned int"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="212">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_get_data_supported"
              c:identifier="cogl_texture_is_get_data_supported">
        <source-position filename="cogl/cogl/cogl-texture.h" line="450"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_sliced" c:identifier="cogl_texture_is_sliced">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="233">Queries if a texture is sliced (stored as multiple GPU side tecture
objects).</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="244"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="240">%TRUE if the texture is sliced, %FALSE if the texture
  is stored as a single GPU texture</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="235">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_components" c:identifier="cogl_texture_set_components">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="117">Affects the internal storage format for this texture by specifying
what components will be required for sampling later.

This api affects how data is uploaded to the GPU since unused
components can potentially be discarded from source data.

For textures created by the â€˜_with_sizeâ€™ constructors the default
is %COGL_TEXTURE_COMPONENTS_RGBA. The other constructors which take
a %CoglBitmap or a data pointer default to the same components as
the pixel format of the data.

Note that the %COGL_TEXTURE_COMPONENTS_RG format is not available
on all drivers. The availability can be determined by checking for
the %COGL_FEATURE_ID_TEXTURE_RG feature. If this format is used on
a driver where it is not available then %COGL_TEXTURE_ERROR_FORMAT
will be raised when the texture is allocated. Even if the feature
is not available then %COGL_PIXEL_FORMAT_RG_88 can still be used as
an image format as long as %COGL_TEXTURE_COMPONENTS_RG isn't used
as the texture's components.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="142"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="119">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="components" transfer-ownership="none">
            <type name="TextureComponents" c:type="CoglTextureComponents"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_data" c:identifier="cogl_texture_set_data" throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="332">@texture a #CoglTexture.
Sets all the pixels for a given mipmap @level by copying the pixel
data pointed to by the @data argument into the given @texture.

@data should point to the first pixel to copy corresponding
to the top left of the mipmap @level being set.

If @rowstride equals 0 then it will be automatically calculated
from the width of the mipmap level and the bytes-per-pixel for the
given @format.

A mipmap @level of 0 corresponds to the largest, base image of a
texture and @level 1 is half the width and height of level 0. If
dividing any dimension of the previous level by two results in a
fraction then round the number down (floor()), but clamp to 1
something like this:

```
 next_width = MAX (1, floor (prev_width));
```

You can determine the number of mipmap levels for a given texture
like this:

```
 n_levels = 1 + floor (log2 (max_dimension));
```

Where %max_dimension is the larger of cogl_texture_get_width() and
cogl_texture_get_height().

It is an error to pass a @level number &gt;= the number of levels that
@texture can have according to the above calculation.

Since the storage for a #CoglTexture is allocated lazily then
if the given @texture has not previously been allocated then this
api can return %FALSE and throw an exceptional @error if there is
not enough memory to allocate storage for @texture.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="385"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="381">%TRUE if the data upload was successful, and
              %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="335">the #CoglPixelFormat used in the source @data buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="336">rowstride of the source @data buffer (computed from
            the texture width and @format if it equals 0)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="338">the source data, pointing to the first top-left pixel to set</doc>
            <array zero-terminated="0" c:type="const uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
          <parameter name="level" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="339">The mipmap level to update (Normally 0 for the largest,
        base texture)</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_premultiplied"
              c:identifier="cogl_texture_set_premultiplied">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="160">Affects the internal storage format for this texture by specifying
whether red, green and blue color components should be stored as
pre-multiplied alpha values.

This api affects how data is uploaded to the GPU since Cogl will
convert source data to have premultiplied or unpremultiplied
components according to this state.

For example if you create a texture via
cogl_texture_2d_new_with_size() and then upload data via
cogl_texture_set_data() passing a source format of
%COGL_PIXEL_FORMAT_RGBA_8888 then Cogl will internally multiply the
red, green and blue components of the source data by the alpha
component, for each pixel so that the internally stored data has
pre-multiplied alpha components. If you instead upload data that
already has pre-multiplied components by passing
%COGL_PIXEL_FORMAT_RGBA_8888_PRE as the source format to
cogl_texture_set_data() then the data can be uploaded without being
converted.

By default the @premultipled state is @TRUE.</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="190"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="162">a #CoglTexture pointer.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="premultiplied" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="163">Whether any internally stored red, green or blue
                components are pre-multiplied by an alpha
                component.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_region" c:identifier="cogl_texture_set_region">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="292">Sets the pixels in a rectangular subregion of @texture from an in-memory
buffer containing pixel data.

The region set can't be larger than the source @data</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="319"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="315">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="294">a #CoglTexture.</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="295">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="296">upper left coordinate to use from source data.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="297">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="298">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="299">width of destination region to write. (Must be less
  than or equal to @width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="301">height of destination region to write. (Must be less
  than or equal to @height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="303">width of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="304">height of source data buffer.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="305">the #CoglPixelFormat used in the source buffer.</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="306">rowstride of source buffer (computed from width if none
specified)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="308">the actual pixel data.</doc>
            <array zero-terminated="0" c:type="const uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="set_region_from_bitmap"
              c:identifier="cogl_texture_set_region_from_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="392">Copies a specified source region from @bitmap to the position
(@src_x, @src_y) of the given destination texture @handle.

The region updated can't be larger than the source
bitmap</doc>
        <source-position filename="cogl/cogl/cogl-texture.h" line="415"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture.h"
               line="411">%TRUE if the subregion upload was successful, and
  %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="394">a #CoglTexture pointer</doc>
            <type name="Texture" c:type="CoglTexture*"/>
          </instance-parameter>
          <parameter name="src_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="395">upper left coordinate to use from the source bitmap.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="src_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="396">upper left coordinate to use from the source bitmap</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_x" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="397">upper left destination horizontal coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_y" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="398">upper left destination vertical coordinate.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="dst_width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="399">width of destination region to write. (Must be less
  than or equal to the bitmap width)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="dst_height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="401">height of destination region to write. (Must be less
  than or equal to the bitmap height)</doc>
            <type name="guint" c:type="unsigned int"/>
          </parameter>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture.h"
                 line="403">The source bitmap to read from</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </method>
      <property name="context"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Context"/>
      </property>
      <property name="format"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="COGL_PIXEL_FORMAT_ANY">
        <type name="PixelFormat"/>
      </property>
      <property name="height"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="loader"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="width"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <field name="parent_instance">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
    </class>
    <class name="Texture2D"
           c:symbol-prefix="texture_2d"
           c:type="CoglTexture2D"
           parent="Texture"
           final="1"
           glib:type-name="CoglTexture2D"
           glib:get-type="cogl_texture_2d_get_type"
           glib:type-struct="Texture2DClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture-2d.h"
           line="44">Functions for creating and manipulating 2D textures

These functions allow low-level 2D textures to be allocated. These
differ from sliced textures for example which may internally be
made up of multiple 2D textures, or atlas textures where Cogl must
internally modify user texture coordinates before they can be used
by the GPU.</doc>
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="64"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_new_from_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="173">Creates a low-level #CoglTexture2D texture based on data residing
in a #CoglBitmap.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="194"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="191">A newly allocated #CoglTexture2D</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="bitmap" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="175">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_from_data"
                   c:identifier="cogl_texture_2d_new_from_data"
                   throws="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="133">Creates a low-level #CoglTexture2D texture based on data residing
in memory.

This api will always immediately allocate GPU memory for the
texture and upload the given data so that the @data pointer does
not need to remain valid once this function returns. This means it
is not possible to configure the texture before it is allocated. If
you do need to configure the texture before allocation (to specify
constraints on the internal format for example) then you can
instead create a #CoglBitmap for your data and use
cogl_texture_2d_new_from_bitmap() or use
cogl_texture_2d_new_with_size() and then upload data using
cogl_texture_set_data()</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="165"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="159">A newly allocated #CoglTexture2D, or if
         the size is not supported (because it is too large or a
         non-power-of-two size that the hardware doesn't support)
         it will return %NULL and set @error.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="135">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="136">width of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="137">height of texture in pixels</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="138">the #CoglPixelFormat the buffer is stored in in RAM</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
          <parameter name="rowstride" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="139">the memory offset in bytes between the starts of
   scanlines in @data. A value of 0 will make Cogl automatically
   calculate @rowstride from @width and @format.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="142">pointer the memory region where the source buffer resides</doc>
            <array zero-terminated="0" c:type="const uint8_t*">
              <type name="guint8" c:type="uint8_t"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_format"
                   c:identifier="cogl_texture_2d_new_with_format">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="77">Creates a low-level #CoglTexture2D texture with a given @width and
@height that your GPU can texture from directly.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="101"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="98">A new #CoglTexture2D object with no storage yet allocated.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="79">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="80">Width of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="81">Height of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="82">format of the texture to allocate</doc>
            <type name="PixelFormat" c:type="CoglPixelFormat"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_new_with_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="106">Creates a low-level #CoglTexture2D texture with a given @width and
@height that your GPU can texture from directly.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or preferably let Cogl
automatically allocate storage lazily when it may know more about
how the texture is being used and can optimize how it is allocated.

The texture is still configurable until it has been allocated so
for example you can influence the internal format of the texture
using cogl_texture_set_components() and
cogl_texture_set_premultiplied().</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="129"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d.h"
               line="126">A new #CoglTexture2D object with no storage yet allocated.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="108">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="109">Width of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="110">Height of the texture to allocate</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="set_auto_mipmap"
              c:identifier="cogl_texture_2d_set_auto_mipmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d.h"
             line="232">Sets whether the texture will automatically update the smaller
mipmap levels after any part of level 0 is updated. The update will
only occur whenever the texture is used for drawing with a texture
filter that requires the lower mipmap levels. An application should
disable this if it wants to upload its own data for the other
levels. By default auto mipmapping is enabled.</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d.h" line="245"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="texture" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="234">A #CoglTexture2D</doc>
            <type name="Texture2D" c:type="CoglTexture2D*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d.h"
                 line="235">The new value for whether to auto mipmap</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
    </class>
    <record name="Texture2DClass"
            c:type="CoglTexture2DClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Texture2D">
      <source-position filename="cogl/cogl/cogl-texture-2d.h" line="64"/>
    </record>
    <class name="Texture2DSliced"
           c:symbol-prefix="texture_2d_sliced"
           c:type="CoglTexture2DSliced"
           parent="Texture"
           final="1"
           glib:type-name="CoglTexture2DSliced"
           glib:get-type="cogl_texture_2d_sliced_get_type"
           glib:type-struct="Texture2DSlicedClass">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture-2d-sliced.h"
           line="38">Functions for creating and manipulating 2D meta textures
that may internally be comprised of multiple 2D textures
with power-of-two sizes.

These functions allow high-level meta textures to be allocated
that may internally be comprised of multiple 2D texture
"slices" with power-of-two sizes.

This API can be useful when working with GPUs that don't have
native support for non-power-of-two textures or if you want to load
a texture that is larger than the GPUs maximum texture size limits.

The algorithm for slicing works by first trying to map a virtual
size to the next larger power-of-two size and then seeing how many
wasted pixels that would result in. For example if you have a
virtual texture that's 259 texels wide, the next pot size = 512 and
the amount of waste would be 253 texels. If the amount of waste is
above a max-waste threshold then we would next slice that texture
into one that's 256 texels and then looking at how many more texels
remain unallocated after that we choose the next power-of-two size.
For the example of a 259 texel image that would mean having a 256
texel wide texture, leaving 3 texels unallocated so we'd then
create a 4 texel wide texture - now there is only one texel of
waste. The algorithm continues to slice the right most textures
until the amount of waste is less than or equal to a specified
max-waste threshold. The same logic for slicing from left to right
is also applied from top to bottom.</doc>
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="77"/>
      <constructor name="new_from_bitmap"
                   c:identifier="cogl_texture_2d_sliced_new_from_bitmap">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d-sliced.h"
             line="129">Creates a new #CoglTexture2DSliced texture based on data residing
in a bitmap.

A #CoglTexture2DSliced may internally be comprised of 1 or more
#CoglTexture2D textures depending on GPU limitations.  For example
if the GPU only supports power-of-two sized textures then a sliced
texture will turn a non-power-of-two size into a combination of
smaller power-of-two sized textures. If the requested texture size
is larger than is supported by the hardware then the texture will
be sliced into smaller textures that can be accessed by the
hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size is
larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                         line="169"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d-sliced.h"
               line="165">A newly created #CoglTexture2DSliced
              or %NULL on failure and @error will be updated.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="bmp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="131">A #CoglBitmap</doc>
            <type name="Bitmap" c:type="CoglBitmap*"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="132">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_with_size"
                   c:identifier="cogl_texture_2d_sliced_new_with_size">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture-2d-sliced.h"
             line="84">Creates a #CoglTexture2DSliced that may internally be comprised of
1 or more #CoglTexture2D textures depending on GPU limitations.
For example if the GPU only supports power-of-two sized textures
then a sliced texture will turn a non-power-of-two size into a
combination of smaller power-of-two sized textures. If the
requested texture size is larger than is supported by the hardware
then the texture will be sliced into smaller textures that can be
accessed by the hardware.

@max_waste is used as a threshold for recursively slicing the
right-most or bottom-most slices into smaller sizes until the
wasted padding at the bottom and right of the textures is less than
specified. A negative @max_waste will disable slicing.

The storage for the texture is not allocated before this function
returns. You can call cogl_texture_allocate() to explicitly
allocate the underlying storage or let Cogl automatically allocate
storage lazily.

It's possible for the allocation of a sliced texture to fail
later due to impossible slicing constraints if a negative
@max_waste value is given. If the given virtual texture size size
is larger than is supported by the hardware but slicing is disabled
the texture size would be too large to handle.</doc>
        <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                         line="123"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-texture-2d-sliced.h"
               line="119">A new #CoglTexture2DSliced object with no storage
         allocated yet.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </return-value>
        <parameters>
          <parameter name="ctx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="86">A #CoglContext</doc>
            <type name="Context" c:type="CoglContext*"/>
          </parameter>
          <parameter name="width" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="87">The virtual width of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="height" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="88">The virtual height of your sliced texture.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
          <parameter name="max_waste" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="cogl/cogl/cogl-texture-2d-sliced.h"
                 line="89">The threshold of how wide a strip of wasted texels
            are allowed along the right and bottom textures before
            they must be sliced to reduce the amount of waste. A
            negative can be passed to disable slicing.</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </constructor>
    </class>
    <record name="Texture2DSlicedClass"
            c:type="CoglTexture2DSlicedClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Texture2DSliced">
      <source-position filename="cogl/cogl/cogl-texture-2d-sliced.h"
                       line="77"/>
    </record>
    <record name="TextureClass"
            c:type="CoglTextureClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Texture">
      <source-position filename="cogl/cogl/cogl-texture.h" line="56"/>
    </record>
    <enumeration name="TextureComponents" c:type="CoglTextureComponents">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture.h"
           line="96">See cogl_texture_set_components().</doc>
      <source-position filename="cogl/cogl/cogl-texture.h" line="115"/>
      <member name="a" value="1" c:identifier="COGL_TEXTURE_COMPONENTS_A">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="98">Only the alpha component</doc>
      </member>
      <member name="rg" value="2" c:identifier="COGL_TEXTURE_COMPONENTS_RG">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="99">Red and green components. Note that
  this can only be used if the %COGL_FEATURE_ID_TEXTURE_RG feature
  is advertised.</doc>
      </member>
      <member name="rgb" value="3" c:identifier="COGL_TEXTURE_COMPONENTS_RGB">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="102">Red, green and blue components</doc>
      </member>
      <member name="rgba"
              value="4"
              c:identifier="COGL_TEXTURE_COMPONENTS_RGBA">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="103">Red, green, blue and alpha components</doc>
      </member>
      <member name="depth"
              value="5"
              c:identifier="COGL_TEXTURE_COMPONENTS_DEPTH">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="104">Only a depth component</doc>
      </member>
    </enumeration>
    <enumeration name="TextureError" c:type="CoglTextureError">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-texture.h"
           line="75">Error codes that can be thrown when allocating textures.</doc>
      <source-position filename="cogl/cogl/cogl-texture.h" line="90"/>
      <member name="size" value="0" c:identifier="COGL_TEXTURE_ERROR_SIZE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="77">Unsupported size</doc>
      </member>
      <member name="format" value="1" c:identifier="COGL_TEXTURE_ERROR_FORMAT">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="78">Unsupported format</doc>
      </member>
      <member name="bad_parameter"
              value="2"
              c:identifier="COGL_TEXTURE_ERROR_BAD_PARAMETER">
      </member>
      <member name="type" value="3" c:identifier="COGL_TEXTURE_ERROR_TYPE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-texture.h"
             line="79">A primitive texture type that is
  unsupported by the driver was used</doc>
      </member>
    </enumeration>
    <callback name="TextureForeachCallback"
              c:type="CoglTextureForeachCallback">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-meta-texture.h"
           line="92">A callback used with cogl_texture_foreach_in_region() to
retrieve details of all the low-level `CoglTexture`s that
make up a given #CoglTexture.</doc>
      <source-position filename="cogl/cogl/cogl-meta-texture.h" line="116"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="sub_texture" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-meta-texture.h"
               line="94">A low-level #CoglTexture making up part of a
              #CoglTexture.</doc>
          <type name="Texture" c:type="CoglTexture*"/>
        </parameter>
        <parameter name="sub_texture_coords" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-meta-texture.h"
               line="96">A float 4-tuple ordered like
                     (tx1,ty1,tx2,ty2) defining what region of the
                     current @sub_texture maps to a sub-region of a
                     #CoglTexture. (tx1,ty1) is the top-left
                     sub-region coordinate and (tx2,ty2) is the
                     bottom-right. These are low-level texture
                     coordinates.</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="meta_coords" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-meta-texture.h"
               line="103">A float 4-tuple ordered like (tx1,ty1,tx2,ty2)
              defining what sub-region of a #CoglTexture this
              low-level @sub_texture maps too. (tx1,ty1) is
              the top-left sub-region coordinate and (tx2,ty2) is
              the bottom-right. These are high-level meta-texture
              coordinates.</doc>
          <type name="gfloat" c:type="const float*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-meta-texture.h"
               line="109">A private pointer passed to
            cogl_texture_foreach_in_region().</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="TimestampQuery"
            c:type="CoglTimestampQuery"
            disguised="1"
            opaque="1">
      <source-position filename="cogl/cogl/cogl-types.h" line="349"/>
    </record>
    <function-macro name="VALUE_HOLDS_COLOR"
                    c:identifier="COGL_VALUE_HOLDS_COLOR"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="313">Evaluates to %TRUE if @x holds a `CoglColor`.</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="319"/>
      <parameters>
        <parameter name="x">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="315">a #GValue</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="VertexP2" c:type="CoglVertexP2">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-primitive.h"
           line="62">A convenience vertex definition that can be used with
cogl_primitive_new_p2().</doc>
      <source-position filename="cogl/cogl/cogl-primitive.h" line="72"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="64">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="65">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP2C4" c:type="CoglVertexP2C4">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-primitive.h"
           line="87">A convenience vertex definition that can be used with
cogl_primitive_new_p2c4().</doc>
      <source-position filename="cogl/cogl/cogl-primitive.h" line="102"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="89">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="90">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="r" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="91">The red component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="g" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="93">The blue component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="b" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="92">The green component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
      <field name="a" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="94">The alpha component of a color attribute</doc>
        <type name="guint8" c:type="uint8_t"/>
      </field>
    </record>
    <record name="VertexP2T2" c:type="CoglVertexP2T2">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-primitive.h"
           line="104">A convenience vertex definition that can be used with
cogl_primitive_new_p2t2().</doc>
      <source-position filename="cogl/cogl/cogl-primitive.h" line="117"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="106">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="107">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="108">The s component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="109">The t component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP3" c:type="CoglVertexP3">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-primitive.h"
           line="74">A convenience vertex definition that can be used with
cogl_primitive_new_p3().</doc>
      <source-position filename="cogl/cogl/cogl-primitive.h" line="85"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="76">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="77">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="78">The z component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <record name="VertexP3T2" c:type="CoglVertexP3T2">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-primitive.h"
           line="119">A convenience vertex definition that can be used with
cogl_primitive_new_p3t2().</doc>
      <source-position filename="cogl/cogl/cogl-primitive.h" line="133"/>
      <field name="x" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="121">The x component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="y" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="122">The y component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="z" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="123">The z component of a position attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="s" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="124">The s component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
      <field name="t" writable="1">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-primitive.h"
             line="125">The t component of a texture coordinate attribute</doc>
        <type name="gfloat" c:type="float"/>
      </field>
    </record>
    <enumeration name="VerticesMode"
                 glib:type-name="CoglVerticesMode"
                 glib:get-type="cogl_vertices_mode_get_type"
                 c:type="CoglVerticesMode">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="147">Different ways of interpreting vertices when drawing.</doc>
      <member name="points"
              value="0"
              c:identifier="COGL_VERTICES_MODE_POINTS"
              glib:nick="points"
              glib:name="COGL_VERTICES_MODE_POINTS">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="149">FIXME, equivalent to `GL_POINTS`</doc>
      </member>
      <member name="lines"
              value="1"
              c:identifier="COGL_VERTICES_MODE_LINES"
              glib:nick="lines"
              glib:name="COGL_VERTICES_MODE_LINES">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="150">FIXME, equivalent to `GL_LINES`</doc>
      </member>
      <member name="line_loop"
              value="2"
              c:identifier="COGL_VERTICES_MODE_LINE_LOOP"
              glib:nick="line-loop"
              glib:name="COGL_VERTICES_MODE_LINE_LOOP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="151">FIXME, equivalent to `GL_LINE_LOOP`</doc>
      </member>
      <member name="line_strip"
              value="3"
              c:identifier="COGL_VERTICES_MODE_LINE_STRIP"
              glib:nick="line-strip"
              glib:name="COGL_VERTICES_MODE_LINE_STRIP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="152">FIXME, equivalent to `GL_LINE_STRIP`</doc>
      </member>
      <member name="triangles"
              value="4"
              c:identifier="COGL_VERTICES_MODE_TRIANGLES"
              glib:nick="triangles"
              glib:name="COGL_VERTICES_MODE_TRIANGLES">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="153">FIXME, equivalent to `GL_TRIANGLES`</doc>
      </member>
      <member name="triangle_strip"
              value="5"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_STRIP"
              glib:nick="triangle-strip"
              glib:name="COGL_VERTICES_MODE_TRIANGLE_STRIP">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="154">FIXME, equivalent to `GL_TRIANGLE_STRIP`</doc>
      </member>
      <member name="triangle_fan"
              value="6"
              c:identifier="COGL_VERTICES_MODE_TRIANGLE_FAN"
              glib:nick="triangle-fan"
              glib:name="COGL_VERTICES_MODE_TRIANGLE_FAN">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="155">FIXME, equivalent to `GL_TRIANGLE_FAN`</doc>
      </member>
    </enumeration>
    <enumeration name="Winding"
                 glib:type-name="CoglWinding"
                 glib:get-type="cogl_winding_get_type"
                 c:type="CoglWinding">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-types.h"
           line="273">Enum used to represent the two directions of rotation. This can be
used to set the front face for culling by calling
cogl_pipeline_set_front_face_winding().</doc>
      <member name="clockwise"
              value="0"
              c:identifier="COGL_WINDING_CLOCKWISE"
              glib:nick="clockwise"
              glib:name="COGL_WINDING_CLOCKWISE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="275">Vertices are in a clockwise order</doc>
      </member>
      <member name="counter_clockwise"
              value="1"
              c:identifier="COGL_WINDING_COUNTER_CLOCKWISE"
              glib:nick="counter-clockwise"
              glib:name="COGL_WINDING_COUNTER_CLOCKWISE">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-types.h"
             line="276">Vertices are in a counter-clockwise order</doc>
      </member>
    </enumeration>
    <enumeration name="WinsysFeature"
                 glib:type-name="CoglWinsysFeature"
                 glib:get-type="cogl_winsys_feature_get_type"
                 c:type="CoglWinsysFeature">
      <member name="vblank_counter"
              value="0"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_COUNTER"
              glib:nick="vblank-counter"
              glib:name="COGL_WINSYS_FEATURE_VBLANK_COUNTER">
      </member>
      <member name="vblank_wait"
              value="1"
              c:identifier="COGL_WINSYS_FEATURE_VBLANK_WAIT"
              glib:nick="vblank-wait"
              glib:name="COGL_WINSYS_FEATURE_VBLANK_WAIT">
      </member>
      <member name="texture_from_pixmap"
              value="2"
              c:identifier="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP"
              glib:nick="texture-from-pixmap"
              glib:name="COGL_WINSYS_FEATURE_TEXTURE_FROM_PIXMAP">
      </member>
      <member name="swap_buffers_event"
              value="3"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT"
              glib:nick="swap-buffers-event"
              glib:name="COGL_WINSYS_FEATURE_SWAP_BUFFERS_EVENT">
      </member>
      <member name="swap_region"
              value="4"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION"
              glib:nick="swap-region"
              glib:name="COGL_WINSYS_FEATURE_SWAP_REGION">
      </member>
      <member name="swap_region_throttle"
              value="5"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE"
              glib:nick="swap-region-throttle"
              glib:name="COGL_WINSYS_FEATURE_SWAP_REGION_THROTTLE">
      </member>
      <member name="swap_region_synchronized"
              value="6"
              c:identifier="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED"
              glib:nick="swap-region-synchronized"
              glib:name="COGL_WINSYS_FEATURE_SWAP_REGION_SYNCHRONIZED">
      </member>
      <member name="buffer_age"
              value="7"
              c:identifier="COGL_WINSYS_FEATURE_BUFFER_AGE"
              glib:nick="buffer-age"
              glib:name="COGL_WINSYS_FEATURE_BUFFER_AGE">
      </member>
      <member name="sync_and_complete_event"
              value="8"
              c:identifier="COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT"
              glib:nick="sync-and-complete-event"
              glib:name="COGL_WINSYS_FEATURE_SYNC_AND_COMPLETE_EVENT">
      </member>
      <member name="n_features"
              value="9"
              c:identifier="COGL_WINSYS_FEATURE_N_FEATURES"
              glib:nick="n-features"
              glib:name="COGL_WINSYS_FEATURE_N_FEATURES">
      </member>
    </enumeration>
    <enumeration name="WinsysID" c:type="CoglWinsysID">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-renderer.h"
           line="128">Identifies specific window system backends that Cogl supports.

These can be used to query what backend Cogl is using or to try and
explicitly select a backend to use.</doc>
      <source-position filename="cogl/cogl/cogl-renderer.h" line="147"/>
      <member name="any" value="0" c:identifier="COGL_WINSYS_ID_ANY">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="130">Implies no preference for which backend is used</doc>
      </member>
      <member name="stub" value="1" c:identifier="COGL_WINSYS_ID_STUB">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="131">Use the no-op stub backend</doc>
      </member>
      <member name="glx" value="2" c:identifier="COGL_WINSYS_ID_GLX">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="132">Use the GLX window system binding API</doc>
      </member>
      <member name="egl_xlib" value="3" c:identifier="COGL_WINSYS_ID_EGL_XLIB">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-renderer.h"
             line="133">Use EGL with the X window system via XLib</doc>
      </member>
      <member name="custom" value="4" c:identifier="COGL_WINSYS_ID_CUSTOM">
      </member>
    </enumeration>
    <function name="color_from_string"
              c:identifier="cogl_color_from_string"
              moved-to="Color.from_string">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="123">Parses a string definition of a color, filling the #CoglColor.red,
#CoglColor.green, #CoglColor.blue and #CoglColor.alpha fields
of @color.

The @color is not allocated.

The format of @str can be either one of:

  - an hexadecimal value in the form: `#rgb`, `#rrggbb`, `#rgba`, or `#rrggbbaa`
  - a RGB color in the form: `rgb(r, g, b)`
  - a RGB color in the form: `rgba(r, g, b, a)`
  - a HSL color in the form: `hsl(h, s, l)`
   -a HSL color in the form: `hsla(h, s, l, a)`

where 'r', 'g', 'b' and 'a' are (respectively) the red, green, blue color
intensities and the opacity. The 'h', 's' and 'l' are (respectively) the
hue, saturation and luminance values.

In the rgb() and rgba() formats, the 'r', 'g', and 'b' values are either
integers between 0 and 255, or percentage values in the range between 0%
and 100%; the percentages require the '%' character. The 'a' value, if
specified, can only be a floating point value between 0.0 and 1.0.

In the hls() and hlsa() formats, the 'h' value (hue) is an angle between
0 and 360.0 degrees; the 'l' and 's' values (luminance and saturation) are
percentage values in the range between 0% and 100%. The 'a' value, if specified,
can only be a floating point value between 0.0 and 1.0.

Whitespace inside the definitions is ignored; no leading whitespace
is allowed.

If the alpha component is not specified then it is assumed to be set to
be fully opaque.</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="165"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="162">%TRUE if parsing succeeded, and %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="color"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="125">return location for a #CoglColor</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="str" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="126">a string specifying a color</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="color_init_from_hsl"
              c:identifier="cogl_color_init_from_hsl"
              moved-to="Color.init_from_hsl">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="292">Converts a color expressed in HLS (hue, luminance and saturation)
values into a #CoglColor.</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="303"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="color"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="294">return location for a #CoglColor</doc>
          <type name="Color" c:type="CoglColor*"/>
        </parameter>
        <parameter name="hue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="295">hue value, in the 0 .. 360 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="saturation" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="296">saturation value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
        <parameter name="luminance" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="297">luminance value, in the 0 .. 1 range</doc>
          <type name="gfloat" c:type="float"/>
        </parameter>
      </parameters>
    </function>
    <function name="dma_buf_handle_new"
              c:identifier="cogl_dma_buf_handle_new"
              moved-to="DmaBufHandle.new"
              introspectable="0">
      <source-position filename="cogl/cogl/cogl-dma-buf-handle.h" line="45"/>
      <return-value>
        <type name="DmaBufHandle" c:type="CoglDmaBufHandle*"/>
      </return-value>
      <parameters>
        <parameter name="framebuffer" transfer-ownership="none">
          <type name="Framebuffer" c:type="CoglFramebuffer*"/>
        </parameter>
        <parameter name="width" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="height" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="format" transfer-ownership="none">
          <type name="guint32" c:type="uint32_t"/>
        </parameter>
        <parameter name="modifier" transfer-ownership="none">
          <type name="guint64" c:type="uint64_t"/>
        </parameter>
        <parameter name="n_planes" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="fds" transfer-ownership="none">
          <type name="gint" c:type="int*"/>
        </parameter>
        <parameter name="strides" transfer-ownership="none">
          <type name="guint32" c:type="uint32_t*"/>
        </parameter>
        <parameter name="offsets" transfer-ownership="none">
          <type name="guint32" c:type="uint32_t*"/>
        </parameter>
        <parameter name="bpp" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="destroy_func" transfer-ownership="none" scope="async">
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="glib_source_new" c:identifier="cogl_glib_source_new">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-glib-source.h"
           line="43">Creates a #GSource which handles Cogl's internal system event
processing.</doc>
      <source-position filename="cogl/cogl/cogl-glib-source.h" line="54"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-glib-source.h"
             line="51">a new #GSource</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-glib-source.h"
               line="45">A #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-glib-source.h"
               line="46">The priority of the #GSource</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="graphene_matrix_project_point"
              c:identifier="cogl_graphene_matrix_project_point">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-graphene.h"
           line="41">Transforms a point whose position is given and returned as four float
components.</doc>
      <source-position filename="cogl/cogl/cogl-graphene.h" line="53"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="43">A 4x4 transformation matrix</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </parameter>
        <parameter name="x"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="44">The X component of your points position</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="y"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="45">The Y component of your points position</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="z"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="46">The Z component of your points position</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
        <parameter name="w"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="47">The W component of your points position</doc>
          <type name="gfloat" c:type="float*"/>
        </parameter>
      </parameters>
    </function>
    <function name="graphene_matrix_project_points_f3"
              c:identifier="cogl_graphene_matrix_project_points_f3">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-graphene.h"
           line="112">Projects an array of input points and writes the result to another
array of output points. The output points always have 4 components (known
as homogeneous coordinates). The output array can simply point to
the input array to do the transform in-place.

Here's an example with differing input/output strides:
```c
typedef struct {
  float x,y, z;
  uint8_t r,g,b,a;
  float s,t,p;
} MyInVertex;
typedef struct {
  uint8_t r,g,b,a;
  float x,y,z;
} MyOutVertex;
MyInVertex vertices[N_VERTICES];
MyOutVertex results[N_VERTICES];
graphene_matrix_t matrix;

my_load_vertices (vertices);
my_get_matrix (&amp;matrix);

cogl_graphene_matrix_project_points_f3 (&amp;matrix,
                                        sizeof (MyInVertex),
                                        &amp;vertices[0].x,
                                        sizeof (MyOutVertex),
                                        &amp;results[0].x,
                                        N_VERTICES);
```</doc>
      <source-position filename="cogl/cogl/cogl-graphene.h" line="153"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="114">A projection matrix</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </parameter>
        <parameter name="stride_in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="115">The stride in bytes between input points.</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="points_in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="116">A pointer to the first component of the first input point.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="stride_out" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="117">The stride in bytes between output points.</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="points_out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="118">A pointer to the first component of the first output point.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="n_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="119">The number of points to transform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="graphene_matrix_transform_points"
              c:identifier="cogl_graphene_matrix_transform_points">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-graphene.h"
           line="59">Transforms an array of input points and writes the result to
another array of output points. The input points can either have 2
or 3 components each. The output points always have 3 components.
The output array can simply point to the input array to do the
transform in-place.

Here's an example with differing input/output strides:
```c
typedef struct {
  float x,y;
  uint8_t r,g,b,a;
  float s,t,p;
} MyInVertex;
typedef struct {
  uint8_t r,g,b,a;
  float x,y,z;
} MyOutVertex;
MyInVertex vertices[N_VERTICES];
MyOutVertex results[N_VERTICES];
graphene_matrix_t matrix;

my_load_vertices (vertices);
my_get_matrix (&amp;matrix);

cogl_graphene_matrix_transform_points (&amp;matrix,
                              2,
                              sizeof (MyInVertex),
                              &amp;vertices[0].x,
                              sizeof (MyOutVertex),
                              &amp;results[0].x,
                              N_VERTICES);
```</doc>
      <source-position filename="cogl/cogl/cogl-graphene.h" line="104"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="matrix" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="61">A transformation matrix</doc>
          <type name="Graphene.Matrix" c:type="const graphene_matrix_t*"/>
        </parameter>
        <parameter name="n_components" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="62">The number of position components for each input point.
               (either 2 or 3)</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="stride_in" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="64">The stride in bytes between input points.</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="points_in"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="65">A pointer to the first component of the first input point.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="stride_out" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="66">The stride in bytes between output points.</doc>
          <type name="gsize" c:type="size_t"/>
        </parameter>
        <parameter name="points_out"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="67">A pointer to the first component of the first output point.</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="n_points" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-graphene.h"
               line="68">The number of points to transform.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <docsection name="meta-texture">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-meta-texture.h"
           line="41">Interface for high-level textures built from
low-level textures like #CoglTexture2D.
Cogl helps to make it easy to deal with high level textures such
as `CoglAtlasTexture`s, `CoglSubTexture`s,
#CoglTexturePixmapX11 textures and #CoglTexture2DSliced textures
consistently.

A #CoglTexture is a texture that might internally be
represented by one or more low-level `CoglTexture`s
such as #CoglTexture2D. These low-level textures are the only ones
that a GPU really understands but because applications often want
more high-level texture abstractions (such as storing multiple
textures inside one larger "atlas" texture) it's desirable to be
able to deal with these using a common interface.

For example the GPU is not able to automatically handle repeating a
texture that is part of a larger atlas texture but if you use
%COGL_PIPELINE_WRAP_MODE_REPEAT with an atlas texture when drawing
with cogl_rectangle() you should see that it "Just Worksâ„¢" - at
least if you don't use multi-texturing. The reason this works is
because cogl_rectangle() internally understands the #CoglTexture
interface and is able to manually resolve the low-level textures
using this interface and by making multiple draw calls it can
emulate the texture repeat modes.

Cogl doesn't aim to pretend that meta-textures are just like real
textures because it would get extremely complex to try and emulate
low-level GPU semantics transparently for these textures.  The low
level drawing APIs of Cogl, such as cogl_primitive_draw() don't
actually know anything about the #CoglTexture interface and its
the developer's responsibility to resolve all textures referenced
by a #CoglPipeline to low-level textures before drawing.

If you want to develop custom primitive APIs like
cogl_framebuffer_draw_rectangle() and you want to support drawing
with `CoglAtlasTexture`s or `CoglSubTexture`s for
example, then you will need to use this #CoglTexture interface
to be able to resolve high-level textures into low-level textures
before drawing with Cogl's low-level drawing APIs such as
cogl_primitive_draw().

Most developers won't need to use this interface directly
but still it is worth understanding the distinction between
low-level and meta textures because you may find other references
in the documentation that detail limitations of using
meta-textures.</doc>
    </docsection>
    <function name="param_spec_color"
              c:identifier="cogl_param_spec_color"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-color.h"
           line="348">Creates a #GParamSpec for properties using #CoglColor.</doc>
      <source-position filename="cogl/cogl/cogl-color.h" line="361"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-color.h"
             line="358">the newly created #GParamSpec</doc>
        <type name="GObject.ParamSpec" c:type="GParamSpec*"/>
      </return-value>
      <parameters>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="350">name of the property</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="nick" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="351">short name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="blurb" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="352">description (can be translatable)</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="default_value" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="353">default value</doc>
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-color.h"
               line="354">flags for the param spec</doc>
          <type name="GObject.ParamFlags" c:type="GParamFlags"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_format_get_bytes_per_pixel"
              c:identifier="cogl_pixel_format_get_bytes_per_pixel"
              moved-to="PixelFormat.get_bytes_per_pixel">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="285">Queries the number of bytes per pixel for a given format in the given plane.</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="296"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="293">The number of bytes per pixel in the given format's given plane.</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="287">The pixel format</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
        <parameter name="plane" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="288">The index of the plane (should not be more than the number of planes
        in the given format).</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_format_get_n_planes"
              c:identifier="cogl_pixel_format_get_n_planes"
              moved-to="PixelFormat.get_n_planes">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="341">Returns the number of planes the given CoglPixelFormat specifies.</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="350"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="347">The no. of planes of @format (at most %COGL_PIXEL_FORMAT_MAX_PLANES)</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="343">The format for which to get the number of planes</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="pixel_format_to_string"
              c:identifier="cogl_pixel_format_to_string"
              moved-to="PixelFormat.to_string">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-pixel-format.h"
           line="352">Returns a string representation of @format, useful for debugging purposes.</doc>
      <source-position filename="cogl/cogl/cogl-pixel-format.h" line="361"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="cogl/cogl/cogl-pixel-format.h"
             line="358">A string representation of @format.</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="format" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-pixel-format.h"
               line="354">a #CoglPixelFormat</doc>
          <type name="PixelFormat" c:type="CoglPixelFormat"/>
        </parameter>
      </parameters>
    </function>
    <function name="renderer_error_quark"
              c:identifier="cogl_renderer_error_quark"
              moved-to="RendererError.quark">
      <source-position filename="cogl/cogl/cogl-renderer.h" line="84"/>
      <return-value transfer-ownership="none">
        <type name="guint32" c:type="uint32_t"/>
      </return-value>
    </function>
    <function name="scanout_error_quark"
              c:identifier="cogl_scanout_error_quark"
              moved-to="ScanoutError.quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="set_tracing_disabled_on_thread"
              c:identifier="cogl_set_tracing_disabled_on_thread">
      <source-position filename="cogl/cogl/cogl-trace.h" line="264"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_tracing_enabled_on_thread"
              c:identifier="cogl_set_tracing_enabled_on_thread">
      <source-position filename="cogl/cogl/cogl-trace.h" line="260"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="void*"/>
        </parameter>
        <parameter name="group" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="start_tracing_with_fd"
              c:identifier="cogl_start_tracing_with_fd"
              throws="1">
      <source-position filename="cogl/cogl/cogl-trace.h" line="253"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="start_tracing_with_path"
              c:identifier="cogl_start_tracing_with_path"
              throws="1">
      <source-position filename="cogl/cogl/cogl-trace.h" line="249"/>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="filename" transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </parameter>
      </parameters>
    </function>
    <function name="stop_tracing" c:identifier="cogl_stop_tracing">
      <source-position filename="cogl/cogl/cogl-trace.h" line="257"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
    </function>
    <function name="value_get_color" c:identifier="cogl_value_get_color">
      <source-position filename="cogl/cogl/cogl-color.h" line="342"/>
      <return-value transfer-ownership="none">
        <type name="Color" c:type="const CoglColor*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_set_color" c:identifier="cogl_value_set_color">
      <source-position filename="cogl/cogl/cogl-color.h" line="338"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="color" transfer-ownership="none">
          <type name="Color" c:type="const CoglColor*"/>
        </parameter>
      </parameters>
    </function>
    <function name="xlib_renderer_set_foreign_display"
              c:identifier="cogl_xlib_renderer_set_foreign_display"
              introspectable="0">
      <doc xml:space="preserve"
           filename="cogl/cogl/cogl-xlib-renderer.h"
           line="38">Sets a foreign Xlib display that Cogl will use for and Xlib based winsys
backend.

Note that calling this function will automatically disable Cogl's
event retrieval. Cogl still needs to see all of the X events so the
application should also use cogl_renderer_handle_event() if it
uses this function.</doc>
      <source-position filename="cogl/cogl/cogl-xlib-renderer.h" line="51"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="renderer" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="cogl/cogl/cogl-xlib-renderer.h"
               line="40">a #CoglRenderer</doc>
          <type name="Renderer" c:type="CoglRenderer*"/>
        </parameter>
        <parameter name="display" transfer-ownership="none">
          <type name="xlib.Display" c:type="Display*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
